[{"categories":["Java"],"content":"一、基础部分 ","date":"2024-12-14","objectID":"/text40/:1:0","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"1. 关键字keyword 全是小写，能被虚拟机识别。goto 和 const 是保留字（现在保留，可能会成为关键字）。 ","date":"2024-12-14","objectID":"/text40/:1:1","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"2.标识符 作用：起名字。 组成：$ _ 数字 英文大小写 （不能以数字开头） 常见的命名规则： 见名知意 包：其实就是文件夹，用于把相同的类名进行区分 单级包（全部小写）：wangty 多级包（用.隔开）：cn.wangty –指cn包下的wangty包 类/接口 一个单词组成，首字母大写：Student、Dog 多个单词组成，大驼峰：HelloWorld 方法/变量 一个单词，首字母小写：main方法、name变量 多个单词，小驼峰：studentAge 常量 一个单词，全部大写：PI 圆周率 多个单词，全部大写，以_ 隔开：STUDENT_MAX_AGE This is a tip\r类：为java基本底层，一切以其为开始，{ }中可以写：结构定义语句、功能执行语句\r","date":"2024-12-14","objectID":"/text40/:1:2","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"3.注释 用于解释说明程序，调试排错 单行注释：// 多行注释：/* */ （不能嵌套使用） 文档注释：/** */ （被javadoc工具解析，生成一个说明书，面向对象部分讲解） ","date":"2024-12-14","objectID":"/text40/:1:3","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"4.常量 执行过程中，其值不可发生改变。 使用final关键字申明（前端一般使用const申明），只能进行一次赋值 字面值常量 字符串常量：双引号括起来的内容，例： \"Hello\" 整数常量：所有整数，例：100 小数常量：所有小数，例：0.11111 字符常量：单引号括起来的内容，例：'A' 布尔常量：真/假，例：true false 空常量：null 自定义常量 ​ ","date":"2024-12-14","objectID":"/text40/:1:4","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"5.进制 1) 定义 表示进位的方式。（X进制：逢x进一） 计算机的电子原件状态：开/关 ，用数字1/0 表示 表达数据的时候，国际化标准组织规定，用8个这样的信号来表示一个数据，单位为字节 ob开头：2进制 o开头：8进制 ox开头：16进制 ​ 2) 进制转换 X → 10 进制的转换：（任意进制 → 十进制） 系数：每一个位上的数值本身，成为系数 基数：X进制，基数为X 权：从右开始，以0开始编号，即为该位上权值 示例：2进制 转 10进制 示例：8进制 转 10进制 示例：16进制 转 10进制 8421码 8421码：用于2进制与10进制的快速转换 2 1 1 1 1 1 1 1 1 10 128 64 32 16 8 4 2 1 示例：2进制 转 10进制 将不同权位上为1的，对应位置上的数值相加 示例：10进制 转 2进制 左添0，从高位寻起，有则为1；相减，无则为0。去掉左0，添ob标识 10 100 100 36 4 4 4 0 0 10 128 64 32 16 8 4 2 1 2 0 1 1 0 0 1 0 0 10 → X 进制的转换：（十进制 → 任意进制） 商为0时结束，倒写余数。除基取余，直到商为0，余数反转。 示例：10进制 转 2进制 示例：10进制 转 8进制 示例：10进制 转 16进制 X → Y 任意进制之间转换：（X → Y） 以10进制做桥梁，X → 10，10 → Y ​ ","date":"2024-12-14","objectID":"/text40/:1:5","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"6.有符号数据表示法 在计算机内，有符号数有3中表示法：原码、补码、反码 在计算机操作的时候，都是采用数据对应的二进制补码来计算的。 原码：二进制定点表示法，最高位为符号位，\"0\"表示正，\"1\"表示负，其余表数值的大小 示例：±7。首先得到7的二进制为111 原码 符号位 数值位 +7 0 0000111 总共8为，不为1的补0 -7 1 0000111 总共8为，不为1的补0 反码：正数的反码与其原码相同。负数的反码，对其原码逐为取反，但符号位除外。 反码 符号位 数值位 +7 0 0000111 -7 1 1111000 对应取反 补码：正数的补码与其原码相同。负数的补码，是在反码的基础上加1 反码 符号位 数值位 +7 0 0000111 -7 1 1111001 加在尾部，若要进位则进 2个练习加深印象： 已知X的原码10110100B，求补/反码 第一个符号位，为1，该数为负数 原码B表示二进制 反码：0 1001011 补码：0 1001100 （注意进位） 已知X补码11101110B，求原码 补码减1，注意借位，不够往前借 补码：1 1101110 反码：1 1101101 原码：1 0010010 ","date":"2024-12-14","objectID":"/text40/:1:6","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"7.变量 内存中的一小块区域。 //强制转换 byte c = (byte)(a+b) 变量相加：先提升数据，再计算运行 常量相加：先计算结果（调试、编译），再赋值。再检测数据类型范围，超出则报错 //示例： byte b1 = 3; byte b2 = 4; byte b; //byte的范围 -128 ~ 127 b = b1 + b2 //报错,数据提升。（先提升成int 3，int4，才会进行相加赋值 7是int） b = 3 + 4 //b = 7 （7是byte） //'a' = 97 //'A' = 65 //'o' = 48 字符串相加：其+表示为连接符。结果为：字符串 数值相加：其+表示为运算符。结果为：计算结果 //示例 'a' + 1 + 'hello' //98hello 'hello' + 'a' + '1' //helloa1 定义Long类型变量，1L。 定义Float类型变量，1f。 整数默认为int，浮点默认为Double byte、short在定义时，他们接受的其实是一个int类型的值。（做了一个数据检测，如果不再它们的范围内，就报错） byte值的问题 //byte的范围 -128 ~ 127 byte b1 = 127; byte b2 = (byte) 128; //-128 byte b3 = (byte) 129; //-127 byte b4 = (byte) 130; //-126 //128:10000000 //-128: 10000000 这里1既是符号位，也是数值位，这里的0为负0 ","date":"2024-12-14","objectID":"/text40/:1:7","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"8.默认类型转换 char(2)、byte(1)、short(2) → int(4) → long(8) → float(4) → double 为什么 ‘8字节’ 可以转换为 ‘4字节’？ long：8字节，整数存储 float：4字节，浮点型存储 它们底层的存储类型不同，float类型在计算机中只使用4个字节存储，遵循IEEE-754格式标准。一个浮点数有两个部分构成： 底数m：以二进制数表示词浮点数的实际值，占24bit，高位始终为1。 指数e：占用8bit的二进制数，范围0-255。有±，减127才是真正的指数 例如： 17.625存储 二进制：10001.101 整数部分：除以2，商为0，余数反转。（10001.101） 小数部分：乘以2，乘位为0，进位顺序取（1.0001101高位恒为1） 右移至小数点前只有1位，2→3，需移动4位，指数加127 = 4 + 127=131 131二进制：10000011 结果为：0 1000001 10001101 00000000 00000000 符号位 指数 底数 0 10000011 0001101 0…0 float表示的数据范围比long大 证明： char能存一个中文字符，一个字符2个字节。java语言采用Unicode编码。 ​ ","date":"2024-12-14","objectID":"/text40/:1:8","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"9.运算符 1) 算术运算符（Operator） +、-、×、÷、%、++、-- 例一：a = 10； b = 10 ；c = 10； a = b++; //a = 10； b = 11 ；c = 10 c = --a; //a = 9； b = 11 ；c = 9 b = ++a; //a = 10； b = 10 ；c = 9 c = c--; //a = 9； b = 10 ；c = 8 //在前，先++/--，再赋值 //在后，先赋值，再++/-- 例二：x = 4 y = (x++) + (++x) + (x*10); //x = 6;y = 70 // 4 6 60 // x = 5 x = 6 ​ 2）赋值运算符 =、+=、-=、*=、/=、%= 例一：short s = 1； s = s + 1; //short 参加运算，提升为int，可能损失精度 s += 1; //s为short //拓展的赋值运算符其实隐含了一个强制类型转换 /* s += 1; \u003c≠\u003e s = s + 1; \u003c=\u003e s =(short) s + 1; */ ​ 3）比较运算符（关系运算符） \u003c、\u003e、\u003c=、\u003e=、!=、==、instanceof 结果都是boolean类型，只要有一个满足条件就可以 ​ 4）逻辑运算符 \u0026 与 ：同真为真 | 或 ：同假为假 ^ 异或：同名为假，异名为真 ! 非 ：取反 \u0026\u0026 短路与 ：左假右不管 || 短路或 ：左真右不算 左右必须都是布尔型表达式。 ​ 5）位运算符（2进制） \u003c\u003c 扩大，正数补0，负数补1 \u003e\u003e 缩小，正数补0，负数补1 \u0026、|、^ 当两边为数据做的是“位运算”，两边为表达式做的是“逻辑运算” ~、 \u003e\u003e\u003e 无符号右移，全补0 例一：某一个数据对另一个数据位异或两次，数据不变 //可以用来加密 a^b^b = a a^b^a = b 例二：将两个变量所携带的整数进行交换。a换成b，b换成a //方法一： a = a^b; b = a^b; //b = a^b^b = a; a = a^b; //a = a^b^a = b; //方法二： a = a+b; //a =30; b = a-b; //b = 10, b = (a+b)-b = a; a = a-b; //a = 20, a = (a+b)-a = b; //方法三： c = a; a = b; b = c; //方法四： b = (a+b)-(a=b) //等价于 a = b; b = (a+b)-b = a; ","date":"2024-12-14","objectID":"/text40/:1:9","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"10.键盘录入数据（Scanner） 导包 import java.util.Scanner; 创建键盘录入对象 Scanner sc = new Scanner(System.in); 通过对象获取数据 int x = sc.nextInt(); //键盘录入 整数值 String s = sc.nextLine(); //键盘录入 字符串 例一： import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"请输入：\"); int x = sc.nextInt(); System.out.println(\"你输入的是：\"+x); } } ​ ","date":"2024-12-14","objectID":"/text40/:1:10","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"11.流程控制语句 1）顺序结构 // 顺序结构示例 System.out.println(\"程序开始\"); // 变量赋值 int a = 10; int b = 20; // 计算和 int sum = a + b; // 输出结果 System.out.println(\"a 和 b 的和是: \" + sum); System.out.println(\"程序结束\"); 2）选择结构（if/switch） if(比较表达式){ 语句体 }else{ 语句体 } switch(表达式){ case 值1 :语句体1; break; default :语句体n+1; break; } /* 1、case后面，只能是常量，不能是变量，且多个case后的值不能相同 2、default可以省略，不建议 3、break可以省略吗？可以（最后一个） 4、default一定要在最后面吗？可以在任意位置 */ if/switch的区分： Boolean用if 1000上万数据用if 小数范围用if 针对几个常量值情况用switch 3）循环结构（for/do-while） for循环语句 for(初始化语句;判断条件语句;变量变化){ 循环语句体 } 例一：输出1~10 for(int x=1;x\u003c=10;x++){ System.out.println(x); } 例二：求1~10的数据和 int sum = 0; for(int x=1;x\u003c=10;x++){ sum += x; } System.out.println(sum); 例三：求1~100之间的偶数和 /** 思路：1~100之和为5050 1~100奇/偶对半各50 偶比奇大1，总共多50 （5050-50）÷ 2 +50 = 偶数和 */ //方法一： int sum = 0; for(int x=1;x\u003c=100;x++){ if(x%2 == 0){ sum += x; } } System.out.println(sum); //方法二： //从0开始，自增2位 int sum = 0; for(int x=0;x\u003c=100;x+=2){ sum += x; } System.out.println(sum); 例四：求5的阶乘 //阶乘：n! = n*(n-1)! = n*(n-1)*(n-2)*...*1 int sum = 1; for(int x=1;x\u003c=5;x++){ sum *= x; } System.out.println(sum); 例五：水仙花数（求所有水仙花数） //水仙花数：一个三位数，即各位数字的立方和等于该数本身。 //例如：153 = 1^3+5^3+3^3 = 153 for(int x=100;x\u003c1000;x++){ int ge = x%10; //获取个位数 int shi = x/10%10; //获取十位数 int bai = x/10/10%10; //获取百位数 if(x == (ge*ge*ge + shi*shi*shi +bai*bai*bai)){ System.out.println(x); } } while循环语句 可以与for循环等价转换 while(判断条件语句){ 循环体语句 } 例一：按照for语句，交换各项位置 for(int x=0;x\u003c10;x++){ System.out.println(\"hello\"); } //等价于 int x = 0; while(x\u003c10){ System.out.println(\"hello\"); x++; } /* while的初始化在外面，x为全局变量 for的x为局部变量 当循环，有范围时，用for；无明确范围时，用while */ do-while循环语句 do{ 循环语句 }while(判断条件句) //对应上方for循环 int x = 0; do{ System.out.println(\"hello\"); x++; }while(x\u003c10) This is a tip\r三种循环的区别： do-while至少执行一次循环体 while、for必须判断条件再循环（只有这一个区别） 死循环： ctrl+c 强制停止循环。一定注意造成死循环是因为没有写条件控制 ​ ","date":"2024-12-14","objectID":"/text40/:1:11","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"12.跳转控制语句 1）break中断 break使用场景（离开下面两个场景，无意义） switch语句中 循环语句中 //嵌套for中，只跳出一层 //使用“标签名：语句” - 跳出目标层 wc:for(...){ nc:for(...){ if(){break wc;} //中断外+内层 if(){break nc;} //中断内层 } } 2）continue继续 使用场景，for循环中。（离开此场景无意义） 跳出本次循环，进入下一循环体 （0,1,2,跳出，4,5,6…） ​ 3）return返回 使用场景，结束一个方法，跳转到上层调的方法 方法的注意事项： 方法不调用不执行 方法与方法是平级关系，不能嵌套定义 方法定义的时候参数之间用逗号隔开 方法调用时不用在传递数据类型 如有明确返回值，一定要return ​ ","date":"2024-12-14","objectID":"/text40/:1:12","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"二、核心部分 ","date":"2024-12-14","objectID":"/text40/:2:0","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"1.方法（函数） 方法定义在一个类中，完成特定功能的代码块。 修饰符 返回类型 方法名(参数类型 参数名){ 函数体; return 返回值; } /* 写一个方法（两个明确） 1、返回值类型：结果的数据类型 2、参数列表：传递几个、每个的数据类型 */ 参数： 实参：实际参与运算的 形参：形式上定义的，用来接受实际参数的 return：结束方法 返回值：就是功能的结果，由return带回给调用者 例一：求2个数的和 //方法不调用不会自动运行 public static int Sum(int a,int b) { int c = a+b; return c; } 特例：main方法，在Java虚拟机处调用，所以不用认为调用，依然可以运行 public static void main(String[] args) {....} 方法的调用方式： //单独调用 Sum(a,b); //输出调用 System.out.println(Sum(a,b)); //赋值调用 int result = Sum(a,b); void方法调用：只适用于第一种\"单独调用\" ​ ","date":"2024-12-14","objectID":"/text40/:2:1","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"2.重载 方法的功能相同，参数列表不同，java允许它们起相同的名字。 参数列表不同： 参数个数不同 参数数据类型不同 通过参数个数识别，不同的方法。JVM会根据不同的参数，去调用不同的方法。 //原方法 public static int Sum(int a,int b) {} //重载入参个数 public static int Sum(int a,int b,int c) {} //重载入参类型 public static float Sum(float a,float b) {} ​ ","date":"2024-12-14","objectID":"/text40/:2:2","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"3.数组 数组是用于存储多个变量(元素)的容器，这多个元素的数据类型相同。 数据类型[] 数组名 //常用 数据类型 数组名[] 数组定义后，没有值，需要初始化 int[] arr = new int[3]; //int[] arr：看成一个变量，变量需要初始化才能使用 //new：为数组分配内存空间。之后看见的所有的new都是分配内存空间的 //int[3]：数组长度，动态初始化 初始化：开辟内存空间，并赋值 静态初始化：给定元素数值，长度系统定 动态初始化：给定系统长度，由系统分配初始值（默认为0） //动态初始化格式 数据类型[] 数组名 = new 数据类型[数组长度] //静态初始化格式 数据类型[] 数组名 = new 数据类型[元素1,元素2,...] 注意：不要同时使用动/静态初始化。 使用System.out.println(arr) 输出数组arr，显示数组的地址值 用数组名和索引相结合，可以获取数组中指定编号的元素。格式：数组名[索引值]。 This is a tip\rJava中的内存分配以及栈和堆的区别： 为了提高运算效率，对内存空间进行了不同区域的划分 栈：存\"基本类型变量\"和\"引用变量\" 不同区域：有特定的“处理数据方式\"和\"内存管理方式\" 5个内存空间： 栈（存储局部变量：方法定义上、方法申明上） 堆（存储new出来的东西 + 数组） 方法区 本地方法区（和系统有关） 寄存器（给CPU使用） 堆内存的特点： 每一个new出来的东西都有地址值 每个变量都有默认值 byte、short、int、long → 0 float、double → 0.0 char → ‘\\u0000’ （空字符） boolean → false 引用类型 → null 使用完毕后，就变成垃圾，但是并没有立即收回，在垃圾回收器空间的时候回收。 栈内存的特点： 用完即释放（数据脱离其作用域） 图解： 数组操作（越界/空指针）问题： ArrayIndexOutOfBoundsException 数组索引越界异常：原因你访问了不存在的索引。 NullPointerException 空指针异常：原因数组已经不指向堆内存了，但你使用数组名访问了元素。 图解： 数组操作（遍历）： 依次输出数组中每一个元素。 //每个元素只有索引值不同 //遍历：用循环改变索引即可 for(int x=0;x\u003c10;x++){ System.out.println(arr[x]); } ​ ","date":"2024-12-14","objectID":"/text40/:2:3","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"4. ","date":"2024-12-14","objectID":"/text40/:2:4","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"基础概念入门 ","date":"2024-12-11","objectID":"/text39/:1:0","tags":["Java"],"title":"【Java】Java语言基础（一）","uri":"/text39/"},{"categories":["Java"],"content":"一、计算机 裸机：没有安装任何软件的计算机 科学计算 —— 数值计算 数据处理 自动控制 计算机辅助设计 人工智能 多媒体应用 计算机网络 计算机硬件：电工、机械、光电元件（各种物理装置的总称） CPU、主板、内存、电源、主机箱、硬盘、显卡、键盘、鼠标、显示器 计算机软件：一系列指令（由程序 + 相关文档 组成，用于执行特定任务/功能） 系统软件：DOS（Disk Operating System）、Windows、ios、Android、Mac、Linux 应用软件：Office、QQ、微信 软件开发：特定顺序 + 数据 + 指令 的集合 人机交互：图形化界面 + 命令行方式 （例如：控制台） Dos窗口命令： d: 切换至d盘 [盘符切换] dir: 列出当前目录下的文件 （ls Nginx中使用这个） md 创建目录 rd 删除目录（删文件夹） 带内容的文件夹删除 一个一个的删 rd + /s rd + /s + /q cd 进入指定目录 cd.. 退出当前目录 （单级退出） del 删除 （只能删除*.txt类文件） cls 清屏 exit 退出 edit 编辑 notepad 打开记事本 mspaint 打开画图 ctrl + alt + L 代码对齐 键盘prtSc 屏幕截图 确保系统上已正确安装 Java 开发工具包（JDK），Dos窗格中可以： javac HelloWorld.java 编译 java HelloWorld.class 运行 Java语言平台版本 J2SE 桌面 J2ME 手机 J2EE 电脑 Java的垮平台性：指Java程序能够在不同操作系统和硬件平台上运行，而无需修改源代码。 Java虚拟机（JVM）： Java源代码在编译后生成的是字节码（.class文件），而不是直接生成特定操作系统的机器代码。字节码可以在任何安装了Java虚拟机（JVM）的设备上运行。各个操作系统都有各自的JVM实现，这使得相同的Java字节码可以在Windows、Linux、Mac OS等平台上无缝运行。 一次编写，到处运行（WORA）： Java的设计理念是“一次编写，随处运行”。开发者只需将Java程序编写一次，并编译成字节码，之后就可以在任何支持JVM的系统上运行，而无需进行任何修改。 高度的抽象性： Java提供了大量的标准库和API，这些库和API被设计为与平台无关。开发者在编写应用时主要使用这些标准的功能，而不需要考虑底层操作系统的差异。 图例： （大）JDK：Java开发工具包（开发环境） Javac.exe 编译工具 jar.exe 打包工具 ….. （中）JRE：Java运行环境 （小）JVM：Java虚拟机 （小）Java核心库：一组重要类和接口，它们提供了Java程序开发所需的基本功能 java.lang：包含基本的类，如 String、Math、Object 等，所有Java程序默认导入这个包。 java.util：提供了许多实用的工具类，如集合框架（List、Set、Map）、日期/时间类等。 java.io：包含输入/输出类，允许程序与数据源（如文件、网络）进行数据交换。 java.net：提供网络编程的支持，包括URL、Socket等类。 java.awt 和 javax.swing：用于创建图形用户界面（GUI）的类。 java.sql：提供与数据库连接和操作相关的类。 ​ ","date":"2024-12-11","objectID":"/text39/:1:1","tags":["Java"],"title":"【Java】Java语言基础（一）","uri":"/text39/"},{"categories":["Java"],"content":"二、path环境配置 PATH 是一个环境变量，用于告诉操作系统在命令行中寻找可执行程序的位置。正确配置 PATH 变量，使你能够在任何位置通过命令调用相关的可执行文件，而不需要输入其完整的路径。这在使用 Java、Git 等开发工具时特别重要。 目的：需要在任意的目录下均可运行（可执行性文件.exe） Windows 中配置 打开系统属性： 右键点击“此电脑”或“计算机”，选择“属性”。 点击“高级系统设置”。 在“系统属性”窗口中，点击“环境变量”按钮。 编辑 PATH 变量： 在“系统变量”或“用户变量”区域，查找PATH变量： 如果不存在，点击“新建”，输入变量名 Path。 如果已存在，选择它并点击“编辑”。 添加新的路径： 在编辑窗口中，点击“新建”，然后添加你想要包含的目录路径（例如，Java 的 bin 目录）。 示例路径： C:\\Program Files\\Java\\jdk-11\\bin 你也可以直接在已有的路径中添加（用分号 ; 分隔每个路径）。 保存并关闭： 点击“确定”以保存更改，然后关闭所有相关窗口。 macOS 和 Linux 中配置 打开终端。 编辑配置文件： 根据你使用的 shell，编辑相应的配置文件（例如 .bashrc、.bash_profile 或 .zshrc）。 使用文本编辑器打开文件。例如： nano ~/.bashrc # 对于 bash 对于其他 shell，如 zsh，你可能需要编辑 .zshrc 文件。 添加路径到 PATH： 在文件的末尾添加以下行： export PATH=\"/path/to/directory:$PATH\" 例如，如果你希望添加 Java 的bin目录： export PATH=\"/usr/local/java/jdk-11/bin:$PATH\" 保存并退出（对于 nano，使用 CTRL + X，然后按 Y 保存）。 使改动生效： 运行以下命令： source ~/.bashrc # 或者 source ~/.zshrc 这会使新的 PATH 设置在当前终端会话中生效。也可以重新打开终端来应用更改。 ​ 验证 PATH 配置 你可以通过在命令行中输入以下命令来验证 PATH 是否配置正确： 在 Windows： echo %PATH% 在 macOS/Linux： echo $PATH 执行该命令后，你应该能看到你添加的路径。如果没有，可能需要检查是否正确保存了文件并重新加载配置。 ","date":"2024-12-11","objectID":"/text39/:1:2","tags":["Java"],"title":"【Java】Java语言基础（一）","uri":"/text39/"},{"categories":["Java"],"content":"三、classpath环境配置 在Java中，CLASSPATH 是一个环境变量，用于告诉**Java虚拟机（JVM）**和 **Java编译器（javac）**在哪些目录下寻找类文件（.class文件）和库文件（.jar文件）。 设置 CLASSPATH 的作用 查找类：CLASSPATH 告诉JVM和编译器从哪里加载所需的类和资源。 项目依赖：在一个应用程序中，可能会需要多个外部库，CLASSPATH 有助于管理这些依赖。 CLASSPATH 配置方法 在不同操作系统上，配置 CLASSPATH 的方法略有不同： Windows 打开系统属性： 右键点击“此电脑”或“计算机”，选择“属性”。 点击“高级系统设置”。 在“系统属性”窗口中，点击“环境变量”。 创建或编辑 CLASSPATH： 在“系统变量”或“用户变量”区域，查找CLASSPATH变量： 如果不存在，点击“新建”，输入变量名 CLASSPATH。 如果已存在，选择它并点击“编辑”。 添加路径： 在变量值中添加目录路径或jar文件的路径，用分号（;）分隔。例如： C:\\myproject\\classes;C:\\myproject\\lib\\mylibrary.jar 保存和关闭： 点击“确定”保存，并关闭所有窗口。 macOS 和 Linux 打开终端。 编辑配置文件： 根据使用的shell，编辑相应的配置文件（例如，~/.bashrc、~/.bash_profile 或 ~/.zshrc）。 使用文本编辑器打开文件，例如： nano ~/.bashrc 添加 CLASSPATH： 在文件末尾添加以下行： export CLASSPATH=/path/to/classes:/path/to/libs/mylibrary.jar:$CLASSPATH : 用于分隔多个路径。 保存并退出（对于 nano，使用 CTRL + X，然后按 Y 保存）。 使改动生效： source ~/.bashrc 或重新打开终端。 ","date":"2024-12-11","objectID":"/text39/:1:3","tags":["Java"],"title":"【Java】Java语言基础（一）","uri":"/text39/"},{"categories":["前端"],"content":"Vue3快速上手 ","date":"2024-11-14","objectID":"/vue3/:1:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.Vue3简介 2020年9月18日，Vue.js发布3.0版本，代号:One Piece(海贼王) 耗时2年多、2600+次提交、30+个RFC（请求修改意见稿）、600+次PR、99位贡献者 github上的tags（各个开源版本）地址:https://github.com/vuejs/vue-next/releases/tag/v3.0.0 ","date":"2024-11-14","objectID":"/vue3/:1:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.Vue3带来了什么 ","date":"2024-11-14","objectID":"/vue3/:1:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"一、创建Vue3.0工程 ","date":"2024-11-14","objectID":"/vue3/:2:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.使用 vue-cli 创建 官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create ## 查看@vue/c1i版本，确保@vue/cli版本在4.5.0以上 ,vue -V查看本机@vue/c1i版本 vue --version ## 安装或者升级你的@vue/cli --不满足版本要求就自行这一步重新安装 npm install -g @vue/cli ## 创建 vue create vue_test ## 启动 cd vue_test npm run serve ​ ","date":"2024-11-14","objectID":"/vue3/:2:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.使用 vite 创建 官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite vite官网：https://vitejs.cn 什么是vite? —— 新一代前端构建工具（作用对比webpack）。 优势如下： 开发环境中，无需打包操作，可快速的冷启动。 轻量快速的热重载(HMR) 真正的按需编译，不再等待整个应用编译完成。 传统构建 与 vite构建对比图（这两张图来自于vite官网位置） npm run serve这种的webpack传统工作模式：先是从一个entry，先看路由，再看模块，再进行打包，最后告知8080服务器启动好了。【主要等待时间在Bundle打包的位置】 vite构建工作模式：先告知8080服务器启动准备完成，根据你发起的请求，找到对应的entry并且解析该模块对应的路由和组件信息展示。 ## 创建工程 npm init vite-app \u003cproject-name\u003e ##进入工程目录 cd \u003cproject-name\u003e ##安装依赖 npm insta1l ## 运行 npm run dev 我们将两种构建模式放一起同时运行，很明显vite方式的要比传统方式快很多。 期间，传统方式等待的这段时间，就是在打包。 注意\r传统运行命令是npm run serve，vite运行命令式npm run dev。现在vite模式还没有大规模应用，所以我们此文档后面的演示还是使用基于传统模式的运行方式。\r","date":"2024-11-14","objectID":"/vue3/:2:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"3.分析工程结构 This is a tip\r分析工程结构，需要：使用Vue3搭建好后最原始的初始化工程 关闭框架自动的校验提示，同样使用Vue2中根目录下的vue.config.js文件。拷贝放入根目录即可。 入口文件main.js 首先分析入口文件，文件路径为工程项目包/src/main.js //引入的不再是Vue构造函数了，引入的是一个名为createApp的工厂函数 //Vue构造函数：需要使用new关键字进行引用 //工厂函数：不需要使用new关键字，可以直接调用，如：createApp() import {createApp } from 'vue' import App from './App.vue‘ createApp(App).mount('#app') 我们对这一句代码createApp(App).mount('#app')，进行拆解分析： //创建应用实例对象，类似于vm，但app比vm更\"轻\"，没有那么多的属性和方法 const app = createApp(App) app.mount('#app') //挂载mount。 //对应挂载mount，有unmount卸载. //使用定时器，1秒钟后卸载app组件，整体页面消失 setTimeout(()=\u003e{ app.unmount('#app') },1000) 对比vue2中写法，可以发现结构其实是相似的： import {Vue } from 'vue' const vm = new Vue({ render:h=\u003eh(App) }) vm.$mount('#app') 特别注意\r在Vue3的项目入口文件中使用Vue2中的写法是不可以的。我们可以清晰的看见报错信息： 翻译过来为：不存在的对象，不能进行实例化。 我们打印Vue实例对象，我们发现并没有成功引入进来。 所以使用new实例化对象的Vue2写法在Vue3项目中并不可行。 领头组件App.vue \u003ctemplate\u003e \u003c!--Vue3组件中的模板结构，可以不使用div根标签包裹，如果写，也不会报错--\u003e \u003cimg alt=\"Vue logo\" src=\"./assets/logo.png\"\u003e \u003cHelloWorld msg=\"Welcome to Your Vue.js App\"/\u003e \u003c/template\u003e \u003cscript\u003e \u003c!--正常引入组件--\u003e import HelloWorld from './components/HelloWorld.vue' export default { name: 'App', components:{HelloWorld} } \u003c/script\u003e \u003c!--组件样式--\u003e \u003cstyle\u003e ..... \u003c/style\u003e ","date":"2024-11-14","objectID":"/vue3/:2:3","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"4.安装开发者工具 Vue2篇幅中，安装在浏览器里的Vue开发者工具是不支持Vue3的。 由此，我们需要安装Vue3专用的开发者工具。 同样，也有两种安装方式： **在线安装：**直接在chrome网上应用商店，搜索vue，选择图标带脚标的，进行添加安装 **离线安装：**Vue开发者工具安装包，拖入拓展程序页面，点击添加，添加后启用。 如果扩展程序同时添加了Vue2以及Vue3的开发者工具，则需要禁用一个，启用一个。 ","date":"2024-11-14","objectID":"/vue3/:2:4","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"二、常用 Composition API Composition API 我们也称组合式API 官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html ","date":"2024-11-14","objectID":"/vue3/:3:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.setup配置项 理解：Vue3.0中一个新的配置项，值为一个函数。 setup(){ //数据 //方法 //计算属性，监视属性 //生命周期等钩子函数 } 组件中所用到的：数据、方法等等，均要配置在setup中。 setup函数的两种返回值: 1.若返回一个对象，则对象中的属性、方法,在模板中均可以直接使用。 2.若返回一个渲染函数：则可以自定义渲染内容。 简单示例： \u003ctemplate\u003e \u003ch1\u003eHello Vue3\u003c/h1\u003e \u003c!--直接使用setup的返回中暴露的数据和方法--\u003e \u003ch2\u003e姓名：{{name}}\u003c/h2\u003e \u003ch2\u003e年龄：{{age}}\u003c/h2\u003e \u003cbutton @click=\"sayHello\"\u003e说你好\u003c/button\u003e \u003c/template\u003e \u003c!--返回一个对象--\u003e \u003cscript\u003e export default { name:'App', //此处简单示例只用于测试setup工作，暂不考虑处理响应式 setup(){ //数据 let name = '张三' //不用const说明，以后这些数据有可能发生变化 let age = 18 //方法 function sayHello(){ alert(`我叫${name},我${age}岁了，你好！`) //使用``模版字符串 } //setup返回一个对象，将所有数据和方法暴露出去 return { name, //当key-value形式，写为 name:name时，可以触发简写形式name age, sayHello } } } \u003c/script\u003e \u003ctemplate\u003e \u003c!--不论此模版处写什么，都不进行编译，只读取返回的渲染函数中的内容--\u003e \u003ch1\u003eHello Vue3\u003c/h1\u003e \u003c/template\u003e \u003c!--返回一个渲染函数--\u003e \u003cscript\u003e //手动引用h函数 import {h} from 'vue' export default { name:'App', setup(){ //数据 let name = '张三' let age = 18 //方法 function sayHello(){ alert(`我叫${name},我${age}岁了，你好！`) } //setup返回一个渲染函数【这种写法不常用，但可做了解】 //在Vue2中，有个render配置项 //只要写render，Vue就帮你传入一个h，并调用，这个h就是渲染函数 //Vue3中，需要手动引入这个h函数，才能调用 //调用方式和Vue2中一样，传入两个参数:h('想要放入页面的元素','该元素对应的文字') //例如：h('h1','你好') //将h函数的调用返回值暴露返回给setup的return。return h('h1','你好') //即整体写做 return ()=\u003e{return h('h1','你好')} //简写为 return ()=\u003e h('h1','你好') return ()=\u003e h('h1','你好') } } \u003c/script\u003e Vue3是可以向下兼容Vue2写法的，他们可以同时存在和使用，例如： \u003ctemplate\u003e \u003c!--Vue3所配置的数据及方法--\u003e \u003ch2\u003e姓名：{{name}}\u003c/h2\u003e \u003cbutton @click=\"sayHello\"\u003e说你好\u003c/button\u003e \u003c!--Vue2所配置的数据及方法--\u003e \u003ch2\u003e姓名：{{age}}\u003c/h2\u003e \u003cbutton @click=\"sayAge\"\u003e说你好\u003c/button\u003e \u003c/template\u003e \u003c!--返回一个对象--\u003e \u003cscript\u003e export default { name:'App', //-----------Vue2语法------------ data(){ return {sex:'男'} }, methods：{ sayAge(){ alert(`22222222`) } }, //-----------Vue3语法------------ setup(){ let name = '张三' function sayHello(){ alert(`11111111`) } return { name,sayHello } } } \u003c/script\u003e 注意点: 尽量不要与Vue2.x配置混用 Vue2.x配置(data、methos、computed..)中可以访问到setup中的属性、方法。 \u003c!--Vue2中访问Vue3的setup配置中的数据、方法：均能访问成功--\u003e \u003cscript\u003e export default { name:'App', data(){ return {sex:'男'} }, methods：{ test(){ console.log(this.sex) //男 console.log(this.name) //张三 console.log(this.sayHello) //function(..) } }, //-----------Vue3语法------------ setup(){ let name = '张三' function sayHello(){ alert(`11111111`) } return { name,sayHello } } } \u003c/script\u003e 但在setup中不能访问到Vue2.x配置(data、methos、computed…)。 \u003c!--Vue3的setup配置中访问Vue2的数据、方法：均不能访问成功--\u003e \u003cscript\u003e export default { name:'App', data(){ return {sex:'男'} }, methods：{ sayAge(){ alert(`22222222`) } }, setup(){ let name = '张三' function sayHello(){ alert(`11111111`) } function test(){ console.log(this.sex) //undefined console.log(this.sayAge) //undefined console.log(name) //张三 console.log(sayHello) //function(..) } return { name,sayHello,test } } } \u003c/script\u003e 如果有重名，setup优先。 \u003ctemplate\u003e \u003ch2\u003e{{a}}\u003c/h2\u003e\u003c!--编译a的值，显示为：200--\u003e \u003c/template\u003e \u003cscript\u003e export default { name:'App', //-----------Vue2语法------------ data(){ return {a:100} }, //-----------Vue3语法------------ setup(){ let a = 200 return { a } } } \u003c/script\u003e setup不能是一个async函数（不可写做async setup(){}）。 凡是async修饰的函数，返回值不再是return的对象，而是promise包裹了一层的对象，会导致Vue模板看不到return对象中的属性。 在写function为同异步调用的时候特别注意！！这里不能使用！！会导致模版编译不可用！！ ","date":"2024-11-14","objectID":"/vue3/:3:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.ref函数 作用：定义一个响应式的数据 接收的数据可以是：基本类型、也可以是对象类型。 基本类型的数据：响应式依然是靠 0bject.defineProperty()的 get 与 set 完成的。 对象类型的数据：响应式内部“求助”了Vue3.0中的一个新函数-reactive函数【后面阐述】 Vue2中ref是一个标签属性，写做\u003cinput ref=\"qwq' ...\u003e，用于标识组件或者标签。 Vue3中ref也可以作为标签属性，但他还有一个用法，就是作为ref函数： 看一个现象： 正常声明数据变量，并在方法中修改，变量被修改成功，但页面并不渲染。 \u003ctemplate\u003e \u003ch1\u003e一个人的信息\u003c/h1\u003e \u003ch2\u003e姓名:{{name}}\u003c/h2\u003e \u003ch2\u003e年龄:{{age}}\u003c/h2\u003e \u003cbutton @click=\"changeInfo\"\u003e修改人的信息\u003c/button\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'App', setup(){ let name = '张三' let age = 18 //方法 function changeInfo(){ name ='李四' age = 48 console.log(name,age) } return { name, age, changeInfo } } \u003c/script\u003e ref函数-基本类型数据申明 我们用ref函数包裹申明，并且打印申明的数据： import {ref} from 'vue' .... setup(){ let name = ref('张三') let age = ref(18) //方法 function changeInfo(){ console.log(name) console.log(18) } .... 根据打印结果，很明显的，所有的数据都申明成了一个RefImpl对象。 数据内容都是对RefImpl的实例化。 我们拆分RefImpl单词，分别为reference引用， implement实现。所以对其申明的对象（{}中的内容），我们称之为：引用实现对象。 全称：引用实现的实例对象。 也简称：引用对象。 对于基本数据类型，如果在Vue3中想要实现响应式，则需要将数据丢给ref函数进行处理，形成引用对象。 在Vue3中，基本数据类型通过ref实现响应式，和Vue2中一样，也是通过0bject.defineProperty()实现getter、setter的方式。 且getter、setter其不在实例对象本体RefImpl上，而在原型对象__proto__上。找不到默认往原型上找，可以成功找到。使用数据的时候，可以通过.value的方式进行访问，修改时，也可以通过setter进行页面的重新渲染，且保证了实例对象的属性精简。 上述例子，修改数据的完整写法： \u003ctemplate\u003e \u003ch1\u003e一个人的信息\u003c/h1\u003e \u003ch2\u003e姓名:{{name}}\u003c/h2\u003e \u003ch2\u003e年龄:{{age}}\u003c/h2\u003e \u003cbutton @click=\"changeInfo\"\u003e修改人的信息\u003c/button\u003e \u003c/template\u003e \u003cscript\u003e import {ref} from 'vue' export default { name: 'App', setup(){ let name = ref('张三') let age = ref(18) //方法 function changeInfo(){ name.value ='李四' age.value = 48 console.log(name,age) } return { name, age, changeInfo } } \u003c/script\u003e 这里注意：\r只有在setup访问中，遵循ES6语法时，访问数据才使用.value的形式。 在模版解析的时候：不能写成name.value。 \u003c!--模版中，正常使用插值语法--\u003e \u003ctemplate\u003e \u003ch2\u003e姓名:{{name}}\u003c/h2\u003e \u003ch2\u003e年龄:{{age}}\u003c/h2\u003e \u003c/template\u003e 在Vue3中，解析模版时，当其发现引用数据为RefImpl的实例对象，则会自动帮我们访问数据对象的.value属性。 如果再手动加.value，就会识别成name.value.value导致也能渲染失败 ref函数-对象类型数据申明 注意申明结构： let person = ref({ name : '张三', age : 18 }) 打印person.value结果 这里能看到，对象类型的数据实现响应式，不再同Vue2一样。而是使用的Proxy对象。【后面会详细阐述】 访问每个属性则使用：person.value.type 修改对象类型数据的完整写法： \u003ctemplate\u003e \u003ch1\u003e一个人的信息\u003c/h1\u003e \u003ch2\u003e姓名:{{person.type}}\u003c/h2\u003e \u003ch2\u003e年龄:{{person.salary}}\u003c/h2\u003e \u003cbutton @click=\"changeInfo\"\u003e修改人的信息\u003c/button\u003e \u003c/template\u003e \u003cscript\u003e import {ref} from 'vue' export default { name: 'App', setup(){ let person = ref({ type : '前端工程师', salary : 30k }) //方法 function changeInfo(){ person.value.type = 'UI设计师' person.value.salary = '40k' } return { person, changeInfo } } \u003c/script\u003e ","date":"2024-11-14","objectID":"/vue3/:3:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"3.reactive函数 作用：定义一个对象类型的响应式数据 与ref基本和对象类型的都可以申明不同，reactive只能申明对象类型的。用reactive申明基本数据类型let number = reactive(666)，控制台报错： 申明对象类型的，则控制台打印： 语法：const 代理对象 = reactive(源对象) 接收一个对象(或数组)，返回一个代理对象(proxy的实例对象，简称proxy对象) //申明对象 let job = reactive({ d:111, a:{ b:{ c: 666 } } }) reactive定义的响应式数据是“深层次的”。 //修改对象 job.a.b.c = 999 //申明数组 let hobby = reactive(['111','222','333']) //修改数组 hobby[0] = '000' 内部基于 ES6 的 Proxy 实现，通过 代理对象 操作 源对象 内部数据进行操作。 ​ ","date":"2024-11-14","objectID":"/vue3/:3:3","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"4.Vue3.0中的响应式原理 vue2.x的响应式 实现原理: 对象类型:通过 Object.defineProperty()对对象的的读取、修改进行拦截(数据劫持)。 数组类型:通过重写更新数组的一系列方法来实现拦截。(对数组的变更方法进行了包裹) Object.defineProperty(data,'count',{ get(){}， set(){} }) 存在问题： 新增属性、删除属性，界面不会更新。（原因是：defineProperty只检测查改，检测不到增删。检测查改利用的get和set，没有检测增删的手段和方法） \u003ctemplate\u003e \u003cdiv\u003e \u003c!--person身上追加一个性别属性，删除原有的name属性--\u003e \u003ch1 v-show=\"person.name\"\u003e姓名：{{person.name}}\u003c/h1\u003e \u003ch1\u003e年龄：{{person.age}}\u003c/h1\u003e \u003ch1 v-show=\"person.sex\"\u003e性别：{{person.sex}}\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'App', data(){ return { person:{ name:'张三'， age: 18 } } }, methods:{ addSex(){ this.person.sex = '女' //person中数据改了，但是页面不更新 //解决办法 this.$set(this.person,'sex','女') //或者 import Vue from 'vue' Vue.set(this.person,'sex','女') }, deleteName(){ delete this.person.name //person中数据改了，但是页面不更新 //解决办法 this.$delete(this.person,'name') //或者 import Vue from 'vue' Vue.delete(this.person,'name') } } } \u003c/script\u003e 直接通过下标修改数组,界面不会自动更新。 \u003ctemplate\u003e \u003cdiv\u003e \u003c!-- --\u003e \u003ch1\u003e爱好：{{person.hobby}}\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'App', data(){ return { person:{ hobby:['学习','吃饭','睡觉'] } } }, methods:{ updateHobby(){ this.person.hobby[0] = '逛街' //person中数据改了，但是页面不更新 //解决办法 this.$set(this.person.hobby,0,'逛街') //或者 this.person.hobby.splice(0,1,'逛街') } } } \u003c/script\u003e ​ vue3.0的响应式 vue2.x的响应式模拟 新建一个.html文件，我们在其中模拟vue2.x实现响应式原理的关键代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e //源数据 let person = { name:'张三'， age:18 } //模拟Vue2中实现响应式 let p = {} //新建一个代理对象 Object.defineProperty(p,'name',{ //(操作对象,'对象中要操作的属性',{get\\set方法}) configurable:true,//允许删除 get(){ //有人读取person中的name时调用 return person.name }, set(value){ //有人修改person中name时调用 console.log('有人修改了name属性，我发现了，我要去更新界面！') person.name = value } }) //age同理---------------- Object.defineProperty(p,'age',{ get(){ //有人读取person中的age时调用 return person.age }, set(value){ //有人修改person中age时调用 console.log('有人修改了age属性，我发现了，我要去更新界面！') person.age = value } }) //.... //有多少个属性就要写多少个Object.defineProperty()---------------- \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 测试一下响应式的效果 ​ vue3.0的响应式模拟 想研究Vue3中的响应式，需要认识window上的window.Proxy这个函数。 他是window身上的一个内置的构造函数（不用下载安装，不用引入，直接就可以通过window使用） 这个Proxy我们在之前配置脚手架的代理的时候也用过，当时用作解决ajax跨域的问题。其实，不管在哪里，他都是代理的意思。 他的作用，就是使用p去映射对person的操作。和defineProperty弄出来一个p去匹配get、set；一操作p，就使person发生变化，并且能检测到，是一个道理。 下面是他的使用语法： 同样是新建一个.html文件，我们在其中模拟vue3.0实现响应式原理的关键代码 \u003c!--只是模拟关键代码，阐述原理，vue3底层并不是真正的这样去直接操作源数据--\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e //源数据 let person = { name:'张三'， age:18 } //模拟Vue3中实现响应式 //(要代理的对象，{代理使用的CRUD方法}) //const p = new Proxy(person,{}) //{}里可以空着，但是{}必须写 const p = new Proxy(person,{ get(target, propName){ console.log('有人读取了p身上的${propName}属性，我发现了，我要去更新界面！') return target[propName] }, set(target, propName, value){ console.log('有人修改了p身上的${propName}属性，我发现了，我要去更新界面！') target[propName] = value }， // 拦截删除属性 deleteProperty(target,propName){ console.log('有人删除了p身上的${propName}属性，我发现了，我要去更新界面！') return delete target[propName] } }) //不管多少个属性，写一个Proxy就可以了---------------- \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 测试一下响应式的效果 vue3.0的响应式真实原理 Vue3中响应式的实现原理\rnew Proxy(data,{ // 拦截读取属性值 get(target, propName){ return Reflect.get(target,propName) }, // 拦截设置属性值或添加新属性 set(target, propName, value){ return Reflect.set(target,propName,value) }， // 拦截删除属性 deleteProperty(target,propName){ return Reflect.deleteProperty(target,propName) } }) 实现原理: 通过Proxy(代理)：拦截对象中任意属性的变化，包括:属性值的读写、属性的添加、属性的删除等。 通过Reflect(反射)：对被代理对象的属性进行操作。 MDN文档中描述的Proxy与Reflect： Proxy: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy Reflect: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect let obj = {a:1,b:2} 读取一个对象obj身上的属性： //方式一 obj.a //1 //方式二 //window.Reflect 反射 Reflect.get(obj,'a') //1 控制台效果： 修改一个对象obj身上的属性： //方式一 obj.a = 100 //a=100 //方式二 Reflect.set(obj,'a',666) //a=666 控制台效果： 删除一个对象obj身上的属性： Reflect.deleteProperty(obj,'a') //true ","date":"2024-11-14","objectID":"/vue3/:3:4","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"5.reactive对比ref 从定义数据角度对比： ref用来定义：基本类型数据。 reactive用来定义：对象(或数组)类型数据 备注：ref也可以用来定义对象(或数组)类型数据，它内部会自动通过 reactive 转为代理对象。 从原理角度对比： ref通过 Object.defineProperty()的get 与 set 来实现响应式**(数据劫持)**。 reactive通过使用Proxy来实现响应式(数据劫持),并通过Reflect操作源对象内部的数据。 从使用角度对比： ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。 reactive定义的数据：操作数据与读取数据：均不需要.value。 ​ ","date":"2024-11-14","objectID":"/vue3/:3:5","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"6.setup的两个注意点 setup执行的时机 在beforeCreate之前执行一次，this是undefined。 setup的参数 props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。 context：上下文对象 attrs：值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性，相当于this.$attrs slots: 收到的插槽内容，相当于this.$slots emit: 分发自定义事件的函数，相当于this.$emit 。 Vue2中父子组件传值方式\rprops接受传参 \u003cDemo msg='111' school='222'\u003e \u003c!--父组件中传值--\u003e \u003cscript\u003e...,props:['msg','school'] //子组件中接受 \u003c/script\u003e \u003ch3\u003e{{msg}}\u003c/h3\u003e \u003c!--子组件中使用--\u003e \u003ch3\u003e{{school}}\u003c/h3\u003e \u003c!--子组件中使用--\u003e $attrs存储传参 \u003cDemo msg='111' school='222'\u003e \u003c!--父组件中传值--\u003e \u003cscript\u003e...,props:[] //子组件中不接受 \u003c/script\u003e \u003ch3\u003e{{$attrs.msg}}\u003c/h3\u003e \u003c!--子组件中使用--\u003e \u003ch3\u003e{{$attrs.school}}\u003c/h3\u003e \u003c!--子组件中使用--\u003e 这里注意一个现象： 同样的，$slots中也能够存储插槽的虚拟节点信息。如： \u003cDemo\u003e \u003cspan\u003e1111\u003c/span\u003e \u003cspan\u003e2222\u003c/span\u003e \u003c/Demo\u003e \u003c!--父组件中传值--\u003e \u003cdiv class=\"demo\"\u003e \u003ch3\u003e我是Demo组件\u003c/h3\u003e \u003cslot\u003e\u003c/slot\u003e\u003c!--子组件中不管使不使用，$slots中均有内容--\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/div\u003e Vue3中父子组件传值方式\rsetup在beforeCreate之前执行，且setup内的this是undefined。 \u003cscript\u003e export default { name: 'Demo', beforeCreate(){ console.log('---beforeCreate---') }， setup(){ console.log('---setup---',this) } } \u003c/script\u003e 控制台效果： setup中的props参数接受传参 \u003cDemo msg='111' school='222'\u003e \u003c!--父组件中传值--\u003e \u003cscript\u003e\u003c!--子组件中接收--\u003e export default { name: 'Demo', setup(props){ console.log('---setup---',props) } } \u003c/script\u003e 控制台效果： ​ 说明Vue3中不能只申明不接收就在setup中使用！ \u003cscript\u003e\u003c!--子组件中接收--\u003e export default { name: 'Demo', props:['msg','school'],//*******所有传入参数，必须全部申明********* setup(props){ console.log('---setup---',props) } } \u003c/script\u003e setup中的context参数 \u003cscript\u003e\u003c!--子组件中接收--\u003e export default { name: 'Demo', setup(context){ console.log('---setup---',context) } } \u003c/script\u003e 控制台效果： 这个里面配置项的效果，与Vue2中对应的配置项，的效果一致。 注意！emits要用的时候，必须都先申明： \u003cscript\u003e\u003c!--子组件中接收--\u003e export default { name: 'Demo', props:['msg','school'],//*******申明props********* emits:['hello'],//*******申明emits********* setup(props,context){ console.log('---setup---',context.attrs)//相当于Vue2中的$attrs console.log('---setup---',context.emit)//触发自定义事件 console.log('---setup---',context.slots)//插槽 } } \u003c/script\u003e 注意：Vue3中有API兼容的问题，推荐使用插槽的时候使用v-slot:名字的方式 \u003c!--父组件中传值--\u003e \u003ctemplate v-slot:qwe\u003e \u003cspan\u003e11111\u003c/span\u003e \u003c/template\u003e ","date":"2024-11-14","objectID":"/vue3/:3:6","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"7.计算属性与监视 1.computed函数 与Vue2.x中computed配置功能一致 写法 import {computed} from 'vue' setup(){ ... //计算属性一简写 let fullName = computed(()=\u003e{ return person.firstName + '-' + person.lastName }) //计算属性-完整 let fullName = computed({ get(){ return person.firstName +'-'+ person.lastName }, set(value){ const nameArr =value.split('_') person.firstName =nameArr[0] person.lastName =nameArr[1] } }) } 2.watch函数 与Vue2.x中watch配置功能一致 两个小\"坑\"： 监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视(deep配置失效)。 监视reactive定义的响应式数据中某个属性时：deep配置有效。 //情况一:监视ref定义的响应式数据 watch(sum,(newValue,oldValue)=\u003e{ console.log('sum变化了',newValue,oldValue) },{immediate:true}) //情况二:监视多个ref定义的响应式数据 watch([sum,msg],(newValue,oldValue)=\u003e{ console.log('sum或msg变化了',newValue,oldValue) }) /*情况三:监视reactive定义的响应式数据 若watch监视的是reactive定义的响应式数据，则无法正确获得oldvalue!! 若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */ watch(person,(newValue,oldValue)=\u003e{ console.log('person变化了',newValue,oldValue) },{immediate:true,deep:false})//此处的deep配置不再奏效 //情况四:监视reactive定义的响应式数据中的某个属性 watch(()=\u003eperson.job,(newValue,oldValue)=\u003e{ console.log('person的job变化了',newValue,oldValue) },{immediate:true,deep:true}) //情况五:监视reactive所定义的一个响应式数据中的某些属性 watch([()=\u003eperson.name,()=\u003eperson.age],(newValue,oldValue)=\u003e{ console.log('person的name或age变化了',newValue,oldValue) }) //特殊情况 watch(()=\u003eperson.job,(newValue,oldValue)=\u003e{ console.log('person的job变化了',newValue,oldValue) },{deep:true})//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效 3.watchEffect函数 watch的套路是：既要指明监视的属性，也要指明监视的回调。 watchEfect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。 watchEffect有点像computed： 但computed注重的计算出来的值(回调函数的返回值)，所以必须要写返回值 而watchEffect更注重的是过程(回调函数的函数体)，所以不用写返回值。 //watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。 watchEffect(()=\u003e{ const x1= sum.value const x2=person.age console.log('watchEffect配置的回调执行了') }) ","date":"2024-11-14","objectID":"/vue3/:3:7","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"8.生命周期 待完善 ","date":"2024-11-14","objectID":"/vue3/:3:8","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"9.自定义hook函数 什么是hook?——本质是一个函数，把setup函数中使用的Composition API进行了封装。 类似于vue2.x中的mixin。 自定义hook的优势：复用代码，让setup中的逻辑更清楚易懂。 ","date":"2024-11-14","objectID":"/vue3/:3:9","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"10.toRefs 作用：创建一个 ref对象，其value值指向另一个对象中的某个属性值。 语法：const name =toRef(person,'name') 应用：要将响应式对象中的某个属性单独提供给外部使用时。 扩展：toRefs与toRef功能一致，但可以批量创建多个ref 对象，语法：toRefs(person) ","date":"2024-11-14","objectID":"/vue3/:3:10","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"三、其它 Composition API ","date":"2024-11-14","objectID":"/vue3/:4:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.shallowReactive 与 shallowRef shallowReactive：只处理对象最外层属性的响应式(浅响应式)。 shallowRef：只处理基本数据类型的响应式，不进行对象的响应式处理。 什么时候使用? 如果有一个对象数据，结构比较深，但变化时只是外层属性变化 ===\u003e shallowReactive。 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===\u003e shallowRef。 ","date":"2024-11-14","objectID":"/vue3/:4:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.readonly 与 shallowReadonly readonly：让一个响应式数据变为只读的(深只读)。 shallowReadonly：让一个响应式数据变为只读的(浅只读)。 应用场景：不希望数据被修改时。 ","date":"2024-11-14","objectID":"/vue3/:4:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"3.toRaw 与 markRaw toRaw： 作用：将一个由reactive 生成的响应式对象转为普通对象。 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。 markRaw： 作用：标记一个对象，使其永远不会再成为响应式对象。 应用场景： 有些值不应被设置为响应式的，例如复杂的第三方类库等。 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。 ","date":"2024-11-14","objectID":"/vue3/:4:3","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"4.customRef 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。 实现防抖效果： \u003ctemplate\u003e \u003cinput type=\"text\" v-model=\"keyword\"\u003e \u003ch3\u003e{{keyword}}\u003c/h3\u003e \u003c/template\u003e \u003cscript\u003e import {ref,customRef} from 'vue' export default{ name:'Demo', setup(){\\ //let keyword = ref('hello') //使用Vue准备好的内置ref //自定义一个myRef function myRef(value,delay){ let timer //通过customRef去实现自定义 return customRef((track,trigger)=\u003e{ return{ get(){ track()//告诉Vue这个value值是需要被“追踪”的 return value }, set(newValue){ clearTimeout(timer) timer = setTimeout(()=\u003e{ value = newValue trigger()//告诉Vue去更新界面 },delay) } } }) } // let keyWord =ref('hello') //使用Vue提供的ref let keyWord = myRef('hello',500)//使用程序员自定义的ref return {keyWord} } \u003c/script\u003e ","date":"2024-11-14","objectID":"/vue3/:4:4","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"5.provide 与 inject 作用：实现祖孙组件间通信 套路：父组件有一个 provide 选项来提供数据，子组件有一个 inject 选项来开始使用这些数据 具体写法： 祖组件中: setup(){ ... let car =reactive({name:'奔驰',price:'40万'}) provide('car',car) ... } 孙组件中: setup(props,context){ ... const car=inject('car') return {car} ... } ","date":"2024-11-14","objectID":"/vue3/:4:5","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"6.响应式数据的判断 isRef：检查一个值是否为一个 ref 对象 isReactive：检查一个对象是否是由 reactive 创建的响应式代理 isReadonly：检査一个对象是否是由 readonly 创建的只读代理 isProxy：检査一个对象是否是由 reactive 或者 readonly 方法创建的代理 ","date":"2024-11-14","objectID":"/vue3/:4:6","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"四、Composition API 的优势 ","date":"2024-11-14","objectID":"/vue3/:5:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.Options API 存在的问题 使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改。 ","date":"2024-11-14","objectID":"/vue3/:5:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.Composition APl 的优势 我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。 ","date":"2024-11-14","objectID":"/vue3/:5:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"五、新的组件 ","date":"2024-11-14","objectID":"/vue3/:6:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.Fragment 在Vue2中：组件必须有一个根标签 在Vue3中：组件可以没有根标签，内部会将多个标签包含在一个Fragment虚拟元素中 好处：减少标签层级，减小内存占用 ","date":"2024-11-14","objectID":"/vue3/:6:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.Teleport 什么是Teleport? —— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。 \u003cteleport to=\"移动位置\"\u003e \u003cdiv v-if=\"isShow\" class=\"mask\"\u003e \u003cdiv class=\"dialog\"\u003e \u003ch3\u003e我是一个弹窗\u003c/h3\u003e \u003cbutton @click=\"isShow = false\"\u003e关闭弹窗\u003c/button\u003e \u003c/div\u003e \u003c/div\u003e \u003c/teleport\u003e ","date":"2024-11-14","objectID":"/vue3/:6:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"3.Suspense 等待异步组件时渲染一些额外内容，让应用有更好的用户体验 使用步骤： 异步引入组件 import {defineAsyncComponent} from 'vue' const Child = defineAsyncComponent(()=\u003eimport('./components/Child.vue')) 使用 Suspense包裹组件，并配置好 default 与 fallback \u003ctemplate\u003e \u003cdiv class=\"app\"\u003e \u003ch3\u003e我是App组件\u003c/h3\u003e \u003cSuspense\u003e \u003ctemplate v-slot:default\u003e \u003cChild/\u003e \u003c/template\u003e \u003ctemplate v-slot:fallback\u003e \u003ch3\u003e加载中.....\u003c/h3\u003e \u003c/template\u003e \u003c/Suspense\u003e \u003c/div\u003e \u003c/template\u003e ","date":"2024-11-14","objectID":"/vue3/:6:3","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"六、其他 ","date":"2024-11-14","objectID":"/vue3/:7:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.全局API的转移 Vue 2.x有许多全局 API和配置。 例如：注册全局组件、注册全局指令等 //注册全局组件 Vue.component('MyButton',{ data:()=\u003e({ count:0 }), template:'\u003cbutton @click=\"count++\"\u003eClicked {{ count }} times.\u003c/button\u003e' //注册全局指令 Vue.directive('focus',{ inserted:el =\u003eel.focus() } Vue3.0中对这些API做出了调整： 将全局的API，即:Vue.xxx调整到应用实例(app)上 ","date":"2024-11-14","objectID":"/vue3/:7:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.其他改变 data选项应始终被声明为一个函数。 过度类名的更改: Vue2.x写法 .enter, .v-leave-to{ opacity:0; } .v-leave, .v-enter-to{ opacity: 1; } Vue3.x写法 .v-enter-from, .v-leave-to{ opacity: 0; } .v-leave-from, .v-enter-to{ opacity: 1; } 移除 keyCode作为 v-on 的修饰符，同时也不再支持 config.keyCodes 移除 v-on.native 修饰符 父组件中绑定事件 \u003cmy-component v-on:close=\"handleComponentEvent\" v-on:click=\"handleNativeclickEvent\" /\u003e 子组件中声明自定义事件 \u003cscript\u003e export default { emits:['close'] } \u003c/script\u003e 移除过滤器(filter) 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是“只是 JavaScript\" 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。 ","date":"2024-11-14","objectID":"/vue3/:7:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["Office基本操作"],"content":"带路径的文件名称 待提取的文件夹下新建txt文件，拷贝下面这段代码 @echo off dir /s/b *.* \u003e文件名.txt exit 保存这个txt文件，然后将txt文件的后缀修改为bat。 双击这个bat文件，此时文件夹中会多出来一个txt文件，此txt文件就是提取的文件夹路径和文件名称了。 ","date":"2024-11-11","objectID":"/text36/:1:0","tags":["bat","excel"],"title":"【bat批处理】提取多文件夹下的文件名称","uri":"/text36/"},{"categories":["Office基本操作"],"content":"带结构的文件名称 待提取的文件夹下新建txt文件，拷贝下面这段代码 @ECHO OFF tree /F \u003e 文件名列表.txt 保存这个txt文件，然后将txt文件的后缀修改为bat。 双击这个bat文件，此时文件夹中会多出来一个txt文件，此txt文件就是提取的文件夹路径和文件名称了。 ","date":"2024-11-11","objectID":"/text36/:2:0","tags":["bat","excel"],"title":"【bat批处理】提取多文件夹下的文件名称","uri":"/text36/"},{"categories":["Office基本操作"],"content":"excel处理文件名称 选择文件路径内容所在列，选择导航栏：数据 - 分列 默认选择[分隔符]号，点击下一步。 选择其他并输入符号“\\”，点击下一步。 点击完成。 ","date":"2024-11-11","objectID":"/text36/:3:0","tags":["bat","excel"],"title":"【bat批处理】提取多文件夹下的文件名称","uri":"/text36/"},{"categories":["Idea"],"content":"idea连接svn配置选项设置如下： ","date":"2024-11-11","objectID":"/text38/:0:0","tags":["idea"],"title":"【idea】IDEA现有项目连接SVN","uri":"/text38/"},{"categories":["前端"],"content":"闭包的概念 如果一个函数访问了此函数的父级及父级以上的作用域变量，那么这个函数就是一个闭包。 本质上，JS中的每个函数都是一个闭包，因为每个函数都可以访问[全局变量]。 ","date":"2024-11-11","objectID":"/text37/:0:1","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["前端"],"content":"闭包的用途 访问函数内部的变量 让变量始终保持在内存中 ","date":"2024-11-11","objectID":"/text37/:0:2","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["前端"],"content":"闭包的优点 可以减少全局变量的定义，避免全局变量的污染 能够读取函数内部的变量 在内存中维护一个变量，可以用做缓存 ","date":"2024-11-11","objectID":"/text37/:0:3","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["前端"],"content":"闭包的2种形成方式 1、函数作为参数被传递 // 将函数作为实参传递给另一个函数调用 function showDelay(msg,time){ //setTimeout 的第一个参数function是函数，符合闭包的规则 setTimeout(function(){ alert(msg) },time) } showDelay('张三',2000) 2、函数作为返回值被返回 function a() { var i = '初始值'; i = i + \"—_执行a\" // 此处的函数b访问了父级函数a中的局部变量i,成为了一个闭包 function b() { i = i + \"_执行b\" console.log(i) } return b; } var c = a(); // 此时 i 的值为 ：初始值—_执行a c() // 此时 i 的值为 ：初始值—_执行a_执行b c() // 此时 i 的值为 ：初始值—_执行a_执行b_执行b 将函数a赋值给全局变量c时，a会执行一次，局部变量 i 的值变为初始值—_执行a，最终返回函数b，此时全局变量c的值为闭包函数b的引用。 此时函数a虽然已执行完，但因为内部包含闭包函数b，所以函数 a 的执行期上下文会继续保留在内存中，不会被销毁，所以局部变量 i 仍是初始值—_执行a This is a tip\r执行期上下文：当函数执行时，会创建一个执行期上下文的内部对象。每调用一次函数，就会创建一个新的上下文对象，他们之间是相互独立的。当函数执行完毕，它所产生的执行期上下文会被销毁\r第一次执行 c() 时，闭包函数b第一次执行，局部变量 i 的值变为初始值—_执行a_执行b 第二次执行 c() 时，闭包函数b第二次执行，局部变量 i 的值变为初始值—_执行a_执行b_执行b ","date":"2024-11-11","objectID":"/text37/:0:4","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["前端"],"content":"闭包的特点 被闭包函数访问的父级及以上的函数的局部变量（如范例中的局部变量 i ）会一直存在于内存中，不会被JS的垃圾回收机制回收。 闭包函数实现了对其他函数内部变量的访问。（函数内部的变量对外是无法访问的，闭包通过这种变通的方法，实现了访问。） This is a tip\rJavascript的垃圾回收机制： 如果一个对象不再被引用，那么这个对象就会被GC回收。 如果两个对象互相引用，而不再被第三者所引用，那么这两个对象都会被回收。 ","date":"2024-11-11","objectID":"/text37/:0:5","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["前端"],"content":"闭包的应用场景 模拟两人对话、使setTimeout支持传参、封装私有变量、模拟块作用域、实现迭代器 ","date":"2024-11-11","objectID":"/text37/:0:6","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["前端"],"content":"闭包的缺点 造成内存泄露 闭包会使函数中的变量一直保存在内存中，内存消耗很大，所以不能滥用闭包。 【内存泄露：无用的变量一直在内存中，无法被释放】 解决方法：使用完变量后，手动将它赋值为null； This is a tip\r闭包是内存泄漏吗? 闭包只是让变量在内存常驻，本身不是内存泄漏， 滥用闭包才会导致内存泄漏 闭包可能在父函数外部，改变父函数内部变量的值。 造成性能损失 由于闭包涉及跨作用域的访问，所以会导致性能损失。 解决方法：通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响 免责申明\r———————————————— 转载摘录，原文链接：https://blog.csdn.net/weixin_41192489/article/details/124312822 本文仅用于记录学习，不做商用，版权归属原作者，如涉侵权，请联系删除 ","date":"2024-11-11","objectID":"/text37/:0:7","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["虚拟机"],"content":"新建一个虚拟机 1、打开虚拟机主页面，点击“创建新的虚拟机” 2、该页面建议选择”自定义“，并点击”下一步“ 3、这里选最大16.2.x，并点击“下一步” 4、选择“稍后安装操作系统”，并点击“下一步” 5、没有win11的名称，就选择win10 x64版本，并点击“下一步” 6、根据自己具体的情况，选择虚拟机存放的位置 7、修改虚拟机的名称，用于区别自己创建的其他虚拟机。并点击“下一步” 8、该页面，点击“下一步” 9、根据情况和需求，配置处理器数量。并点击“下一步” 10、根据情况和需求，配置内存大小。并点击“下一步” 11、选择“使用桥接网络”，并点击“下一步” 12、点击“下一步” 13、点击“下一步” 14、点击“下一步” 15、根据情况和需求，配置磁盘大小。并点击“下一步” 16、根据自己具体的情况，选择虚拟机存放的位置，并点击“下一步” 17、在浏览器使用搜索引擎（这里使用的是：百度搜索引擎），搜索Windows11。选择微软官网。 18、在官网找到“win11磁盘映像” 19、选择ISO版本，语言“简体中文”，点击64-bit Download 20、找到下载完成后保存的位置 21、继续回到虚拟机安装导向，点击自定义硬件 22、选择新CD/DVD，选择使用ISO映像文件，配置刚刚下载的文件的位置，点击“关闭”。 23、点击“完成” 24、点击“编辑虚拟机设置”，选择“选项”卡，选择“访问控制”，点击“加密” 25、根据自己的情况，设置加密密码，两次密码保持一致。并点击“加密” --随机生成密码 spoHLT2b 26、选择“硬件选项卡”，点击“添加，”选择“可信平台模块”，并点击完成 27、点击“开启此虚拟机”。 28、进入时，如卡住，按enter回车键，继续。ctrl+alt可以实现鼠标光标在虚拟机内外来回切换 29、出现“安装系统界面”，点击\"下一步\" 30、点击\"下一步\" 31、选择\"我没有产品密钥\" 32、选择\"win11专业版\"，并点击\"下一步\" 33、勾选\"我接受\"，并点击\"下一步\" 34、新建磁盘空间，点击\"新建\"，大小为1024的倍数。例如50G就是50*1024即可。点击\"应用\" 35、其余自动的硬盘分区，也应用，并点击\"下一步\" 39、点击\"安装\" 40、等待安装进度条 41、可以等待他自动重启，也可以点击\"立即重启\" 42、等待重启 43、安装准备界面，根据提示和导向，一路点\"是\" --pin 1437059026@qq.com 48、等待桌面加载 49、进入到win11系统桌面界面 ","date":"2024-11-06","objectID":"/text35/:0:1","tags":["VMware"],"title":"【VMware】VMware虚拟机安装Windows11系统教程","uri":"/text35/"},{"categories":["虚拟机"],"content":"设置虚拟机屏幕全屏 1、选择\"虚拟机\"，选择\"安装VMware Tools\" 2、右下角弹出窗，表示安装完成 3、进入资源管理器，选择\"此电脑\"，双击打开\"DVD驱动器\" 4、选择\"是\"，等待安装 5、弹出\"安装向导\"，点击\"下一步\" 6、继续点击\"下一步\" 7、点击\"安装\" 8、等待安装进度 9、安装完成后就自动适配了全屏，点击\"完成\" 10、弹出窗，选择\"是\" ","date":"2024-11-06","objectID":"/text35/:0:2","tags":["VMware"],"title":"【VMware】VMware虚拟机安装Windows11系统教程","uri":"/text35/"},{"categories":["虚拟机"],"content":"虚拟机内win11系统激活 打开个性化有下面这个标识，标识win11系统未激活 1、激活脚本拷贝进虚拟机 https://www.123pan.com/s/g520Vv-rgRid 2、连接上网络，双击激活脚本，选择\"是\" 3、根据该网址激活教程操作 https://massgrave.dev/ irm https://get.activated.win | iex ​ 到此，关闭所有黑窗口 6、桌面空白处，右键，选择\"个性化\"。若激活提示消失，说明激活成功。 ","date":"2024-11-06","objectID":"/text35/:0:3","tags":["VMware"],"title":"【VMware】VMware虚拟机安装Windows11系统教程","uri":"/text35/"},{"categories":["虚拟机"],"content":"操作习惯设置 1、个性化 - 主题 - 桌面图标设置 2、勾选\"计算机\"、“回收站”、“控制面板”，点击\"应用\" 3、系统 - 显示 - 缩放 ， 大小改为\"125%\" 4、虚拟机这个图标可以全屏，全屏后顶部同样点这个图标可以退出全屏 开机密码-- 1437059026 ","date":"2024-11-06","objectID":"/text35/:0:4","tags":["VMware"],"title":"【VMware】VMware虚拟机安装Windows11系统教程","uri":"/text35/"},{"categories":["虚拟机"],"content":"虚拟机下载资源 虚拟机安装包：https://www.123pan.com/s/g520Vv-Dg2id 最新系统镜像文件：https://www.123pan.com/s/g520Vv-KIWid 最新Win10Win11系统激活工具：https://www.123pan.com/s/g520Vv-rgRid 虚拟机安装 win11系统选择VMware-workstation-full-16.2.3-19376536.exe 1、双击安装程序 2、在该界面等待准备完成 3、准备完成出现安装导向，点击”下一步“ 4、点“接受”，继续“下一步” 5、安装位置，根据自己的情况来选择，并点击“下一步” 6、取消勾选这两个选项，并点击“下一步” 7、快捷方式根据自己情况勾选，并点击“下一步” 8、点击安装，等待安装 9、安装结束界面，点击“许可证” 10、把激活密钥，复制粘贴到许可证的位置 11、点击“输入” 12、最后点击“完成” 13、桌面上双击虚拟机图标进入虚拟机，检查是否安装成功 ","date":"2024-11-06","objectID":"/text34/:0:0","tags":["VMware"],"title":"【VMware】VMware虚拟机下载安装激活教程","uri":"/text34/"},{"categories":["Idea"],"content":"1. idea可以显示侧边文件的最后修改时间以及文件大小 具体如下图 ","date":"2024-11-04","objectID":"/text32/:0:1","tags":["Java"],"title":"【idea】IDEA显示侧边文件的最后修改时间以及文件大小","uri":"/text32/"},{"categories":["Idea"],"content":"2. 关闭或开启 在低版本的idea中 可以使用快捷键 Shift + alt + \\ 来进行开启或者关闭 在idea高版本中取消了快捷键，可以在setting中手动设置快捷键 或者在view - Appearance - Details in Tree View 通过勾选或者取消勾选来进行开启或关闭 ","date":"2024-11-04","objectID":"/text32/:0:2","tags":["Java"],"title":"【idea】IDEA显示侧边文件的最后修改时间以及文件大小","uri":"/text32/"},{"categories":["Java"],"content":"Java中正则的使用 ","date":"2024-11-04","objectID":"/regex/:0:0","tags":["JavaSE"],"title":"【Java】Java中正则的使用","uri":"/regex/"},{"categories":["Java"],"content":"正则简介 非常常见的问题： 如何判断字符串是否是有效的电话号码？例如：010-1234567，123ABC456，13510001000等 如何判断字符串是否是有效的电子邮件地址？例如：test@example.com，test#example等 如何判断字符串是否是有效的时间？例如：12:34，09:60，99:99等 如何通过程序判断，这种方法需要为每种用例创建规则，然后用代码实现，太过复杂；因此出现了正则表达式 正则表达式就是一个描述规则的字符串，所以，只需要编写正确的规则，我们就可以让正则表达式引擎去判断目标字符串是否符合规则； 正则适用于任何语言 正则表达式是用字符串描述的一个匹配规则，使用正则表达式可以快速判断给定的字符串是否符合匹配规则。Java标准库Java.util.regex内建了正则表达式引擎 ","date":"2024-11-04","objectID":"/regex/:1:0","tags":["JavaSE"],"title":"【Java】Java中正则的使用","uri":"/regex/"},{"categories":["Java"],"content":"匹配规则 基本的规则 .：匹配任意字符 \\d：匹配数字；\\D表示匹配非数字 \\w：匹配一个字母、数字或下划线，w的意思是word；\\W表示匹配非字母 \\s：匹配空格、tab键；S表示匹配非空格 [ABC]：匹配方括号中任意字符 [axA-F1-9]：匹配 a、x、A-F、1-9中的任意字符 AB|CD|EF：匹配 AB或CD或EF [\\u4e00-\\u9fa5]：匹配中文 [^A-F]：匹配不包含 A-F 的字符，^ 放在 [] 中表示不匹配 ^：匹配开头，放在 [] 中表示不匹配 $：匹配结尾 ^[0-9]\\*$：^ 表示以什么开头，$ 表示以什么结尾，这里正则代表匹配数字 匹配次数 {n}：匹配 n 次 {n,m}：匹配 n-m 次 {n,}：匹配最少n次，最大无上限 *：匹配任意次 +：匹配至少一次以上 注意：Java中字符的转义和正则表达式中的转义 //简单的正则匹配，注意转义字符的使用 boolean b1 = \"abc\".matches(\"abc\"); //true boolean b2=\"19882445846\".matches(\"1\\\\d{10}\"); //true boolean b3=\"lei@sdadsa.com\".matches(\"\\\\w{1,4}@\\\\w{5,6}\\\\.\\\\w{2,3}\"); //true boolean b4=\"A19a\".matches(\"[A19]{4}\"); //false，因为[]中没有字符 a boolean b5=\"045875641\".matches(\"[1-9]*\"); //false boolean b6=\"145875641\".matches(\"[1-9]*\"); //true ","date":"2024-11-04","objectID":"/regex/:2:0","tags":["JavaSE"],"title":"【Java】Java中正则的使用","uri":"/regex/"},{"categories":["Java"],"content":"分组匹配 使用(...)进行分组匹配 姓名：电话这个规则，匹配字符串后，分别取出姓名和电话，方便后续操作 分组匹配单次 /* * 注意： * m.matches() 判断的是匹配的整个字符串，匹配成功返回 true，失败返回 false * */ Pattern p = Pattern.compile(\"([\\\\u4e00-\\\\u9fa5]{2,3})-(1\\\\d{10})\"); Matcher m = p.matcher(\"张三-15196116945\"); int start=0; if (m.matches()){ m.group(0); //张三-15196116945 m.group(1); //张三 m.group(2) //15196116945 } 分组匹配多次 /* * 注意: * m.matches() 在这里会返回 false，因为 正则规则此时不能完全匹配字符串 * m.find(i) 带参数时，表示从字符串索引 i 后开始寻找匹配，不带参数表示从头开始 * m.end() 返回当前匹配字符串最后位置索引 * m.group() 表示当前已经匹配上的字符串，参数0 表示当前匹配的字符串全部，参数1 表示当前匹配的分组规则1的字符换 ...... * */ Pattern p = Pattern.compile(\"([\\\\u4e00-\\\\u9fa5]{2,3})-(1\\\\d{10})\"); Matcher m = p.matcher(\"张三-15196111945李四-19882415846\"); int start=0; while (m.find(start)){ System.out.println(m.group(0)+m.group(1)+\":\"+m.group(2)); m.group(1); m.group(2); start=m.end(); } 例子：获取2021-09-11 23:01:59的年月日和时分秒 Pattern pattern = Pattern.compile(\"(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\\\\s(\\\\d{2}):(\\\\d{2}):(\\\\d{2})\"); Matcher matcher = pattern.matcher(\"2021-09-11 23:01:59\"); if (matcher.matches()) { System.out.println(matcher.group(1)+\"年\"+matcher.group(2)+\"月\"+matcher.group(3)+\"日\"); System.out.println(matcher.group(4)+\"时\"+matcher.group(5)+\"分\"+matcher.group(6)+\"秒\"); } ","date":"2024-11-04","objectID":"/regex/:3:0","tags":["JavaSE"],"title":"【Java】Java中正则的使用","uri":"/regex/"},{"categories":["Java"],"content":"非贪婪匹配 正则匹配默认为贪婪匹配，既尽可能多的进行匹配 给定一个字符串表示的数字，现判断结尾0的个数 157000：三个0 9560：一个零 595：0个0 思路：使用分组匹配，正则表达式为：(\\d+)(0*)，代码如下 Pattern pattern = Pattern.compile(\"(\\\\d+)(0*)\"); Matcher matcher = pattern.matcher(\"157000\"); if (matcher.matches()) { matcher.group(1); // \"157000\" matcher.group(2); // \"\" } 可以看到：(\\d+)将整个数字字符串都进行匹配了，因为默认为贪婪匹配，会尽可能多的匹配满足条件的字符 使用?修改为非贪婪匹配，(\\d+?) 此时只要匹配上就不继续进行匹配了，代码如下 Pattern pattern = Pattern.compile(\"(\\\\d+?)(0*)\"); Matcher matcher = pattern.matcher(\"1230000\"); if (matcher.matches()) { System.out.println(\"group1=\" + matcher.group(1)); // \"123\" System.out.println(\"group2=\" + matcher.group(2)); // \"0000\" } 注意：matcher.matches() 方法，会尽可能地去完成匹配，结合下面 matcher.find() 例子理解 // matcher.find() 带参数时，从字符串首位开始进行匹配 // 这里(\\d+?)表示非贪婪匹配，只要匹配到则返回；(0*)匹配 0个或多个0 // 因此这里会匹配到三次，循环输出三次，前两次group(1)都只是匹配到了一个数字结束，最后一次匹配到3000 Pattern pattern = Pattern.compile(\"(\\\\d+?)(0*)\"); Matcher matcher = pattern.matcher(\"1230000\"); int start=0; while (matcher.find(start)){ System.out.println(matcher.group(1)+\":\"+matcher.group(2)); start=matcher.end(); } //输出结果如下： // 1: // 2: // 3:0000 ","date":"2024-11-04","objectID":"/regex/:4:0","tags":["JavaSE"],"title":"【Java】Java中正则的使用","uri":"/regex/"},{"categories":["Java"],"content":"搜索和替换 分割字符串 使用正则表达式分割字符串可以实现更加灵活的功能。String.split()方法传入的正是正则表达式。我们来看下面的代码： \"a b c\".split(\"\\\\s\"); // { \"a\", \"b\", \"c\" } \"a b c\".split(\"\\\\s\"); // { \"a\", \"b\", \"\", \"c\" } \"a, b ;; c\".split(\"[\\\\,\\\\;\\\\s]+\"); // { \"a\", \"b\", \"c\" } 如果我们想让用户输入一组标签，然后把标签提取出来，因为用户的输入往往是不规范的，这时，使用合适的正则表达式，就可以消除多个空格、混合,和;这些不规范的输入，直接提取出规范的字符串。 搜索字符串 使用正则表达式还可以搜索字符串，我们来看例子： String s = \"the quick brown fox jumps over the lazy dog.\"; Pattern p = Pattern.compile(\"\\\\wo\\\\w\"); Matcher m = p.matcher(s); while (m.find()) { String sub = s.substring(m.start(), m.end()); System.out.println(sub); } 我们获取到Matcher对象后，不需要调用matches()方法（因为匹配整个串肯定返回false），而是反复调用find()方法，在整个串中搜索能匹配上\\\\wo\\\\w规则的子串，并打印出来。这种方式比String.indexOf()要灵活得多，因为我们搜索的规则是3个字符：中间必须是o，前后两个必须是字符[A-Za-z0-9_]。 替换字符串 使用正则表达式替换字符串可以直接调用String.replaceAll()，它的第一个参数是正则表达式，第二个参数是待替换的字符串 String s = \"The quick\\t\\t brown fox jumps over the lazy dog.\"; String r = s.replaceAll(\"\\\\s+\", \" \"); System.out.println(r); // \"The quick brown fox jumps over the lazy dog.\" 反向引用 如果我们要把搜索到的指定字符串按规则替换，比如前后各加一个\u003cb\u003exxxx\u003c/b\u003e，这个时候，使用replaceAll()的时候，我们传入的第二个参数可以使用$1、$2来反向引用匹配到的子串。例如： String s = \"the quick brown fox jumps over the lazy dog.\"; String r = s.replaceAll(\"\\\\s([a-z]{4})\\\\s\", \" \u003cb\u003e$1\u003c/b\u003e \"); System.out.println(r); //the quick brown fox jumps \u003cb\u003eover\u003c/b\u003e the \u003cb\u003elazy\u003c/b\u003e dog. 它实际上把任何4字符单词的前后用\u003cb\u003exxxx\u003c/b\u003e括起来。实现替换的关键就在于\" \u003cb\u003e$1\u003c/b\u003e \"，它用匹配的分组子串([a-z]{4})替换了$1 例子：将2021-09-11 23:01:59替换显示为2021年09月11日 23时01分59秒 String time=\"2021-09-11 23:01:59\"; String formatTime=time.replaceAll(\"(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\\\\s(\\\\d{2}):(\\\\d{2}):(\\\\d{2})\",\"$1年$2月$3日 $4时$5分$6秒\"); System.out.println(s); //2021年09月11日 23时01分59秒 ","date":"2024-11-04","objectID":"/regex/:5:0","tags":["JavaSE"],"title":"【Java】Java中正则的使用","uri":"/regex/"},{"categories":["Java"],"content":"一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。 Apple apple = new Apple(); //直接初始化，「正射」 apple.setPrice(4); 上面这样子进行类对象的初始化，我们可以理解为「正」。 ","date":"2024-11-04","objectID":"/text31/:0:0","tags":["Java"],"title":"【Java】反射的基本使用及API","uri":"/text31/"},{"categories":["Java"],"content":"反射 不知道初始化的对象是什么，无法使用new关键字 这时候，我们使用 JDK 提供的反射 API 进行反射调用： Class clz = Class.forName(\"com.chenshuyi.reflect.Apple\"); Method method = clz.getMethod(\"setPrice\", int.class); Constructor constructor = clz.getConstructor(); Object object = constructor.newInstance(); method.invoke(object, 4); 在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect.Apple） 反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法 ","date":"2024-11-04","objectID":"/text31/:1:0","tags":["Java"],"title":"【Java】反射的基本使用及API","uri":"/text31/"},{"categories":["Java"],"content":"一个简单例子 public class Apple { private int price; public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } public static void main(String[] args) throws Exception{ //正常的调用 Apple apple = new Apple(); apple.setPrice(5); System.out.println(\"Apple Price:\" + apple.getPrice()); //使用反射调用 Class clz = Class.forName(\"com.chenshuyi.api.Apple\"); Method setPriceMethod = clz.getMethod(\"setPrice\", int.class); Constructor appleConstructor = clz.getConstructor(); Object appleObj = appleConstructor.newInstance(); setPriceMethod.invoke(appleObj, 14); Method getPriceMethod = clz.getMethod(\"getPrice\"); System.out.println(\"Apple Price:\" + getPriceMethod.invoke(appleObj)); } } 输出结果： Apple Price:5 Apple Price:14 从这个简单的例子可以看出，一般情况下我们使用反射获取一个对象的步骤： 获取类的 Class 对象实例 Class clz = Class.forName(\"com.zhenai.api.Apple\"); 根据 Class 对象实例获取 Constructor 对象 Constructor appleConstructor = clz.getConstructor(); 使用 Constructor 对象的 newInstance 方法获取反射类对象 Object appleObj = appleConstructor.newInstance(); 而如果要调用某一个方法，则需要经过下面的步骤： 获取方法的 Method 对象 Method setPriceMethod = clz.getMethod(\"setPrice\", int.class); 利用 invoke 方法调用方法 setPriceMethod.invoke(appleObj, 14); 到这里，我们已经能够掌握反射的基本使用。但如果要进一步掌握反射，还需要对反射的常用 API 有更深入的理解。 在 JDK 中，反射相关的 API 可以分为下面几个方面： 获取反射的 Class 对象、 通过反射创建类对象、 通过反射获取类属性方法及构造器。 ","date":"2024-11-04","objectID":"/text31/:1:1","tags":["Java"],"title":"【Java】反射的基本使用及API","uri":"/text31/"},{"categories":["Java"],"content":"反射常用API 1、获取反射中的Class对象 在 Java API 中，获取 Class 类对象有三种方法： **第一种，使用 Class.forName 静态方法。**当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。 Class clz = Class.forName(\"java.lang.String\"); 第二种，使用 .class 方法。 这种方法只适合在编译前就知道操作的 Class。 Class clz = String.class; 第三种，使用类对象的getClass()方法。 String str = new String(\"Hello\"); Class clz = str.getClass(); 2、通过反射获取类属性、方法、构造器 我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。 Class clz = Apple.class; Field[] fields = clz.getFields(); for (Field field : fields) { System.out.println(field.getName()); } 输出结果是： price 而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性： Class clz = Apple.class; Field[] fields = clz.getDeclaredFields(); for (Field field : fields) { System.out.println(field.getName()); } 输出结果是： name price 与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。 ","date":"2024-11-04","objectID":"/text31/:1:2","tags":["Java"],"title":"【Java】反射的基本使用及API","uri":"/text31/"},{"categories":["Office基本操作"],"content":"办法1：ctrl+p 在edge浏览器中，使用ctrl+p快捷键可以快速调出打印。 打印页面选择，另存为pdf ","date":"2024-11-04","objectID":"/text33/:0:1","tags":["pdf"],"title":"【PDF文档】将网页转换为pdf文件并下载","uri":"/text33/"},{"categories":["Office基本操作"],"content":"办法2：Open in new tab 打开网页右上方的三个点，找到更多工具，打开开发者工具； 找到Network，找到Fetch/XHR，CTRL+R刷新界面，滑到最下面的fetch文件； 右击最下面的fetch文件，选择Open in new tab； 自动跳转到文件下载页，点击下载按钮。 ","date":"2024-11-04","objectID":"/text33/:0:2","tags":["pdf"],"title":"【PDF文档】将网页转换为pdf文件并下载","uri":"/text33/"},{"categories":["Office基本操作"],"content":"办法3：window.open Open in new tab打不开的页面 打开控制台Console，输入下面代码，并按回车键 window.open(URL,'_blank') 这里的URL复制Network处的路径 在跳转到的文件下载页，点击下载按钮。 ","date":"2024-11-04","objectID":"/text33/:0:3","tags":["pdf"],"title":"【PDF文档】将网页转换为pdf文件并下载","uri":"/text33/"},{"categories":["Hugo系列"],"content":"image画廊 一个 image 示例: {{\u003c image src=\"./images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"./images/lighthouse-small.jpg\" src_l=\"./images/lighthouse-large.jpg\" \u003e}} 呈现的输出效果如下: Lighthouse (image)\rimage shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. ","date":"2024-11-01","objectID":"/text29/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（五）","uri":"/text29/"},{"categories":["Hugo系列"],"content":"typeit打字动画 typeit shortcode 基于 TypeIt 库提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2024-11-01","objectID":"/text29/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（五）","uri":"/text29/"},{"categories":["Hugo系列"],"content":"1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2024-11-01","objectID":"/text29/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（五）","uri":"/text29/"},{"categories":["Hugo系列"],"content":"2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2024-11-01","objectID":"/text29/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（五）","uri":"/text29/"},{"categories":["Hugo系列"],"content":"禁止解析代码块 使用/*...*/包裹禁止解析的代码，Hugo官方文档- 代码高亮. ","date":"2024-11-01","objectID":"/text29/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（五）","uri":"/text29/"},{"categories":["后端"],"content":"报错信息： A component required a bean of type ‘com...Mapper‘ that could not be found. Consider defining a bean of type ‘com.yinhai.msg.localResource.msgtpl.mapper 检查配置： pom文件（项目总） \u003cmodules\u003e ..... \u003cmodule\u003emsg-center\u003c/module\u003e ..... \u003c/modules\u003e pom文件（项目启动类） \u003cdependencies\u003e .... \u003cdependency\u003e \u003cgroupId\u003ecom.yinhai\u003c/groupId\u003e \u003cartifactId\u003emsg-center\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e .... \u003c/dependencies\u003e pom文件（所在包） \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cparent\u003e \u003cgroupId\u003ecom.yinhai\u003c/groupId\u003e \u003cartifactId\u003eyhch-base-backend\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cartifactId\u003emsg-center\u003c/artifactId\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.yinhai\u003c/groupId\u003e \u003cartifactId\u003ecommon\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e application-datasource.yml （启动类配置文件） ta404: datasource: datasource-list: * type: * druid: ta404ds: datasource: url: jdbc:oracle:* username: * password: * # 初始化连接数 initial-size: 5 # 连接池最大连接数量 max-active: 20 # 获取链接超时时间 （毫秒） max-wait: 60000 mybatis: mapper-locations: # mapper映射文件路径 - classpath*:mapper/msg-center/**.xml base-packages: # 包路径 - com.yinhai.msg.**.mapper mybatis-plus: db-type: oracle ","date":"2024-10-11","objectID":"/text28/:0:0","tags":["Spring-boot"],"title":"【Spring-boot】启动报错注入bean失败Mapper找不到","uri":"/text28/"},{"categories":["office基本操作"],"content":"\rThis is a tip\rword 页码不连续可通过以下步骤解决：1. 检查并删除分节符；2. 更改页码格式为连续编号；3. 更新整篇文档页码；4. 检查页眉或页脚中的页码设置，确保与正文一致；5. 取消页眉或页脚之间的链接。\r1. 检查分节符： 分节符可以将文档分成不同的部分，每个部分可以有自己的页码。 将光标放在页码中断处，然后转到“布局”选项卡 \u003e “分隔符”组。 如果有分节符插入，请删除它。 2. 更改页码格式： 转到“插入”选项卡 \u003e “页码”组。 选择“页码格式”选项，然后选择连续页码选项。 确保“页码起始编号”设置为 1。 3. 更新页码： 更新页码后，需要更新整个文档的页码。 转到“插入”选项卡 \u003e “页码”组，然后单击“更新页码”。 选择“更新整篇文档”选项。 4. 检查页眉或页脚： 有时，页眉或页脚中的页码设置可能与文档正文不匹配。 双击页眉或页脚区域进行编辑。 检查页码设置是否正确，并将其与文档正文中的页码保持一致。 5. 取消链接页眉或页脚： 如果页眉或页脚之间存在链接，可能会导致页码不连续。 双击要更改页眉或页脚的页面。 转到“设计”选项卡 \u003e “页眉和页脚”组，然后取消选中“链接到前一节”复选框。 ","date":"2024-10-08","objectID":"/text27/:0:0","tags":["office"],"title":"【word文档】word页脚页码不连续解决办法","uri":"/text27/"},{"categories":["Hugo系列"],"content":"hugo访问统计功能 由于静态网站静态的属性，所以一些动态的内容，如评论、计数等模块就需要借助外来平台。而不蒜子就是这么一个访问统计模块，但与百度统计谷歌分析不同的是，它可直接将访问次数显示在在网页上。因此我们可以通过不蒜子快速便捷地添加访问统计功能。 当然除了不蒜子，valine 评论系统也附带了单页的阅读人数统计。但是由于不蒜子除了单页的阅读人数统计还可以提供全站的访问统计，外加我用的不是 valine 评论系统，所以不蒜子是更加普适且好用的访问统计模块。 在下文中，由于不涉及主题的参数，所以有可能很多的 Hugo 主题都适用，但本文仍以 LoveIt 主题为例。 ","date":"2024-09-13","objectID":"/text24/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加 Html 模板 在your_site\\layouts\\partials\\plugin\\路径下添加文件busuanzi.html，并将下面的配置输入至该文件 在配置文件中添加参数 找到your_site\\config.toml配置文件，在最后面添加不蒜子的参数如下： # 添加不蒜子计数 [params.busuanzi] enable = true # 是否开启全站独立访客数 site_uv = true # 全站独立访客数前的图标或提示语 site_uv_pre = '\u003ci class=\"fa fa-user\"\u003e\u003c/i\u003e' # 全站独立访客数后的图标或提示语 site_uv_post = '' # 是否开启全站浏览量 site_pv = true # 全站浏览量前的图标或提示语 site_pv_pre = '\u003ci class=\"fa fa-eye\"\u003e\u003c/i\u003e' # 全站浏览量后的图标或提示语 site_pv_post = '' # 是否开启单页浏览量 page_pv = true # 单页浏览量前的图标或提示语 page_pv_pre = '\u003ci class=\"far fa-eye fa-fw\"\u003e\u003c/i\u003e' # 单页浏览量后的图标或提示语 page_pv_post = '' ","date":"2024-09-13","objectID":"/text24/:1:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"在对应处引入不蒜子 开启页脚的全站统计 把your_site\\themes\\LoveIt\\layouts\\partials\\footer.html复制粘贴到路径your_site\\layouts\\partials\\下。 再修改文件your_site\\layouts\\partials\\footer.html，在最后三行 \u003c/div\u003e \u003c/footer\u003e {{- end -}} 的前面添加 {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.busuanzi \"bsz_type\" \"footer\") -}} 添加后代码如下图： 最后的呈现结果如下图： This is a tip\r如果只想简单地开启全站统计，我们可以忽略## 添加 Html 模板和## 在配置文件中添加参数，直接从开启页脚的全站统计开始，但需把要添加的 {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.busuanzi \"bsz_type\" \"footer\") -}} 换为 \u003cscript async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"\u003e\u003c/script\u003e \u003cspan id=\"busuanzi_container_site_pv\"\u003e \u003ci class=\"fa fa-eye\"\u003e\u003c/i\u003e \u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e 次 \u003c/span\u003e | \u003cspan id=\"busuanzi_container_site_uv\"\u003e \u003ci class=\"fa fa-user\"\u003e\u003c/i\u003e \u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e 位 \u003c/span\u003e 但这种方法不好添加单页阅读 开启单页的阅读统计 把your_site\\themes\\LoveIt\\layouts\\posts\\single.html复制粘贴到路径your_site\\layouts\\posts\\下。再在your_site\\layouts\\posts\\single.html中找到第二个\u003cdiv class=\"post-meta-line\"\u003e标签，并在该标签下添加下面的代码 {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.busuanzi \"bsz_type\" \"page-reading\") -}} 添加后代码如下： 最后的呈现结果如下图： This is a tip\r参考文章：不蒜子官方\r","date":"2024-09-13","objectID":"/text24/:1:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"Permalinks 参数修改 修改这个参数，可以使我们之后修改网站文章的 url 更便捷，不需再采用hugo new posts/your_post.md新建文章的方式来修改，我们甚至还可以做到文章文件名与其 url 不一致。 This is a tip\r文章文件名就是指你使用hugo new posts/your_post.md后生成的文章的文件名，本例子中是your_post；而网站文章 url，是指这篇文章在你的 blog 网站中的 url，在本例中如果按照 LovIt 主题默认的方式，那么网站文章 url 为 https://stilig.me/your_post/\r","date":"2024-09-13","objectID":"/text24/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 Permalink 配置 找到博客根目录下的配置文件your_site/config.toml，找到参数Permalinks，按照下面的代码块修改： # Permalinks 配置 [Permalinks] # 原来是 posts = \":filename\"，其意为以文件名为 url posts = \"/posts/:slug\" # 如果你不想改变原来的 url（比如说文章已被搜索网站收录）,可以去掉/posts/，那么其将变为 posts= \":slug\" ","date":"2024-09-13","objectID":"/text24/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"将 slug 参数添加至.md文件的模版 在你博客的根目录下找到your_site\\archetypes\\default.md并打开，把 slug 参数 添加到 title 参数下，如下代码块： --- title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" slug: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" \u003c!-- 注意：这里 \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" 表示参数取文章的文件名，这只是为了防止参数为空而设定的默认值 --\u003e ... ... --- 这样我们新建的文章中就都会有 slug 参数了，然后我们只需要修改slug=\"\" 的\"\"中的值，就可以改变文章 url 了。 而对于之前那些文章，我们也只需要在文章头中添加参数 slug 就可以了，如下图： ","date":"2024-09-13","objectID":"/text24/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加自定义404页面 在博客根目录的your_site\\layouts\\文件夹下，放入你想放的404.html文件，这样它就会覆盖掉原主题的your_blog\\themes\\LoveIt\\layouts\\404.html文件。 This is a tip\r生成 public 文件时，Hugo 会优先读取根目录的文件，然后再读取主题里文件（也就是your_blog\\themes\\LoveIt\\layouts\\里的文件）。 我们当然也可以直接修改主题里的文件，但是如果这样做，那么在更新主题后我们之前的修改也会一并地消失。因此在本文的后面，我们宁愿把主题里的文件复制到根目录对应位置后再修改，也不直接修改。 ","date":"2024-09-13","objectID":"/text24/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加文章数量统计 其实就是利用 hugo 提供的变量来获取文章数量，再通过 html 里的sup标签，把文章数量在上标中显示出来，如下图： ","date":"2024-09-13","objectID":"/text24/:4:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 list.html 文件 复制your_site\\themes\\LoveIt\\layouts\\taxonomy\\list.html到your_site\\layouts\\taxonomy\\路径下。 然后打开your_site\\layouts\\taxonomy\\list.html，找到下面的内容： {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else if eq $taxonomy \"tag\" -}} \u003ci class=\"fas fa-tag fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else -}} 将其改为： {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }}\u003csup\u003e{{ len .Pages }}\u003c/sup\u003e {{- else if eq $taxonomy \"tag\" -}} \u003ci class=\"fas fa-tag fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }}\u003csup\u003e{{ len .Pages }}\u003c/sup\u003e {{- else -}} 继续找到： {{- range $pages.PageGroups -}} \u003ch3 class=\"group-title\"\u003e{{ .Key }}\u003c/h3\u003e 将其改为： {{- range $pages.PageGroups -}} \u003ch3 class=\"group-title\"\u003e{{ .Key }} \u003csup\u003e{{ len .Pages }}\u003c/sup\u003e\u003c/h3\u003e 因为 LoveIt 博客是以年份来分组的，但是我的博文没有那么多，以月份来分组更加有记录感，所以可以把下面内容： {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \"2006\" -}} 改为： {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \"2006-01\" -}} 从而达到以月份分组。 ","date":"2024-09-13","objectID":"/text24/:4:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 terms.html 文件 复制your_site\\themes\\LoveIt\\layouts\\taxonomy\\terms.html到your_site\\layouts\\taxonomy\\路径下。 然后打开your_site\\layouts\\taxonomy\\terms.html，找到下面的内容： \u003cdiv class=\"page archive\"\u003e {{- /* Title */ -}} \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- .Params.Title | default (T $taxonomies) | default $taxonomies | dict \"Some\" | T \"allSome\" -}} \u003c/h2\u003e 改成： \u003cdiv class=\"page archive\"\u003e {{- /* Title */ -}} \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- .Params.Title | default (T $taxonomies) | default $taxonomies | dict \"Some\" | T \"allSome\" -}}\u003csup\u003e{{ len .Pages }}\u003c/sup\u003e \u003c/h2\u003e 继续找到： \u003ch3 class=\"card-item-title\"\u003e \u003ca href=\"{{ .RelPermalink }}\"\u003e \u003ci class=\"far fa-folder fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Page.Title }} \u003c/a\u003e \u003c/h3\u003e 然后改成： \u003ch3 class=\"card-item-title\"\u003e \u003ca href=\"{{ .RelPermalink }}\"\u003e \u003ci class=\"far fa-folder fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Page.Title }} \u003csup\u003e{{ len .Pages }}\u003c/sup\u003e \u003c/a\u003e \u003c/h3\u003e ","date":"2024-09-13","objectID":"/text24/:4:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 section.html 文件 复制your_site\\themes\\LoveIt\\layouts\\_default\\section.html到your_site\\layouts\\_default\\路径下。 然后打开your_site\\layouts\\_default\\section.html，找到下面的内容： \u003cdiv class=\"page archive\"\u003e {{- /* Title */ -}} \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- .Params.Title | default (T .Section) | default .Section | dict \"Some\" | T \"allSome\" -}} \u003c/h2\u003e 改成： \u003cdiv class=\"page archive\"\u003e {{- /* Title */ -}} \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- .Params.Title | default (T .Section) | default .Section | dict \"Some\" | T \"allSome\" -}}\u003csup\u003e{{ len .Pages }}\u003c/sup\u003e \u003c/h2\u003e 继续找到： {{- range $pages.PageGroups -}} \u003ch3 class=\"group-title\"\u003e{{ .Key }}\u003c/h3\u003e 然后改成： {{- range $pages.PageGroups -}} \u003ch3 class=\"group-title\"\u003e{{ .Key }} \u003csup\u003e{{ len .Pages }}\u003c/sup\u003e\u003c/h3\u003e 同样，这里是以年份分组的，若要改为以月份分组，则要把下面代码： {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \"2006\" -}} 改为： {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \"2006-01\" -}} 这样操作后，以我的网站为例，归档、分类和标签页面就都能加上文章数量统计了。 ","date":"2024-09-13","objectID":"/text24/:4:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加文章密码 有时候我们并不想把一部分网页展示给所有人，那么我们可以加密我们的网页，使其要通过密码访问，如下图: ","date":"2024-09-13","objectID":"/text24/:5:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 single.html 将your_site\\themes\\LoveIt\\layouts\\posts\\single.html复制粘贴到your_site\\layouts\\posts\\路径下。打开your_site\\layouts\\posts\\single.html文件，在{{- $params := .Scratch.Get \"params\" -}}下添加下面内容： {{- $password := $params.password | default \"\" -}} {{- if ne $password \"\" -}} \u003cscript\u003e (function(){ if({{ $password }}){ if (prompt('请输入文章密码') != {{ $password }}){ alert('密码错误！'); if (history.length === 1) { window.opener = null; window.open('', '_self'); window.close(); } else { history.back(); } } } })(); \u003c/script\u003e {{- end -}} ","date":"2024-09-13","objectID":"/text24/:5:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"将 password 参数添加至.md文件的模版 之后我们只要将 password 参数添加到文章头即可。 但为了方便起见，我这里直接把它加到了模板文件中，即在博客的根目录下找到your_site\\archetypes\\default.md并打开，把 password 参数添加进去，如下代码块： --- title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" slug: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" ... ... password: \"\" ... ... --- This is a tip\rpassword= \"\"的\"\"中的字符即为密码，若无字符，则文章不加密无需密码登录。\r","date":"2024-09-13","objectID":"/text24/:5:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加_custom.scss以自定义 css Hugo 会优先读取博客根目录下的同名目录和文件，所以我们在博客根目录下添加文件your_site\\assets\\css\\_custom.scss This is a tip\r我们要使用hugo_extended版本的 Hugo 才可使_custom.scss文件生效\r","date":"2024-09-13","objectID":"/text25/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"添加custom.js以自定义 JavaScript 我们要创建一个.js文件来自定义 JavaScript，但是由于 LoveIt 主题本身并没有提供这样的一个文件，所以除了创建文件，我们还要修改一下 LoveIt 主题的模版。 ","date":"2024-09-13","objectID":"/text25/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"创建custom.js文件 在博客根目录添加文件your_site\\static\\js\\custom.js，之后我们自定义 JavaScript 的修改就都是在这个文件中进行的。 ","date":"2024-09-13","objectID":"/text25/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"修改 LoveIt 模版 把your_site\\themes\\LoveIt\\layouts\\partials\\assets.html文件复制到your_site\\layouts\\partials\\路径下。 在your_site\\layouts\\partials\\assets.html文件内容的最尾部找到{{- partial \"plugin/analytics.html\" . -}}，并在其上一行中添加如下内容： {{- /* 自定义 js 文件 */ -}} \u003cscript type=\"text/javascript\" src=\"/js/custom.js\"\u003e\u003c/script\u003e 由于本系列文章的部分功能会用到 jQuery（如网站运行时间和背景图片），因此强烈建议与自定义的 js 文件一起引入，即在刚才添加的内容的上一行再添加如下的内容： \u003cscript type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js\"\u003e\u003c/script\u003e ","date":"2024-09-13","objectID":"/text25/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"添加网站运行时间 把your_site\\themes\\LoveIt\\layouts\\partials\\footer.html复制到your_site\\layouts\\partials\\路径下。 打开文件your_site\\layouts\\partials\\footer.html，在其中找到\u003cdiv class=\"footer-container\"\u003e，并在其下方添加如下内容： \u003cdiv class=\"footer-line\"\u003e \u003cspan id=\"run-time\"\u003e\u003c/span\u003e \u003c/div\u003e 之后，在我们刚刚新建的your_site\\static\\js\\custom.js文件中添加如下内容： /* 站点运行时间 */ function runtime() { window.setTimeout(\"runtime()\", 1000); /* 请修把这里的建站时间换为你自己的 */ let startTime = new Date('05/23/2023 08:00:00'); let endTime = new Date(); let usedTime = endTime - startTime; let days = Math.floor(usedTime / (24 * 3600 * 1000)); let leavel = usedTime % (24 * 3600 * 1000); let hours = Math.floor(leavel / (3600 * 1000)); let leavel2 = leavel % (3600 * 1000); let minutes = Math.floor(leavel2 / (60 * 1000)); let leavel3 = leavel2 % (60 * 1000); let seconds = Math.floor(leavel3 / (1000)); let runbox = document.getElementById('run-time'); runbox.innerHTML = '本站已运行\u003ci class=\"far fa-clock fa-fw\"\u003e\u003c/i\u003e ' + ((days \u003c 10) ? '0' : '') + days + ' 天 ' + ((hours \u003c 10) ? '0' : '') + hours + ' 时 ' + ((minutes \u003c 10) ? '0' : '') + minutes + ' 分 ' + ((seconds \u003c 10) ? '0' : '') + seconds + ' 秒 '; } runtime(); ","date":"2024-09-13","objectID":"/text25/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"lightgallery 图片相册功能的改进 lightgallery 是 LoveIt 支持的图片相册功能（就是点击图片能放大观察的功能）。如果要开启，则先要在your_site/config.toml配置文件中，令参数lightgallery为 true。 但是若要真正的启用这个功能，那么我们要对每个图片起一个标题（引入图片的形式为![图片说明](https://picture.com\"图片标题\")），但是懒惰的我一般不会给图片起标题（因为要打两个双引号），所以要是图片说明能当图片标题就好了。 为了达到上面的效果，我们只需要创建your_site/layouts/_default/_markup/render-image.html文件，并在该文件中添加如下内容： {{ $figcap := or .Title .Text }} {{ $caption := or .Text \" \" }} {{- if eq $figcap $caption -}} {{ $caption = \" \" }} {{- end -}} {{- if $figcap -}} \u003cfigure\u003e {{- dict \"Src\" .Destination \"Title\" $figcap \"Caption\" $caption \"Linked\" true \"Resources\" .Page.Resources | partial \"plugin/image.html\" -}} \u003cfigcaption class=\"image-caption\"\u003e {{- $figcap | safeHTML -}} \u003c/figcaption\u003e \u003c/figure\u003e {{- else -}} {{- dict \"Src\" .Destination \"Title\" (path.Base .Destination) \"Resources\" .Page.Resources | partial \"plugin/image.html\" -}} {{- end -}} 但是如果你真的不需要标题，而且嫌标题很丑的话，那么可以在your_site\\assets\\css\\_custom.scss文件中添加如下内容： /* 图片 */ figcaption { display: none !important; } 然后标题就可以消失了。 ","date":"2024-09-13","objectID":"/text25/:4:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"文章过期提醒 像这种科技博文，一般都有时效性，所以添加一个文章过期提醒就显得很有必要了。 ","date":"2024-09-13","objectID":"/text25/:5:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"修改配置及模版文件 在your_site/config.toml配置文件中，添加如下内容： # Display a message at the beginning of an article to warn the readers that it's content may be outdated. # 在文章末尾显示提示信息，提醒读者文章内容可能过时。 [params.outdatedInfoWarning] enable = true hint = 90 # Display hint if the last modified time is more than these days ago. # 如果文章最后更新于这天数之前，显示提醒 warn = 180 # Display warning if the last modified time is more than these days ago. # 如果文章最后更新于这天数之前，显示警告 但是我们总不可能每一篇都是这种有时效性的科技博客，所以我们要添加一个参数来控制其是否开启。为了方便起见，这里我选择直接在模版文件your_site\\archetypes\\default.md里添加变量： outdatedInfoWarning: true This is a tip\r这里默认文章过期提醒开启，若想修改默认，直接将 true 改为 false 即可。之前创建的文章直接在文章头添加该参数即可。\r","date":"2024-09-13","objectID":"/text25/:5:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"修改国际化文件 把your_site\\themes\\LoveIt\\i18n\\zh-CN.toml复制到your_site\\i18n\\路径下，打开your_site\\i18n\\zh-CN.toml文件，添加如下内容： [outdatedInfoWarningBefore] other = \"本文最后更新于 \" [outdatedInfoWarningAfter] other = \"，文中内容可能已过时，请谨慎使用。\" ","date":"2024-09-13","objectID":"/text25/:5:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"添加outdated-info-warning.html文件 在your_site/layouts/partials/single/路径下添加outdated-info-warning.html文件，内容如下： {{- if or .Params.outdatedInfoWarning (and .Site.Params.outdatedInfoWarning.enable (ne .Params.outdatedInfoWarning false)) }} {{- $daysAgo := div (sub now.Unix .Lastmod.Unix) 86400 }} {{- $hintThreshold := .Site.Params.outdatedInfoWarning.hint | default 30 }} {{- $warnThreshold := .Site.Params.outdatedInfoWarning.warn | default 180 }} {{- $updateTime := .Lastmod }} {{- if .GitInfo }} {{- if lt .GitInfo.AuthorDate.Unix .Lastmod.Unix }} {{- $updateTime := .GitInfo.AuthorDate }} {{- end }} {{- end -}} {{- if gt $daysAgo $hintThreshold }} {{- $iconDetails := \"fas fa-angle-right fa-fw\" -}} {{- if gt $daysAgo $warnThreshold }} {{- $type := \"warning\" -}} {{- $icon := \"fas fa-exclamation-triangle fa-fw\" -}} \u003cdiv class=\"details admonition {{ $type }} open\"\u003e \u003cdiv class=\"details-summary admonition-title\"\u003e \u003ci class=\"icon {{ $icon }}{{ $type }}\"\u003e\u003c/i\u003e{{ T $type }}\u003ci class=\"details-icon {{ $iconDetails }}\"\u003e\u003c/i\u003e {{- else }} {{- $type := \"question\" -}} {{- $icon := \"fas fa-exclamation-triangle fa-fw\" -}} \u003cdiv class=\"details admonition {{ $type }} open\"\u003e \u003cdiv class=\"details-summary admonition-title\"\u003e \u003ci class=\"icon {{ $icon }}{{ $type }}\"\u003e\u003c/i\u003e{{ T $type }}\u003ci class=\"details-icon {{ $iconDetails }}\"\u003e\u003c/i\u003e {{- end }} \u003c/div\u003e \u003cdiv class=\"details-content\"\u003e \u003cdiv class=\"admonition-content\"\u003e {{ T \"outdatedInfoWarningBefore\" -}} \u003cspan class=\"timeago\" datetime=\"{{ dateFormat \"2006-01-02T15:04:05\" $updateTime }}\" title=\"{{ dateFormat \"January 2, 2006\" $updateTime }}\"\u003e {{- dateFormat \"January 2, 2006\" $updateTime -}} \u003c/span\u003e{{ T \"outdatedInfoWarningAfter\" -}} \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e {{- end -}} {{- end -}} ","date":"2024-09-13","objectID":"/text25/:5:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"修改single.html文件 把your_site/themes/LoveIt/layouts/posts/single.html复制到your_site/layouts/posts/路径下，然后打开your_site/layouts/posts/single.html找到下面内容： {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e 修改为： \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} {{- /* Outdated Info Warning */ -}} {{- partial \"single/outdated-info-warning.html\" . -}} \u003c/div\u003e ","date":"2024-09-13","objectID":"/text25/:5:4","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"双击生成颜表情 在your_site\\static\\js\\custom.js文件中，添加如下内容： /* 返回随机颜色 */ function randomColor() { return \"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"; } /* 点击生成字符特效 */ var a_idx = 0; var a_click = 1; /* 生成的字符内容 */ var a = new Array(\"乀(ˉεˉ乀)\",\"𓂃𓂃𓂃𓊝𓄹𓄺𓂃𓂃𓂃\",\"˘ᗜ˘\",\"(╥╯^╰╥)\",\"╰(*´︶`*)╯\",\"✧(◍˃̶ᗜ˂̶◍)✩\",\"｡◕‿◕｡\", \"(๑ت๑)\",\"(๑❛ᴗ❛๑)\",\"w(ﾟДﾟ)w\",\"Σ( ° △ °|||)︴\",\"(⊙ˍ⊙)\",\"(๑ˉ∀ˉ๑)\",\"\u003c(￣︶￣)\u003e\",\"╰(*°▽°*)╯\",\"✿\", \"(,,•́ . •̀,,)\",\"վ'ᴗ' ի\",\"(◔◡◔)\",\"⚝\",\"₍ᐢ. ֑ .ᐢ₎\"); jQuery(document).ready(function($) { $(\"body\").click(function(e) { /* 点击频率，点击几次就换文字 */ var frequency = 2; if (a_click % frequency === 0) { var $i = $(\"\u003cspan/\u003e\").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css({ \"z-index\": 9999, \"top\": y - 20, \"left\": x, \"position\": \"absolute\", \"font-weight\": \"bold\", \"color\": randomColor(), \"-webkit-user-select\": \"none\", \"-moz-user-select\": \"none\", \"-ms-user-select\": \"none\", \"user-select\": \"none\" }); $(\"body\").append($i); $i.animate({ \"top\": y - 180, \"opacity\": 0 }, 1500, function() { $i.remove(); }); } a_click ++; }); }); ","date":"2024-09-13","objectID":"/text25/:6:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"离开进入网站的标题变化 可以发现，若离开我的网站去其他页面，那么我的网站的标题和图标会发生变化。若再次回到我的网站，则标题和图标会再次发生变化。想要达到这个效果，只需在your_site\\static\\js\\custom.js文件中添加如下内容： /* 离开当前页面时修改网页标题，回到当前页面时恢复原来标题 */ window.onload = function() { var OriginTitile = document.title; var titleTime; document.addEventListener('visibilitychange', function() { if(document.hidden) { $('[rel=\"icon\"]').attr('href', \"/failure.ico\"); $('[rel=\"shortcut icon\"]').attr('href', \"/failure.ico\"); document.title = '哦~该回码头了'; clearTimeout(titleTime); } else { $('[rel=\"icon\"]').attr('href', \"/favicon.ico\"); $('[rel=\"shortcut icon\"]').attr('href', \"/favicon.ico\"); document.title = '哈~又整到薯条了'; titleTime = setTimeout(function() { document.title = OriginTitile; }, 2000); } }); } 其中文字部分改为自己喜欢的就可以了，而至于网站图标文件favicon.ico和failure.ico如果不清楚，具体可见我之前的文章 Hugo的Lovelt主题美化（一）。 这里只简单的说一下：一般而言，我们会把网站图标放到your_site\\static\\路径下，而在当前的目的下，我们可以只调用48*48的.ico文件作为显示图标。此外，favicon.ico一般是我们原来的网站图标，所以我们只需要在创建一个failure.ico作为离开页面时显示的图标即可。 ","date":"2024-09-13","objectID":"/text25/:7:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"二级标题样式 为了使文章的可读性更强，在这里最好修改一下 LoveIt 主题的文章样式。 ","date":"2024-09-13","objectID":"/text26/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"二级标题的修改 原主题的二级标题我不好评价，它跟下一级的标题几乎区分不开，这导致文章看起来没有条理。因此在这里我们将修改二级标题的样式以做区分。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 标题 */ .page.single h2 { box-shadow: rgb(95, 90, 75) 0px 0px 0px 1px, rgba(10, 10, 0, 0.5) 1px 1px 6px 1px; color: rgb(255, 255, 255); font-family: 微软雅黑, 宋体, 黑体, Arial; font-weight: bold; line-height: 1.3; text-shadow: rgb(34, 34, 34) 2px 2px 3px; background: rgb(43, 102, 149); border-radius: 6px; border-width: initial; border-style: none; border-color: initial; border-image: initial; padding: 7px; margin: 18px 0px 18px -5px !important; } ","date":"2024-09-13","objectID":"/text26/:1:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"行内代码 原主题的行内代码能用，但只能用一点点，实在是与正文区分不开，所以在这修改一下它的样式。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 行内代码块 */ code { margin: 0 .2rem; font-size: .9em; border: 1px solid #d6d6d6; border-radius: .2rem; } /* 预格式代码块(用tab键插入的代码块) */ pre code { margin: 0; border: none; font-size: .875rem; } /* 标题里的代码块样式 */ .page.single .content\u003eh2 code { color: #f7ab01; background: transparent !important; border: none; } ","date":"2024-09-13","objectID":"/text26/:1:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"分割线 在原主题中分割线几乎看不到，这里修改一下。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 分隔线 */ hr { border: none; border-bottom: 2px dashed #7a7a7a !important; } ","date":"2024-09-13","objectID":"/text26/:1:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"页脚分割线 页脚内容与其他内容连在一起有点杂乱，因此添加一个页脚的分割线还是很有必要的。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 页脚分割线 */ .footer { display: block; border-top-width: 3px; border-top-style: solid; border-top-color: #96c1db; position: relative; z-index: -1; max-width: 800px; width: 60%; margin: .5rem auto 0 auto; padding-left: 0rem; padding-right: 0rem; } @media only screen and (max-width: 1440px) { .footer { width:54.5% } } @media only screen and (max-width: 1200px) { .footer { width:50.5% } } @media only screen and (max-width: 960px) { .footer { width: 77% } } @media only screen and (max-width: 680px) { .footer { width: 95% } } ","date":"2024-09-13","objectID":"/text26/:1:4","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"首页头像旋转 这是一个没什么用的功能，但是好玩。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 头像旋转 */ .home .home-profile .home-avatar img { width: 5rem; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ease-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; \u0026:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } } ","date":"2024-09-13","objectID":"/text26/:1:5","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"更新时间设置 原主题是有最近更新时间参数的，只不过藏的比较深，一般不显示。但实际上，更新时间是要比发布时间更好用的（毕竟老文章改改也就成新文章了）。 ","date":"2024-09-13","objectID":"/text26/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"首页显示最近更新时间 虽然我们有最近更新时间，但首页并不显示，这好吗？这不好！所以我劝年轻人们都把它加上。 把your_site/themes/LoveIt/layouts/_default/summary.html复制到your_site/layouts/_default/路径下，然后打开your_site/layouts/_default/summary.html文件，找到如下内容： {{- with .Site.Params.dateFormat | default \"2006-01-02\" | .PublishDate.Format -}} \u0026nbsp;\u003cspan class=\"post-publish\"\u003e {{- printf `\u003ctime datetime=\"%v\"\u003e%v\u003c/time\u003e` . . | dict \"Date\" | T \"publishedOnDate\" | safeHTML -}} \u003c/span\u003e {{- end -}} 把它修改为下面的内容： {{- with .Site.Params.dateFormat | default \"2006-01-02\" | .PublishDate.Format -}} \u0026nbsp;\u003cspan class=\"post-publish\"\u003e {{- printf `\u003ctime datetime=\"%v\"\u003e%v\u003c/time\u003e` . . | dict \"Date\" | T \"publishedOnDate\" | safeHTML -}}, \u003c/span\u003e {{- end -}} {{- with .Site.Params.dateFormat | default \"2006-01-02\" | .Lastmod.Format -}} \u0026nbsp;\u003cspan class=\"post-publish\"\u003e {{- printf `\u003ctime datetime=\"%v\"\u003e%v\u003c/time\u003e` . . | dict \"Date\" | T \"updatedOnDate\" | safeHTML -}}, \u003c/span\u003e {{- end -}} ","date":"2024-09-13","objectID":"/text26/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"显示最近更新的十篇文章 一般来说，归档页面只有按发布时间排序的列表，但是我们最新的动态往往会涉及到修改以前的文章，所以我们最好加一栏用来显示最近更新的文章。 首先，在your_site/config.toml配置文件中添加新参数： [params.section] # 显示最近更新文章的数量 lastUpdatedSize = 10 然后，把your_site/themes/LoveIt/layouts/_default/section.html复制到your_site/layouts/_default/路径下，然后打开your_site/layouts/_default/section.html文件，找到如下内容： {{- /* Paginate */ -}} 在它的上面添加如下内容： {{- /* Last Modified */ -}} {{- $lastUpdatedSize := .Site.Params.section.lastUpdatedSize -}} {{- if $lastUpdatedSize -}} {{- if .Pages -}} {{- $pages := .Pages.ByLastmod.Reverse -}} \u003ch3 class=\"group-title\"\u003e{{ T \"RecentUpdate\" -}} \u003csup\u003e{{- $lastUpdatedSize -}}\u003c/sup\u003e\u003c/h3\u003e {{- range first $lastUpdatedSize $pages -}} \u003carticle class=\"archive-item\"\u003e \u003ca href=\"{{ .RelPermalink }}\" class=\"archive-item-link\"\u003e {{- .Title -}} \u003c/a\u003e \u003cspan class=\"archive-item-date2\"\u003e {{- \"2006-01-02\" | .Lastmod.Format -}} \u003c/span\u003e \u003c/article\u003e {{- end -}} {{- end -}} {{- end -}} 接着来修改国际化文件，把your_site\\themes\\LoveIt\\i18n\\zh-CN.toml复制到your_site\\i18n\\路径下，打开your_site\\i18n\\zh-CN.toml文件，添加如下内容： [RecentUpdate] other = \"最近更新\" 如果还设置了其他语言，那么我们只需将这个参量添加到对应的文件，再把 other 的内容改掉即可。 然后在your_site/assets/css/_custom.scss中添加如下内容： .archive-item-date2 { color: #7c7c88; } 最后，为了区分开发布时间和最近更新时间，我们要在每篇文章中添加最近更新时间的 meta。把your_site/themes/LoveIt/layouts/posts/single.html复制到your_site/layouts/posts/路径下，然后打开your_site/layouts/posts/single.html文件，找到如下内容： {{- with .Site.Params.dateformat | default \"2006-01-02\" | .PublishDate.Format -}} \u003ci class=\"far fa-calendar-alt fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;\u003ctime datetime=\"{{ . }}\"\u003e{{ . }}\u003c/time\u003e\u0026nbsp; {{- end -}} 将其改为： {{- with .Site.Params.dateformat | default \"2006-01-02\" | .PublishDate.Format -}} \u003ci class=\"far fa-calendar fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;\u003ctime datetime=\"{{ . }}\"\u003e{{ . }}\u003c/time\u003e\u0026nbsp; {{- end -}} {{- with .Site.Params.dateformat | default \"2006-01-02\" | .Lastmod.Format -}} \u003ci class=\"far fa-calendar-plus fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;\u003ctime datetime=\"{{ . }}\"\u003e{{ . }}\u003c/time\u003e\u0026nbsp; {{- end -}} ","date":"2024-09-13","objectID":"/text26/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"添加友链卡片 为了我们的友链显得更加的好看，这里我们引入友链卡片。 ","date":"2024-09-13","objectID":"/text26/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"添加friend.html文件 在your_site\\layouts\\shortcodes\\路径下，新创建文件friend.html，并且在里面添加如下内容： {{ if .IsNamedParams }} {{- $src := .Get \"logo\" -}} {{- $small := .Get \"logo_small\" | default $src -}} {{- $large := .Get \"logo_large\" | default $src -}} \u003cdiv class=\"friend-div\"\u003e \u003ca target=\"_blank\" href={{ .Get \"url\" | safeURL }} title={{ .Get \"name\" }} \u003e \u003cimg class=\"lazyload\" src=\"/svg/loading.min.svg\" data-src={{ $src | safeURL }} alt={{ .Get \"name\" }} data-sizes=\"auto\" data-srcset=\"{{ $small | safeURL }}, {{ $src | safeURL }} 1.5x, {{ $large | safeURL }} 2x\" /\u003e \u003cspan class=\"friend-name\"\u003e{{ .Get \"name\" }}\u003c/span\u003e \u003cspan class=\"friend-info\"\u003e{{ .Get \"word\" }}\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e {{ end }} ","date":"2024-09-13","objectID":"/text26/:3:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"添加_friend.scss文件 在your_site\\assets\\css\\_partial\\_single\\路径下（如果没有就自己创建），新建文件_friend.scss，并在里面添加如下内容： #article-container { word-wrap: break-word; overflow-wrap: break-word } #article-container a { color: #49b1f5 } #article-container a:hover { text-decoration: underline } #article-container img { margin: 0 auto .8rem } .flink#article-container .friend-list-div \u003e .friend-div a .friend-info, .flink#article-container .friend-list-div \u003e .friend-div a .friend-name { overflow: hidden; -o-text-overflow: ellipsis; text-overflow: ellipsis; white-space: nowrap } .flink#article-container .friend-list-div { overflow: auto; padding: 10px 10px 0; text-align: center; } .flink#article-container .friend-list-div \u003e .friend-div { position: relative; float: left; overflow: hidden; margin: 15px 7px; width: calc(100% / 3 - 15px); height: 90px; border-radius: 8px; line-height: 17px; -webkit-transform: translateZ(0) } @media screen and (max-width: 1100px) { .flink#article-container .friend-list-div \u003e .friend-div { width: calc(50% - 15px) !important } @media screen and (max-width: 600px) { .flink#article-container .friend-list-div \u003e .friend-div { width: calc(100% - 15px) !important } } } .flink#article-container .friend-list-div \u003e .friend-div:hover { background: rgba(87, 142, 224, 0.15); } .flink#article-container .friend-list-div \u003e .friend-div:hover img { -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -o-transform: rotate(360deg); -ms-transform: rotate(360deg); transform: rotate(360deg) } .flink#article-container .friend-list-div \u003e .friend-div:before { position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: -1; background: var(--text-bg-hover); content: ''; -webkit-transition: -webkit-transform .3s ease-out; -moz-transition: -moz-transform .3s ease-out; -o-transition: -o-transform .3s ease-out; -ms-transition: -ms-transform .3s ease-out; transition: transform .3s ease-out; -webkit-transform: scale(0); -moz-transform: scale(0); -o-transform: scale(0); -ms-transform: scale(0); transform: scale(0) } .flink#article-container .friend-list-div \u003e .friend-div:hover:before, .flink#article-container .friend-list-div \u003e .friend-div:focus:before, .flink#article-container .friend-list-div \u003e .friend-div:active:before { -webkit-transform: scale(1); -moz-transform: scale(1); -o-transform: scale(1); -ms-transform: scale(1); transform: scale(1) } .flink#article-container .friend-list-div \u003e .friend-div a { color: var(--font-color); text-decoration: none } .flink#article-container .friend-list-div \u003e .friend-div a img{ float: left; margin: 15px 10px; width: 60px; height: 60px; border-radius: 35px; -webkit-transition: all .3s; -moz-transition: all .3s; -o-transition: all .3s; -ms-transition: all .3s; transition: all .3s } .flink#article-container .friend-list-div \u003e .friend-div a .friend-name { display: block; padding: 16px 10px 0 0; height: 40px; font-weight: 700; font-size: 20px } .flink#article-container .friend-list-div \u003e .friend-div a .friend-info { display: block; padding: 1px 10px 1px 0; height: 50px; font-size: 13px } ","date":"2024-09-13","objectID":"/text26/:3:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"在_single.scss中引入代码 把your_site\\themes\\LoveIt\\assets\\css\\_page\\_single.scss复制粘贴到路径your_site\\assets\\css\\_page\\下。 再在文件your_site\\assets\\css\\_page\\_single.scss里添加如下内容： @import \"../_partial/_single/friend\"; ","date":"2024-09-13","objectID":"/text26/:3:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"调用友链卡片 至此，我们便可以使用如下的shortcodes在我们文章.md的任意地方调用友链卡片了： \u003cdiv class=\"flink\" id=\"article-container\"\u003e \u003cdiv class=\"friend-list-div\" \u003e {{ \u003c friend name=\"友链名称1\" url=\"友链地址1\" logo=\"友链图片链接1\" word=\"友链描述1\" \u003e }} {{ \u003c friend name=\"友链名称2\" url=\"友链地址2\" logo=\"友链图片链接2\" word=\"友链描述2\" \u003e }} \u003c/div\u003e \u003c/div\u003e This is a tip\r不能省略这两个div\r","date":"2024-09-13","objectID":"/text26/:3:4","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"创建友链页面 有了友链卡片，我们最好还要有一个页面来专门放置友链。之前我讲过如何添加关于页面，而其实这次与添加关于页面差不多。 ","date":"2024-09-13","objectID":"/text26/:4:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"创建friend/index.md文件 于终端中来到博客的根目录，我们来创建一个.md文件作为友链页面， 本站友链 friend name=\"Ty Note\" url=\"https://Wangty654.github.io\" logo=\"https://Wangty654.github.io/apple-touch-icon.png\" word=\"一个简单的私人博客网站 (˘◡˘)\" ","date":"2024-09-13","objectID":"/text26/:4:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"自定义网站图标 ","date":"2024-09-13","objectID":"/text23/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"1. 主页头像 在 blog 根目录下找到文件夹assets，打开该文件夹并新建文件夹images，把我们的主页头像图片avatar.png放到文件夹images中。 在 blog 根目录下找到配置文件config.toml ,在配置文件中找到# 主页配置 -\u003e # 主页显示头像的 URL的参数avatarURL = \"\"。在\"\"中填入主页头像图片在assets下的路径（这里填图片的URL亦可），最后则为avatarURL = \"images/avatar.png\"。 然后我们的 blog 主页就有头像了，如下图： ","date":"2024-09-13","objectID":"/text23/:1:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"2. 网站名前的logo 同前面一样，先将 logo 图标logo.png放到assets/images下。 在配置文件config.toml中找到# 页面头部导航栏配置 -\u003e # LOGO 的 URL的参数logo = \"\"。填入路径后将变为logo = \"images/logo_ico.png\"（当然图片URL亦可）。 This is a tip\r这里我发现，如果使用.png的图片，图片大小控制不好的话,会导致图与文字排列奇怪。图标会将标题顶开一定的位置。 但是如果我们使用.ico的图片，那么这种情况就不会出现。然而logo这个参数本身并不支持.ico图片。因此我们需要把作为 logo 的.ico图片的后缀名改为.png，这样logo才能读取图片文件。 而如果你的 logo 图一开始是.png图片，那么可以通过这个网站在线修改为.ico图片。 然后我们的 blog 就有了显示正常的 logo 了，如下图： ","date":"2024-09-13","objectID":"/text23/:1:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"3. 网站图标 注意与上面不同的是，我们要先将网站图标放到 blog 根目录的static文件夹下，而对于要放什么类型的图标我们有两种选择： 使用.svg后缀的伸缩矢量图形： 如果你的图标是.png文件（其他的类似），则可以通过这个网站，在线地把.png转换为.svg文件。然后把这个.svg文件放到static文件夹即可。 然后在配置文件config.toml中找到# 应用图标配置的参数svgFavicon = \"\"，不妨认为我们的.svg图标名为safari-pinned-tab.svg，那么我们只需修改参数为svgFavicon = \"/safari-pinned-tab.svg\"即可。 使用多尺寸的图标： 我们可以找到 LoveIt 主题文件里的配置文件config.toml（路径为your_blog\\themes\\LoveIt\\config.toml），可以发现svgFavicon参数为空，但是它的官网却也有网站图标。我们观察一下主题自带的exampleSite文件里的static（路径为your_blog\\themes\\LoveIt\\exampleSite\\static），可以发现里面有大小各异的网站图标，如下图： 因此我们可以依葫芦画瓢，在我们 blog 根目录的static文件夹里，放入我们各种大小的网站图标，如下图：（采用此方法，svgFavicon参数一定要为空，且各种大小的图标命名要和官方一致）在这里可以传入你想要的图片，很容易的生成这些文件。 然后我们的 blog 就有网站图标了，如下图： ","date":"2024-09-13","objectID":"/text23/:1:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"文章头的参数 我们在根目录archetypes文件夹下修改的default.md。这个default.md实际是我们每篇文章头（如下图）的模板。 ","date":"2024-09-13","objectID":"/text23/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"tags 此参数意为文章的标签，可以有多个，若要添加多个标签，只需按照如下形式即可（即用\"\"引住标签内容，而,作为标签内容间的分隔）： tags: [\"博客\",\"LoveIt 美化\"] ","date":"2024-09-13","objectID":"/text23/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"categories 此参数意为文章的分类，一篇文章可以同时存在于多个分类下（与 tags 参数类似），若要文章处于多个分类下，只需按照如下形式即可（即用\"\"引住分类名称，而,作为分类名称间的分隔）： categories: [\"Hugo 博客\",\"Markdown\"] ","date":"2024-09-13","objectID":"/text23/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"share 此参数意为是否开启文章底部的分享功能。 ","date":"2024-09-13","objectID":"/text23/:2:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"comment 此参数意为是否开启文章底部的评论功能。 ","date":"2024-09-13","objectID":"/text23/:2:4","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"hiddenFromHomePage 此参数意为是否在主页隐藏本文章。 ","date":"2024-09-13","objectID":"/text23/:2:5","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"hiddenFromSearch 此参数意为是否在搜索时隐藏本文章。 ","date":"2024-09-13","objectID":"/text23/:2:6","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"summary 在主页中显示的对文章的描述性语言，如下图： 但如果不加，如下图： 那么hugo会自动将文章内容前半部分取过来，显示在描述这里，文章描述会很杂乱。 ","date":"2024-09-13","objectID":"/text23/:2:7","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"featuredImagePreview 这个参数为在主页显示的文章配图：我们可以对该参数添加图片URL，那么主页对应文章标题上方便会出现被裁剪后的配图，如下图： 但如果我们不加配图，如下图： 那么主页文章间的分割不明显，且不够花里胡哨。 ","date":"2024-09-13","objectID":"/text23/:2:8","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"featuredImage 这个参数与上个参数类似，但它在为主页添加配图的同时，也将图片（未裁剪的）添加至文章内容的开头，如下图： This is a tip\r加到 featuredImagePreview 中的图片的宽高比尽量为 10:3 ，不然会自动裁剪为 10:3 ，这样有可能损失内容。同时为了使网页背景与图片可区分，我们不要让图片以纯白或深灰为底。我一般选# f6f6f6 或# f6f6ff代替纯白。\r","date":"2024-09-13","objectID":"/text23/:2:9","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"链接和提示框 ","date":"2024-09-13","objectID":"/text23/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"link 如果我们在 Markdown 文件中输入{{ \u003c link \"https://Wangty654.github.io\" \u003e }}，则在网页上会显示为https://Wangty654.github.io。 ","date":"2024-09-13","objectID":"/text23/:3:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"admonition 横幅 我们若在任意一个 Mardown 中输入： 则会出现如下效果： This is a tip\r一个 技巧 横幅\r其中参数 admonition type 为横幅的类型，一共有12种，分别为 note，abstract，info，tip，success，question，warning，failure，danger，bug，example，quote（其中默认值为note）。 参数 title 顾名思义是横幅的标题 参数 open 为横幅是否自动打开，默认是 true 打开。 ","date":"2024-09-13","objectID":"/text23/:3:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"其他的拓展 Shortcode 具体可见这里，而一些 Hugo 内置的 Shortcode 可见这里 This is a note\r一个 技巧 横幅\rThis is a abstract\r一个 技巧 横幅\rThis is a info\r一个 技巧 横幅\rThis is a tip\r一个 技巧 横幅\rThis is a success\r一个 技巧 横幅\rThis is a question\r一个 技巧 横幅\rThis is a warning\r一个 技巧 横幅\rThis is a failure\r一个 技巧 横幅\rThis is a danger\r一个 技巧 横幅\rThis is a bug\r一个 技巧 横幅\rThis is a example\r一个 技巧 横幅\rThis is a quote\r一个 技巧 横幅\r","date":"2024-09-13","objectID":"/text23/:3:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"关于页面 我们的 blog 往往会有一个\"关于\"页面来介绍自己，但我们一开始所给的配置参数并不包含这个页面，因此我们可以来添加该页面。 首先我们要在终端中来到 blog 的根目录，执行下面命令，在content文件夹下创建一个about文件夹，并使其有文件index.md。一般读取都是读取路径包下的index.md文件，若没有多个文件，也可以建成单独的about.md 这个index.md或者about.md就是我们的\"关于\"页面。 然后我们还要在菜单栏配置中添加\"关于\"这一栏。在 blog 根目录下找到 config.toml,再在该配置下找到# 菜单配置，在这一项下添加： [[menu.main]] name = \"关于\" # weight 参数可以看做菜单栏上各项的排序，越大的排在电脑网页的越右边 weight = 4 identifier = \"about\" url = \"/about/\" title = \"About\" 这样，“关于\"页面就创建好了。 ","date":"2024-09-13","objectID":"/text23/:4:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["前端"],"content":"第1章：Vue核心 ","date":"2024-08-21","objectID":"/vue2/:0:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"1.vue简介： vue是一套用于构建用户界面的渐进式javaScript框架 This is a tip\rvue可以自底向上逐层的应用 简单应用：只需要一个轻量小巧的核心库 复杂应用：可以引入各式各样的vue插件 This is a warning\rvue2.0发布于2016年10月1日，vue3.0发布于2020年9月18日\r","date":"2024-08-21","objectID":"/vue2/:1:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"vue的特点： 组件化 采用组件化模式，提高代码复用率、且让代码更好维护 声明式 声明式编码，让编码人员无需直接操作DOM，提高开发效率 说明： 当有一个需求如下，需要将数据persons，放入容器list中： //数据persons [ {id:'001',name:'张三',age:18}, {id:'002',name:'李四',age:19}, {id:'003',name:'王五',age:20} ] //list \u003cul id=\"list\" \u003e\u003c/ul\u003e 效果为： 命令式编码实现方式： 原生javaScript写法 //准备html字符串 let htmlStr = '' //遍历数据拼接html字符串 persons.forEach( p =\u003e{ htmlStr += `\u003cli\u003e${p.id} - ${p.name} - ${p.age}\u003c/li\u003e` }); //获取list元素 let list = document.getElementById('list') //修改内容(亲自操作Dom) list.innerHTML = htmlStr 声明式编码实现方式： \u003cul id=\"list\" \u003e \u003cli v-for=\"p in persons \"\u003e {{p.id}} - {{p.name}} - {{p.age}} \u003c/li\u003e \u003c/ul\u003e 虚拟dom 3.使用虚拟DOM+优秀的Diff算法，尽量复用DOM节点 This is a tip\rdiff算法： 新生成的虚拟dom会和之前生成的虚拟dom比较，这个比较算法称为diff算法。 当新的虚拟dom中，存在与旧dom中相同的属性和内容值时， vue就直接将旧的真实dom直接拿到页面渲染出来，再处理不同的部分 ​ 原生js 4.学习vue之前需要掌握的javaScript基础知识 ES6语法规范：结构赋值、模板字符串、箭头函数等。ES6基础-久远银海内部链接 ES6模块化：默认暴露、分别暴露、统一暴露、import、isport等 包管理器：npm、yram、cnpm 原型、原型链： 数组常用方法：过滤一个数组、加工一个数组、筛选最值 axios： promise：异步请求 ​ ","date":"2024-08-21","objectID":"/vue2/:1:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"2. vue官网使用指南 地址：vue官网操作手册 ​ ","date":"2024-08-21","objectID":"/vue2/:2:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"3.搭建vue开发环境 在没有脚手架的情况下，最原始的使用vue框架，就是在.html 文件中，引入vue.js包 \u003c!-- 开发环境版本，包含了有帮助的命令行警告 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"\u003e\u003c/script\u003e 或者 \u003c!-- 生产环境版本，优化了尺寸和速度 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2\"\u003e\u003c/script\u003e 在vue2的官方文档中，解释了两种引入vue的方式 ","date":"2024-08-21","objectID":"/vue2/:3:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"script直接引入 首先先看第一种安装vue的方式： CDN：阿里云CND操作文档 我们在写script的时候，里面有一个属性，叫src，可以指定资源的位置 如果把src写成：\"./xxx\"的形式，为引入一个本地文件。如果写成\"https\"的形式，一般为了加速，会在其中加入一个CDN的标识 This is a tip\rCDN 内容分发网络（Content Delivery Network，CDN）是建立并覆盖在承载网上，由不同区域的服务器组成的分布式网络。将源站资源缓存到全国各地的边缘服务器，供用户就近获取，降低源站压力。 官网两个vue版本，点击后均会进行下载，但下载的文件有些不同 为方便演示，将两个版本均下载在桌面，并新建一个文件夹取名为vue_basic，并用vscode打开 将引入写入html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e初识Vue\u003c/title\u003e \u003c!-- 引入vue --\u003e \u003cscript type=\"text/javascript\" src=\"../js/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-08-21","objectID":"/vue2/:3:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"控制台提示 直接引入产生的控制台提示 打开写好的html页面，在控制台会出现两个小提示 提示解析： Download the Vue Devtools extension for a better development experinence: //表示：请你下载vue的开发者工具，到达一个更好的开发体验 You are running Vue in development mode. //表示：你正在运行一个开发者模版的vue. Make sure to turn on production mode when deploying for production. //请确认你的项目不在生产时使用 [此句话意思表明，你引入的是vue.js其中带有很多提示和警告，包比较大，不适合上线项目使用] 开发者工具 解决 下载vue开发者工具 的问题 国外网络可以正常访问谷歌商城： 正常能打开gitHub，点击官网的下载链接过去，选择谷歌浏览器选项 进入谷歌网上应用商店，点击添加，完成 国内无法正常访问谷歌商城： Vue开发者工具扩展链接： 【下载开发者工具】： https://pan.baidu.com/s/1MtYvMPew4lb14piIrs9x6w 提取码：6666 【安装开发者工具】： 一、Chrome浏览器安装方式： ①：点击右上角三个点 ②：点击更多工具 ③：点击扩展程序 ④：点击右上角的开发者模式，将他启用 ⑤：将下载的Vue.crx文件直接拖动到浏览器窗口即可 ⑥：点到扩展的详细信息界面，再开启【允许访问文件URL】选项再试试看 二：Edge浏览器安装方式 ①：点击浏览器右上角的三个点 ②：点击扩展 ③：点击左下角的开发人员模式，将他启用 ④：将Vue.crx文件拖动到浏览器即可 解决 vue.js不建议在上线项目中使用的提示 Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列 property(属性) 首先验证，Vue.config 是否存在： 这里的属性，是对vue的全局配置。一次修改，到处都可以使用。 此处的：productionTip: true 小提示默认为true，是默认开启状态 代码的body中键入下方代码，可以对提示进行关闭： \u003cbody\u003e \u003c!--关闭生产提示--\u003e \u003cscript type=\"text/javascript\"\u003eVue.config.productionTip = false\u003c/script\u003e \u003c/body\u003e 【注意：上方代码如果失效，则进入vue.js文件，直接对productionTip属性进行修改为false】 开端开发编辑工具vscode下载地址：开端开发编辑工具vscode下载地址 ​ ","date":"2024-08-21","objectID":"/vue2/:3:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"4. Hello小案例 ","date":"2024-08-21","objectID":"/vue2/:4:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"html的基础写法 hello代码示例 【注意：此段代码是html的基础写法，并没有用到vue】 \u003cbody\u003e \u003c!-- 准备一个容器 --\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003c/div\u003e \u003c/body\u003e ","date":"2024-08-21","objectID":"/vue2/:4:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Live Server 插件运行 右键打开页面，控制台错误如下： favicon.ico - 指网站的页签图标 打开控制台的Network选项卡，强制刷新一下[ 按住shift 点击刷新]，可以看见请求了本地5500服务器访问该图标 关于本地5500服务器的解释说明： 在vscode中，右键，使用Live Server 插件打开的页面：Live Server会自动先帮你打开当前选择的这个页面，并在你的电脑的5500的端口上开了一台小型的内置服务器，并且进行了“把你所有工程的文件和文件夹，作为这个服务器的根资源去使用”的一个操作。 验证内置5500端口服务器，可以地址栏直接访问127.0.0.1:5500。显示的一定是当前工程下的所有文件夹。 解决图标访问404的问题，只需要在根目录中放置一个叫favicon.ico的图片文件，页面刷新即可 This is a tip\rlive server 插件是一个具有实时加载功能的小型服务器，它的作用： 模拟服务器的方式打开页面 代码改动后,会自动刷新页面 vsCode中装Live Server插件。 ","date":"2024-08-21","objectID":"/vue2/:4:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"vue的写法演示 使用vue进行hello的显示 理解：引入的vue相当于外部引入的一个函数。要使用vue函数，需要new Vue \u003c!-- 准备一个容器 --\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e //创建Vue实例 /* * 注意Vue()中只传一个参数，这个参数是一个配置对象{} * 配置对象中，都以 key : value 的形式书写 * 配置对象中，key的名称不得更改，value的值必须符合key的数据类型 */ const x = new Vue({ //vue的第一个key是el，el是element元素的简写。 //键值对象类似于css中的id选择器 //el用于指定当前Vue实例为哪个容器，值通常为css选择器字符串。 el:'#root' //还有一种写法，一般不用，但是可以这样写 //指 人为找到这个元素，再给他配置到el里去 el:document.getElementById('root') }) \u003c/script\u003e \u003c!-- 如果用class不用id --\u003e \u003cdiv class=\"root\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const x = new Vue({ //el就写成css中类选择器的写法 el:'.root' }) \u003c/script\u003e 利用插值语法 \u003c!-- 如果用class不用id --\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello,{{name}}\u003c/h1\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const x = new Vue({ el:'#root', data:{ //data中用于存储数据，数据供el所指定的容器去使用 name:'wangty' } }) \u003c/script\u003e 注意：data中的数据需要在指定的容器中使用，没在容器中使用data内数据并不会生效 This is a tip\r三个注意事项： 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；目前这里为：el、data root容器里的代码依然符合html规范，只不过混入一些特殊的Vue语法； root容器里的代码被称为【Vue模版】 对于vue模版的解释： 我们写的为一个Vue模板，经过解析，形成一个全新的正常的html片段块，然后替换掉模板的位置，显示在页面上 容器的作用： 1、为Vue提供模板 2、把Vue解析后的html片段，指定位置放置 ​ ","date":"2024-08-21","objectID":"/vue2/:4:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"5. 分析Hello案例 ","date":"2024-08-21","objectID":"/vue2/:5:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"一对一关系 演示说明：容器和实例是一对一，一一对应关系 有两个同名的容器的情况： 首先，能运行成功，且控制台不报错 说明，一个Vue实例不能同时接管两个容器 有两个Vue实例指向同一个容器的情况： 首先，第一个Vue内容显示正常，第二个内容不显示，且控制台报错 说明，一个容器只能被一个Vue实例接管和解析 ","date":"2024-08-21","objectID":"/vue2/:5:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"{{ }} 中为js表达式 This is a tip\r注意：{{ }} 中可以写的内容，不一定是Vue实例中声明过的。只要是js里的表达式，Vue都是可以解析的\r注意区分:js表达式 和js代码(语句) ​ 1.表达式: 一个表达式会生成一个值，可以放在任何一个需要值的地方: ​ (1).a ​ (2).a+b ​ (3).demo(1) ​ (4).x === y ? ‘a’ : ‘b’ ​ 2.js代码(语句) ​ (1).if( ){ } ​ (2).for( ){ } ","date":"2024-08-21","objectID":"/vue2/:5:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue的开发者工具 打开控制台右侧Vue选项卡 Root这里代表唯一的那一个Vue实例，点击这里的Root，能看的data里的所有数据 点击配置对象旁边的编辑按钮，可以对其值进行修改 \u003c!-- 前端小写内容全部转换为大写的方法使用 .toUpperCase() --\u003e \u003ch1\u003e{{name.toUpperCase()}} \u003c/h1\u003e //name:'wangty' // WANGTY ","date":"2024-08-21","objectID":"/vue2/:5:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生产包和开发包 关于 vue.js 和vue.min.js 在new Vue实例对象时候的区别 当不写new的时候，vue.js： 当不写new的时候，vue.min.js并不报这个warning ","date":"2024-08-21","objectID":"/vue2/:5:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"6. 模板语法 ","date":"2024-08-21","objectID":"/vue2/:6:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"6.1 插值语法 把指定的值，放到指定的位置，使用方法，见上述hello案例 【注意：插值语法多用于指定标签体内容。即，两标签之间的内容。不可以用于标签属性和属性值】 ","date":"2024-08-21","objectID":"/vue2/:6:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"6.2 指令语法（内置语法） 【注：指令语法小结示例里包含了很多后面的东西，建议先跳过看完后面再看这一节比较好理解】 普通html，点击跳转地址写法 \u003ca href=\"https://www.baidu.com\"\u003e点我去百度\u003c/a\u003e v-bind vue写法 \u003cdiv id=\"root\"\u003e \u003ch1\u003e指令语法\u003c/h1\u003e \u003ca :href=\"url\"\u003e点我去百度\u003c/a\u003e \u003c!--等价于\u003ca v-bind:href=\"url\"\u003e点我去百度\u003c/a\u003e --\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root' , data:{ url:'https://www.baidu.com' //注意，这里如果写两个一模一样的属性名，控制台不会报错 //Vue会默认读取第二个属性名的内容，这里就会默认跳转淘宝 //url:'https://www.taobao.com' } }) \u003c/script\u003e 注意：这里的 “:href\"中的冒号，是v-bind的简写。我们把类似于v-bind这样的语法称为，指令语法。 This is a tip\r在html标签中，如果标签中的属性没有使用指定语法，则就是普通的属性和属性值 如果使用了指定语法，Vue就会把属性值引号内的东西，取出来当做表达式进行执行 Class 与 Style 绑定 操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 绑定样式: 1.class样式 ​ 写法:class=“xxx”xxx可以是字符串、对象、数组。 ​ 字符串写法适用于: 类名不确定，要动态获取。 ​ 对象写法适用于: 要绑定多个样式，个数不确定，名字也不确定。 ​ 数组写法适用于:要绑定多个样式，个数确定，名字也确定，但不确定用不用。 ​ 2.style样式 ​ :style=\"{fontSize:xxx}“其中xxx是动态值。 ​ :style=\"[a,b]“其中a、b是洋式对象 绑定class样式 \u003c!--正常的样式正常写，绑定的样式传值，字符串写法--\u003e \u003cdiv class=\"basic\" :class=\"normal\"\u003e\u003c/div\u003e .... data(){ normal:'red' } .... \u003c!--html解析后显示为 class=\"basic red\"--\u003e \u003c!----------------------------或者--------------------------------\u003e \u003c!--正常的样式正常写，绑定的样式传值，数值写法--\u003e \u003cdiv class=\"basic\" :class=\"arr\"\u003e\u003c/div\u003e .... data(){ arr:['red'，'yellow'，'buld'] } .... \u003c!--html解析后显示为 class=\"basic red yellow buld\"--\u003e \u003c!--按钮事件动态操作arr数组可以实现样式的改变--\u003e \u003c!----------------------------或者--------------------------------\u003e \u003c!--正常的样式正常写，绑定的样式传值，对象写法--\u003e \u003cdiv class=\"basic\" :class=\"Obj\"\u003e\u003c/div\u003e .... data(){ Obj:{ red:false, yellow:false } } .... \u003c!--按钮事件动态操作Obj对象可以实现样式的改变--\u003e 绑定style样式 v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名： \u003cdiv v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"\u003e\u003c/div\u003e data: { activeColor: 'red', fontSize: 30 } 直接绑定到一个样式对象通常更好，这会让模板更清晰： \u003cdiv v-bind:style=\"styleObject\"\u003e\u003c/div\u003e data: { styleObject: { color: 'red', fontSize: '13px' } } 同class一样，也可以写成数组，v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上： \u003cdiv v-bind:style=\"[baseStyles, overridingStyles]\"\u003e\u003c/div\u003e v-model 数据绑定 \u003cdiv id=\"root\"\u003e 单项数据绑定：\u003cinput type=\"text\" v-bind:value=\"name\"\u003e \u003cbr/\u003e 双向数据绑定：\u003cinput type=\"text\" v-model:value=\"name2\" \u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root' , data:{ name:'wangty', name2:'wangty', } }) \u003c/script\u003e 页面效果： Vue中有2种数据绑定的方式: 1.单向绑定(v-bind):数据只能从data流向页面, 2.双向绑定(v-model):数据不仅能从data流向页面，还可以从页面流向data。 只适用于表单元素 注意：不是任意的所有的地方都能使用v-model来进行双向绑定 例： \u003cdiv id=\"root\"\u003e \u003ch3 v-bind:x=\"name\"\u003ewangty\u003c/h3\u003e \u003ch3 v-model:x=\"name\"\u003ewangty\u003c/h3\u003e \u003c!-- 该行代码是有问题的 --\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root' , data:{ name:'wangty', } }) \u003c/script\u003e 上面的几行代码，首先在页面查看效果如下： 说明：v-model只能应用在表单元素上（输入类元素，有value值的元素）。 简写形式 和v-bind一样，v-model有他的简写形式 \u003c!-- v-bind简写 --\u003e \u003cinput type=\"text\" v-bind:value=\"name\"\u003e 等价于 =====\u003e \u003cinput type=\"text\" :value=\"name\"\u003e ---------------------------------------------------------------------- \u003c!-- v-model简写 --\u003e \u003cinput type=\"text\" v-model:value=\"name2\" \u003e 等价于 =====\u003e \u003cinput type=\"text\" v-model=\"name2\" \u003e v-on 事件处理 事件的基本使用: 1.使用v-on:xxx或@xxx定事件，其中xxx是事件名; ​ 2.事件的回调需要配置在methods对象中，最终会在vm上; ​ 3.methods中配置的的数，不要用箭头函数。否则this就不是vm了; ​ 4.methods中配置的的数，都是被Vue所管理的函数，this的指向是vm或组件实例对象 ​ 5.@click=“demo\"和 @click=“demo($event)”效果一致，但后者可以传参; \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello,{{name}} \u003c/h1\u003e \u003c!-- 简写形式 v-on:click =====\u003e 等价于 @click --\u003e \u003cbutton v-on:click=\"showInfo\"\u003e点击实现提示信息\u003c/button\u003e \u003cbutton @click=\"showInfo\"\u003e点击实现提示信息\u003c/button\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e //创建Vue实例 new Vue({ el:'#root', data(){ return{} }, //注意showInfo需要放在methods里。 //这儿有个问题：可不可以放进data里呢？ 是可以的。 //能够正常运行，且控制台不报错。但是会被Vue执行数据代理，加重Vue的负荷。 methods:{ //注意这里的showInfo方法也会存储在vm身上，打印vm时可以看见 showInfo(a,b,c,d){ //alert(\"提示\"); console.log(a,b,c,d); } } }) \u003c/script\u003e 方法写在data里的情况，会使得vm对此方法进行数据代理。详解请看【数据代理】小结。 所以我们一般写点击事件只传一个参数，格式写为 showInfo(event){ console.log(event); //获取点击时间的触发目标，一般指按钮对象 //使用event.target console.log(event.target.innerText); //按钮名称 //这里的this也是Vue实例 //这里showInfo如果写成箭头","date":"2024-08-21","objectID":"/vue2/:6:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"7. el与data的两种写法 我们知道，Vue实例和容器之间是通过el属性进行关联的，如果不写el，则标签引用的Vue数据不会被解析，如下面这段代码： \u003c!-- 如果不写el,则Vue不工作，name不被解析 --\u003e \u003cdiv id=\"root\"\u003e \u003ch3\u003e{{name}}\u003c/h3\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ //el:'#root' ,将该行代码注释，页面不解析name，且控制台不报错 data:{ name:'wangty', } }) \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:7:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"v.$mount(’’) 那么有没有什么办法能替代el，使得Vue工作呢 \u003cdiv id=\"root\"\u003e \u003ch3\u003e{{name}}\u003c/h3\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const v = new Vue({ //我们使用一个恒定不变的对象来承接整个Vue实例，取名叫v data:{ name:'wangty', } }) console.log(v); //打印这个v，我们能够看到整个Vue的实例对象 v.$mount('#root') //使用Vue实例的$mount方法，指向root容器，以实现解析和挂载 \u003c/script\u003e 在控制台，这是我们第一个看见Vue的整个实例对象 通过这种写法，我们可以很容易的控制Vue解析页面的时间 //让Vue等一秒钟，再进行页面的解析 setTimeout(()=\u003e{ v.$mount('#root') },1000) 图解 ","date":"2024-08-21","objectID":"/vue2/:7:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"data函数式写法 在Vue实例中，我们把data: { }，这种写法形式称为对象式写法，花括号{}里包含的是对象属性。 除此之外，data在Vue实例里还能写成函数的形式： new Vue({ //data的第一种写法：对象式 data:{ name:'wangty', } //data的第二种写法：函数式 data:function(){ return{ name:'wangty' } } }) ","date":"2024-08-21","objectID":"/vue2/:7:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"关于this 注意：这里的data函数不是我们手动调用的，是Vue帮我们调用的 在这里我们打印输入一下，data方法中的this new Vue({ data:function(){ console.log(\"this\",this); return{ name:'wangty' } } }) 这里this指向的是整个Vue实例对象 注意，如果把data写成箭头函数，例： new Vue({ data:()=\u003e{ console.log(\"this\",this); return{ name:'wangty' } } }) 这里的this指向就会有问题，就会指向全局的window。（箭头函数是没有自己的this的，他默认就会向外去找指向，就会找到外层全局的window，当做他的this去使用） ","date":"2024-08-21","objectID":"/vue2/:7:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"简写形式 我们通常写普通的函数时，一般用（）来代替:function()，所以写成： new Vue({ //data:function() =====\u003e 等价于 =====\u003e data() data(){ console.log(\"this\",this); return{ name:'wangty' } } }) This is a tip\r注意：由Vue所管理的函数，一定不能写成箭头函数，例：data()，watch()，computer()等\r","date":"2024-08-21","objectID":"/vue2/:7:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"8. 理解MVVM Vue在最初的设计的时候，很大程度上参考了MVVM模型官网解释地址 1.M：模型（Model) :对应 data 中的数据 2.V：视图(View):模板 3.VM：视图模型(ViewModel)：Vue 实例对象 这块注意有个现象：写在data里的属性，会同步出现在Vue实例对象的属性里面，原理我们在数据代理时会进行阐述。 同时{{ }}中，Vue实体内中能够看到的所有属性，也能够使用 【Vue实体内的所有属性，Vue模板都可以使用】 例如： \u003ch1\u003e{{$options}}\u003c/h1\u003e \u003ch1\u003e{{$emit}}\u003c/h1\u003e \u003ch1\u003e{{_c}}\u003c/h1\u003e ","date":"2024-08-21","objectID":"/vue2/:8:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"9. Object.defineProperty 数据劫持、数据代理、计算属性，的底层均用到了Object.defineProperty这个方法 作用：给一个方法或者一个对象定义属性 用法：Object.defineProperties(操作的对象名,‘添加的属性名’,{配置项键值对}) \u003cscript type=\"text/javascript\"\u003e let person = { name:'wangty', address:'chengdu' } //给person对象添加一个属性，叫age，值为18 Object.defineProperty(person,'age',{ value:18 }) console.log(person); \u003c/script\u003e 注意这块添加进去的age属性，在控制台的呈现样子 这个颜色的区别，表示这个age不可以被枚举，及age这个属性不参与遍历 ","date":"2024-08-21","objectID":"/vue2/:9:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"enumerable配置项 //我们通过Object的keys方法对其进行验证 // Object.keys()传入一个对象，将对该对象的属性名进行提取，并拼合成一个数组 console.log(Object.keys(person)); 这里可以明显看到，没有age属性 如果想让age属性能够正常被遍历和枚举，我们引入defineProperty中的另一个配置项enumerable //enumerable可枚举的，默认为false Object.defineProperty(person,'age',{ value:18, enumerable:true }) ","date":"2024-08-21","objectID":"/vue2/:9:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"writable配置项 我们在控制台分别操作一下name属性和age属性，再次打印，我们发现age并不能操作成功 这说明defineProperty设置的属性的属性值是不能被修改的 若要使其同正常属性一样能够修改其属性值，则需要使用另一个配置项writable //writable 能否被修改，默认为false Object.defineProperty(person,'age',{ value:18, writable:true }) console.log(person); ","date":"2024-08-21","objectID":"/vue2/:9:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"configurable配置项 我们对属性进行删除操作，这里同样操作name和age： 这说明defineProperty设置的属性的属性值是不能被删除的 若要使其同正常属性一样能够删除，则需要使用另一个配置项configurable //configurable能否被删除，默认为false Object.defineProperty(person,'age',{ value:18, configurable:true, }) console.log(person); ","date":"2024-08-21","objectID":"/vue2/:9:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"getter get函数 当我有一个从变量number中获取年龄的age需求时，希望：当变量发生变化时，年龄属性也同步发生变化。 \u003cscript type=\"text/javascript\"\u003e let number = 18 let person = { name:'wangty', address:'chengdu' } Object.defineProperty(person,'age',{ //注意简写： //get:function() ========\u003e 等价于 get() get:function(){ //当有人读取person的age属性时，get函数就会被调用,且返回值就是age的值 return 'hello' //设置成变量 //return number } }) console.log(person); \u003c/script\u003e 控制台效果为： 注意：每一次使用或者涉及读取age这个属性的时候，都会现调用getter ","date":"2024-08-21","objectID":"/vue2/:9:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"setter 和getter相同的，有一个控制写入的配置项函数，set函数 //当有人修改person的age属性时，set函数就会被调用,且入参是修改的age值 set(value){ console.log(\"有人修改age,且修改值为：\"+value); number = value } ","date":"2024-08-21","objectID":"/vue2/:9:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"10.数据代理 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写） 例： \u003cscript type=\"text/javascript\"\u003e let obj={x:100} let obj2 ={y:200} 0bject.defineProperty(obj2,'x',{ get(){ return obj.x }， set(value){ obj.x = value }) \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:10:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue中的数据代理 1.Vue中的数据代理: 通过vm对象来代理data对象中属性的操作(读/号) 2.Vue中数据代理的好处: 更加方便的操作data中的数据 3.基本原理: 通过object.defineProperty()把data对象中所有属性添加到vm上。 为每一个添加到vm上的属性，都指定一个getter/setter。 在getter/setter内部去操作(读/号)data中对应的属性 这个时候我们来看MVVM小结里的Vue实例中的现象，就很好理解： 首先，Vue在设置data方法的时候，将data内的数据复制了一份，放进了Vue实例对象的_data里 此时使用设置的name，可以用_data.name。 此时还没有进行数据代理。 然后，Vue对所有的data内属性和值使用数据代理，在Vue实体中添加name等属性，自动为其设置getter、setter方法，使得： vm._data.name = vm.name 此时：vm._data = options.data = data 【注意后面这个=成立需要将data要放到整个全局】 关于_data 注意：这块展开_data能够看到和vm中一样的结构，但他并不是数据代理，他主要用来监听data内容变化，用于影响页面解析显示 Vue中的数据劫持主要是通过ES6的Object.defineProperty()方法来实现。Vue会遍历data选项中的属性，并使用Object.defineProperty()将它们转为带有getter和setter的属性，这样Vue就能监控和响应数据的变化。 数据劫持：我们把原始的data内容，复制后增加了getter和setter方法用于数据监测的这种改写和加工操作，称为数据劫持。 ","date":"2024-08-21","objectID":"/vue2/:10:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"11.Computed ","date":"2024-08-21","objectID":"/vue2/:11:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"姓名案例 \u003c!-- 写一个姓名案例：实现输入框输入姓名的时候，自动拼成全名 --\u003e \u003cdiv id=\"root\"\u003e 姓：\u003cinput type=\"text\" v-model=\"xing\"\u003e 名：\u003cinput type=\"text\" v-model=\"ming\"\u003e \u003c!-- 插值语法的正常写法 --\u003e 全名：\u003cspan\u003e{{xing}} - {{ming}}\u003c/span\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root', data(){ return{ xing:'wang', ming:'ty' } }, }) \u003c/script\u003e 页面效果为 这个时候，当input内无限输入姓名的长度，却只取前4位时，插值的写法 \u003c!-- 当需求越复杂，插值语法中的内容就越多 --\u003e \u003c!-- 这种写法不报错，但是不推荐 --\u003e 全名：\u003cspan\u003e{{xing.slice(0,3)}} - {{ming}}\u003c/span\u003e 在Vue官方文档中，风格指南中明确表示，组件模板中应当只包含简单表达式： methods的写法： \u003c!-- fullName不加()返回的是整个函数体 --\u003e \u003c!-- fullName加()返回的是return里的东西 --\u003e 全名：\u003cspan\u003e{{fullName()}}\u003c/span\u003e methods:{ fullName(){ //return 'wangty' return this.xing +'-'+this.ming } } ","date":"2024-08-21","objectID":"/vue2/:11:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"计算属性 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e computed:{ fullName:{ \u003c!-- get原理和defineProperty一样 --\u003e get(){ return 'wangty' } } } 计算属性加载后依旧会放在vm中 在Vue开发者工具的结构中也能够很清晰的区分普通属性和计算属性 Vue对计算属性的缓存处理： \u003c!-- 写一个姓名案例：实现输入框输入姓名的时候，自动拼成全名 --\u003e \u003cdiv id=\"root\"\u003e 姓：\u003cinput type=\"text\" v-model=\"xing\"\u003e 名：\u003cinput type=\"text\" v-model=\"ming\"\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第一次调用 --\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第二次调用 --\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第三次调用 --\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第四次调用 --\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ el:'#root', data(){ return{ xing:'wang', ming:'ty' } }, computed:{ fullName:{ //有人读取fullname时，被调用 get(){ console.log(\"get被调用\"); return this.xing + '-' + this.ming } } } }) \u003c/script\u003e 注意控制台，这个地方对get的调用只调了一次！ 实际上，在第一次调用fullName属性的时候，Vue向计算属性要了返回结果，并进行了缓存处理。在后面再次请求fullName属性的时候，直接使用了缓存中的值。 那么这个缓存在数据变化时是否会对显示造成影响呢？是不会的。 计算属性中的get有两个被调用时机： ​ 1、初次读取fullName属性时 ​ 2、当依赖的数据发生变化时 此处就可以区分methods写法和computed写法之间的优劣了。对的，methods会反复调用！！ \u003cscript type=\"text/javascript\"\u003e ..... ,computed:{ fullName:{ //有人读取fullname时，被调用 get(){ console.log(\"get被调用\"); return this.xing + '-' + this.ming }, //有人修改fullname时，被调用 //传入value为‘李-四’ set(value){ console.log(\"set被调用,被修改的值：\",value); const arr = value.split('-') this.xing = arr[0]; this.ming = arr[1]; } } }, ....... \u003c/script\u003e 计算属性总结： 1.定义：要用的属性不存在，要通过已有属性计算得来。 2.原理：底层借助了objcet.defineproperty方法提供的getter和setter。 3.get函效什么时候执行？ （1）.初次读取时会执行一次。 （2）.当依赖的数据发生改变时会被再次调用。 4.优势：与methods实现相比。内部有缓存机制（复用），效奉更高，调试方便。 5.备注： 1.计算属性最终会出现在vm上，直接读取使用即可。 2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生 ","date":"2024-08-21","objectID":"/vue2/:11:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"计算属性 简写 通常情况下，我们多使用计算属性的读取，不怎么使用修改。当确定计算属性只读不改时： 我们简化计算属性的写法： 1、删除掉set方法； 2、将fullName由对象写法改成函数写法： ​ fullName:{ } ===\u003e fullName:function( ){ } ===\u003e fullName(){ } ​ 并将这个函数，当作get函数使用 \u003cscript type=\"text/javascript\"\u003e ..... ,computed:{ fullName(){ return this.xing + '-' + this.ming }, }, ....... \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:11:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"12.watch ","date":"2024-08-21","objectID":"/vue2/:12:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"天气案例 \u003c!-- 写一个按钮点击后，实现页面天气的切换，并且输出切换前的天气和切换后的天气 --\u003e \u003cdiv id=\"root\"\u003e \u003ch3\u003e今天天气很{{info}}\u003c/h3\u003e \u003cbutton @click=\"isHost = !isHost\"\u003e点击切换天气\u003c/button\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ el:'#root', data(){ return{ isHost:true, } }, methods:{ }, computed:{ info(){ return this.isHost? '炎热':'凉爽' } } }) \u003c/script\u003e 效果是，点击按钮，天气能在炎热凉爽之间来回切换 注意：这样的写法，在Vue开发者工具上会有个bug \u003cdiv id=\"root\"\u003e \u003c!-- 当我将下面这行代码 --\u003e \u003ch3\u003e今天天气很{{info}}\u003c/h3\u003e \u003c!-- 改为 --\u003e \u003ch3\u003e今天天气很一般\u003c/h3\u003e ..... \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e .... ,computed:{ info(){ return this.isHost? '炎热':'凉爽' } }, .... \u003c/script\u003e 此处，computed中info的属性依旧随着isHost值的变化，而计算了 但是在Vue开发者工具中却并不能提现。但是我们可以通过vm验证，计算属性是变化了的。 即，当页面没有使用计算属性和基本属性的时候，Vue开发者工具，就不更新data中被修改的基本属性的值了。但是实际上vm中的data属性值和计算属性值都是被更改了的。 此处属于Vue开发者工具的一个小坑，后续可能Vue开发者工具会进行维护。 ","date":"2024-08-21","objectID":"/vue2/:12:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"监视属性 \u003cscript type=\"text/javascript\"\u003e new Vue({ ..... ,watch:{ //isHost：监视谁，这儿就写谁的名字，这里指监视isHost的变化 isHost:{ //handler函数什么时候调用？在isHost被修改的时候。 handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //初始化时是否执行handler,默认为false immediate:true } }, }) \u003c/script\u003e 控制台效果 第二种写法，可以通过Vue实例对象，实现效果都是一样的 \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ ........ }) //注意这里监视对象要加''引号。里面的配置项内容和watch里的写法一样 vm.$watch('isHost',{ handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //immediate:true }) \u003c/script\u003e 监视属性watch 1.当被监视的属性变化时，回调函数自动调用，进行相关操作 2.监视的属性必须存在，才能进行监视！！ 没有不会报错，但是监视前后数据都是undefined 3.监视的两种写法： （1）. new Vue时传入watch配置 ​ （2）. 通过vm.$watch监视 ","date":"2024-08-21","objectID":"/vue2/:12:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"深度监视 深度监视： （1）Vue中的watch默认不监测对象内部值的改变（一层）。 （2）配置deep:true可以监测对象内部值改变（多层）。 备注： （1）Vue自身可以监测对象内部值的改变，但vue提供的watch默认不可以！ （2）使用watch时根据数据的具体结构，决定是否采用深度监视。 \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ el:'#root', data(){ return{ number:{ a:1, b:1 } } }, watch:{ //监视多级结构中，某个属性的变化 'number.a':{ handler(){ console.log('a被修改了'); }, } }, }) \u003c/script\u003e 注意：这块儿监视的number是指number：{ }对象所在的地址值 如果写成watch：{ number：{ } } 地址永远不会变化，则永远不会触发监听。 如果想要监视到number中任意一个值变化，那么需要加上监视穿透deep \u003cscript type=\"text/javascript\"\u003e ........., watch:{ number:{ deep:true, handler(){ console.log('a被修改了'); }, } }, ....... \u003c/script\u003e 注意：这块两个概念，Vue实例是可以监测到多层级数据中属性的变化的，这个可以在控制台通过打印vm验证。只是Vue提供给开发者的watch属性中，无法直接监测到多层级数据的变化，需要设置默认检测层级或者使用deep。 ","date":"2024-08-21","objectID":"/vue2/:12:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"监视的简写形式 如果监视的对象不适用其他配置项，例如deep，immediate等，只使用handler，可简写成： \u003cscript type=\"text/javascript\"\u003e ........., watch:{ //正常写法 isHost:{ handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //简写，isHost对象式写成函数式，当handler用 isHost(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, }, ....... \u003c/script\u003e 或者 \u003cscript type=\"text/javascript\"\u003e ........., //正常写法 vm.$watch('isHost',{ handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //deep:true //immediate:true }) //简写 vm.$watch('isHost',function(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }) ....... \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:12:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"13.watch对比computed 计算属性 vs 侦听属性 Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子： \u003cdiv id=\"demo\"\u003e{{ fullName }}\u003c/div\u003e var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' }, watch: { firstName: function (val) { this.fullName = val + ' ' + this.lastName }, lastName: function (val) { this.fullName = this.firstName + ' ' + val } } }) 上面代码是命令式且重复的。将它与计算属性的版本进行比较： var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar' }, computed: { fullName: function () { return this.firstName + ' ' + this.lastName } } }) 好得多了，不是吗？ 我们发现，好多功能在使用watch和computed属性都可以完成： 不过呢。。。computed完全依赖return的内容。 但是，目前还没有办法可以让computed等待一段时间再进行return返回。 说明，计算属性中，是不能够开启异步任务去处理数据的。 那这个时候就需要依赖watch watch不依赖return，watch中的数据修改，依赖于数据处理语句，例如：a = b ，给a的赋值语句 所以当有：想要某值改变，但是延迟一秒操作的时候。使用watch进行处理 这里注意一个小细节哦： //这里的setTimeout很自然的使用了箭头函数 //之前我们说过，尽量不适用箭头函数以免改变了方法体中this的指向 //这里： //isHost是Vue管理下的函数。 //但是setTimeout定时器所指定的回调，是不受Vue控制的。浏览器定时器管理模块控制的。最后到时间了，也是js引擎帮我们调的函数 //------------------------------------------------------ //所以这儿，必须写成箭头函数 //如果这儿写成普通函数，js引擎会认为this是它引擎控制的整个window //------------------------------------------------------ //原理： //当这儿写成箭头函数的时候，由于箭头函数没有this，就会默认往外层找 //这儿setTimeout的外层是isHost函数 //而isHost函数的this就是Vue //由此使得this的指向正常 watch:{ isHost(val){ setTimeout(()=\u003e{ this.isHost = val },1000); } 小结： computed利watch之间的区别： 1.computed能完成的功能，watch都可以完成。 2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。 两个重要的小原则： 1.所被vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。 2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数、Promise的回调函数等，只要是没引入Vue都可以调用的函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象 ","date":"2024-08-21","objectID":"/vue2/:13:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"14.列表过滤 两种实现方式，先用watch写一遍再用computed写一遍 watch写法： \u003cbody\u003e \u003cdiv\u003e \u003ch3\u003e列表过滤\u003c/h1\u003e \u003c/div\u003e \u003cdiv id=\"root\"\u003e \u003cinput type=\"text\" v-model=\"keyWord\"\u003e \u003cul\u003e \u003cli v-for=\"(p,index) of filPersons\" :key=\"p.id\"\u003e {{p.name}}-{{p.age}}-{{p.sex}} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#root', computed:{ }, watch:{ keyWord:{ immediate:true, handler(val){ //这块注意，filter要返回满足条件的新数组 this.filPersons = this.persons.filter((p)=\u003e{ //indexOf对于包含的内容返回索引，不包含的内容返回-1 //这里注意，都包含空字符串：任何字符串.indexOf('')都返回0 return p.name.indexOf(val) !== -1 }) }, } }, data:{ keyWord:'', persons:[ {id:'001',name:'马冬梅',age:18,sex:'女'}, {id:'002',name:'周冬雨',age:19,sex:'女'}, {id:'003',name:'周杰伦',age:20,sex:'男'}, {id:'004',name:'温兆伦',age:21,sex:'男'}, ], filPersons:[] }, }) \u003c/script\u003e \u003c/body\u003e computed写法： \u003cbody\u003e \u003cdiv\u003e \u003ch3\u003e列表过滤\u003c/h1\u003e \u003c/div\u003e \u003cdiv id=\"root\"\u003e \u003cinput type=\"text\" v-model=\"keyWord\"\u003e \u003cul\u003e \u003cli v-for=\"(p,index) of filPersons\" :key=\"p.id\"\u003e {{p.name}}-{{p.age}}-{{p.sex}} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#root', computed:{ filPersons(){ return this.persons.filter((p)=\u003e{ return p.name.indexOf(this.keyWord) !== -1 }) } }, data:{ keyWord:'', persons:[ {id:'001',name:'马冬梅',age:18,sex:'女'}, {id:'002',name:'周冬雨',age:19,sex:'女'}, {id:'003',name:'周杰伦',age:20,sex:'男'}, {id:'004',name:'温兆伦',age:21,sex:'男'}, ], }, }) \u003c/script\u003e \u003c/body\u003e ","date":"2024-08-21","objectID":"/vue2/:14:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"15.列表排序 排序和搜索都能同时控制使用 computed写法： \u003cbody\u003e \u003cdiv\u003e \u003ch3\u003e列表排序\u003c/h1\u003e \u003c/div\u003e \u003cdiv id=\"root\"\u003e \u003cinput type=\"text\" v-model=\"keyWord\"\u003e \u003cbutton @click = \"sortType = 2\"\u003e年龄升序\u003c/button\u003e \u003cbutton @click = \"sortType = 1\"\u003e年龄降序\u003c/button\u003e \u003cbutton @click = \"sortType = 0\"\u003e原顺序\u003c/button\u003e \u003cul\u003e \u003cli v-for=\"(p,index) of filPersons\" :key=\"p.id\"\u003e {{p.name}}-{{p.age}}-{{p.sex}} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#root', computed:{ filPersons(){ const arr = this.persons.filter((p)=\u003e{ return p.name.indexOf(this.keyWord) !== -1 }) //为0时不进该判断 if(this.sortType){ //升降序方法.sort(a,b)两个入参。升序-前减后，降序-后减前 arr.sort((p1,p2)=\u003e{ return this.sortType === 1? p2.age - p1.age : p1.age - p2.age }) } return arr; } }, data:{ keyWord:'', sortType:0, // 0原顺序 1降序 2升序 persons:[ {id:'001',name:'马冬梅',age:18,sex:'女'}, {id:'002',name:'周冬雨',age:19,sex:'女'}, {id:'003',name:'周杰伦',age:20,sex:'男'}, {id:'004',name:'温兆伦',age:21,sex:'男'}, ], }, methods:{ } }) \u003c/script\u003e \u003c/body\u003e ","date":"2024-08-21","objectID":"/vue2/:15:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"16.Vue监测数据改变的原理 这里注意，修改更新data中的数据时存在这样一个问题： \u003cbody\u003e \u003cdiv\u003e \u003ch3\u003e人员列表\u003c/h1\u003e \u003c/div\u003e \u003cdiv id=\"root\"\u003e \u003cbutton @click=\"updataMei\"\u003e点击更改马冬梅的数据\u003c/button\u003e \u003cul\u003e \u003cli v-for=\"(p,index) of persons\" :key=\"p.id\"\u003e {{p.name}}-{{p.age}}-{{p.sex}} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e const vm = new Vue({ el:'#root', computed:{ }, data:{ persons:[ {id:'001',name:'马冬梅',age:18,sex:'女'}, {id:'002',name:'周冬雨',age:19,sex:'女'}, {id:'003',name:'周杰伦',age:20,sex:'男'}, {id:'004',name:'温兆伦',age:21,sex:'男'}, ], }, methods:{ updataMei(){ //这里挨个修改data中的第一行数据 this.persons[0].name = '马老师'; this.persons[0].age = '50'; this.persons[0].sex = '男'; //这里整体修改data中的第一行数据 【会发现此种写法它不生效】 this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} } } }) \u003c/script\u003e \u003c/body\u003e 运行结果： 可以看出，逐条修改数据，可以成功修改Vue中的数据，并且更新页面上的显示；但是整体修改，Vue中的数据确实被修改了，这里通过vm可以看出，页面上却不更新显示。 由此我们在这里探讨：Vue监测数据改变的原理。（Vue是如何监测数据改变的） ","date":"2024-08-21","objectID":"/vue2/:16:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"响应式解析过程 data中数据的解析过程： ​ 在数据代理小节：我们知道，Vue将data中的数据复制一份,形成了_data。Vue通过_data进行数据代理生成页面上的data。 ​ 但是，这儿能看出我们写的data和vm中的_data，_data结构上比我们写的多了些东西。这里说明Vue不是单纯的复制了我们写的data，它对data进行了加工。 ​ 它对data进行加工的作用，使得我们在修改data中的数据的时候，它通过setter方法重新解析模板。这就是响应式。 ​ 整个响应式流程：data中name修改，形成新的_data.name，调用setter方法、重新解析模版，生成虚拟dom，新旧dom对比算法，复用旧dom/生成新dom。 ","date":"2024-08-21","objectID":"/vue2/:16:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"模拟数据监测 这里我们不使用Vue，单独写一个对象的数据监测： \u003c!--Vue的数据检测类似 --\u003e \u003cscript text=\"text/javascript\"\u003e let data = { name: 'username', age:'12' } //这里创建一个监视的实力对象，用于监视数据data中的数据变化 const obs = new Observer(data); console.log(obs); //这里的obs打印输出来和data一致 //Observer函数：入参为需要监视的数据对象 function Observer(obs){ //取对象中所有的属性形成一个数组 ，这里是[name,age] const keys = Object.keys(obs) //遍历 keys.forEach((k)=\u003e{ //k为每一个属性,this为整个obs实例对象 //Object.defineProperty(对象,'属性',{}) Object.defineProperty(this,k,{ //读：就把改属性的值返回去 get(){ console.log(\"被读\"); return obs[k] }, //改：就把收到的值替换到对应属性 set(val){ console.log(\"被改\"); obs[k] = val } }) }) } \u003c/script\u003e 注意不能直接对data使用defineProperty，防止死循环 //死循环代码 //这种监视会反复调用读取，导致卡死 Object.defineProperty(data,'name',{ get(){ return data.name } }) ","date":"2024-08-21","objectID":"/vue2/:16:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue里的对象监测原理 ​ Vue底层的对象监测类似于此，依赖于Vue.set() ","date":"2024-08-21","objectID":"/vue2/:16:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue.set() 注意，Vue里模版中使用一个对象中不存在的属性，则值默认为undefined。如果Vue在页面中遇到undefined，则默认成什么都不展示，且控制台无报错。 当Vue里模版中使用vm身上不存在的属性，控制台就会报错告诉你未定义。 所以这里，我们设置一个属性时，将其定义在对象中。保证我们的演示效果，写法如上图左侧 我们需要对student.sex实时追加属性值，使得页面上同时进行实时更新。 这里使用Vue.set() 官网API地址 //Vue提供函数 target改动对象，key操作的属性，val修改的值 Vue.set(target,key,val) //vm._data取对象 Vue.set(vm._data.student,'sex','男') //或者vm.data取对象，数据代理原理 Vue.set(vm.student,'sex','男') 或者使用vm.$set() vm.$set(target,key,val) //vm._data取对象 vm.$set(vm._data.student,'sex','男') //或者vm.data取对象，数据代理原理 vm.$set(vm.student,'sex','男') 注意：对象不能是 Vue 实例，或者 Vue 实例的根数据对象。Vue.set()不是万能的，其设定了禁止直接对vm进行操作。即，只能操作data里的对象，不能操作data对象，例如： //使用Vue.set()直接在vm中加入sex属性 //此操作会报错，告诉你禁止直接操作vm下的data对象。 //下面是两种错误写法 Vue.set(vm._data.sex,'sex','男') Vue.set(vm.sex,'sex','男') ","date":"2024-08-21","objectID":"/vue2/:16:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue里的数组监测原理 Vue如何检测数组里的数据改变 我们将data中设置一组对象数据，和一组数组数据，我们在页面控制台输出的data中可以看到两个数据的差别 Vue在加工的时候，给对象都创建了getter和setter方法。但是数组却没有。 当我们修改数组的时候 this.school[0] = '大学' //页面不生效 原因这儿就找到了！页面模版的重新解析，依赖了数据中的setter方法，而数组没有setter。所以当我们修改数组时，vm的data中确实数据发生了更改，而页面却没有任何变化。这就也解释了为什么人员列表的时候，persons数组列表中直接修改第一行的数据，vm被改动，但页面不生效的现象了。 在Vue 的设计者认为中，数组应使用修改数组的一些方法对其进行修改。只有当使用数组的通用修改方法时，Vue才承认数组被改变了，才能够监测到数组数据的改变。 修改数组的一些常用方法： ​ push：在数组尾部添加一个元素 ​ pop：删除最后一个元素 ​ shift：删除第一个元素 ​ unshift：在数组头部添加一个元素 ​ splice：在某索引处进行删除、修改、添加 ​ sort：数组排序 ​ reverse：数组翻转 当使用上面这些方法时，Vue则可以成功监测到数据改变，同步更新页面。例如： vm._data.school.push('大学') 当然，提供的Vue.set() 依旧对数组有效 Vue.set(vm._data.school,0,'大学') 不过需要注意的是，这里vm使用的push及其以上方法，并是不原生态的Array数组使用的push方法。Vue对其进行了包装。官网API地址 //控制台验证 vm._data.school.push === Array.prototype.push //false ","date":"2024-08-21","objectID":"/vue2/:16:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"17.表单数据收集 表单数据收集时： ajax前台往后台传参数的时候，把一组数据转成JSON格式的 JSON.statiy()数据转换成JSON格式 收集表单数据：可以用this._data，但是一般不推荐直接使用 建议整个表单数据，前面包一个对象，通过 对象收集 this.queryInfo v-model的修饰符： v-model.trim =\u003e 不收集输入的空格（所有的空格都不收集） v-model.number =\u003e 收集的数据自动转成数值类型 v-model.lazy =\u003e 收集时，需要失去焦点后再记录 小结： 如果input框的type类型是text，v-model收集的是value，用户输入的也是value 如果类型是radio，需要给标签配置value值 如果类型是checkbox， 没有设置value，收集的是是否被选中，true/false 配置了value，初始值是数组，收集的是选中的数组。是非数组，收集的是布尔值 ","date":"2024-08-21","objectID":"/vue2/:17:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"18.过滤器 小案例：当前时间戳的转换。【日期第三方库 moment.js 、 dayjs】 我们用三种实现方式：计算属性、methods、过滤器 分别实现 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e过滤器\u003c/title\u003e \u003cscript src=\"js/vue.js\"\u003e\u003c/script\u003e \u003c!-- 日期转换方法第三方库引入 --\u003e \u003c!-- 有互联网也可以引在线的 --\u003e \u003c!-- https://www.bootcdn.cn/ 搜索dayjs 复制链接 另存为 --\u003e \u003cscript src=\"js/dayjs.min.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003e过滤器 时间戳切换\u003c/h1\u003e \u003ch3\u003e当前时间：{{time}}\u003c/h3\u003e \u003c!-- 计算属性 实现 --\u003e \u003ch3\u003e当前时间：{{timeComputed}}\u003c/h3\u003e \u003c!-- methods 实现 --\u003e \u003ch3\u003e当前时间：{{getNowTime()}}\u003c/h3\u003e \u003c!-- filter 实现 --\u003e \u003c!-- | 管道符前面的为入参 后面的为过滤器函数 --\u003e \u003c!-- 后面的函数return的内容 整个替换掉插值位置的所有内容 显示 --\u003e \u003ch3\u003e当前时间：{{time | timeFormater}}\u003c/h3\u003e \u003c!-- filter传参 --\u003e \u003c!-- 默认第一位参数为 | 前参数，第二位参数为小括号内参数 --\u003e \u003ch3\u003e当前时间：{{time | timeFormater(\"YYYY年MM月DD日\")}}\u003c/h3\u003e \u003c!-- filter串联 --\u003e \u003c!-- 串联不影响传参 --\u003e \u003c!-- mySlice只接受timeFormater返回地方值进行计算 挨着串联 只处理该函数 | 前的返回值为入参--\u003e \u003ch3\u003e当前年份：{{time | timeFormater(\"YYYY年MM月DD日\") | mySlice}}\u003c/h3\u003e \u003c/div\u003e \u003cscript\u003e //定义全局过滤器 //一次只能定义一个 //Vue.filter('注册全局过滤器名称',function(入参){方法体} Vue.filter('mySlice',function(val){ return val.slice(0,4) }) new Vue({ el:'#root', data:{ time:Date.now(), }, computed:{ timeComputed(){ return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss') } }, methods:{ getNowTime(){ return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss') } }, //注意：new Vue中的filters 可以写多个。里面的每一个filter都属于局部过滤器。当这个Vue是组件时，A组件和B组件的filter不能相互使用。 filters:{ //timeFormater(val){ 没有第二入参的写法 timeFormater(val,str = 'YYYY-MM-DD HH:mm:ss'){ //有第二入参用入参，没有用默认的 = 后的这个 //return 'hello' 返回啥页面就是啥，完全依赖此处return return dayjs(val).format('YYYY-MM-DD HH:mm:ss') }, mySlice(val){ return val.slice(0,4) } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ⚠️注意：new Vue中的filters 可以写多个。里面的每一个filter都属于局部过滤器。当这个Vue是组件时，A组件和B组件的filter不能相互使用。 \u003c!-- 过滤器使用方式 --\u003e \u003c!-- 插值语法 --\u003e \u003ch3\u003e当前时间：{{time | timeFormater}}\u003c/h3\u003e \u003c!-- 单向属性绑定（双向用不了，这种形式也用的比较少） --\u003e \u003ch3 :x=\"time | timeFormater\"\u003e\u003c/h3\u003e 🏷小结：一般用于 对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理） ","date":"2024-08-21","objectID":"/vue2/:18:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"19.生命周期 定义\r生命周期: 1.又名: 生命周期回调函数、生命周期函数、生命周期钩子。（只需要准备好函数，在特定的时间，将函数钩出来使用。） 2.是什么: Vue在关键时刻帮我们调用的一些特殊名称的函数。 3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的 4.生命周期函数中的this指向是vm或组件实例对象。 实现一个幻灯片渐隐渐现的效果 \u003c!-- 定时器写在外部(不推荐) --\u003e \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003c!-- 此处为 :style=\"{opacity:opacity}\" 因为style中为js函数体，函数体同名可以省略，由此写成下面的这种形式--\u003e \u003ch2 :style=\"{opacity}\"\u003e一个渐隐渐现的效果\u003c/h2\u003e \u003c/div\u003e \u003cscript\u003e const vm = new Vue({ el:'#el', data:{ opacity:1 //初始化：默认透明度为1 }, }) //再Vue外面写一个定时器，循环操作vm setInterval(()=\u003e{ //每次透明度减小0.01 vm.opacity -= 0.01 //注意此处写成 \u003c=0 ,而不是写成 ==0 ，因为在js中 0.1 +0.1 不一定等于0.2 ，所以在-0.01的时候不一定会刚好减到0，有可能直接奔负数就去了 //一旦发现透明度减完了，就使其恢复到1 if(vm.opacity \u003c= 0) vm.opacity =1 },16) //每隔16毫秒就减一次透明度 \u003c/script\u003e \u003c/body\u003e 使用声明周期函数，使得定时器能够自然的存在于Vue的内部 原理：Vue在解析完模板，由虚拟DOM生成真实DOM之后，会默认调用的几个函数，帮我们完成在元素加载后，自动调用需要调用的函数 【在Vue整个干活过程中，特殊的时间点，去调用的函数，统称为生命周期函数】 \u003c!-- mounted()生命周期函数 写法--\u003e \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003ch2 :style=\"{opacity}\"\u003e一个渐隐渐现的效果\u003c/h2\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#el', data:{ opacity:1 //初始化：默认透明度为1 }, //Vue完成模版的解析并把真实的DOM元素放入页面后（挂载完成）调用mounted //只在真DOM放入时调用一次，后面解析模板不会再被调用 mounted(){ setInterval(()=\u003e{ this.opacity -= 0.01 if(this.opacity \u003c= 0) this.opacity =1 },16) } }) \u003c/script\u003e \u003c/body\u003e 官方操作手册中给出了非常完整的Vue生命周期图示：如这里 ， 同时也给了详细的解释。这里我们仅仅将图拿过来，进行简单的备注和阐述。 阅读此图注意： 实色填充图形均为 生命周期 流程 红色圆角矩形框 均为 生命周期 函数 绿色填充和黄色填充圆角矩形框和菱形框 均为 生命周期 某环节 ","date":"2024-08-21","objectID":"/vue2/:19:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生命周期_挂载流程 beforeCreate() 第一个生命周期函数： 数据创建前 首先打印函数名称，确定函数执行；其次验证vm上并没有data的数据代理 \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003ch2\u003e当前的n值是：{{n}}\u003c/h2\u003e \u003cbutton @click = \"add\"\u003e点我n+1\u003c/button\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#el', data:{ n:1 }, methods:{ add(){ n++} }, beforeCreate(){ console.log('beforeCreate'); console.log(this); debugger; } }) \u003c/script\u003e \u003c/body\u003e 控制台表现 created() 第二个生命周期函数： 数据创建完毕 首先打印函数名称，确定函数执行；其次验证vm上完成了data的数据代理 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); console.log(this); } }) \u003c/script\u003e \u003c/body\u003e 控制台表现 beforeMount() 第三个生命周期函数 数据挂载前 首先打印函数名称，确定函数执行；其次验证vm中有值，但此时并没有将解析结果（值）放入页面 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); }, beforeMount(){ console.log('beforeMount'); console.log(this); debugger; }, }) \u003c/script\u003e \u003c/body\u003e 控制台表现 验证此处对DOM的所有操作，最终都不会有效 mounted() 第四个生命周期函数 数据挂载完毕 首先打印函数名称，确定函数执行；其次，确定页面上所有的元素都被解析完成，且挂载完毕 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); }, beforeMount(){ console.log('beforeMount'); }, mounted(){ console.log('mounted'); console.log(this); debugger; }, }) \u003c/script\u003e \u003c/body\u003e 控制台效果 到此，整个挂载流程结束。 挂载流程 - 图解： 注意\r在使用template模版对象时，有多个节点只能用\u003cdiv\u003e标签进行包裹，不能使用\u003ctemplate\u003e标签。 \u003cscript\u003e ..... //只能使用div template:` \u003cdiv\u003e \u003ch2\u003e当前的n值是：{{n}}\u003c/h2\u003e \u003cbutton @click = \"add\"\u003e点我n+1\u003c/button\u003e \u003c/div\u003e `, ...... //不能使用template template:` \u003ctemplate\u003e \u003ch2\u003e当前的n值是：{{n}}\u003c/h2\u003e \u003cbutton @click = \"add\"\u003e点我n+1\u003c/button\u003e \u003c/template\u003e `, \u003c/script\u003e 我们知道\u003ctemplate\u003e标签，在页面解析的时候，会自动隐藏掉最外的一层，只显示\u003ctemplate\u003e标签里面的内容。所以，容易产生\u003ctemplate\u003e标签里面多根节点的问题。导致template模版对象编译失败报错 ","date":"2024-08-21","objectID":"/vue2/:19:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生命周期_更新流程 beforeUpdate() 第五个生命周期函数 在页面数据更新完成前 首先打印函数名称，确定函数执行；其次，验证此环节：数据已经更改，但页面并未更新 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); }, beforeMount(){ console.log('beforeMount'); }, mounted(){ console.log('mounted'); }, beforeUpdate(){ console.log('beforeUpdate'); console.log(this.n); debugger; }, }) \u003c/script\u003e \u003c/body\u003e 控制台效果 updated() 第六个生命周期函数 在页面数据更新完毕 首先打印函数名称，确定函数执行；其次，验证此环节：数据已经更改，页面完成更新 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); }, beforeMount(){ console.log('beforeMount'); }, mounted(){ console.log('mounted'); }, beforeUpdate(){ console.log('beforeUpdate'); }, updated(){ console.log('updated'); console.log(this.n); debugger; }, }) \u003c/script\u003e \u003c/body\u003e 控制台效果 到此，整个更新流程结束。 更新流程 - 图解： ","date":"2024-08-21","objectID":"/vue2/:19:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生命周期_销毁流程 This is a tips\rvm被销毁： 使得该vm不再工作（数据变化时，不再继续解析了） 但是原来工作的成果还在（即，已经被解析挂载的页面不会有变化）。 官方解释：https://cn.vuejs.org/v2/api/#vm-destroy beforeDestroy() 第七个生命周期函数 将要销毁前 这里是可以访问所有的vm中的所有数据和方法的，但是此时所有对数据的修改都不会再返过去触发更新流程了。即，这里所有的数据修改操作，页面都不会有任何效果。（值可以随便用，方法可以随便调，页面不会有变化） \u003cscript\u003e new Vue({ ..... beforeDestroy(){ console.log('beforeDestroy'); console.log(this.n); //能正常拿到 this.n = 99 //改行操作无用 }, }) \u003c/script\u003e destroyed() 第八个生命周期函数 销毁完毕 \u003cscript\u003e new Vue({ ..... beforeDestroy(){ console.log('beforeDestroy'); }, destroyed(){ console.log('destroyed'); } }) \u003c/script\u003e 到此，整个销毁流程结束。 销毁流程 - 图解： ","date":"2024-08-21","objectID":"/vue2/:19:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生命周期_总结 整个生命周期 - 图解： 4对生命周期钩子： vm的一生(vm的生命周期): 将要创建========\u003e调用beforeCreate函数。 创建完毕========\u003e调用created函数。 将要挂载========\u003e调用beforeMount。 (重要)挂载完毕==\u003e调用mounted函数========\u003e【重要的钩子】 将要更新========\u003e调用beforeUpdate数。 更新完毕========\u003e调用updated函数。 (重要)将要销毁==\u003e调用beforeDestroy函数。========\u003e【重要的钩子】 销毁完毕========\u003e调用destroyed函数。 这块流程中：主要阐述8个钩子。还有3个常用的钩子，需要在特殊的场景才能被调用，我们会在路由小节中进行详细描述。 第2章：Vue组件化编程 ","date":"2024-08-21","objectID":"/vue2/:19:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"20.组件 Vue组件化编程 传统方式编写应用，存在2个问题： 1、依赖关系混乱不好维护（一堆html引用一堆js和css）； 2、代码复用率不高。 组件的定义： 实现应用中局部功能代码(html、js、css)和资源(mp3、gif)的集合 模块化： 当用js来写的，并且将一个大的js按照模块分成多个不同的js来编写应用，就称为一个模块化应用 组件化： 当用组件来写，并且应用中的功能都是多个组件来编写的，就称为一个组件化的应用。 组件复用不需要复制粘贴，只需要引用即可。非常方便。 ","date":"2024-08-21","objectID":"/vue2/:20:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"非单文件组件 一个文件中包含有n个组件。例如：a.html中有4个组件 ","date":"2024-08-21","objectID":"/vue2/:20:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"单文件组件 一个文件中只包含有1个组件。例如：a.vue中有且只有唯一一个组件 ","date":"2024-08-21","objectID":"/vue2/:20:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue中使用组件的三步 1、创建组件 \u003cscript\u003e //创建school组件 const school = Vue.extend({ //组件定义时，一定不要写el配置项 //因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器 //el:'#el', //data这里必须写成函数形式 data(){ //在return中返回你要设置的data内容 //这个问题在el于data的写法小节有铺垫过 //原因就是：data对象式直接使用了同一个对象，导致多方调用时，相互影响。 //而data函数形式，每一次调用都是return创建的一个新的对象，解决了多方调用被相互影响的问题。 return{ name:'某学校', address:'某地址' } }, template:` \u003cdiv\u003e \u003ch2\u003e学校名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学校地址：{{address}}\u003c/h2\u003e \u003c/div\u003e ` }) //创建student组件 const student = Vue.extend({ data(){ return{ name:'张三', age:'18' } }, template:` \u003cdiv\u003e \u003ch2\u003e学生名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学生年龄：{{age}}\u003c/h2\u003e \u003c/div\u003e ` }) new Vue({ el:'#el', }) \u003c/script\u003e 2、注册组件 This is a tip\r全局注册 Vue.component('school',school) \u003cscript\u003e new Vue({ el:'#el', //全新配置项 //注册组件（局部注册） components:{ school:school, student:student } }) \u003c/script\u003e 3、编写组件标签，使用组件 \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003c!-- 编写组件标签 --\u003e \u003cschool\u003e\u003c/school\u003e \u003cstudent\u003e\u003c/student\u003e \u003c/div\u003e \u003c/body\u003e 实现效果以及Vue开发者工具节点体现如图： ","date":"2024-08-21","objectID":"/vue2/:20:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"细节点注意 1.关于组件名: 一个单词组成: 第一种写法(首字母小写):school 第二种写法(首字母大写):School 多个单词组成: 第一种写法(kebab-case命名):my-school \u003cmy-school\u003e\u003c/my-school\u003e components:{ 'my-school':school, } 第二种写法(CamelCase命名):MySchool(需要Vue脚手架支持) \u003c!-- 不在Vue脚手架里会报错 --\u003e \u003cMySchool\u003e\u003c/MySchool\u003e components:{ MySchool:school, } 备注: (1).组件名尽可能回避HTML中已有的元素名称，例如:h2、H2都不行。 (2).可以使用name配置项指定组件在开发者工具中呈现的名字。 \u003cscript\u003e const student = Vue.extend({ //自定义组件名字 - 没有这个就取注册时候的key:value的key值 name:'student' data(){ return{ .... } }, template:.... }) \u003c/script\u003e 2.关于组件标签: 第一种写法:\u003cschool\u003e\u003c/school\u003e 第二种写法:\u003cschoo1/\u003e 备注:不用使用脚手架时，\u003cschool/\u003e会导致后续组件不能渲染 \u003c!-- 两种写法：页面均可正常渲染school组件 --\u003e \u003cmyshool\u003e\u003c/myshool\u003e \u003cmyshool/\u003e \u003c!-- 页面渲染三个school组件 --\u003e \u003cmyshool\u003e\u003c/myshool\u003e \u003cmyshool\u003e\u003c/myshool\u003e \u003cmyshool\u003e\u003c/myshool\u003e \u003c!-- 页面只渲染一个school组件，后面的不再渲染 --\u003e \u003cmyshool/\u003e \u003cmyshool/\u003e \u003cmyshool/\u003e 3.一个简写方式: const school =Vue.extend(options)可简写为:const school = options \u003cscript\u003e //主动调用组件扩展方法extend const student = Vue.extend({ data(){ return{ ... } }, template:.... }) //简写 const student = { data(){ return{ ... } }, template:.... } new Vue({ el:'#el', //注册组件时判断：有写extend直接使用组件，没有则帮忙调用extend之后使用组件 components:{ school:school, } }) \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:20:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"组件的嵌套 下方是三个组件的嵌套。 所有的组件都嵌在app组件中，app组件中有同级school组件、hello组件，school组件中含有student组件、 代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"../js/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003capp\u003e\u003c/app\u003e \u003c/div\u003e \u003cscript\u003e //创建student组件 const student = Vue.extend({ data(){ return{ name:'张三', age:'18' } }, template:` \u003cdiv\u003e \u003ch2\u003e学生名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学生年龄：{{age}}\u003c/h2\u003e \u003c/div\u003e ` }) //创建school组件 const school = Vue.extend({ data(){ return{ name:'某学校', address:'某地址' } }, template:` \u003cdiv\u003e \u003ch2\u003e学校名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学校地址：{{address}}\u003c/h2\u003e \u003c!-- 2在哪里注册的，在哪个模版中写 --\u003e \u003cstudent\u003e\u003c/student\u003e \u003c/div\u003e `, //注册组件 components:{ //1定义组件的代码，要写在注册组件之前（比如这里的14~27行代码，必须在49行代码之前） //简写 student } }) const hello = Vue.extend({ template:`\u003ch1\u003e你好鸭！欢迎来进行学习~\u003c/h1\u003e` }) const app = Vue.extend({ template:` \u003cdiv\u003e \u003chello\u003e\u003c/hello\u003e \u003cschool\u003e\u003c/school\u003e \u003c/div\u003e `, components:{ hello, school } }) new Vue({ el:'#el', //注册组件 components:{ //简写 app } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 页面及控制台运行效果： This is a tip\r1 定义组件的代码，要写在注册组件之前 2 子组件只能写在，注册的父组件的模版template中 ","date":"2024-08-21","objectID":"/vue2/:20:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"VueComponent结构函数 关于VueComponent： 1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的 const school = Vue.extend({}) //定义组件后，打印组件 console.log(\"@\",school); 控制台输出为： 这里可以看出，其是一个函数。严谨上来讲，我们称其为构造函数，其调用方式应该为new VueComponent() 我们打开Vue.js查找VueComponent函数，打印一段文字。我们会发现，当我们使用组件时候，使用一次就调一次该函数。即，有一个\u003cschool\u003e\u003c/school\u003e调一次new，有三个，就调3次。 2.我们只需要写\u003cschool/\u003e或\u003cschool\u003e\u003c/school\u003e，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)。 3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！ const school = Vue.extend({}) const student = Vue.extend({}) //定义组件后，打印组件 console.log(\"@\",school); console.log(\"@\",student); //打印出来的东西，看起来都是长一样的，都是VueComponent //但是是两个全新的，各自独立的，功能长相都一样的 VueComponent //-----------------验证----------------- console.log(school === student); //false school.a = 99 console.log(school.a); //99 console.log(student.a); //undefind 4.关于this指向： (1).组件配置中： data函数、methods中的函数、watch中的函数、computed中的函数它们的this均是【VueComponent实例对象】 (2).new Vue()配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】 5.VueComponent的实例对象，以后简称vc(也可称之为:组件实例对象)。 Vue的实例对象，以后简称vm。 控制台输出vm，结构里面能通过$children很清晰的看见各个组件的 结构关系，和上下管理层级关系。 ","date":"2024-08-21","objectID":"/vue2/:20:6","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue实例 \u0026 组件实例 vm和vc从结构上来看基本上一致，但并不是完全一致，并不是完全相等的两个东西。 首先，vm是Vue创建实例的时候，生成的实例对象；vc是VueComponent创建实例的时候，生成的实例对象。 Vue生成实例对象和VueComponent生成实例对象的缔造过程并不是一模一样的！所以他们两并不是完全一样的 其次，vm中是可以使用el配置项的，用于指定服务于哪个容器；vc中是不能使用el的 再有，vm中的data可以写成data:{}，也可以写成data(){}；但是vc中data只能写成data(){return }函数形式 ","date":"2024-08-21","objectID":"/vue2/:20:7","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"内置关系 首先复习一个js上的属性概念：.prototype \u0026 .__proto__ \u003cscript type=\"text/javascript\"\u003e //定义一个构造函数 function Demo(){ this.a = 1 this.b = 2 } //创建一个Demo的实例对象 const d = new Demo() //显式原型属性 //只有function函数才有这个属性，实例对象是没有的 //一般通过该条:程序员追加值 console.log(Demo.prototype); //打印输出为 原型对象{} //隐式原型属性 //实例对象默认都带有这个属性 //一般通过该条程序自动访问值 console.log(d.__proto__);//也打印输出为 原型对象{} ,且与上面的长得一样 //通过 显式原型属性 操作原型对象，追加一个x属性 Demo.prototype.x = 99 //手动通过这种方式访问值 //发现是同步更新到值的 console.log(d.__proto__.x); //99 //验证两个原型对象是否是完全相同的 console.log(Demo.prototype === d.__proto__); //true //通过Demo的实例对象访问 console.log(d); //Demo{a=1,b=2} 这里，Demo表示后面的{}里的对象内容，是由Demo缔造出来的 console.log(d.x); //99 //为什么输出的d带着Demo //表示这个{}对象是谁构造出来的 //例如 function school(){} function student(){} const s = new school() const ss = new student() console.log(s); //school{} console.log(ss);//student{} //这里如果没有前面的这个名字，则分不清对象来自于哪里 \u003c/script\u003e 由此引入一个重要的内置关系： VueComponent.prototype.__proto__ === Vue.prototype 这个关系的作用： 让组件实例对象vc可以访问到Vue原型上的属性、方法 这是Vue独有的：增加了，vc原型对象的原型对象指向vm的原型对象。 \u003c!-- 因为有这个内置关系：使得组件里this.x打印输出为99 得以实现 --\u003e \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003cschool\u003e\u003c/school\u003e \u003c/div\u003e \u003cscript\u003e Vue.prototype.x = 99 //创建school组件 const school = Vue.extend({ data(){ return{ name:'某学校', address:'某地址' } }, template:` \u003cdiv\u003e \u003ch2\u003e学校名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学校地址：{{address}}\u003c/h2\u003e \u003cbutton @click=\"onChange\"\u003e点击获取x的值\u003c/button\u003e \u003c/div\u003e `, methods:{ onchange(){ alert(\"当前x的值是\"+this.x) } } }) new Vue({ el:'#el', components:{ school } }) \u003c/script\u003e \u003c/body\u003e ","date":"2024-08-21","objectID":"/vue2/:20:8","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"单文件组件 单文件组件，均是以xxxx.vue的文件 命名规范： 一个单词的文件命名为：school.vue，School.vue 多个单词的文件命名为：my-school.vue，MySchool.vue 一般我们都使用大写字母开头进行命名，主要是为了和开发者工具那边的根节点结构展示的名字一样【这边写成小写开头，那边也会默认显示为大写】。 1新建一个单文件组件School.vue \u003c!-- .vue文件中主要是：页面资源的合集，即html、css、js 为了迎合常见的前端三种资源显示的写法，vue提供了三个标签 分别是： 1、组件的结构标签\u003ctemplate\u003e 2、组件的交互标签\u003cscript\u003e 3、组件的样式标签\u003cstyle\u003e --\u003e \u003c!-- 这里就能看出“非单文件”的一个弊端： 组件的样式是不能单独写的，是公共写公共引用的 “单文件”的样式，一个文件一个，是独立的 --\u003e \u003c!-- 组件的结构标签 --\u003e \u003ctemplate\u003e \u003cdiv class=\"demo\"\u003e \u003ch2\u003e学校名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学校地址：{{address}}\u003c/h2\u003e \u003cbutton @click=\"onChange\"\u003e点击获取x的值\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003c!-- 组件的交互标签 --\u003e \u003cscript\u003e //组件需要被引用，外部使用import //这儿有三种暴露方式： // export const school = Vue.extend({})//1分别暴露 // export{school}//2统一暴露 // export default school //3默认暴露 //我们一般使用默认暴露，因为引用时比较简单，只需要import 起名 from vue文件的位置； //export default Vue.extend({}) //由于Vue.extend不写vue也会自动帮我们调用，所以这里可以简写 export default{ name:'School',//和文件名保持一致，开发者工具呈现的是这儿的名字 data(){ return{ name:'某学校', address:'某地址', x:1 } }, methods:{ onchange(){ alert(\"当前x的值是\"+this.x) } } } \u003c/script\u003e \u003c!-- 组件的样式标签 --\u003e \u003cstyle\u003e .demo{ background-color: aqua; } \u003c/style\u003e 2新建一个总体管理的顶级父组件App.vue \u003ctemplate\u003e \u003c!-- 这儿的div必须有，保证根节点 --\u003e \u003cdiv\u003e \u003cSchool\u003e\u003c/School\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e //引入组件 import School from './School.vue'; import School from './School.vue'; export default{ name:'App', //注册 components:{ School } } \u003c/script\u003e 3新建一个入口文件main.js //vue脚手架选择了main.js用来调用new Vue()创建vm实例对象 //引入App import App from \"./App.vue\"; new Vue({ el:\"#root\", componements:{App} }) 4新建一个根容器文件index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 指定容器 --\u003e \u003cdiv id=\"root\"\u003e \u003c!-- 引用App --\u003e \u003cApp\u003e\u003c/App\u003e \u003c/div\u003e \u003c!-- 在模块加载完毕后引入 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/vue.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"./main.js\"\u003e\u003c/script\u003e \u003c!-- main.js入口文件 --\u003e \u003c/body\u003e \u003c/html\u003e 整个单文件组件引用流程和书写规范就结束了，主要的文件如图： xxxx.vue文件运行，借助： 1、自己单独使用webpack 搭建工作流，借助一些第三方插件和node将.vue文件转换 成 .html 文件使得浏览器能够运行 2、Vue脚手架【vue官方团队，也是通过webpack经过一些node借助一些第三方插件打造的一个工作流，是一个搭建好的一个编译环境，可以直接使用】 ———————-所以，我们这里阐述vue脚手架的内容———————– 第3章：使用Vue脚手架 ","date":"2024-08-21","objectID":"/vue2/:20:9","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"21.Vue脚手架 ","date":"2024-08-21","objectID":"/vue2/:21:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"创建Vue脚手架 1说明 Vue脚手架是Vue官方提供的标准化开发工具（开发平台） 最新的版本是4.x 官方文档：https://cli.vuejs.org/zh/。 CLI的全称是 command line interface 直译过来是：命令行接口工具 2具体步骤 第一步（仅第一次执行）：全局安装@vue/cli npm install -g @vue/cli 第二步：切换到你要创建项目的目录，然后使用命令创建项目 vue create xxxx 提示选择用哪个版本的Vue创建项目，这里移动光标，选择Vue2，回车 babel：ES6转ES5需要用到的语法编译器 eslint：语法检查器 等待创建 创建完成 第三步：启动项目 npm run serve 按步骤执行 启动成功 打开页面 停止程序 crtl+c 连续两次即可 This is a tip\r备注： 1、如果出现下载缓慢请配置npm淘宝镜像： //该镜像已经过期 npm config set registry https://registry.npm.taobao.org //请使用下面的最新的镜像 npm config set registry https://registry.npmmirror.com 2、Vue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，请执行 vue inspect \u003e output.js 3、执行完install命令，退出命令窗口，重新cmd打开，再输入vue测试是否安装成功。 //退回到上一层目录 cd //清空上面所有记录 cls //新建一个文件夹 mkdir 4、vue create xxxx命令创建的项目中，包含 vue脚手架 官方给你写好的HelloWord例子 ","date":"2024-08-21","objectID":"/vue2/:21:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"分析脚手架结构 将项目用vscode打开，同样用终端启动。分析项目中对应文件的作用。 .gitignore 哪些文件或者文件夹不想接受git管理，在.gitignore这个文件中配置 babel.config.js demo的控制文件。配置一些ES6转ES5的规则。【不需要我们去修改】 package.json 包的说明书。你的包叫什么名字，什么版本，使用的一些依赖，引入的一些库，一些短命令。 package-lock.json 包管理器。包版本控制文件。 README.md 对整个工程进行一个说明或者一个描述 src 下面的4个四个文件： assets - 一般放前端的静态资源：例如图片 components App.vue - 顶级父组件 main.js - 入口文件 public 下面两个文件： favicon.ico - 网站图标 index.html - 主页面 ","date":"2024-08-21","objectID":"/vue2/:21:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"22.render函数 new Vue({ render: h =\u003e h(App), }).$mount('#app') 替换成 new Vue({ render(createElement){ return createElement('h1','你好啊') } }).$mount('#app') 发现页面正常显示： 由此可以知道，render：是vue帮我们调用的，且利用入参createElement函数帮我们编译模板。 上面的代码： render(createElement){ return createElement('h1','你好啊') } 简化可以写成： //函数写成箭头函数 //render:(createElement) =\u003e{return createElement('h1','你好啊')} //一个入参，可以去掉括号 //render:createElement =\u003e{return createElement('h1','你好啊')} //一个唯一返参，可以去掉return render:createElement =\u003ecreateElement('h1','你好啊') //这便是main.js中写入模版精简的形式 render: h =\u003e h(App) 讨论main.js中的render函数的作用 我们之前独自写过main.js，格式是这样的： import App from \"./App.vue\"; new Vue({ el:\"#root\", template:`\u003cApp\u003e\u003c/App\u003e`, componements:{App} }) 那为什么vue创建的main.js不这么写呢。 我们将上面这段代码copy后，放入脚手架中，编译项目，可以看见控制台报错： 我们去调查，为什么vue不完整 在Es6引入第三方库的时候，我们一般写到某个路径下具体某个文件xxx.js 在vue引入第三方库的时候，我们一般只写到它的名字。 那么它具体引入的是哪个js，按住ctrl键，点击： 点击引用的vue文件，可以看到来到了node_moudles中 这儿能看见整个vue包含的文件。其实，main.js中import Vue from 'vue'只写到了这个vue包文件夹，具体指向的哪个js文件，需要依赖配置项： package.json中的module的配置js。 这里可以看到是dist/vue.runtime.esm.js。这个js是个精简版的vuejs，它将模版解析器精简掉了，所以他没办法解析template配置项，产生报错。 打开dist文件夹，我们可以看见他下方有很多个vuejs，但是只有Vue.js是完整版的，其余的都是在它的基础上精简或者稍加改变的。 那么问题找到了，我们将main.js包中的引入换成完整版的： import Vue from 'vue' 替换为： import Vue from 'vue/dist/vue' 重新编译后，页面和控制台： 模版编译成功，控制台无报错。 为什么不使用这个完整版的vue呢。 vue.runtime.esm.js体积小，打包以后体积还能更小一点。且模版编译器最终，不应该出现在我们最终打包好的文件内。 This is a tip\r注意： 组件中也有template标签，但是不用render函数去编译解析。 在package.json中专门引入了依赖包，去解析组件中的模版标签。 只有vm中的模版标签它解析不了，需要使用render函数 脚手架中一般只有一个vm，render也只会在vm中出现一次 ","date":"2024-08-21","objectID":"/vue2/:22:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"23.修改默认配置 脚手架的默认配置 为了安全Vue将配置的文件隐藏起来，使用下面的这个命令可以将隐藏的文件形成一个.js文件显示在项目的根目录： Vue inspect \u003e output.js 虽然output.js是可以看见默认配置的，但是对这个文件的修改是无效果的。 如果要自定义配置，可以在项目的根目录下，新建一个文件vue.config.js 修改脚手架默认配置 官方文档解释位置：https://cli.vuejs.org/zh 例如，我们把main入口文件的名字改成自定义 原理： Vue底层基于webpack，webpack基于node 使用文件vue.config.js中的这块，重写webpack中修改的这一部分 使得核心部分能有修改入口，且不会对基本核心内部进行破坏造成影响 ","date":"2024-08-21","objectID":"/vue2/:23:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"24.ref属性 This is a tip\rref属性 1.被用来给元素或子组件注册引用信息(id的替代者) 2.应用在htmi标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象(vc) 3.使用方式: 打标识:\u003ch1 ref=\"xxx\"\u003e.....\u003c/h1\u003e或\u003cSchool ref=\"xxx\"\u003e\u003c/School\u003e获取:this.$refs.xxx 获取Dom元素，原始写法： document.getElementById(\"text\") 用ref写法 \u003cdiv\u003e \u003ch1 ref=\"text\" id=\"text\"\u003etext\u003c/h1\u003e \u003cSchool ref=\"sch\" id=\"sch\"/\u003e \u003c/div\u003e \u003cscript\u003e .... methods:{ showDOM(){ //组件里的this都是vc //输出的是h1的整个DOM元素 - 基本标签ref可以当id用 console.log(this.$refs.text) console.log(document.getElementById(\"text\"))//结果同上 //输出的是组件school的vc实例对象 console.log(this.$refs.sch) //输出的是组件模版解析后的真实DOM console.log(document.getElementById(\"sch\")) } } \u003c/script\u003e 看一下输出ref： 看一下输出id： ","date":"2024-08-21","objectID":"/vue2/:24:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"25._props配置 props的作用：让组件接收外部传过来的数据 组件外属性传值： \u003cstudent name=\"张三\" sex=\"男\" age=\"18\"\u003e 组件内接受，三种写法： //简单接受 props:['name','age','sex'] //接受的同时对数据进行类型限制 props:{ name:String, sex:String, age:Number } //接受时限制是否必传、默认值以及类型 props:{ name:{ type:String, //限制name类型为String required:true //且为必传 }, sex:{ type:Number, default:99 //不必传，没传时默认99 }, age:{ type:String, required:true }, } This is a tip\r备注:props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。 例如： this.age = 19; //页面有效果，控制台有警告 Vue不建议在组件内部，修改外部传入的属性的属性值。 一般做法： //使用一个中间变量 data(){ return{ changeAge:this.age } } //修改中间变量，并使用中间变量 this.changeAge = 19 ","date":"2024-08-21","objectID":"/vue2/:25:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"26.mixin混入 两个组件共享一个配置 ，实现复用方法的效果 //新建一个共有.js文件 《hunhe.js》 //该文件中暴露共用配置方法 //export const为分别暴露，引入的时候需要带{} export const hunhe ={ methods:{ ...... } } //需要的组件中引入.js文件 import {hunhe} from '../hunhe.js' //组件中使用mixins配置项 mixins:[hunhe] This is a tip\r混合中data中的数据以及methods冲突，以组件为主，例如： //《hunhe.js》中 export const hunhe ={ data(){ return{ a:1 } } } //《组件student中》 data(){ return{ a:99 } },mixins:[hunhe] console.log(this.a) //输出为99，以组件为准 但是！！！ 生命周期冲突，不以任何为主，都会执行 //《hunhe.js》中 export const hunhe ={ ..., mounted(){ console.log(\"11\") } } //《组件student中》 ..., mounted(){ console.log(\"22\") },mixins:[hunhe] //启动后控制台输出： //11 //22 ","date":"2024-08-21","objectID":"/vue2/:26:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"27.插件 插件实际上是一个{ }对象 自定义插件必须有有个install函数 //新建《plugins.js》 export default{ install(Vue){ ... //install的入参是Vue。 //此函数中可以设定所有全局Vue能够设定的方法，并且让组件均能使用 } } //main.js中引入插件 import pligins from './pligins.js' //main.js中使用插件 Vue.use(pligins) //这句话或默认帮我们调用《plugins.js》中的install方法 This is a tip\r插件功能:用于增强Vue 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\r","date":"2024-08-21","objectID":"/vue2/:27:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"28.scoped样式 scoped作用：让样式在局部生效，防止冲突 先看一个冲突 解决这个问题 在style标签里加上scoped属性 \u003cstyle scoped\u003e .... \u003c/style\u003e 原理：scoped原本就有作用域的意思，它在每个负责的标签样式后面都随机生成一个属性，配合样式选择器完成每个组件中引用同名样式的区分 ","date":"2024-08-21","objectID":"/vue2/:28:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"29.浏览器本地存储 在浏览器打开某网页，未登录情况下搜索某关键字，发现能够有对应的历史记录。 此历史记录是浏览器将信息存在了本机的硬盘上，也叫浏览器本地存储 浏览器本地存储统称webStorage 1、存储内容大小一般支持5MB左右(不同浏览器可能还不一样) 2、浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。 localStorage sessionStorage ","date":"2024-08-21","objectID":"/vue2/:29:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"localStorage.setItem 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。 浏览器本地存储不是Vue独有的，是js就有的，用.html文件就可以实现编译。 保存本地存储 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003elocalStorage\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch2\u003elocalStorage\u003c/h2\u003e \u003cbutton onclick=\"s()\"\u003e点击保存一个数据\u003c/button\u003e \u003cscript type=\"text/javascript\"\u003e function s(){ //第一个API叫setItem，两个入参必须为字符串 //重复添加同名的，会覆盖之前的值 localStorage.setItem('msg','hello!') //msg hello! localStorage.setItem('msg2',666) //msg2 666 localStorage.setItem('msg3',{'id':'001'})//不是字符串的会自动调toString，对象会存成[Object object] localStorage.setItem('msg4',JOSN.stringify(对象)) } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-08-21","objectID":"/vue2/:29:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"localStorage.getItem 该方法接受一个键名作为参数，返回键名对应的值 读取本地存储 \u003cscript type=\"text/javascript\"\u003e function s(){ //第二个API叫getItem,会给一个字符串的返回值 localStorage.getItem('msg') console.log(localStorage.getItem('msg')); //hello! console.log(JSON.parse(对象字符串));//对象的需要手动转换一下 } \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:29:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"localStorage.removeItem 该方法接受一个键名作为参数，并把该键名从存储中删除 删除本地存储 \u003cscript type=\"text/javascript\"\u003e function s(){ //第三个API叫removeItem localStorage.removeItem('msg') } \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:29:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"localStorage.clear 该方法会清空存储中的所有数据。 清空本地存储 \u003cscript type=\"text/javascript\"\u003e function s(){ //第四个API叫clear localStorage.clear() } \u003c/script\u003e This is a tip\r关闭浏览器，并不会自动清空浏览器本地存储。 但是！！！清除缓存，会清空浏览器本地存储。 ","date":"2024-08-21","objectID":"/vue2/:29:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"sessionStorage sessionStorage的4个API和localStorage使用和功能效果是一样的。 控制台位置，在localStorage下面 This is a tip\r备注: 1、SessionStorage存储的内容会随着浏览器窗口关闭而消失。 2、LocalStorage存储的内容，需要手动清除才会消失。 3、xxxxxstorage.getItem(xxx)如果xxx对应的value获取不到，那么getltem的返回值是null. 4、JSON.parse(null)的结果依然是null。\r","date":"2024-08-21","objectID":"/vue2/:29:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"30.组件自定义事件 ","date":"2024-08-21","objectID":"/vue2/:30:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"绑定【子传父】 子组件给父组件传值，三个写法： function \u003c!--父组件App.vue--\u003e \u003cSchool :getSchoolName=\"getSchoolName\"/\u003e props:['getSchoolName'], methods:{ getSchoolName(name){ console.log(\"学校名：\"+name) } } \u003c!--子组件School.vue--\u003e this.getSchoolName(this.name) $emit （自定义事件） \u003c!--父组件App.vue--\u003e \u003cStudent v-on:student=\"getStudentName\"/\u003e \u003cStudent @student=\"getStudentName\"/\u003e\u003c!--简写--\u003e methods:{ getStudentName(name){ console.log(\"学生名：\"+name) } } \u003c!--子组件Student.vue--\u003e this.$emit('student',this.name) ref （自定义事件） \u003c!--父组件App.vue--\u003e \u003cStudent ref=\"student\"/\u003e methods:{ getStudentName(name){ console.log(\"学生名：\"+name) } }, mounted:{ this.$refs.student.$on('studentTest',this.getStudentName) } \u003c!--子组件Student.vue--\u003e this.$emit('studentTest',this.name) This is a tip\r如果子传父的参数很多，三个办法： 挨个写入参 this.$emit('demo',x,y,z,p...) this.$refs.组件名.$on('demo',x,y,z,p...) 写成一个对象 this.$emit('demo',{params}) this.$refs.组件名.$on('demo',{params}) ES6写法，…a this.$emit('demo',this.name,...params) this.$refs.组件名.$on('demo',this.name,...params) ","date":"2024-08-21","objectID":"/vue2/:30:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"解绑 解绑一个自定义事件 $off \u003c!--父组件App.vue--\u003e \u003cStudent @student=\"getStudentName\"/\u003e \u003c!--子组件Student.vue--\u003e this.$off('student') 解绑多个自定义事件 $off([事件名]) \u003c!--父组件App.vue--\u003e \u003cStudent @student=\"getStudentName\" @demo=\"getDemo\"/\u003e \u003c!--子组件Student.vue--\u003e this.$off(['student','demo']) 解绑所有的自定义事件 $off() \u003c!--父组件App.vue--\u003e \u003cStudent @student=\"getStudentName\" @demo=\"getDemo\"/\u003e \u003c!--子组件Student.vue--\u003e this.$off() This is a tip\r组件上也可以绑定原生DOM事件，需要使用native修饰符. 不使用native修饰符.会默认@click为自定义事件 \u003cStudent @student=\"getStudentName\" @click.native=\"getDemo\"/\u003e this.$refs.组件名.$on('事件名',回调函数)里的回调函数需要写成箭头函数，或者直接定义在当前组件的methods中。否则this指向会有问题 this.$refs.组件名.$on('事件名',()=\u003e{}) //或者 methods:{ demo(){} } this.$refs.组件名.$on('事件名',this.demo) ","date":"2024-08-21","objectID":"/vue2/:30:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"31.全局事件总线 ","date":"2024-08-21","objectID":"/vue2/:31:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"GlobalEventBus 一种组件间通讯的方式，适用于任意组件间的通讯 安装全局事件总线 //《main.js》 new Vue({ .... beforeCreate(){ Vue.prototype.$bus = this //定义全局事件总线 }, ...... }) 使用事件总线： 1、接受数据 //《School.vue》 this.$bus.$on(\"事件名\",回调函数) 2、提供数据 //《Student.vue》 this.$bus.$emit(\"事件名\",传递入参数据) 3、关闭总线中不用的自定义事件 //《School.vue》 beforeDestroy(){ this.$bus.$off('demo') } ","date":"2024-08-21","objectID":"/vue2/:31:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"32.消息订阅与发布 ","date":"2024-08-21","objectID":"/vue2/:32:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"_pubsub pubsub.js是一个第三方库，引用这个库可以在任意框架实现消息的订阅和发布。 npm i pubsub-js pubsub是publish发布和subscribe订阅的组合简写 在组件中引入 import pubsub from 'pubsub-js' 订阅消息 pubsub.subscribe('事件名'，回调函数(事件名，收到的数据){}) 发布消息 pubsub.publish('事件名'，事件名，传递入参数据) 销毁消息（ 取消订阅） //在订阅的组件内,通过id取消订阅 this.pubId = pubsub.subscribe('事件名'，回调函数(事件名，收到的数据){}) beforeDestroy(){ pubsub.unsubscribe(this.pubId) } ","date":"2024-08-21","objectID":"/vue2/:32:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"33.$nextTick 语法this.$nextTick(回调函数) 作用：在下一次DOM更新结束后执行其指定的回调 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在$nextTick所指定的回调函数中执行 This is a tip\r不写$nextTick，用定时器也是可以解决，等待DOM更新结束后执行的操作。 setTimeout(( )=\u003e{ 基于更新后的新DOM进行某些操作 },2000) 只是官方推荐使用$nextTick ","date":"2024-08-21","objectID":"/vue2/:33:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"34.动画效果 实现一块元素从左边缓缓进入再离开的动画效果 原始css3的写法： \u003c!-- 合适时候换成go --\u003e \u003ch1 class=\"come\"\u003e\u003c/h1\u003e \u003cstyle scoped\u003e h1{ background-color: burlywood; } .come{ /* 播放这个动画 持续1s钟 */ animation: demo 1s; } .go{ /* 反转播放这个动画 持续1s钟 */ animation: demo 1s reverse; } /* 动画：定义一个关键帧 起名叫demo */ @keyframes demo { /* 左右来回变换 */ from{ /* 从左边 */ transform: translateX(-100%); } to{ transform: translateX(0px); } } \u003c/style\u003e Vue的实现写法 \u003c!--transition标签包裹的就是过度动画 --\u003e \u003ctransition\u003e \u003ch1\u003e\u003c/h1\u003e \u003c/transition\u003e \u003cstyle scoped\u003e h1{ background-color: burlywood; } /* 进入时激活：来 */ .v-enter-active{ /* 播放这个动画 持续1s钟 */ animation: demo 1s; } /* 离开时激活：离开 */ .v-leave-active{ /* 反转播放这个动画 持续1s钟 */ animation: demo 1s reverse; } /* 动画：定义一个关键帧 起名叫demo */ @keyframes demo { /* 左右来回变换 */ from{ /* 从左边 */ transform: translateX(-100%); } to{ transform: translateX(0px); } } \u003c/style\u003e This is a tip\r如果\u003ctransition\u003e有名字，则.v-enter-active开头需要将v替换成取的名字 \u003ctransition name=\"aaa\"\u003e\u003c/transition\u003e \u003cstyle scoped\u003e .aaa-enter-active{ } .aaa-leave-active{ } \u003c/style\u003e 如果要第一次页面就显示动画，需要加上appear属性 \u003ctransition name=\"aaa\" :appear=\"true\"\u003e\u003c/transition\u003e Vue的实现第二种写法 \u003ctransition\u003e \u003ch1\u003e\u003c/h1\u003e \u003c/transition\u003e \u003cstyle scoped\u003e h1{ background-color: burlywood; } .v-enter-active,.v-leave-active{ transition: 0.5s linear; /* 动画持续0.5s 匀速 */ } /* 进入起点，离开终点 */ .v-enter,.v-leave-to{ transform: translateX(-100%); } /* 进入终点，离开起点 */ .v-leave,.v-enter-to{ transform: translateX(-100%); } \u003c/style\u003e 多个元素过度 \u003c!-- 多个元素使用transition-group --\u003e \u003ctransition-group\u003e \u003c!-- 且每个元素必须有key值 --\u003e \u003ch1 key=\"1\"\u003e\u003c/h1\u003e \u003ch1 key=\"2\"\u003e\u003c/h1\u003e \u003c/transition-group\u003e 集成第三方动画 有时候我们也集成一些好用的第三方库来帮我们完成好看的动画效果，npm网站：https://npmjs.com 上有这么这一个库，叫animate.css 这是一个成型的动画库，只需要引入，就能直接使用这个链接里的动画 用一个简单的例子： 安装这个库 npm install animate.css --save 组件里引入这个库 import 'animate.css' 使用这个库 先选一个样式动画，复制 \u003ctransition-group apper name=\"animate__animated animate__bounce\" enter-active-class=\"animate__swing\" \u003e \u003c/transition-group\u003e ","date":"2024-08-21","objectID":"/vue2/:34:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"35.插槽 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 ====\u003e子组件 分类：默认插槽、具名插槽、作用域插槽 使用方式： 默认插槽 父组件中: \u003cCategory\u003e \u003cdiv\u003ehtml结构1\u003c/div\u003e \u003c/Category\u003e 子组件中: \u003ctemplate\u003e \u003cdiv\u003e \u003c!--定义插槽 --\u003e \u003cslot\u003e插槽默认内容...\u003c/slot\u003e \u003c/div\u003e \u003c/template\u003e 具名插槽 父组件中: \u003cCategory\u003e \u003c!-- 基本写法 --\u003e \u003cdiv slot=\"center\"\u003e \u003cdiv\u003ehtml结构1\u003c/div\u003e \u003c/div\u003e \u003c!-- 只有template可以这样写 --\u003e \u003ctemplate v-slot:footer\u003e \u003cdiv\u003ehtm1结构2\u003c/div\u003e \u003c/template\u003e \u003c/Category\u003e 子组件中: \u003ctemplate\u003e \u003cdiv\u003e \u003c!--定义插槽 --\u003e \u003cslot name=\"center\"\u003e插槽默认内容...\u003c/slot\u003e \u003cslot name=\"footer\"\u003e插槽默认内容...\u003c/slot\u003e \u003c/div\u003e \u003c/template\u003e 作用域插槽 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。 具体编码： 父组件中: \u003cCategory\u003e \u003c!-- scope没有d，注意和style那块区分--\u003e \u003c!-- scope收到传来的整个插槽对象的数据 --\u003e \u003c!-- scope里面入参scopeData包含有多个属性的值，如solt :a=\"11\" :b=\"11\" --\u003e \u003c!-- 引用则写成scopeData.a 或者scopeData.b --\u003e \u003ctemplate scope=\"scopeData\"\u003e \u003c!-- 生成的是u1列表--\u003e \u003cu1\u003e \u003cli v-for=\"g in scopeData.games\" :key=\"g\"\u003e{{g}}\u003c/li\u003e \u003c/u1\u003e \u003c/template\u003e \u003c/Category\u003e \u003cCategory\u003e \u003ctemplate slot-scope=\"scopeData\"\u003e \u003c!--生成的是h4标题 --\u003e \u003ch4 v-for=\"g in scopeData.games\" :key=\"g\"\u003e{{g}}\u003c/h4\u003e \u003c/template\u003e \u003c/Category\u003e 子组件中: \u003ctemplate\u003e \u003cdiv\u003e \u003cslot :games=\"games\"\u003e\u003c/slot\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e .... data(){ return{ games:['1','2','3'] } } \u003c/script\u003e 最新写法 \u003c!-- 旧的写法，现在还能用 --\u003e \u003c!-- scope里面入参有多个，如solt :a=\"11\" :b=\"11\" --\u003e \u003ctemplate scope=\"{dataList}\"\u003e \u003c!-- 最新写成 --\u003e \u003ctemplate solt-scope=\"{dataList}\"\u003e 第四章：Vue拓展 ","date":"2024-08-21","objectID":"/vue2/:35:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"36.Vue中的ajax请求 ","date":"2024-08-21","objectID":"/vue2/:36:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"跨域配置代理 在开发的过程中，如何借助Vue脚手架，去解决ajax跨域的问题。 发送一个ajax的方法： xhr new XMLHttpRequest() ： xhr.open() 和 xhr.send() jQuery 对xhr进行封装 $.get 和 $.post 【因为jQuery中80%内容都是用于对DOM操作的封装，Vue避免对DOM进行操作，所以它不常用在Vue中】 axios 【Vue推荐使用】 fetch 我们这里选择使用axios 安装axios库 npm i axios 引入axios库 import axios from 'axios' 使用 methods:{ demo(){ //服务器地址 axios.get('http://localhost:5000/demo').then( //成功回调 response =\u003e{ console.log(response.data)}, //失败回调 error =\u003e{ console.log(error.message)} ) } } 跨域报错警告\rAccess to XMLHttpRequest at 'http://localhost:5000/demo' from origin 'http://localhost:8080' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 访问规定：协议名，主机名，端口号 。三个一致，允许访问。 不一致，会请求，会查到数据，但是返回给请求方的时候报跨域错误。 解决跨域： 服务器位置：通过配置cors，允许某部分请求头能够访问，解决跨域的问题。 jsonp ：借助script标签里的src属性，在引入外部资源的时候，不受同源策略限制的特点实现的。【只能解决get请求，post解决不了】 配置代理服务器 1. 配置代理 方式一 请求方 \u003c======\u003e 代理服务器 \u003c=======\u003e 目标服务器 niginx 反向代理服务器 vue-cli 借助vue脚手架帮我们开启一个服务器 官方文档位置：https://cli.vuejs.org/zh/config/#devserver-proxy 写法： 在vue.config.js里添加下面的代码： //开启代理服务器 devServer:{ proxy:'http://localhost:5000' //指向目标服务器 } 调用 这里只能找代理服务器发请求，代理服务器端口是8080 methods:{ demo(){ //服务器地址 axios.get('http://localhost:8080/demo').then( //成功回调 response =\u003e{ console.log(response.data)}, //失败回调 error =\u003e{ console.log(error.message)} ) } } 注意！！！\r这样的代理配置有两个缺点： 只能配置一个目标服务器 如果public根文件夹下有静态资源，则直接返回了静态资源，不会请求代理服务器，如： http://localhost:8080/demo会直接请求demo.txt文件，没有才请求代理服务器，有就直接返回demo.txt的信息。 2. 配置代理 方式二 写法： 在vue.config.js里添加下面的代码： devServer: { proxy: { '/api': { target: '\u003curl\u003e', ws: true, changeOrigin: true }, '/foo': { target: '\u003cother_url\u003e' } } } 先看第一部分 devServer: { proxy: { '/api': { //请求前缀，如果是以这个名字为前缀的，代理就转发 target: 'http://localhost:5000', //请求的目标服务器 ws: true, //支持：websocket客户端与服务器间的一种通讯方式 changeOrigin: true,//用于控制请求头重host的值。请求来源 返回成和目标服务器一致 pathRewrite:{'^/api':''} //重写路径，正则匹配以api开头的路径，全部替换成空。不然，访问目标服务器时也会带着请求前缀，导致接口404 }, } //前缀写在端口号后，方法名称前 axios.get('http://localhost:8080/api/demo').then() 3. vue-resource vue-resource也是一个发送ajax请求的库，也是对xhr进行封装的，vue1.0使用广泛，现在官方已不再维护。 安装vue-resource npm i vue-resource main.js中引入插件 import vueResource from 'vue-resource' Vue.use(vueResource) 使用同axios this.$http.get('http://localhost:8080/demo').then( //成功回调 response =\u003e{ console.log(response.data)}, //失败回调 error =\u003e{ console.log(error.message)} ) ","date":"2024-08-21","objectID":"/vue2/:36:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"37.Vuex插件 Vuex简介 概念：专门在 Vue 中实现集中式状态(数据)管理的一个 Vue 插件，对 vue 应用中 多个组件的共享状态进行集中式的管理(读/写)，也是一种组件间通信的方式，且适用于任意组件间通信。 Github 地址: https://github.com/vuejs/vuex This is a tip\r**集中式：**将所有接受方集中起来，发送一次，都能接受。 **分布式：**分成多个相同的，同时发送，都能接受。 Vuex工作原理图 搭建Vuex环境 安装插件：npm i vuex 使用插件：Vue.use(Vuex) 注意哦\r在2022年2月7日，vue3成为了默认版本。也就是说，我们现在去执行npm i vue安装的就直接是vue3了。 vue3成为默认版本的同时，vuex也更新到了4版本。也就是说，我们现在去执行npm i vuex安装的是vuex4了。 而vuex的4版本，只能在vue3中使用。如果在vue2版本中使用vuex的4版本，就会出现报错。 vue2中，只能用vuex的3版本 vue3中，只能用vuex的4版本 我们现在用的vue2的框架环境，所以我们这里要引入3版本的vuex，命令为npm i vuex@3 vuex安装后，存在一个store配置项，所有组件均能看见store：vc ==\u003e store 创建文件：src/store/index.js，store文件夹与App.vue同级 //该文件用于创建Vuex中最为核心的store //引入Vue核心库 import Vue from 'vue' //引入Vuex import Vuex from 'vuex' Vue.use(Vuex) //准备actions-用于响应组件中的动作 const actions={} //准备mutations-用于操作修改数据(state) const mutations ={} //准备state-用于保存存储数据 const state ={} //创建并暴露store export default new Vuex.Store({ actions, mutations, state, }) 在main.js中创建vm时引入store配置项 ..... //引入store import store from './store' ..... //创建vm const vm = new Vue({ el:'#app', render:h=\u003eh(App), store, //配置store直接简写 }) 基本使用 初始化数据、配置 actions、配置mutations、操作文件store.js .... //准备actions-用于响应组件中的动作 const actions={ jia(context,value){ // console.1og('actions中的jia被调用了',ministore,value) context.commit('JIA',value) } } //准备mutations-用于操作修改数据(state) const mutations ={ //执行加 JIA(state,value){ // console.log('mutations中的JIA被调用了'state,value) state.sum += value } } //准备state-用于保存存储数据 const state ={ sum:0 } .... 组件中读取vuex中的数据：$store.state.sum 组件中修改vuex中的数据：$store.dispatch('action中的方法名',数据)或$store.commit('mutation中的方法名',数据) 备注\r若没有网络请求或其他业务逻辑，组件中也可以越过actions，即，不写dispatch，直接编写commit\rvuex开发者工具的使用 getters的使用 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。 在store.js中追加getters配置 ..... const getters = { bigSum(state){ return state.sum = 10 } } //创建并暴露store export default new Vuex.Stroe({ ...... getters }) 组件中读取数据：$store.getters.bigSum 四个map方法的使用 **mapState方法：**用于帮助我们映射state中的数据为计算属性 import {mapState} from 'vuex' computed:{ //借助mapState生成计算属性:sum、schoo1、subject(对象写法) ...mapState({sum:'sum',school:'school',subjeCT:'subject')), //借助mapstate生成计算属性:sum、schoO1、subject(数组写法) ...mapState([ 'sum','school','subjact']), }, **mapGetters方法：**用于帮助我们映射getters中的数据为计算属性 import {mapGetters} from 'vuex' computed:{ //借助mapGetters生成计算属性:bigsum(对象写法) ...mapGetters({bigSum:'bigSum'}), //借助mapGetters生成计算属性:bigSum(数组写法) ...mapGetters(['bigSum']) }, **mapActions方法：**用于帮助我们生成与actions对话的方法，即:包含 $store.dispatch(xxx)的函数 import {mapActions} from 'vuex' methods: { //靠mapActions生成:incrementOdd、incrementwait(对象形式) ...mapActions({incrementOdd:'jia0dd',incrementWait:'jiaWait'}) //靠mapActions生成:incrementOdd、incrementWait(数组形式) ...mapActions(['jiaodd','jiawait']) }, **mapMutations方法：**用于帮助我们生成与mutations对话的方法，即:包含$store.commit(xxx)的函数 import {mapMutations} from 'vuex' methods:{ //靠mapMutations生成:increment、decrement(对象形式) ...mapMutations({increment:'JIA',decrement:'JIAN'}), //靠mapMutations生成:JIA、JIAN(数组形式) ...mapMutations(['JIA','JIAN']), }, 备注\rmapActions与mapMutaions使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。\r一个前端随机生成唯一id的方法 import {nanoid} from 'nanoid' Const id = nanoid(); ajax调用接口 import axios from 'axios' axios.get('接口').then( response =\u003e{}, error =\u003e { alert(error.message) } ) 模块化\u0026命名空间 store包下，index.js //求和相关的配置,开启命名空间 const countOptions={actions:{},mutations:{},state:{},getters:{},namespaced:true} //人员管理相关的配置,开启命名空间 const personOptions={actions:{},mutations:{},state:{},getters:{},namespaced:true} //创建并暴露store export default new Vuex.Store({ modules:{ a:countOptions, b:personOptions } }) 模块化则分别将index.js中的两个部分，分成count.js person.js两个js，并精简index.js中的代码 .... import countOptions from './count' import personOptions from './person' ... export default new Vuex.Store({ modules:{ countAbout:countOptions, personAbout:personOptions } }) xxx.vue组件中 computed:{ //借助mapState生成计算属性，从state中取数据。(数组写法) ...mapState('countAbout',['sum','school','subject']), ...mapState('personAbout',['personList']), //借助mapGetters生成计算属性，从getters中读取数据。(数组写法) ...mapGetters('countAbout","date":"2024-08-21","objectID":"/vue2/:37:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"38.路由 ","date":"2024-08-21","objectID":"/vue2/:38:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"路由的简介 路由就是一组key-value的对应关系 =\u003eroute 多个路由，需要经过路由器的管理 =\u003erouter 编码中的路由，为了实现SPA应用(single page web application)，也称单页面应用 单页面应用，指：只有一个.html文件的应用。如下图： 多页面应用，指：有很多个.html文件的来回跳转切换的应用。 路由使用原理： 点击左边侧边栏某菜单 改变 地址栏 端口号后面的路径 路由器router寻找配置的路由route规则 根据对应的 路径=\u003e组件 的配置规则 更新显示页面，致绿色的内容模块中 如下图： 小tips\r生活中：路由器的作用，是：为了实现多台电脑上网 代码中：路由器的作用，是：为了实现单页面应用的页面跳转 vue-router： vue的一个插件库，专门用来实现SAP应用。 SPA 应用： 单页Web应用(single page web application，SPA) 整个应用只有一个完整的页面。 点击页面中的导航链接不会刷新页面，只会做页面的局部更新。 数据需要通过 ajax 请求获取 路由的理解： 什么是路由? 一个路由就是一组映射关系(key-value) key为路径,value 可能是 function 或componente 路由分类： 后端路由： 理解：value 是 function,用于处理客户端提交的请求。 工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据。 前端路由: 理解：value 是 component，用于展示页面内容。 工作过程：当浏览器的路径改变时，对应的组件就会显示。 方便记忆\r路由：根据你的路径，由我决定展示对应的组件\r​ ","date":"2024-08-21","objectID":"/vue2/:38:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"路由基本使用 在vue项目中使用路由，引入vue-router插件 npm i vue-router 注意\r2022年2月7日以后，vue-router的默认版本，为4版本 vue-router4，只能用在vue3中 vue-router3，才能用在vue2中 我们现在使用的是vue2，所以需要指定引入版本 npm i vue-router@3 安装完成后，在main.js中引入，并应用 //引入插件 import VueRouter from 'vue-router' //应用插件 Vue.use(VueRouter) 此时，在vm中，可以使用一个全新的配置项router new Vue(){ ... router:'' //router中的内容格式被严格控制，不允许随意写入字符串 ... } main.js同级位置，新建文件夹router文件夹。在该文件夹下，新增文件index.js。 index.js中拷入下方代码，用于创建整个应用的路由器。 //该文件专门用于创建整个应用的路由器 import VueRouter from 'vue-router' //引入组件 import About from'../components/About import Home from'../components/Home //创建并暴露一个路由器 export default new VueRouter({ routes:[ //一组组key-value对儿 { path:'/about', component:About }, { path:'/home' component:Home }, ] }) 此时在main.js中赋值router配置项为刚创建的服务器 //引入路由器 import router from./router //创建vm new Vue({ .... router:router //赋值配置项 }) 保存所有文件，此时路由器已经配置完成，并开始工作。 地址导航栏能够看见/#/的符号。 路由器以及路由规则配置完成。 现在需要处理两个组件，能够触发路由跳转： \u003c!--原始htm1中我们使用a标签实现页面的跳转--\u003e \u003ca href=\"./about.htm\"\u003eAbout\u003c/a\u003e \u003ca href=\"./home.html\"\u003eHome\u003c/a\u003e 在路由中，我们使用vue-router库中，提供给我们开发者的一个标签\u003crouter-link\u003e，触发跳转 \u003c!--to指想把路径后面改成什么样子--\u003e \u003c!--active-class指想点击了哪一个菜单，哪个就高亮显示。直接修改地址栏，也可以对应触发高亮--\u003e \u003crouter-link to=\"/about\" active-class=\"active\"\u003eAbout\u003c/router-link\u003e \u003crouter-link to=\"/home\" active-class=\"active\"\u003eHome\u003c/router-link\u003e \u003crouter-view\u003e设置页面内容展示的位置 \u003cdiv class=\"panel\"\u003e \u003cdiv class=\"panel-body\"\u003e \u003c!--指定组件的呈现位置--\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/div\u003e \u003c/div\u003e 几个注意点\r一般组件 \u0026 路由组件 正常写的，如\u003cBanner/\u003e为一般组件，在项目中我们通常放在components包下，进行管理 通过\u003crouter-link to=\"/ \"\u003e写的为路由组件，在项目中我们通常放在pages包下，进行管理 路由组件的显示与隐藏 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。 ​ 在菜单间切换的时候，路由组件是被频繁的挂载和销毁的。 ​ 一个路由组件内容，在点击另一个菜单的时候，切换为另一个路由组件内容，该路由组件则被销毁 ​ 每个路由组件中的this，多了两个属性$route，$router ​ 每个组件都有自己的 $route属性，里面存储着自己的路由信息。整个应用只有一个router，可以通过组件的 $router 属性获取到。 ​ 这里注意： ​ 哪个组件的this，打印出来的$route就是哪个组件的path，如下图 ​ 但是每个组件的this中，打印出来的$router是同一个 ​ ","date":"2024-08-21","objectID":"/vue2/:38:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"嵌套路由 嵌套路由的实现效果： ​ 点击左侧的菜单，其右下的内容中有新的菜单，点击新的菜单，更改下方的内容。 如下图： ​ 嵌套路由，有时候我们也叫它多级路由，路径上体现为多级路径：xxx/xxx 嵌套路由的配置，使用children配置项： { path:'/home', component:Home, children:[ { path:'new', //子路由路径前方不写斜杠'/',底层路由处理中会对子路径自动加上'/' component:New, } ] } 组件中的配置，to路径注意写成完整路径 \u003crouter-link to=\"/home/news\" active-class=\"active\"\u003eNew\u003c/router-link\u003e ​ ","date":"2024-08-21","objectID":"/vue2/:38:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"路由传参 路由的query参数 路由嵌套极限一般都在4-5层为极限，一般都在2-3层 只写一个组件Detail路由组件，通过传参来实现多个路由被点击使用时，对应显示的组件内容不同 路由组件有两个参数，其中query参数，和ajax中的query参数传参类似： //路径后面用问号?的形式，多个参数之间用\u0026间隔，例如： \u003crouter-link to=\"/home/message/detail?id=666\u0026title=hello\"\u003e跳转 \u003c/router-link\u003e 在唯一的Detail组件中，有一个属性this.$route能够得到这个组件相关的所有路由配置信息。在配置信息中，有一个属性query包含所有传递过来的参数及参数值。 在组件中获取参数，并页面显示渲染： \u003cul\u003e \u003cli\u003e消息编号：{{$route.query.id}}\u003c/li\u003e \u003cli\u003e消息内容：{{$route.query.title}}\u003c/li\u003e \u003c/ul\u003e 注意： \u003c!--要使参数值为变量，需要使用模版字符串标识符``，并且使用${}包裹变量--\u003e \u003crouter-link to=\"/home/message/detail?id=666\u0026title=hello\"\u003e \u003c/router-link\u003e \u003c!--例如，下面的写法：(字符串写法)--\u003e \u003crouter-link :to=\"`/home/message/detail?id=${m.id}\u0026title=${m.title}`\"\u003e \u003c/router-link\u003e \u003c!--或者，下面的写法：(对象写法)--\u003e \u003crouter-link :to=\"{ path:'/home/message/detail', query:{ id:m.id, title:m.title } }\"\u003e \u003c/router-link\u003e 路由的params参数 路由组件的第二个参数，params参数，和ajax中的params参数传参也类似： //path配置项，路径后面，使用传参占位符 name:'about', path:'/about/:id/:title', component:About, children:[{...}] \u003c!--跳转时传参紧跟路径--\u003e \u003crouter-link to=\"/home/message/about/666/hello\"\u003e\u003c/router-link\u003e 此时参数及参数值，出现在this.$route的params中 在组件中获取参数，并页面显示渲染： \u003cul\u003e \u003cli\u003e消息编号：{{$route.params.id}}\u003c/li\u003e \u003cli\u003e消息内容：{{$route.params.title}}\u003c/li\u003e \u003c/ul\u003e 同样的，将写死的传递参数位置改为变量取值的方式： \u003c!--传参写死--\u003e \u003crouter-link to=\"/home/message/about/666/hello\"\u003e\u003c/router-link\u003e \u003c!--传参改为变量：(字符串写法)--\u003e \u003crouter-link :to=\"`/home/message/about/${m.id}/${m.title}`\"\u003e\u003c/router-link\u003e \u003c!--或者，下面的写法：(对象写法)--\u003e \u003crouter-link :to=\"{ name:'about', params:{ id:m.id, title:m.title } }\"\u003e \u003c/router-link\u003e \u003c!--注：params的对象传参写法，只能使用name来确定路由跳转位置，不能使用path--\u003e 路由的props配置 路由中的一个全新的配置项props，用于路由更加方便的接受参数 props的第一种写法：值为对象 该对象中的所有key-value都会以props的形式传给Detail组件 name:'...', path:'...', component:..., children:[{...}], //props的第一种写法：值为对象-------------------------------------------------- //该对象中的所有key-value都会以props的形式传给Detail组件 props:{ a:666, b:'hello' } 在组件中接受并使用： \u003cul\u003e \u003cli\u003e消息编号：{{a}}\u003c/li\u003e \u003cli\u003e消息内容：{{b}}\u003c/li\u003e \u003c/ul\u003e \u003cscript\u003e { ..., porps:['a','b'] } \u003c/script\u003e 这种写法比较少用，一般情况下，我们不直接在路由配置中写死数据进行传参。 所以我们了解第二种props的写法 props的第二种写法：值为布尔值 若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传递给Detail组件 name:'...', path:'/about/:id/:title', component:..., children:[{...}], //props的第二种写法：值为布尔值-------------------------------------------------- props:true 在组件中接受并使用： \u003cul\u003e \u003cli\u003e消息编号：{{id}}\u003c/li\u003e \u003cli\u003e消息内容：{{title}}\u003c/li\u003e \u003c/ul\u003e \u003cscript\u003e { ..., porps:['id','title'] } \u003c/script\u003e props的第三种写法：值为函数 依赖return，返回的一定是一个对象，对象内的数据都会以props的形式传递给Detail组件 name:'...', path:'/about', component:..., children:[{...}], //props的第三种写法：值为函数-------------------------------------------------- props:function(){} //简写为 props(){ return {id:'666',title:'hello'} } //路由的回调函数带有$route参数 props($route){ return {id:$route.query.id,title:$route.query.title} } //通过解构赋值，可以简写为 props(query){ return {id:query.id,title:query.title} } //或者 props(query:{id,title}){ return {id:id,title:title} } //不过一般情况下，解构赋值的语句语义可读性和理解性不是很清楚，所以一般还是写回调函数$route的写法 ","date":"2024-08-21","objectID":"/vue2/:38:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"命名路由 给路由器取名字 1、作用：可以简化路由的跳转写法 2、示例： //命名使用name配置项 name:'about', path:'/about', component:About, children:[{...}] \u003c!--简化跳转--\u003e \u003c!--简化前：完整路径的2种写法--\u003e \u003crouter-link to=\"/home/message/about\"\u003e\u003c/router-link\u003e \u003crouter-link :to=\"{path:'/home/message/about'}\"\u003e\u003c/router-link\u003e \u003c!--简化后：直接使用命名--\u003e \u003crouter-link :to=\"{name:'about'}\"\u003e\u003c/router-link\u003e \u003c!--这里注意，to属性，不注明使用name，默认是使用的path--\u003e \u003c!--简化传递参数--\u003e \u003crouter-link :to=\"{ name:'about', query:{ id:m.id, title:m.title } }\"\u003e \u003c/router-link\u003e ","date":"2024-08-21","objectID":"/vue2/:38:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"\u003crouter-link\u003e的replace属性 作用：控制路由跳转时操作浏览器历史记录的模式 浏览器的历史记录有两种写入方式：分别为push和 replace，push是追加历史记录，replace 是替换当前记录。路由跳转时候默认为 push 如何开启replace模式：\u003crouter-link replace.......\u003eNews\u003c/router-link\u003e 路由对浏览器历史记录的影响： 浏览器中有两个按钮，← →，一个是前进一个是后退，这两个按钮都是依赖浏览器的历史记录在工作 浏览器的历史记录的操作模式是栈push模式：根据点击，不停的往栈中追加信息。 我们通常将这种追加信息的方式，称为push方式（与数组身上的push类似，不破坏任意一个元素，只往后面追加一个元素。在官方他有一个好听名字，叫压栈） 浏览器的前进与后退，就是操作历史记录列表中的指针进行移动 对历史记录的操作，除了push，还有另外一种方式，replace replace最大的特点就是替换掉当前栈点那一个元素 默认router-link所开起的模式是push模式，如果要开启replace模式，写法如下： \u003c!--追加replace属性--\u003e \u003c!--完整写法--\u003e \u003crouter-link :replace=\"true\" \u003e\u003c/router-link\u003e \u003c!--可简写为--\u003e \u003crouter-link replace \u003e\u003c/router-link\u003e ","date":"2024-08-21","objectID":"/vue2/:38:6","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"编程式路由导航 作用：不借助\u003croute-link\u003e实现路由跳转，让路由跳转更加灵活 如果不使用\u003croute-link\u003e标签进行路由跳转的实现，路由器中的缔造者提供了$router.push \u003cbutton click=\"pushShow(i)\"\u003e按钮1\u003c/button\u003e \u003cscript\u003e ..... methods:{ pushShow(i){ this.$router.push({ //push对象中的写法，同route-link中的to中内容一摸一样 name:'about', //跳转以改命名路由为目标路由的界面 query:{ //正常传参 id:i.id, title:i.title } }) } } \u003c/script\u003e 同理，对应$router.push也有$router.replace，以实现操作历史记录的方式为替换型。写法： \u003cbutton click=\"replaceShow(i)\"\u003e按钮2\u003c/button\u003e \u003cscript\u003e ..... methods:{ replaceShow(i){ this.$router.replace({ //replace和push写法一样 name:'about', //跳转以改命名路由为目标路由的界面 query:{ //正常传参 id:i.id, title:i.title } }) } } \u003c/script\u003e 路由器中也提供了操作历史记录的方法，：后退$router.back()、前进$router.forward()、$router.go(入参) //后退一步 this.$router.back() //前进一步 this.$router.forward() //前进或者后退多少步 //入参必须是数字 this.$router.go(3) //入参是正数，则前进。这里表示前进3步 this.$router.go(-2) //入参是负数，则后退。这里表示后退2步 ","date":"2024-08-21","objectID":"/vue2/:38:7","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"缓存路由组件 作用：让不展示的路由组件保持挂载，不被销毁。 我们每切换一个路由，切换前的路由组件就会被销毁。 当用户在一个路由页面输入信息后，切换致另一个路由浏览信息再切回输入的路由页面进行继续输入时，我们发现，原路由已经被销毁，该路由页面重新渲染，导致了用户输入内容丢失。 在该需求下，我们需要一个缓存原路由组件的办法。由此，我们引入缓存路由组件标签\u003ckeep-alive\u003e \u003c!--该标签包裹住的路由，均不被销毁，均保持缓存--\u003e \u003ckeep-alive\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/keep-alive\u003e \u003c!--include属性,设定只缓存哪一个路由--\u003e \u003c!--特别注意：About为组件名称，要缓存哪个组件，就写哪个组件的组件名称--\u003e \u003ckeep-alive include=\"About\"\u003e \u003c!--如果是缓存多个，则用数组形式--\u003e \u003ckeep-alive :include=\"['About','News']\"\u003e ","date":"2024-08-21","objectID":"/vue2/:38:8","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"两个新的生命周期钩子 作用：用于捕获路由组件的激活状态 定时器开启后，必须在组件即将销毁的生命周期函数beforeDestroy中关闭 当路由组件被缓存时，销毁生命周期函数不会被触发。 上面两个限制，导致了定时器无法被关闭，并会在浏览者中持续一直调用。针对该需求，引出，路由组件独有的两个生命周期钩子：激活activated()、失活deactivated() 当页面切换在当前组件，则当前组件被激活。activated在被激活时候触发 当页面切换至其他组件，则当前组件失活。deactivated再失活时触发 activated(){ console.log('该组件被激活了') //这里可以开启定时器 } deactivated(){ console.log('该组件失活了') //这里关闭定时器 } This is a tip\r**3个不在生命周期图示里面的生命周期构子：**这里的2个路由生命周期构子 + nextTick this.nextTick(function(){ ... })该钩子，当你操作完数据之后，Vue把真实Dom放入页面了以后，Vue再帮你调用该函数里面的内容。 ​ ","date":"2024-08-21","objectID":"/vue2/:38:9","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"路由守卫 作用：对路由进行权限控制。【主要作用：权限校验】 当某个人登陆时，我们将此人对于各个路由所对应的路由组件是否可见，称为对其鉴权。 分类：全局守卫、独享守卫、组件内守卫 代码位置：在router文件夹下的index.js中，在暴露一个创建的路由器对象之前，添加路由守卫。 全局前置 路由守卫 router.beforeEach 全局前置 路由守卫：页面切换前调用 //创建一个路由器 const router = new VueRouter({...}) //--------------全局前置路由守卫-------------- //在每一次路由切换之前，都会调用该函数，进行权限校验; //在初始化到时候，也被调用。 router.beforeEach((to,from,next)=\u003e{ ... //to：【要去哪里】目标路径路由对象 //from：【从哪里去】当前所在路径路由对象 //next()：【放行】没有这条就都不会继续往下走了，需要手动抛出'无权限'异常 next() }) //暴露路由 export default router 判断去哪里是否有权限时我们通常会使用目标路径path属性来进行判定，例如： if(to.path === '/about'){ next() } 当设置需要权限的路由较多时，这样判定就变得不可取了。 此时，我们想要在每个路由申明时，设置某个配置项，以简洁路由权限的判定。 在路由对象中Vue提供了meta这个对象，用于设置一些自定义的配置项。 meta在官方有个好听的名字，叫路由元。我们通常在其中设置一个配置项isAuth(是否被授权)，用来进行路由守卫的判定。 //哪个路由需要鉴权，meta:{isAuth:true}就写在哪里 routes:[ {name:'about',path:'/about',meta:{isAuth:false}}, {name:'home',path:'/home',meta:{isAuth:true}} ] //路由守卫判定:需要鉴权就往下走。没有设置的默认为undefined，该处判定为假，就不进行鉴权 if(to.meta.isAuth){ if('满足鉴权放行的条件：例如登录账号满足超级管理员'){ next()//放行 }else{ console.log('该账号无权限') } }else{ next()//不参与鉴权的路由均放行 } ​ 全局后置 路由守卫 router.afterRach全局后置 路由守卫：页面切换后调用。 //创建一个路由器 const router = new VueRouter({...}) //--------------全局后置路由守卫-------------- //在每一次路由切换之后，都会调用该函数，进行资源操作; router.afterRach((to,from)=\u003e{ //注意该API就没有next入参了，因为是切换后调用，是不用进行放行操作的 //此处通常用来修改：需要页面有权限显示之后，一些页面信息，如： document.title = '对应跳转页面的标题' //修改网页标签名称为跳转页面名称 }) //暴露路由 export default router 独享 路由守卫 独享路由守卫：顾名思义指，某一个路由单独使用的路由守卫。 //某route路由申明中 { name:'', ...., //进入该路由之前，调用该函数中内容 beforeEnter:(to,from,next) =\u003e { .... //写法和前置路由一样 } } 注意：和全局路由守卫不同的是，独享路由守卫只有前置，没有后置。如果想要使用后置，可以独享守卫和全局后置守卫搭配使用。 ​ 组件内 路由守卫 组件内路由守卫：指在具体的某一个组件中去写路由守卫，而不是在这个路由器配置 文件中编写。 //进入守卫：通过路由规则，进入该组件时被调用 beforeRouteEnter(to,from,next){ next() //都得放行才能往下走 }, //离开守卫：通过路由规则，离开该组件时被调用 beforeRouteLeave(to,from,next){ next() //都得放行才能往下走 } 注意\r通过路由规则：通过导航栏点击，改变地址栏路由，引起路由组件展示，则是经过了路由规则。 如果是直接放在其他组件中引用该路由组件，引起路由组件展示，这种方式是不会触发组件内路由守卫的。 ​ ","date":"2024-08-21","objectID":"/vue2/:38:10","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"路由器的两种工作模式 hash模式 在地址栏，我们分析地址：localhost:8080/#/home/message。我们发现，从路由访问开始，地址就一直存在的一个符号：/#/，我们把它称作hash。 这里提到的所有的hash与数据加密无关，只是站在前端的角度，对路径进行分析。 路径中，所有的从#开始，到结束的内容，都称作：路径中的hash值。 hash值的作用：hash最大的特点就是不会随着http的请求发给服务器。 所以路径中属于hash值的内容，不会作为路径发给服务器，进行请求。例如： --请求117服务器5000端口的student资源信息 10.10.10.117:5000/student --添加hash值 10.10.10.117:5000/student/#/xjdsdldfj/sdjfs/2342432/wasdf 以上这两个地址在浏览器地址栏中的请求，返回是一模一样的。因为#/xjdsdldfj/sdjfs/2342432/wasdf不会作为地址发送给服务器。 history模式 在router文件夹下的配置文件index.js中，设置路由器中的mode的配置项。如果不设置，默认使用hash模式。写法： const router = new VueRouter({ mode:'history', //该配置项只有两种值：history、hash。不写该配置项，则默认使用hash模式 routes:[...], }) export default router 这里注意\rVue脚手架的特性是修改代码以后，在当前路径下进行刷新。 所以如果地址栏路径为localhost:8080/#/home/message/detail时，此时修改了mode属性为history，页面刷新依旧默认使用当前路径，导致没有任何效果。 此时，需要将地址栏路径手动改成基本根路径localhost:8080，再进行路由访问。 访问符合路由规则，实现路由组件正常跳转。地址栏路径中#标识符消失，地址格式为localhost:8080/home/message/detail **符合路由规则：**点击路由，经过路由器，根据路由规则rules，匹配路由组件进行展示。 所以符合路由规则是没有进行服务器请求的，此时如果在地址栏点击刷新localhost:8080/home/message/detail该地址会全部作为路径请求服务器，导致404 解决history模式刷新404问题 404问题出现在服务器无法请求访问不存在的地址路径接口。 所以该问题，由后端出面解决。 nodejs服务器有个专门解决这个问题的中间件插件，java也有专门的库（这里只演示nodejs的处理） 在https://www.npmjs.com/官方网站搜索插件connect-history-api-fallback 在服务器控制台，输入下面代码，安装这个中间件： C:Users\\wangty\\Desktop\\demo\u003enpm i connect-history-api-fallback 安装完成后，在server.js中引入中间件： //在“const express = ...”的代码后面 添加这一句 var history = require('connect-history-api-fallback'); 并在server.js中使用中间件： //在“const app = .......”的代码后面 添加这一句 app.use(history()) //在“app.use(express.......”的代码钱面 添加这一句 history模式 VS hash模式 hash模式 history模式 浏览器(路由跳转)兼容性更好 浏览器(路由跳转)兼容性略差 地址不够美观，带# 地址美观，不带# 上线部署不影响后端请求 上线部署需要后端配置配合 地址校验严格时，会被标记不合法 地址校验合法 项目上线的基本流程 所有的.vue文件，通过npm run build命令打包之后形成.html文件放置在服务器中供用户使用。 打包之后形成一个新的dist文件夹，该文件夹只有一个单文件页面index.html。直接访问无效果。 打包的所有文件，需要放置在服务器上，进行部署。 这里使用nodejs的express搭建一个微型的服务器，并将前端打包文件部署上去 只记录简单操作步骤，不解释原理： 桌面新建一个demo文件夹，用vscode打开 vscode中打开控制台，运行npm init package name设置为：wangty_test_server（随便起个服务器名字） 一路回车 控制台路径回到demo时，运行npm i express demo文件夹下新建一个server.js，里面代码如下： const express =require('express') //引入express const app = express() //创建一个app服务实例对象 app·get('/person',(req,res)=\u003e{ //配置一个后端路由，person，返回一个人员信息 res.send({ //req - 请求 ， res - 返回 name:\"tom', age:18 }) }) app.listen(5005,(err)=\u003e{ //app开启一个端口监听，开在5005端口 if(!err)console.log('服务器启动成功了!') //没有错误对象信息，就提示启动成功 }) 控制台运行node server，控制台打印服务器启动成功了表示该微型服务器已经启动成功。 打开浏览器地址栏访问localhost:5005/person，可以成功返回人员信息。 demo文件夹下新建一个static文件夹（有时候也叫public文件夹），在其中放入.html文件 这里为了测试是否成功展示，我们手动新建一个demo.html放入static文件夹下： ```html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003etest\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e\u003ch1\u003e你好！\u003c/h1\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ``` 回到server.js，添加代码： //在“const app = ...”的代码后面 添加这一句 app.use(express.static(__dirname+'/static')) //使用插件,读取当前static文件下的页面 ctrl+c停掉服务器，重新启动服务器 打开浏览器地址栏访问localhost:5005/demo.html，可以成功展示demo.html的你好页面。 我们知道默认浏览器访问index.html页面，所以我们可以将其改得更简化一点。将demo.html文件名称修改为index.html，并且地址栏访问localhost:5005，即可成功展示你好页面。 此时，即可对前端打包文件进行部署。 拷贝所有的dist文件夹中内容，放入static文件夹中，重复的文件点击替换覆盖即可。 ctrl+c停掉服务器，重新启动服务器 地址栏访问localhost:5005，打包的项目即可以正常运行。 部署上线完成。 ","date":"2024-08-21","objectID":"/vue2/:38:11","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"39.Vue UI组件库 移动端常用UI组件库：Vant 、Cube Ul、Mint Ul PC端常用UI组件库：Element Ul、IView Ul、 京东也有一个组件库：NUTUI element-ui举例： element-ui是一个饿了么团队打造的，pc端基于Vue基本使用的一个组件样式库。 引入 Element：完整引入、按需引入 https://element.eleme.cn/#/zh-CN/component/quickstart 【完整引入会导致前端js文件过大，如果引入使用的部分较少，推荐使用按需引入的方式】 ​ 第五章：vue3 使用vue-cli创建工程 使用vite创建工程 分析工程结构 安装开发者工具 初识setup re数 处理基本类型 re函数 处理对象类型 reactive函数 回顾Vue2的响应式原理 Vue3响应式原理proxy Vue3响应式原理reflect reactive对比ref setup的两个注意点 computed计算属性 watch监视re定义的数据 watch监视reactive定义的数据 watch时value的问题 watchEffect函数 Vue3生命周期 自定义hook toRef与toRefs shallowReactive与shallowRef readonly与shallowReadonly toRaw与markRaw customRef provide与inject 响应式数据的判断 CompositionAPl的优势 Fragment组件 Teleport组件 Suspense组件 Vue3中其他的改变 ","date":"2024-08-21","objectID":"/vue2/:39:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["Hugo系列"],"content":"官网下载Typora 安装 网址：Typora 官方中文站 (typoraio.cn) 点立即下载，下载下来的安装包，双击Typora.exe 完成安装 ","date":"2024-08-11","objectID":"/text08/:1:0","tags":["Typora"],"title":"【Typora】破解/安装激活 Typora 2024 教程","uri":"/text08/"},{"categories":["Hugo系列"],"content":"本地激活Typora 激活方法 安装路径下找到：Typora\\resources\\page-dist\\static\\js 右键用记事本打开这个文件，ctrl+F定位到 e.hasActivated=\"true\"==e.hasActivated 替换为 e.hasActivated=\"true\"==\"true\" 这样就已经后台激活完成，但是每次开软件开始会提醒激活。 关闭软件每次启动时的已激活弹窗 继续在安装路径下resources\\page-dist\\license.html，找到 依旧ctrl+F 定位到： \u003c/body\u003e\u003c/html\u003e 替换为 \u003c/body\u003e\u003cscript\u003ewindow.onload=function(){setTimeout(()=\u003e{window.close();},5);}\u003c/script\u003e\u003c/html\u003e 特别注意！！！\r复制粘贴上面这段代码的时候： 有些系统会将window.onload 中onload的英文字母o和n变成其他希腊字母或其他Unicode字符（例如，ο是希腊字母omicron，而ο和o在视觉上非常相似） 这会导致这段代码没有起作用！！！！ 如果这段代码替换后没反应，请务必手敲onload保存后再试。。。。 去除软件左下角“未激活”提示 按照安装路径，找到 resources\\locales\\zh-Hans.lproj\\Panel.json 文件中查找： \"UNREGISTERED\":\"未激活\"， 替换为： \"UNREGISTERED\":\" \" 最后，重新打开Typora，手动关掉激活窗口，之后就不会再出现。 ","date":"2024-08-11","objectID":"/text08/:2:0","tags":["Typora"],"title":"【Typora】破解/安装激活 Typora 2024 教程","uri":"/text08/"},{"categories":["Hugo系列"],"content":"引用图片 注意：Typora 使用带图片的文件，使用相对路径，创建带图片的笔记时，.md文件命名需为index。自动访问路径中的index文件，剪切图片时自动生成image文件夹，使得图片相对路径访问正常 【注意：我的安装路径位置在 C:\\Program Files\\Typora】 ","date":"2024-08-11","objectID":"/text08/:3:0","tags":["Typora"],"title":"【Typora】破解/安装激活 Typora 2024 教程","uri":"/text08/"},{"categories":["Hugo系列"],"content":"Hugo 是 Go 编写的静态网站生成器，速度快，易用，可配置。 Hugo 依赖于 Markdown 文件，元数据字体 。用户可以从任意的目录中运行 Hugo，支持共享主机和其他系统。只需要几分之一秒就可以渲染一个经典的中型网站，非常适合博客，文档等等网站的生成。 ","date":"2024-08-09","objectID":"/text07/:0:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"HUGO下载安装 ","date":"2024-08-09","objectID":"/text07/:1:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"安装环境 安装好Windows版本的 git： git官网：https://git-scm.com/downloads git安装教程请参考：【 Windows系统Git安装教程（详解Git安装过程） - 学为所用 - 博客园 (cnblogs.com)】 下载并安装Windows版本的 GO： go的中文官网：https://go.p2hp.com/ 下载并安装Windows版本的 hugo： hugo·GitHub 地址 https://github.com/gohugoio/hugo/releases 本教程中下载的项目压缩包名为：hugo_extended_0.128.2_windows-amd64 压缩包下载路径：https://github.com/gohugoio/hugo/releases/download/v0.128.2/hugo_extended_0.128.2_windows-amd64.zip ","date":"2024-08-09","objectID":"/text07/:1:1","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"配置环境变量 创建程序目录 在C盘新建一个名为hugo的文件夹，进入文件夹后再创建一个名为bin的文件夹 将下载好的Windows版本hugo应用程序压缩包解压到这个bin文件夹 配置环境变量 然后在Windows搜索栏中搜索环境变量，点击环境变量 选择系统变量中的Path，点击新建 将 C:\\hugo\\bin 这个路径添加到环境变量 查看程序版本 然后打开powershell终端，输入下方命令查看 hugo version 显示版本号，即为成功安装了hugo程序。 ","date":"2024-08-09","objectID":"/text07/:1:2","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"创建博客网站 现在我们就可以使用hugo搭建一个属于自己的博客网站了。 创建站点 首先，我们进入到C盘下的hugo文件夹，点击鼠标右键选择在终端中打开 执行下方命令创建一个静态站点：（本例创建的站点名为myblog，大家可以自定义） hugo new site myblog 创建后，我们回到hugo目录，可以看到新增了一个名为myblog的文件夹： 进入该文件夹后，就能看到刚刚创建的博客网站程序： 在站点中创建一篇文章 创建好了站点后，现在网站中还什么内容都没有，我们可以创建一篇文章来进行一下测试： 现在我们在终端中执行下方命令，进入站点目录： 进入网站目录后，执行下方命令创建一篇markdown格式的文章： hugo new posts/Articles01.md 执行后可以看到提示已经创建了一篇名为Articles01的文章与其所属路径。 进入这个路径，就能看到文章了。 打开这篇文章后能看到这篇文章的标题，日期等相关信息 在这里我们需要把draft（草稿） = true 修改为 draft = false 来表示这并不是一篇草稿。 然后随便在文档中写一些内容，比如： 然后保存关闭即可。 为网站添加主题 现在我们已经创建好了一个博客网站，并在网站中发布了一篇文章，不过现在我们还不能在浏览器中运行这个本地网站进行查看，因为在这之前，我们需要先给网站添加一个主题。 我们可以登录下方的hugo官网页面来挑选一个你喜欢的网站主题： https://themes.gohugo.io/themes 这里我们随便选择一个主题，点击进入页面后，可以看到安装方式： 可以看到，想要安装这个网站主题，需要先在终端中进入站点目录： cd myblog 也可以想上边一样，在myblog目录中右键在终端中打开。 然后执行下方命令： git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c 然后在打开名为 hugo 的 toml源文件，添加主题配置即可。 网站标题修改为myblog，然后再把theme = “m10c”这行代码加进去保存即可。 现在，我们在myblog目录下的主题文件夹中就能看到刚才添加的主题文件目录了： 本地访问测试 现在，我们在终端中执行下方代码启动本地网站进行测试： hugo server 本地清除缓存运行 hugo server --disableFastRender --gc --noHTTPCache --noBuildLock --logLevel debug 可以看到成功启动，在浏览器中输入 localhost:1313/ 即可访问这个本地站点： 可以看到网站标题为myblog，里边有刚才我们发布的第一篇文章Article01： 点击文章标题Article01，即可进入文章页面。 这样我们就成功使用HUGO在Windows本地快速部署了一个静态博客网站。 ","date":"2024-08-09","objectID":"/text07/:2:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"部署到公网 This is a tip\r下面是三种部署网站到公网的办法\r","date":"2024-08-09","objectID":"/text07/:3:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"安装内网穿透工具 目前我们在本机成功部署了一个博客网站，但如果没有公网IP的话，只能在本地局域网环境使用，有一定局限性。如果出差在外想要远程使用的话，可以结合Cpolar内网穿透生成公网地址，免去了本地重新部署过程，只需要使用公网地址直接就可以访问本地部署的网站，进行演示。 点击进入cpolar官网注册一个账号，并下载最新版本的Cpolar https://www.cpolar.com/ 登录成功后，点击下载Cpolar到本地并安装（一路默认安装即可）本教程选择下载Windows版本。 Cpolar安装成功后，在浏览器上访问 localhost:9200，使用cpolar账号登录,登录后即可看到Cpolar web 配置界面,结下来在web 管理界面配置即可。 http://localhost:9200/#/login?redirect=%2Fdashboard 【hugo-账户：1437059026@qq.com 密码：Wty201408.】 配置公网地址 接下来配置一下本地 博客网站 的公网地址， 登录后，点击左侧仪表盘的隧道管理——创建隧道， 创建一个 博客网站 的公网地址隧道： 隧道名称：可自定义命名，注意不要与已有的隧道名称重复 协议：选择 本地地址：1313 域名类型：选择随机域名 地区：选择China VIP 点击创建 隧道创建成功后，点击左侧的状态——在线隧道列表,查看所生成的公网访问地址，有两种访问方式。 使用任意一个上面生成的公网地址,在电脑或任意设备在浏览器进行登录访问,即可成功看到 本地博客网站 界面,这样一个可以远程访问的公网地址就创建好了,使用了Cpolar的公网域名,无需自己购买云服务器,即可在公网访问本地部署的服务了！ ","date":"2024-08-09","objectID":"/text07/:3:1","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"搭建本地服务器 内网穿透地址会随着ip的更新而变化，为了保证不一直修改baseUrl，配置服务器来搭载网站。 配置本地服务器，将编译后的网站文件运行与服务器后，本地可以不启动hugo server 在控制面板打开命令提示符窗格，键入npm install -g anywhere 9999 npm install -g anywhere 9999 9999这里是设置端口号，端口号自行设置，也可以不输入xxx会默认8000端口号 安装成功anywhere后，可以直接使用anywhere指令启动服务，但是默认是查看全部文件列表 编译网站文件并运行于本地服务器 进入myblog根目录下，输入hugo命令进行编译 hugo 编译后，生成public文件夹，进入该文件夹根目录，并输入anywhere使编译文件运行在上面 cd public anywhere 【特别注意：运行在服务器上的一定是：\"编译后的文件！！！！\"】 ","date":"2024-08-09","objectID":"/text07/:3:2","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"BaseUrl配置 使用hugo server本地运行的程序，每次跳转都将走localhost或者127.0.0.1，此处理解和其他程序启动一样，访问及跳转都将走本地。 若要使baseURL配置每次跳转时，自动请求的域名地址为服务器地址，则需要设置.toml文件中的baseURL。 baseURL = 'http://136c5bcc.r16.vip.cpolar.cn/' //内网穿透地址 baseURL = 'http://192.168.9.125/' //本地服务器地址 内网穿透地址需先将本地服务器内网地址先生成，再配置。配置方法同小结6相同，配置好后如图 逻辑为： 1、配置本地baseURL为内网穿透地址，使每次访问均可访问内网穿透地址 2、编译文件后，跳转路径指向内网穿透地址 3、内网穿透地址配置localhost:8000指向本地服务器 4、启动本地服务器，使内网穿透访问正常 5、使跳转路径正常 当此处修改为内网穿透地址后，需先进行编译，再通过本地服务器启动后的地址后，记得编译之后再运行本地服务器 ","date":"2024-08-09","objectID":"/text07/:3:3","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"创建 GitHub Pages 站点 GitHub提供了Github pages用于挂在类似于hugo，hexo这样的博客静态网页， 官方教程：https://docs.github.com/zh/enterprise-server@3.12/pages/getting-started-with-github-pages/creating-a-github-pages-site GitHub登陆后，新建仓库Wangty654.github.io 注意仓库名需要和账户名一致 修改博客配置文件.toml中的默认跳转地址为仓库名 baseURL = 'https://Wangty654.github.io' //仓库服务器地址 仓库建好后，进入博客根目录，编译网站 cd myblog C:/hugo/myblog \u003e hugo 生成的编译后文件夹public为所有html、css、js组成的静态网站文件 上传GitHub cd public C:/hugo/myblog/public \u003e git init git add . git commit -m '1' git push 请求成功后直接访问https://Wangty654.github.io即可 ","date":"2024-08-09","objectID":"/text07/:3:4","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"腾讯云服务器部署 配置的后台的代理 静态资源服务器 如果是放我的静态网页 只需要将dist配置在root上，并对其刷新页面的位置进行配置就行 dist内存在index页面等同于，hugo的public页面 ftp传文件 、shell 输入命令 ","date":"2024-08-09","objectID":"/text07/:3:5","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"网站样式自定义设置 This is a tip\r一些基础样式调整，具体样式美化可以参考：Hugo的LoveIt主题美化（一、二、三、四）\r","date":"2024-08-09","objectID":"/text07/:4:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"关于themes主题 themes主题为git拉取下来用于整个静态网站的样式代码，均可按照需求进行修改 头像设置 1、在layouts包下，有一个baseof.html文件，将其中的首页文件指向调整为你想要的图片 2、并同时更改static文件夹中的图片，使指向和文件名一致。 主题颜色设置 1、拷取themes中配置文件config.toml里默认设置主题颜色的部分代码 默认主题有三种样式 选择其中一种样式，放入我们的配置文件hugo.toml，可以对其中的文字颜色也进行修改，本主题改为粉色 主页文字设置 更改layouts包下，baseof.html文件中书写首页介绍文字的位置 主页分类菜单设置 1、配置文件hugo.html中配置菜单栏 2、并在每条笔记中，使用yaml格式书写抬头 主页关于菜单设置 取主题中content包下的about文件放入myblog的content包根目录下。about内的内容可以自行定义 关于代码块样式设置 配置文件中写入设置样式的命令模块，根据需要更改其中style的值。 hugo中文文档中 ：https://hugo.opendocs.io/getting-started/ 选择“内容管理” - “语法高亮” 在style中选择想要更改的样式，放入配置文件中：https://xyproto.github.io/splash/docs/ ","date":"2024-08-09","objectID":"/text07/:4:1","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["腾讯云"],"content":"腾讯云服务相关配置 添加依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.tencentcloudapi\u003c/groupId\u003e \u003cartifactId\u003etencentcloud-sdk-java-trtc\u003c/artifactId\u003e \u003cversion\u003e3.1.637\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.tencentcloudapi\u003c/groupId\u003e \u003cartifactId\u003etencentcloud-sdk-java-live\u003c/artifactId\u003e \u003cversion\u003e3.1.637\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.tencentcloudapi\u003c/groupId\u003e \u003cartifactId\u003etencentcloud-sdk-java-vod\u003c/artifactId\u003e \u003cversion\u003e3.1.637\u003c/version\u003e \u003c/dependency\u003e 在后端项目resource包目录下，选择或者新建文件application-integration.yml 配置内容： # 腾讯云服务相关配置 tencent: #腾讯云账号 secretId: AKIDRo**********hDyV0 secretKey: wxuy2**********Yiv8 #即时视频 SDKAppId: 160****473 rtcSecretKey: f5391*****************75054 #直播 live: secretId: AKIDRo8XoE**********2GZ2KhDyV0 secretKey: wxuy2AeTI8***********IKKRYiv8 #播放 play: domainName: play.gajy.org.cn authenticationKey: pnWY4******a2sMpR #推流 push: domainName: 203204.push.tlivecloud.com authenticationKey: 627a88a**********9a0eab11 对应的直播服务账户和密码，播放的域名，到 腾讯云官网 付费获取。 这里是：账号申请 相关文档 ","date":"2024-08-09","objectID":"/text41/:0:1","tags":["腾讯云"],"title":"【腾讯云】腾讯云直播后端","uri":"/text41/"},{"categories":["腾讯云"],"content":"腾讯直播工具类 公共包common下，选择或新建util，新建文件TencentLiveBroadcastUtil.java package com.hrss.remotework.infrastructure.common.util; /* * @Description //TODO * @Date 2023/1/5 14:40 * @Author xx **/ import com.hrss.remotework.infrastructure.config.TencentConfig; import com.hrss.remotework.infrastructure.gatewayimpl.database.dataobject.TaskInfo; import com.tencentcloudapi.common.exception.TencentCloudSDKException; import com.tencentcloudapi.live.v20180801.LiveClient; import com.tencentcloudapi.live.v20180801.models.*; import com.tencentcloudapi.trtc.v20190722.models.WaterMark; import com.tencentcloudapi.vod.v20180717.VodClient; import com.tencentcloudapi.vod.v20180717.models.*; import com.yinhai.ta404.core.restservice.resultbean.Page; import com.yinhai.ta404.core.utils.DateUtils; import lombok.extern.slf4j.Slf4j; import org.apache.commons.codec.digest.DigestUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.cglib.beans.BeanMap; import org.springframework.stereotype.Component; import org.springframework.util.Assert; import javax.annotation.Resource; import java.io.UnsupportedEncodingException; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.concurrent.atomic.AtomicLong; import java.util.stream.Collectors; /** * 腾讯直播工具类 * * @author xx * @date 2023/01/05 */ @Component @ConditionalOnClass(TencentConfig.class) @Slf4j public class TencentLiveBroadcastUtil { @Resource private TencentLiveBroadcastProperties tencentLiveBroadcastProperties; private final static String MD5String = \"MD5\"; private VodClient vodClient; @Resource private LiveClient liveClient; @Autowired public void setVodClient(VodClient vodClient) { this.vodClient = vodClient; } private static final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}; public String getPushUrl(String streamName) { long txTime = DateUtils.getCurrentDate().getTime() / 1000 + tencentLiveBroadcastProperties.expireTime.getSeconds(); return new StringBuilder() .append(tencentLiveBroadcastProperties.getPush().domainName).append(\"/\") .append(tencentLiveBroadcastProperties.getAppName()).append(\"/\") .append(streamName).append(\"?\"). append(getTxSecretAndTxTime(tencentLiveBroadcastProperties.getPush().authenticationKey, streamName, txTime)).toString(); } public String getPlayUrl(String streamName) { long txTime = DateUtils.getCurrentDate().getTime() / 1000 + tencentLiveBroadcastProperties.expireTime.getSeconds(); return new StringBuilder() .append(tencentLiveBroadcastProperties.getPlay().domainName).append(\"/\") .append(tencentLiveBroadcastProperties.getAppName()).append(\"/\") .append(streamName).append(\"?\"). append(getTxSecretAndTxTime(tencentLiveBroadcastProperties.getPlay().authenticationKey, streamName, txTime)).toString(); } /* * KEY+ streamName + txTime */ private String getTxSecretAndTxTime(String key, String streamName, long txTime) { String input = new StringBuilder(). append(key). append(streamName). append(Long.toHexString(txTime).toUpperCase()).toString(); String txSecret = null; try { MessageDigest messageDigest = MessageDigest.getInstance(MD5String); txSecret = byteArrayToHexString( messageDigest.digest(input.getBytes(\"UTF-8\"))); } catch (NoSuchAlgorithmException e) { log.error(e.getLocalizedMessage()); } catch (UnsupportedEncodingException e) { log.error(e.getLocalizedMessage()); } return txSecret == null ? \"\" : new StringBuilder(). append(\"txSecret=\"). append(txSecret). append(\"\u0026\"). append(\"txTime=\"). append(Long.toHexString(txTime).toUpperCase()). toString(); } private String byteArrayToHexString(byte[] data) { char[] out = new char[data.length \u003c\u003c 1]; for (int i = 0, j = 0; i \u003c data.length; i++) { out[j++] = DIGITS_LOWER[(0xF0 \u0026 data[i]) \u003e\u003e\u003e 4]; out[j++] = DIGITS_LOWER[0x0F \u0026 data[i]]; } return new String(out)","date":"2024-08-09","objectID":"/text41/:0:2","tags":["腾讯云"],"title":"【腾讯云】腾讯云直播后端","uri":"/text41/"},{"categories":["腾讯云"],"content":"推流地址生成 调用工具类，并存储推流地址。 //推流地址 cz30Do.setAcz02b(tencentLiveBroadcastUtil.getPushUrl(acz300.toString())); //直播存储实体cz30Do //推流记录地址字段acz02b //直播主键id字段acz300 自动生成满足位数的uuid就可以 获取该推流地址，放入前端直播推流代码相应位置。前端推流写法参照：本网站【腾讯云】腾讯云直播前端 ","date":"2024-08-09","objectID":"/text41/:0:3","tags":["腾讯云"],"title":"【腾讯云】腾讯云直播后端","uri":"/text41/"},{"categories":["腾讯云"],"content":"拉流地址生成 调用工具类，并存储拉流地址。 //直播视频流地址(播放) cz30Do.setAcz01y(tencentLiveBroadcastUtil.getPlayUrl(acz300.toString())); //直播存储实体cz30Do //推流记录地址字段acz01y //直播主键id字段acz300 与推流同一个id，则可以拉取到此id推流的直播间的直播信息 获取该拉流地址，放入前端直播拉流代码相应位置。前端拉流写法参照：本网站【腾讯云】腾讯云直播前端 This is a tip\r注：推拉流生成方法一致，但根据推拉流域名不同，所以生成的地址也不同。如图所示： 则每一个直播间一个推流地址对应一个拉流地址，且不同直播间之间互不影响 ","date":"2024-08-09","objectID":"/text41/:0:4","tags":["腾讯云"],"title":"【腾讯云】腾讯云直播后端","uri":"/text41/"},{"categories":["腾讯云"],"content":"腾讯云直播推流器TXLivePusher ：文档地址 腾讯云Web端超级播放器体验：tcplayer Demo 这里是：直播和点播播放的 Web 播放器（ TCPlayer ）的相关参数以及 API 1.直播推流 直播推流需要第三方库 \u003cscript src=\"https://video.sdk.qcloudecdn.com/web/TXLivePusher-2.0.3.min.js\" charset=\"utf-8\"\u003e\u003c/script\u003e 直播推流代码 var livePusher = new TXLivePusher(); console.log(livePusher); livePusher.setRenderView('id_local_video'); // 设置视频质量 livePusher.setVideoQuality('720p'); // 设置音频质量 livePusher.setAudioQuality('standard'); // 自定义设置帧率 livePusher.setProperty('setVideoFPS', 25); // 采集完摄像头和麦克风之后自动推流 Promise.all([livePusher.startScreenCapture(), livePusher.startMicrophone()]) .then(function () { //传入的是一个推流地址，后端返回的，把后端返回的一个地址前边的rtmp换成webrtc就可以了 livePusher.startPush(推流地址) .then(() =\u003e { console.log('pushing'); if (livePusher.isPushing()) { console.log('pushing'); } }) .catch(err =\u003e { console.log(err); }) }) .catch(err =\u003e { console.log(err); }) 2.直播拉流 这里是：腾讯云官方直播拉流的API文档，其中详细阐述了拉流的调用方式和对应参数。 第三方库：腾讯云音视频SDK下载地址 直播拉流所需第三方库 \u003clink href=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/tcplayer.min.css\" rel=\"stylesheet\" /\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 Webrtc 视频，需要在 tcplayer.vx.x.x.min.js 之前引入 TXLivePlayer-x.x.x.min.js。--\u003e \u003c!--有些浏览器环境不支持 Webrtc，播放器会将 Webrtc 流地址自动转换为 HLS 格式地址，因此快直播场景同样需要引入hls.min.x.xx.xm.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/TXLivePlayer-1.2.3.min.js\"\u003e\u003c/script\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 HLS 协议的视频，需要在 tcplayer.vx.x.x.min.js 之前引入 hls.min.x.xx.xm.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/hls.min.1.1.6.js\"\u003e\u003c/script\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 FLV 格式的视频，需要在 tcplayer.vx.x.x.min.js 之前引入 flv.min.x.x.x.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/flv.min.1.6.3.js\"\u003e\u003c/script\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 DASH 视频，需要在 tcplayer.vx.x.x.min.js 之前引入 dash.min.x.x.x.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/dash.all.min.4.5.2.js\"\u003e\u003c/script\u003e \u003c!--播放器脚本文件--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/tcplayer.v4.7.2.min.js\"\u003e\u003c/script\u003e 播放容器 \u003cvideo id=\"player-container-id\" preload=\"auto\" playsinline webkit-playsinline\u003e\u003c/video\u003e 拉流js var player = TCPlayer('player-container-id', {}); // player-container-id 为播放器容器 ID，必须与 html 中一致 player.src(url); // url 播放地址 This is a warning\r直播视频全屏canvas元素无法在最上层 直播弹幕无法在最上层，将z-index设置为最大也没效果，那是因为第三方库用了一个toplayer的东西将播放视频的元素放到最顶层了，用css设置的东西没效果，解决方案就是设置个延时器，等到第三方库把元素放置到页面之后dom操作canvas元素，将其放置到设置toplayer的盒子里边，这样就可以了 ","date":"2024-08-09","objectID":"/text16/:0:0","tags":["腾讯云直播"],"title":"【腾讯云】腾讯云直播前端","uri":"/text16/"},{"categories":["版本控制工具"],"content":" //报错信息 Failed to connect to github.com port 443: Connection refused. //报错翻译 连接github.com 443端口失败:连接拒绝 解决办法： 排查代理问题 尝试重置代理或者取消代理的方式： git config --global --unset http.proxy git config --global --unset https.proxy 如果没效果，接着添加全局代理试试： git config --global http.proxy git config --global https.proxy 如果以上问题还未得到解决 排查DNS解析问题 在DNS解析前先会尝试走hosts，然后在找不到的的情况下再DNS解析,修改hosts文件域名解析就会先走hosts中的ip和域名的映射关系。 我们可以修改hosts文件，修改ip地址和域名的映射关系： Windows：位于C:\\Windows\\System32\\drivers\\etc ping gitHub.com 20.205.243.166 github.com 140.82.112.4 github.com 151.101.1.6 github.global.ssl.fastly.net 185.199.108.153 assets-cdn.github.com 185.199.109.153 assets-cdn.github.com 185.199.110.153 assets-cdn.github.com 185.199.111.153 assets-cdn.github.com 【注意：用“管理员身份运行记事本”进行hosts文件的修改】 刷新DNS ipconfig /flushdns ","date":"2024-08-03","objectID":"/text09/:0:0","tags":["git","gitHub"],"title":"【git】git克隆失败解决办法","uri":"/text09/"},{"categories":["前端"],"content":"1.变量定义 ES6新增了 let 和 const，分别用来声明变量和常量，应该尽可能使用 let 和 const 来定义变量，而不是 var ","date":"2024-07-21","objectID":"/es6/:1:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"1.1 let 关键字 let 用于声明变量，声明的变量只在当前代码块能被访问到 // 外部代码块不能访问到内部代码块定义的变量 if(true) { let a = 1; } console.log(a); // 报错：Uncaught ReferenceError: a is not defined /*-----------------分隔线-----------------*/ // 内部代码块能访问到外部代码块的变量 let arr = [] for(let i = 0; i \u003c 10; i++) { arr.push(i); } console.log(arr.join()); // 打印：0,1,2,3,4,5,6,7,8,9 /*-----------------分隔线-----------------*/ // 注意：在for循环中，循环在一个代码块，循环体在一个代码块 for (let i = 0; i \u003c 3; i++) { let i = 'abc'; console.log(i); } // 打印如下： // abc // abc // abc ","date":"2024-07-21","objectID":"/es6/:1:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"1.2 const 关键字 const 声明一个只读的常量 一旦声明，常量的值就不能改变，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值 const foo; // SyntaxError: Missing initializer in const declaration /*-----------------分隔线-----------------*/ const a = 1; a = 2; // 报错：Uncaught TypeError: Assignment to constant variable. /*-----------------分隔线-----------------*/ // 对于对象 const obj = { str: '123'} console.log(obj.str) // 打印：123 obj.str = '456' console.log(obj.str) // 打印：456 obj = {} // 报错：Uncaught TypeError: Assignment to constant variable. // 或者 let newObj = { str: '123' } obj = newObj // 报错：Uncaught TypeError: Assignment to constant variable. ","date":"2024-07-21","objectID":"/es6/:1:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"2. 模板字符串 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，即换行和缩进将会被保留，或者在字符串中嵌入变量。 let name = 'Ryan'; let age = 23; let str = ` name: ${name} age: 23` console.log(str) ","date":"2024-07-21","objectID":"/es6/:2:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3. 数组常用方法 这里列举数组的常用方法，并不都是ES6新增的方法 ","date":"2024-07-21","objectID":"/es6/:3:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.1 forEach 遍历数组，没有返回值，不改变原数组，处理函数可以接收三个参数，分别是当前位置元素item，当前位置下标index，当前遍历的数组 let arr = [1, 2, 3] arr.forEach(function(item) { console.log(item) }) // 打印： //1 //2 //3 ","date":"2024-07-21","objectID":"/es6/:3:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.2 map 遍历数组，不在源数组上进行操作，返回一个新的数组，处理函数可以接收三个参数，分别是当前位置元素item，当前位置下标index，当前遍历的数组 let arr = [1, 2, 3] let arr1 = arr.map(function(item) { console.log(item) item *= 2 return item }) // 打印： //1 //2 //3 console.log(arr.join()) // 打印：1,2,3 console.log(arr1.join()) //打印：2,4,6 //map一定要返回一个新数组，需要一个新的数组变量来接受 This is a tip\rforEach 和 map 的区别 map方法： map它返回一个新数组，原数组的结构不会被改变。 如果需要对原数组进行操作并返回一个新的数组，map是更合适的选择。 map经常用于转换数组中的每个元素。 forEach方法： forEach直接在原数组上进行操作，不返回任何值（或者说返回undefined）。 它没有能力中断循环，也就是说，即使出现错误，forEach中的函数也会继续执行。 如果需要在数组上直接进行修改，并不需要一个新数组，那么可以使用forEach。 ","date":"2024-07-21","objectID":"/es6/:3:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.3 filter 不在源数组上进行操作，返回一个新的数组，处理函数可以接收三个参数，分别是当前位置元素item，当前位置下标index，当前遍历的数组 let arr = [1, 2, 3, 4] let arr1 = arr.filter(function(item) { return item \u003e 2 }) console.log(arr1.join()) // 打印：3,4 ","date":"2024-07-21","objectID":"/es6/:3:3","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.4 includes 返回一个布尔值，表示某个数组是否包含给定的值，该方法的第二个参数表示搜索的起始位置 let arr = [1, 2, 3, 4] console.log(arr.includes(2)) // 打印：true // 从下标为2的位置开始向数组末尾搜索，没找到，返回false console.log(arr.includes(2, 2)) // 打印：false // 如果第二个参数为负数，则表示倒数的位置，从倒数第二个开始搜索，没找到，返回false console.log(arr.includes(2, -2)) // 打印：false // 如果这时它大于数组长度，则会重置为从0开始，倒数第五个，超过数组长度，则从数组开头向数组末尾搜索 console.log(arr.includes(2, -5)) // 打印：true ","date":"2024-07-21","objectID":"/es6/:3:4","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.5 find() find()方法在JavaScript中用于在数组中查找满足特定条件的第一个元素。它接受一个回调函数作为参数，该函数返回布尔值来确定元素是否匹配。如果找到匹配项，则返回该元素，否则返回undefined。此方法不会改变原始数组，适用于寻找单个匹配项。 array.find((item,index)=\u003e{ console.log(item,index); }) array.find(callback(element[, index[, array]])[, thisArg]) 参数解释： callback：必需。要在数组中每个元素上执行的函数。 element：必需。当前正在处理的数组元素。 index：可选。正在处理的元素的索引。 array：可选。调用该方法的数组本身。 thisArg：可选。当执行回调函数时使用的 this 值。 find() 方法的第一个参数 callback 是一个函数，用于测试每个元素是否符合条件，接收三个 参数： element：表示当前正在被处理的元素。 index：表示正在被处理的元素的索引。 array：表示当前正在被处理的数组对象。 回调函数应该返回一个布尔值，表示当前元素是否符合我们的条件。如果返回 true，则会停止遍历并返回该元素的值；否则，继续遍历直到遇到符合条件的元素或者整个数组都被遍历完毕。 find() 方法实际应用： **实例 1：**查找数组中的第一个负数。 const arr = [1, 2, -3, 4, -5]; const negativeNum = arr.find(num =\u003e num \u003c 0); console.log(negativeNum); // 输出：-3 **实例 2：**从对象数组中查找符合条件的对象。 const users = [ {id: 1, name: 'Alice'}, {id: 2, name: 'Bob'}, {id: 3, name: 'Charlie'} ]; const user = users.find(u =\u003e u.id === 2); console.log(user); // 输出：{id: 2, name: 'Bob'} **实例 3：**使用 thisArg 参数指定回调函数中的 this 值。 function isEven(num) { return num % 2 === 0; } const nums = [1, 3, 4, 7, 8]; const evenNum = nums.find(isEven, this); console.log(evenNum); // 输出：4 ★注意事项 find() 方法会遍历整个数组，直到找到满足条件的元素或者遍历完整个数组。 如果数组为空，那么返回 undefined。 在回调函数中修改数组本身不是一个好习惯。如果要修改数组，请使用 map() 或者 filter() 方法。 当多个元素符合条件时，find() 方法只会返回第一个符合条件的元素。 find() 方法是 ES6 中新增的方法，在较旧的浏览器中可能不被支持。 ","date":"2024-07-21","objectID":"/es6/:3:5","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.6 findIndex() findIndex返回满足条件的第一个元素的索引，而find返回满足条件的元素本身。这两个方法都不会改变原数组，且在找到匹配项后停止遍历剩余元素。 findIndex方法常用来查找数组中满足条件的第一项元素的下标 const arr = [1, 2, 3, 4, 5, 3, 3, 2, 4, 5 ] // 可以这么写 const index = arr.findIndex(item =\u003e { return item \u003e 2 }) console.log(index) // 2 //------------------------------------------ // 也可以这么写 const index = arr.findIndex(item =\u003e item \u003e 2) console.log(index) // 2 返回的index是满足条件的第一项元素的下标，这要注意的是findIndex会给数组中的每一项执行一个函数来判断是否满足表达式，如果满足条件后，剩下的元素则不再执行 ","date":"2024-07-21","objectID":"/es6/:3:6","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.7 indexOf() indexOf方法可返回某个指定的字符串值在字符串中首次出现的位置。 如果没有找到匹配的字符串则返回 -1 注意： indexOf() 方法区分大小写。 let str = 'orange'; str.indexOf('o'); //0 str.indexOf('n'); //3 str.indexOf('c'); //-1 //这里 0 和 3 分别是 o 和 n 在字符串中出现的位置。起始下标是 0。而 -1 代表未匹配 **注意：**indexOf 会做简单的类型转换 let numStr = '2016'; numStr.indexOf('2'); //0 numStr.indexOf(2); //0 //把会先把数字转换成字符串 '2' 然后再执行。 **注意：**number 类型有没有 indexOf 方法 let num = 2016; num.indexOf(2); //Uncaught TypeError: num.indexOf is not a function 对 number 类型使用 indexOf 方法，需要先转换成字符串 //二逼青年的写法 num = '2016'; num.indexOf(2); //0 //普通青年的写法 num.toString().indexOf(2); //0 //文艺青年的写法 ('' + num).indexOf(2); //0 //这里注意，第一种写死的写法在num为变量的时候会显得很蠢。第二种比较常用，第三种则比较精明 **注意：**Array 类型 indexOf() 方法在数组中搜索指定项目，并返回其位置。 搜索将从指定位置开始，如果未指定开始位置，则从头开始，并在数组末尾结束搜索。 如果未找到该项目，则 indexOf() 返回 -1。 如果该项目出现多次，则 indexOf() 方法返回第一次出现的位置。 注释：第一项的位置为 0，第二项的位置为 1，依此类推。 提示：如果您想从尾到头搜索，请使用 lastIndexOf() 方法。 array.indexOf(item, start) 参数值 参数 描述 item 必需。要搜索的项目。 start 可选。从哪里开始搜索。负值给定的位置将从结尾计数，然后搜索到最后。 示例 let arr = ['orange', '2016', '2016']; arr.indexOf('orange'); //0 arr.indexOf('o'); //-1 arr.indexOf('2016'); //1 arr.indexOf(2016); //-1 This is a tip\rfind 与 findIndex find返回元素，findIndex返回索引 找不到时find返回undefined，findlIndex返回-1 findIndex 与 indexOf findlndex比indexOf更强大一些，可以查找 对象数组， indexOf只能查找 数组 中指定时值，不过indexOf可以指定开始查找位置的索引 ","date":"2024-07-21","objectID":"/es6/:3:7","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"4. 对象常用方法 ","date":"2024-07-21","objectID":"/es6/:4:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"4.1 Object.assign() 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target），第一层属性是深拷贝，第二层属性是浅拷贝 const target1 = { a: 1 }; const source1 = { b: 2 }; const source2 = { c: 3 }; Object.assign(target1, source1, source2); console.log(target1) // 打印：{a:1, b:2, c:3} /*-----------------分隔线-----------------*/ // 第二层属性浅拷贝 const target2 = { a: 1 }; const source3 = { b: { name: 'test' }, c: 3 }; Object.assign(target2, source3); source3.b.name = 'nick' console.log(target2) // 打印：{a:1, b:{ name: 'nick' }, c:3} ","date":"2024-07-21","objectID":"/es6/:4:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5. 解构赋值 解构赋值 是一种特殊的语法，它使我们可以将数组或对象“拆包”为到一系列变量中，因为有时候使用变量更加方便 解构操作对那些具有很多参数和默认值等的函数也很奏效 “解构”并不意味着“破坏” 这种语法叫做解构赋值，因为它通过将结构中的各元素复制到变量中来达到“解构”的目的，但数组本身是没有被修改的 ","date":"2024-07-21","objectID":"/es6/:5:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5.1 数组解构赋值 基础 // 我们有一个存放了名字和姓氏的数组 let arr = [\"Ilya\", \"Kantor\"] // 解构赋值 // sets firstName = arr[0] // and surname = arr[1] let [firstName, surname] = arr; console.log(firstName); // Ilya console.log(surname); // Kantor /*-----------------分隔线-----------------*/ // 不需要第二个元素 let [firstName, , title] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"]; console.log( title ); // Consul /*-----------------分隔线-----------------*/ // 等号右侧可以是任何可迭代对象 let [a, b, c] = \"abc\"; // [\"a\", \"b\", \"c\"] let [one, two, three] = new Set([1, 2, 3]); /*-----------------分隔线-----------------*/ // 赋值给等号左侧的任何内容 let user = {}; [user.name, user.surname] = \"Ilya Kantor\".split(' '); console.log(user.name); // Ilya 我们可以将 Object.entries() 方法与解构语法一同使用，来遍历一个对象的”键—值“对： let user = { name: \"John\", age: 30 }; // 循环遍历键—值对 for (let [key, value] of Object.entries(user)) { console.log(`${key}: ${value}`); // name:John, then age:30 } ……对于 map 对象也类似： let user = new Map(); user.set(\"name\", \"John\"); user.set(\"age\", \"30\"); for (let [key, value] of user) { console.log(`${key}: ${value}`); // name:John, then age:30 } 默认值 // 默认值 let [name = \"Guest\", surname = \"Anonymous\"] = [\"Julius\"]; console.log(name); // Julius（来自数组的值） console.log(surname); // Anonymous（默认值被使用了） 剩余的 ... let [name1, name2, ...rest] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"]; console.log(name1); // Julius console.log(name2); // Caesar // 请注意，`rest` 的类型是数组 console.log(rest[0]); // Consul console.log(rest[1]); // of the Roman Republic console.log(rest.length); // 2 5.1.1关于（…）运算符 ","date":"2024-07-21","objectID":"/es6/:5:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5.2 对象解构赋值 基础 let options = { title: \"Menu\", width: 100, height: 200 }; let {title, width, height} = options; console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 /*-----------------分隔线-----------------*/ // 仅提取 title 作为变量 let { title } = options; console.log(title); // Menu /*-----------------分隔线-----------------*/ // 在options变量的基础上，改变 let {...} 中元素的顺序 let {height, width, title} = { title: \"Menu\", height: 200, width: 100 } console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 /*-----------------分隔线-----------------*/ // 在options变量的基础上，改变映射关系，冒号表示“什么值：赋值给谁” let {width: w, height: h, title} = options; // width -\u003e w // height -\u003e h // title -\u003e title console.log(title); // Menu console.log(w); // 100 console.log(h); // 200 默认值 let options = { title: \"Menu\" }; let {width = 100, height = 200, title} = options; console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 /*-----------------分隔线-----------------*/ // 改变映射关系并设置默认值 let {width: w = 100, height: h = 200, title} = options; console.log(title); // Menu console.log(w); // 100 console.log(h); // 200 剩余的 ... let options = { title: \"Menu\", height: 200, width: 100 }; // title = 名为 title 的属性 // rest = 存有剩余属性的对象 let {title, ...rest} = options; // 现在 title=\"Menu\", rest={height: 200, width: 100} console.log(rest.height); // 200 console.log(rest.width); // 100 ","date":"2024-07-21","objectID":"/es6/:5:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5.3 嵌套解构 let options = { size: { width: 100, height: 200 }, items: [\"Cake\", \"Donut\"], extra: true }; // 为了清晰起见，解构赋值语句被写成多行的形式 let { size: { // 把 size 赋值到这里 width, height }, items: [item1, item2], // 把 items 赋值到这里 title = \"Menu\" // 在对象中不存在（使用默认值） } = options; console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 console.log(item1); // Cake console.log(item2); // Donut ","date":"2024-07-21","objectID":"/es6/:5:3","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5.4 函数参数 let options = { title: \"My menu\", items: [\"Item1\", \"Item2\"] }; // 函数把对象展开成变量 function showMenu({ title = \"Untitled\", width = 200, height = 100, items = [] }) { // title, items – 提取于 options， // width, height – 使用默认值 console.log( `${title} ${width} ${height}` ); // My Menu 200 100 console.log( items ); // Item1, Item2 } showMenu(options); ","date":"2024-07-21","objectID":"/es6/:5:4","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"6. ... 运算符 ","date":"2024-07-21","objectID":"/es6/:6:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"6.1 Rest 参数 This is a warning\r注意：Rest 参数必须放到参数列表的末尾\rfunction sumAll(...args) { // 数字名为 args let sum = 0; for (let arg of args) sum += arg; return sum; } console.log( sumAll(1) ); // 1 console.log( sumAll(1, 2) ); // 3 console.log( sumAll(1, 2, 3) ); // 6 function showName(firstName, lastName, ...titles) { console.log( `${firstName} ${lastName}` ); // Julius Caesar // 剩余的参数被放入 titles 数组中 // i.e. titles = [\"Consul\", \"Imperator\"] console.log( titles[0] ); // Consul console.log( titles[1] ); // Imperator console.log( titles.length ); // 2 } showName(\"Julius\", \"Caesar\", \"Consul\", \"Imperator\"); ","date":"2024-07-21","objectID":"/es6/:6:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"6.2 Spread 语法 基础 let arr = [3, 5, 1]; console.log( Math.max(...arr) ); // 5（spread 语法把数组转换为参数列表） /*-----------------分隔线-----------------*/ let arr1 = [1, -2, 3, 4]; let arr2 = [8, 3, -8, 1]; console.log( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25 /*-----------------分隔线-----------------*/ let arr = [3, 5, 1]; let arr2 = [8, 9, 15]; let merged = [0, ...arr, 2, ...arr2]; console.log(merged); // 0,3,5,1,2,8,9,15（0，然后是 arr，然后是 2，然后是arr2） 获取一个对象或数组的副本 let arr = [1, 2, 3]; // 将数组 spread 到参数列表中，然后将结果放到一个新数组 let arrCopy = [...arr]; // 两个数组中的内容相同吗？ console.log(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true // 两个数组相等吗？ console.log(arr === arrCopy); // false（它们的引用是不同的） // 修改我们初始的数组不会修改副本： arr.push(4); console.log(arr); // 1, 2, 3, 4 console.log(arrCopy); // 1, 2, 3 /*-----------------分隔线-----------------*/ // 同样适用于对象 let obj = { a: 1, b: 2, c: 3 }; let objCopy = { ...obj }; // 将对象 spread 到参数列表中，然后将结果返回到一个新对象 // 两个对象中的内容相同吗？ console.log(JSON.stringify(obj) === JSON.stringify(objCopy)); // true // 两个对象相等吗？ console.log(obj === objCopy); // false (not same reference) // 修改我们初始的对象不会修改副本： obj.d = 4; console.log(JSON.stringify(obj)); // {\"a\":1,\"b\":2,\"c\":3,\"d\":4} console.log(JSON.stringify(objCopy)); // {\"a\":1,\"b\":2,\"c\":3} ","date":"2024-07-21","objectID":"/es6/:6:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"6.3 …语法 1.1 合并数组 //es5写法，使用concat let arr1 = [1,2]; let arr2 = [5,6]; let newArr = [20]; newArr = newArr.concat(arr1).concat(arr2); //es6写法 let arr1 = [1,2]; let arr2 = [5,6]; let newArr = [20]; newArr = [20,...arr1,...arr2]; 1.2合并对象 const baseSquirtle = { name: 'Squirtle', type: 'Water' }; const squirtleDetails = { species: 'Tiny Turtle Pokemon', evolution: 'Wartortle' }; const squirtle = { ...baseSquirtle, ...squirtleDetails }; console.log(squirtle); //Result: { name: 'Squirtle', type: 'Water', species: 'Tiny Turtle Pokemon', evolution: 'Wartortle' } 2.1 为数组新增成员 const pokemon = ['小红', '小李']; const charmander = '大大'; const pokedex = [...pokemon, charmander]; console.log(pokedex); //Result: [ '小红', '小李', '大大' ] 2.2 为对象新增属性 const aa= { name: '小红', type: '123' }; const obj= { ...aa, unit: '米', id: '1' }; console.log(obj); //Result: { name: '小红', type: '123', unit: '米', id: '1' } 将一个数组添加到另一个数组的尾部： let arr1 = [0, 1, 2]; let arr2 = [3, 4, 5]; //es5写法 Array.prototype.push.apply(arr1, arr2); //es6写法 let arr1 = [0, 1, 2]; let arr2 = [3, 4, 5]; arr1.push(...arr2); 将字符串转换成数组： //es5写法需要split和join的操作 //... //es6写法 [...'hello'] // [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 解构赋值 例1： let obj = {name:\"小明\",age:18,hobby:\"小红\"}; let newobj = { ...obj } console.log(newobj)//和obj一样 例2： let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; console.log(x); // 1 console.log(y); // 2 console.log(z); // { a: 3, b: 4 } 可以对数组进行浅克 let arr = [1,2,[1,2],3]; let arr2 = [...arr]; arr2.push(1); console.log(arr);//[1,2,[1,2],3] console.log(arr2);//[1,2,[1,2],3,1] 进阶: 复制具有嵌套结构的数据/对象 先看一个例子： const pokemon = { name: 'Squirtle', type: 'Water', abilities: ['Torrent', 'Rain Dish'] }; const squirtleClone = { ...pokemon }; pokemon.name = 'Charmander'; pokemon.abilities.push('Surf'); console.log(squirtleClone); //Result: { name: 'Squirtle', type: 'Water', abilities: [ 'Torrent', 'Rain Dish', 'Surf' ] } 当我们修改原对象的name 属性时，我们的克隆对象的 name 属性没有受影响， 这是符合我们预期的。但是当修改原对象的abilities 属性时，我们的克隆对象也被修改了。 原因: 因为复制过来的abilities 是一个引用类型， 原数据改了， 用到他的地方也会跟着改 解决办法：const squirtleClone = { …pokemon, abilities: […pokemon.abilities] }; const pokemon = { name: 'Squirtle', type: 'Water', abilities: ['Torrent', 'Rain Dish'] }; const squirtleClone = { ...pokemon, abilities: [...pokemon.abilities] }; pokemon.name = 'Charmander'; pokemon.abilities.push('Surf'); console.log(squirtleClone); //Result: { name: 'Squirtle', type: 'Water', abilities: [ 'Torrent', 'Rain Dish' ] } 增加条件属性 方式一： const pokemon = { name: 'Squirtle', type: 'Water' }; const abilities = ['Torrent', 'Rain dish']; const fullPokemon = abilities ? { ...pokemon, abilities } : pokemon; console.log(fullPokemon); 方式二：简化一下 const fullPokemon = abilities \u0026\u0026 { ...pokemon, abilities }; 短路 const pokemon = { name: 'Squirtle', type: 'Water' }; const abilities = ['Torrent', 'Rain dish']; const fullPokemon = { ...pokemon, ...(abilities \u0026\u0026 { abilities }) }; console.log(fullPokemon); 如果 abilities 为 true， 就相当于是 const fullPokemon = { ...pokemon, ...{ abilities } } ","date":"2024-07-21","objectID":"/es6/:6:3","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"7. 箭头函数 创建函数还有另外一种非常简单的语法，并且这种方法通常比函数表达式更好，它看起来像这样： ","date":"2024-07-21","objectID":"/es6/:7:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"7.1 基础 // 这里创建了一个函数 func，它接受参数 arg1..argN，然后使用参数对右侧的 expression 求值并返回其结果 let func = (arg1, arg2, ...argN) =\u003e expression /*-----------------分隔线-----------------*/ // 具体例子 let sum = (a, b) =\u003e a + b; /* 这个箭头函数是下面这个函数的更短的版本： let sum = function(a, b) { return a + b; }; */ console.log( sum(1, 2) ); // 3 ","date":"2024-07-21","objectID":"/es6/:7:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"7.2 多行箭头函数 let sum = (a, b) =\u003e { // 花括号表示开始一个多行函数 let result = a + b; return result; // 如果我们使用了花括号，那么我们需要一个显式的 “return” }; console.log( sum(1, 2) ); // 3 ","date":"2024-07-21","objectID":"/es6/:7:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"7.3 箭头函数没有 this 箭头函数没有 this。如果访问 this，则会从外部获取，例如： let group = { title: \"Our Group\", students: [\"John\", \"Pete\", \"Alice\"], showList1() { this.students.forEach( student =\u003e console.log(this.title + ': ' + student) ); } showList2() { this.students.forEach(function(student) { // Error: Cannot read property 'title' of undefined console.log(this.title + ': ' + student) }); } }; group.showList1(); // 打印： // Our Group: John // Our Group: Pete // Our Group: Alice group.showList2(); // 报错：TypeError: Cannot read property 'title' of undefined 报错是因为 forEach 运行它里面的这个函数，但是这个函数的 this 为默认值 this=undefined，因此就出现了尝试访问 undefined.title 的情况。 但箭头函数就没事，因为它们没有 this。 This is a warning\r注意：不能对箭头函数进行 new 操作 不具有 this 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor）， 即不能用 new 调用它们 ","date":"2024-07-21","objectID":"/es6/:7:3","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"8. Promise Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。 所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise 对象有以下两个特点： 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 ","date":"2024-07-21","objectID":"/es6/:8:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"8.1 用法 ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例 resolve let promise = new Promise((resolve, reject) =\u003e { // 当 promise 被构造完成时，自动执行此函数 // 1 秒后发出工作已经被完成的信号，并带有结果 \"done\" setTimeout(() =\u003e resolve(\"done\"), 1000); }); promise .then(res =\u003e console.log(res)) // 执行条件：promise内的任务处理完成，resolve被执行 .catch(error =\u003e console.log(error)) // 执行条件：reject被执行或者抛出异常 .finally(() =\u003e console.log('this promist done!')) // 执行条件：不管promise内的任务为什么状态都会执行 // 打印： // done // this promist done! reject let promise1 = new Promise(function(resolve, reject) { // 当 promise 被构造完成时，自动执行此函数 // 1 秒后发出工作执行失败的信号，并带有结果 \"failed\" setTimeout(() =\u003e reject(\"failed\"), 1000); }); promise1 .then(res =\u003e console.log(res)) // 执行条件：promise内的任务处理完成，resolve被执行 .catch(error =\u003e console.log(error)) // 执行条件：reject被执行或者抛出异常 .finally(() =\u003e console.log('this promist done!')) // 执行条件：不管promise内的任务为什么状态都会执行 // 打印： // failed // this promist done! ","date":"2024-07-21","objectID":"/es6/:8:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"子=\u003e父 子组件向父组件传参的方式通常通过事件来实现。具体步骤如下： 在子组件中定义事件：子组件可以通过 $emit 方法触发一个自定义事件，并传递参数 // 子组件 ChildComponent.vue \u003ctemplate\u003e \u003cbutton @click=\"sendDataToParent\"\u003e向父组件传参\u003c/button\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { sendDataToParent() { let data = '这是子组件传递给父组件的数据'; this.$emit('child-event', data); } } } \u003c/script\u003e 在上面的代码中，sendDataToParent 方法通过 $emit 发送了一个名为 child-event 的事件，并将 data 作为参数传递给父组件 2.在父组件中监听事件：父组件需要在使用子组件的地方监听这个事件，并处理子组件传递过来的数据 // 父组件 ParentComponent.vue \u003ctemplate\u003e \u003cdiv\u003e \u003cp\u003e从子组件接收到的数据：{{ receivedData }}\u003c/p\u003e \u003cchild-component @child-event=\"handleChildEvent\"\u003e\u003c/child-component\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import ChildComponent from './ChildComponent.vue'; export default { components: { ChildComponent }, data() { return { receivedData: '' }; }, methods: { handleChildEvent(data) { this.receivedData = data; } } } \u003c/script\u003e 在父组件中，使用 标签引入子组件，并通过 @child-event 监听子组件触发的 child-event 事件。当事件被触发时，handleChildEvent 方法会被调用，并将子组件传递的 data 参数赋值给 receivedData。 通过以上方式，子组件就能够向父组件传递数据了。 ","date":"2024-07-01","objectID":"/text17/:0:1","tags":["vue","javascript"],"title":"【Vue前端框架】vue子组件向父组件相互传参的方式","uri":"/text17/"},{"categories":["前端"],"content":"父=\u003e子 Vue项目中在父组件中直接调用子组件的方法 方案一：通过ref直接调用子组件的方法 //父组件中 \u003ctemplate\u003e \u003cdiv\u003e \u003cButton @click=\"handleClick\"\u003e点击调用子组件方法\u003c/Button\u003e \u003cChild ref=\"child\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import Child from './child'; export default { methods: { handleClick() { this.$refs.child.sing(); }, }, } \u003c/script\u003e //子组件中 \u003ctemplate\u003e \u003cdiv\u003e我是子组件\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { sing() { console.log('我是子组件的方法'); }, }, }; \u003c/script\u003e 方案二：通过组件的$emit、$on方法 //父组件中 \u003ctemplate\u003e \u003cdiv\u003e \u003cButton @click=\"handleClick\"\u003e点击调用子组件方法\u003c/Button\u003e \u003cChild ref=\"child\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import Child from './child'; export default { methods: { handleClick() { this.$refs.child.$emit(\"childmethod\") //子组件$on中的名字 }, }, } \u003c/script\u003e //子组件中 \u003ctemplate\u003e \u003cdiv\u003e我是子组件\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { mounted() { this.$nextTick(function() { this.$on('childmethods', function() { console.log('我是子组件方法'); }); }); }, }; \u003c/script\u003e ","date":"2024-07-01","objectID":"/text17/:0:2","tags":["vue","javascript"],"title":"【Vue前端框架】vue子组件向父组件相互传参的方式","uri":"/text17/"},{"categories":["idea"],"content":"1、现象如下 2、解决办法 3、或者搜索框输入ESLint，选择禁用 ","date":"2023-04-03","objectID":"/text05/:0:0","tags":["idea"],"title":"【idea】idea导入ta404前端项目代码后js文件中注释报红色波浪线解决办法","uri":"/text05/"},{"categories":["idea"],"content":"IDEA在Database中连接达梦数据库 repository-达梦8maven.zip · Jared.Yan/dameng-maven - Gitee.com This is a tip\r如果是连接项目代码中的达梦数据库，此处选择的jar包为项目代码依赖中的dm.jar\r1、idea右侧点击database 2、照着我的点就行，驱动包记得得先加上才会出现class选项 3、回到主页面，添加一个数据库连接。 4、测试连接，连接成功 ","date":"2023-04-03","objectID":"/text10/:0:0","tags":["达梦数据库"],"title":"【idea】IDEA在Database中连接达梦数据库","uri":"/text10/"},{"categories":["Java"],"content":"StringEscapeUtils类可以对html js xml sql 等代码进行转义来防止SQL注入及XSS注入 添加依赖 \u003cdependency\u003e \u003cgroupId\u003ecommons-lang\u003c/groupId\u003e \u003cartifactId\u003ecommons-lang\u003c/artifactId\u003e \u003cversion\u003e2.6\u003c/version\u003e \u003c/dependency\u003e 1.html脚本 escapeHtml转义html脚本 unescapeHtml反转义html脚本 System.out.println(StringEscapeUtils.escapeHtml(\"\u003ca\u003eabc\u003c/a\u003e\")); System.out.println(StringEscapeUtils.unescapeHtml(\"\u0026lt;a\u0026gt;abc\u0026lt;/a\u0026gt;\")); 输出 \u0026lt;a\u0026gt;abc\u0026lt;/a\u0026gt; \u003ca\u003eabc\u003c/a\u003e 2.js脚本 escapeJavaScript转义js脚本 unescapeJavaScript反转义js脚本 System.out.println(StringEscapeUtils.escapeJavaScript(\"\u003cscript\u003ealert('123')\u003cscript\u003e\")); System.out.println(StringEscapeUtils.unescapeJavaScript(\"\u003cscript\u003ealert(\\'123\\')\u003cscript\u003e\")); 输出 \u003cscript\u003ealert(\\'123\\')\u003cscript\u003e \u003cscript\u003ealert('123')\u003cscript\u003e 3.字符串Unicode　escapeJava转义成Unicode编码 unescapeJava反转义成Unicode编码 System.out.println(StringEscapeUtils.escapeJava(\"你好\")); System.out.println(StringEscapeUtils.unescapeJava(\"\\u4F60\\u597D\")); 输出 \\u4F60\\u597D 你好 4.xml escapeXML转义XML unescapeXML反转义XML System.out.println(StringEscapeUtils.escapeXml(\"\u003cname\u003e贝贝\u003c/name\u003e\")); System.out.println(StringEscapeUtils.unescapeXml(\"\u0026lt;name\u0026gt;\u0026#36125;\u0026#36125;\u0026lt;/name\u0026gt;\")); 输出 \u0026lt;name\u0026gt;\u0026#36125;\u0026#36125;\u0026lt;/name\u0026gt; \u003cname\u003e贝贝\u003c/name\u003e 5.sql escapeSql sql转义，防止sql注入攻击 转义后 StringBuffer sql = new StringBuffer(\"select * from users where 1=1 \"); String keyWord=\"aaa' or '1=1\"; if(!keyWord.isEmpty()){ sql.append(\" and username like '%\" + StringEscapeUtils.escapeSql(keyWord) + \"%'\"); } System.out.println(sql); 输出 select * from users where 1=1 and username like '%aaa'' or ''1=1%' 不进行转义的 select * from users where 1=1 and username like '%aaa' or '1=1%' ","date":"2023-04-03","objectID":"/text15/:0:0","tags":["java"],"title":"【Java】转义StringEscapeUtils的使用","uri":"/text15/"},{"categories":["Java"],"content":"String转为int，使用parseInt，或者valueOf.intValue int i = Integer.parseInt（string）; int i = Integer.valueOf(s).intValue(); int转为String，使用valueOf，或者toString，或者\"“空字符串相加 String s = String.valueOf(i); String s = Integer.toString(i); String s = \"\" + i; ","date":"2023-03-01","objectID":"/text02/:0:0","tags":["java"],"title":"【Java】Java中int与String互相转换方法","uri":"/text02/"},{"categories":["Python"],"content":"本文指导如何处理PyCharm中关于MicrosoftWebDriver.exe路径错误，需下载对应浏览器驱动，如Edge驱动，重命名并将其放置在Python安装目录下，以便PyCharm正常使用Selenium打开浏览器。edge驱动下载地址：驱动程序 将下载好的驱动程序解压。 找到python的目录文件，将Edge驱动程序放置在python根目录下。 This is a tip\r如果不知道自己的python安装在什么位置了，可以打开cmd键入“where python”\r3.完成以上步骤你得pycharm就可以正常打开浏览器了。 driver = webdriver.Edge() url = \"https://www.baidu.com\" driver.get(url) ","date":"2022-07-12","objectID":"/text19/:0:0","tags":["Python"],"title":"【Python】Python的WebDriver问题","uri":"/text19/"},{"categories":["Python"],"content":"python官网地址：https://www.python.org/ 第1步：先勾选，再安装，上面是默认安装路径，下面是自定义安装路径 等待安装 安装完成，设置MAX_PATH，授管理员权限 打开终端窗口，输入python命令，验证是否安装成功 ","date":"2022-07-08","objectID":"/text04/:0:0","tags":["Python"],"title":"【Python】Python下载与安装操作步骤","uri":"/text04/"},{"categories":["读卡器驱动"],"content":"报错信息Exception in thread “AWT-EventQueue-0” java.lang.UnsatisfiedLinkError: Unable to load library ‘c:\\dcrf32.dll’:Native library (win32-x86-64/c:\\dcrf32.dll) not found in resource path 翻译过来就是：线程“AWT-EventQueue-0”出现异常，无法加载库’c:\\dcrf32.dll’:本机库(win32-x86-64/c:\\dcrf32.dll)在资源路径中找不到 解决办法： 1、我先是检查了jdk 版本，jre是不是选择和动态库相同位数的32 or 64？ 检查jdk版本位数的方法: java -version 2、 动态库是否添加到jdk里面？我检查的时候，是加了的，但是还是报找不到 3、是不是动态库要求放到具体某一个文件夹下了？ Unable to load library ‘c:\\dcrf32.dll’:Native library (win32-x86-64/c:\\dcrf32.dll) not found 这个括号里面搜索的动态库的位置在c盘根目录下，很像是代码写死了访问位置。于是我找代码去了，确实代码里面是指定要求限制了。 解决办法：把动态库的位置移动到c盘根目录下，或者代码访问位置去掉前面的磁盘限制。 这个错找了很久，特此记录 ","date":"2022-05-18","objectID":"/text03/:0:0","tags":["idea","jar"],"title":"【读卡器驱动】dcrf32.dll","uri":"/text03/"},{"categories":["前端"],"content":"数字短信验证码 思路： a.两个文本框+一个获取验证码按钮，文本框用来输入手机号和获取到的验证码，按钮负责点击和记录倒计时； b.js书写定时器setTimeout，进行60秒验证码失效时间记录； c.后台提供短信获取验证的接口，我们把手机号作为参数上传，后台获取到后给该手机号下发验证码 下放代码可以直接 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cscript type=\"text/javascript\" src=\"https://libs.baidu.com/jquery/2.1.4/jquery.min.js\" \u003e //验证码 var counts = 60; function settime(val) { if(counts == 0) { val.removeAttribute(\"disabled\"); val.value = \"获取验证码\"; counts = 60; return false; } else { val.setAttribute(\"disabled\", true); val.value = \"重新发送（\" + counts + \"）\"; counts--; } setTimeout(function() { settime(val); }, 1000); } $(function(){ //获取验证码 $(\"#verCodeBtn\").click(function() { var userinfo = { \"UserPhoneNum\": '86//' + $(\"input[name='phone']\").val() } $.ajax({ url: \"https://www.xxxxx.cn/user/sendcode/\", data: userinfo, type: \"get\", success: function(data) { if(JSON.parse(data).state === 404 || JSON.parse(data).state === 202 || userinfo.UserPhoneNum === '86//') { alert(\"验证码发送失败\") } else { alert(\"验证码发送成功，请耐心等待\") } }, error: function() { alert(\"发送失败\"); } }); }); }) \u003c/script\u003e \u003cbody\u003e \u003cinput type=\"text\" name=\"phone\" id=\"phone\" value=\"\" placeholder=\"请输入手机号\" maxlength=\"11\" /\u003e \u003cinput type=\"\" name=\"verCode\" id=\"verCode\" value=\"\" placeholder=\"请输入验证码\" maxlength=\"6\"/\u003e \u003cinput type=\"button\" name=\"\" id=\"verCodeBtn\" value=\"获取验证码\" onclick=\"settime(this);\"/\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-01-09","objectID":"/text14/:0:1","tags":["JavaScript"],"title":"【JS】JS 验证码功能的三种实现方式","uri":"/text14/"},{"categories":["前端"],"content":"图形验证码 概要：一般的图形验证码就像上方的短信验证码一样，就是后台生成的验证码图片返回给前端的，那样的话就比较简单，因为复杂的都让后台解决了，我在这里主要说的是另一种，就是不调用后台接口，通过canvas画布来解决图形验证码。 思路： a.一个文本框用来输入由数字和字母组合的验证码+一个画布标签来显示图形验证码+一个提交按钮； b.提交按钮进行表单验证，输入正确或者错误进行相应的提示； c.用画布生成并渲染出验证码图形，并且得到随机的颜色值； \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e验证码\u003c/title\u003e \u003cstyle\u003e .input-val { width: 150px; height: 30px; border: 1px solid #ddd; box-sizing: border-box;/*box-sizing 属性允许你以某种方式定义某些元素，以适应指定区域。*/ } #canvas { vertical-align: middle;/*vertical-align属性设置一个元素的垂直对齐。*/ box-sizing: border-box; border: 1px solid #ddd; cursor: pointer; } .btn { display: block; margin-top: 10px; height: 30px; width: 80px; font-size: 16px; color: #fff; background-color: #409EFE; border: 1px solid #EBEDEF; border-radius: 50px; } \u003c/style\u003e \u003c/head\u003e \u003cscript type=\"text/javascript\" src=\"https://libs.baidu.com/jquery/2.1.4/jquery.min.js\" \u003e\u003c/script\u003e \u003cscript\u003e $(function(){ var show_num = []; draw(show_num); $(\"#canvas\").on('click',function(){ draw(show_num); }) $(\".btn\").on('click',function(){ var val = $(\".input-val\").val().toLowerCase(); //toLowerCase()函数将字符串中的所有字符转为小写。所以输入框不区分大小写。 var num = show_num.join(\"\"); if(val==''){ alert('请输入验证码！'); }else if(val == num){ alert('提交成功！'); $(\".input-val\").val(''); }else{ alert('验证码错误！请重新输入！'); $(\".input-val\").val(''); } }) }) function draw(show_num) {//生成并渲染出验证码图形 var canvas_width=$('#canvas').width(); var canvas_height=$('#canvas').height(); var canvas = document.getElementById(\"canvas\");//获取canvas var context = canvas.getContext(\"2d\");//获取到canvas画图的环境 canvas.width = canvas_width; canvas.height = canvas_height; var sCode = \"A,B,C,E,F,G,H,J,K,L,M,N,P,Q,R,S,T,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,m,n,p,q,r,s,t,u,v,w,x,y,z,1,2,3,4,5,6,7,8,9,0\"; var aCode = sCode.split(\",\"); var aLength = aCode.length;//获取到数组的长度 for (var i = 0; i \u003c 4; i++) { //这里的for循环可以控制验证码位数 var j = Math.floor(Math.random() * aLength);//获取到随机的索引值 var deg = Math.random() - 0.5; //产生一个随机弧度 var txt = aCode[j];//得到随机的一个内容 show_num[i] = txt.toLowerCase(); var x = 10 + i * 20;//文字在canvas上的x坐标 var y = 20 + Math.random() * 8;//文字在canvas上的y坐标 context.font = \"bold 24px 微软雅黑\"; context.translate(x, y); context.rotate(deg); context.fillStyle = randomColor(); context.fillText(txt, 0, 0); context.rotate(-deg); context.translate(-x, -y); } for (var i = 0; i \u003c= 5; i++) { //验证码上显示线条 context.strokeStyle = randomColor(); context.beginPath(); context.moveTo(Math.random() * canvas_width, Math.random() * canvas_height); context.lineTo(Math.random() * canvas_width, Math.random() * canvas_height); context.stroke(); } for (var i = 0; i \u003c= 20; i++) { //验证码上的小点 context.strokeStyle = randomColor();//随机生成 context.beginPath(); var x = Math.random() * canvas_width; var y = Math.random() * canvas_height; context.moveTo(x, y); context.lineTo(x + 1, y + 1); context.stroke(); } } function randomColor() {//得到随机的颜色值 var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return \"rgb(\" + r + \",\" + g + \",\" + b + \")\"; } \u003c/script\u003e \u003cbody\u003e \u003cdiv class=\"code\"\u003e \u003cinput type=\"text\" value=\"\" placeholder=\"请输入验证码\" class=\"input-val\"\u003e \u003ccanvas id=\"canvas\" width=\"100\" height=\"30\"\u003e\u003c/canvas\u003e \u003cbutton class=\"btn\"\u003e验证\u003c/button\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-01-09","objectID":"/text14/:0:2","tags":["JavaScript"],"title":"【JS】JS 验证码功能的三种实现方式","uri":"/text14/"},{"categories":["前端"],"content":"滑动验证码 滑块登录，是完成拼图形式的，我下面这个原理是一样的，逻辑是根据鼠标滑动轨迹，坐标位置，计算拖动速度等等来判断是否人为操作，如果小伙伴想做和博客园效果一样的，那么可以用来做参考。 思路： a.由三个div组成，构成了滑块和底部进度条的效果； b.书写js,注册鼠标按下，悬浮，松开事件； c.记录滑块移动的距离和状态进行判断是否成功； html \u003cdiv class=\"drag\"\u003e \u003cdiv class=\"bg\"\u003e\u003c/div\u003e \u003cdiv class=\"text\" onselectstart=\"return false;\"\u003e请拖动滑块解锁\u003c/div\u003e \u003cdiv class=\"btn\"\u003e\u0026gt;\u0026gt;\u003c/div\u003e \u003c/div\u003e css \u003cstyle\u003e .drag{ width: 300px; height: 40px; line-height: 40px; background-color: #e8e8e8; position: relative; margin:0 auto; } .bg{ width:40px; height: 100%; position: absolute; background-color: #75CDF9; } .text{ position: absolute; width: 100%; height: 100%; text-align: center; user-select: none; } .btn{ width:40px; height: 38px; position: absolute; border:1px solid #ccc; cursor: move; font-family: \"宋体\"; text-align: center; background-color: #fff; user-select: none; color:#666; } \u003c/style\u003e js \u003cscript\u003e //一、定义一个获取DOM元素的方法 var $ = function(selector){ return document.querySelector(selector); }, box = $(\".drag\"),//容器 bg = $(\".bg\"),//背景 text = $(\".text\"),//文字 btn = $(\".btn\"),//滑块 success = false,//是否通过验证的标志 distance = box.offsetWidth - btn.offsetWidth;//滑动成功的宽度（距离） //二、给滑块注册鼠标按下事件 btn.onmousedown = function(e){ //1.鼠标按下之前必须清除掉后面设置的过渡属性 btn.style.transition = \"\"; bg.style.transition =\"\"; //说明：clientX 事件属性会返回当事件被触发时，鼠标指针向对于浏览器页面(或客户区)的水平坐标。 //2.当滑块位于初始位置时，得到鼠标按下时的水平位置 var e = e || window.event; var downX = e.clientX; //三、给文档注册鼠标移动事件 document.onmousemove = function(e){ var e = e || window.event; //1.获取鼠标移动后的水平位置 var moveX = e.clientX; //2.得到鼠标水平位置的偏移量（鼠标移动时的位置 - 鼠标按下时的位置） var offsetX = moveX - downX; //3.在这里判断一下：鼠标水平移动的距离 与 滑动成功的距离 之间的关系 if( offsetX \u003e distance){ offsetX = distance;//如果滑过了终点，就将它停留在终点位置 }else if( offsetX \u003c 0){ offsetX = 0;//如果滑到了起点的左侧，就将它重置为起点位置 } //4.根据鼠标移动的距离来动态设置滑块的偏移量和背景颜色的宽度 btn.style.left = offsetX + \"px\"; bg.style.width = offsetX + \"px\"; //如果鼠标的水平移动距离 = 滑动成功的宽度 if( offsetX == distance){ //1.设置滑动成功后的样式 text.innerHTML = \"验证通过\"; text.style.color = \"#fff\"; btn.innerHTML = \"\u0026radic;\"; btn.style.color = \"green\"; bg.style.backgroundColor = \"lightgreen\"; //2.设置滑动成功后的状态 success = true; //成功后，清除掉鼠标按下事件和移动事件（因为移动时并不会涉及到鼠标松开事件） btn.onmousedown = null; document.onmousemove = null; //3.成功解锁后的回调函数 setTimeout(function(){ alert('解锁成功！'); },100); } } //四、给文档注册鼠标松开事件 document.onmouseup = function(e){ //如果鼠标松开时，滑到了终点，则验证通过 if(success){ return; }else{ //反之，则将滑块复位（设置了1s的属性过渡效果） btn.style.left = 0; bg.style.width = 0; btn.style.transition = \"left 1s ease\"; bg.style.transition = \"width 1s ease\"; } //只要鼠标松开了，说明此时不需要拖动滑块了，那么就清除鼠标移动和松开事件。 document.onmousemove = null; document.onmouseup = null; } } \u003c/script\u003e ","date":"2022-01-09","objectID":"/text14/:0:3","tags":["JavaScript"],"title":"【JS】JS 验证码功能的三种实现方式","uri":"/text14/"},{"categories":["前端"],"content":"利用原生JSON对象，将对象转为字符串，使用 JSON.stringify（对象名） var jsObj = {}; jsObj.testArray = [1,2,3,4,5]; jsObj.name = 'CSS3'; jsObj.date = '8 May, 2011'; var str = JSON.stringify(jsObj); alert(str); 从JSON字符串转为对象 ，使用JSON.parse（字符串名） var jsObj = {}; jsObj.testArray = [1,2,3,4,5]; jsObj.name = 'CSS3'; jsObj.date = '8 May, 2011'; var str = JSON.stringify(jsObj); var str1 = JSON.parse(str); alert(str1); ","date":"2022-01-09","objectID":"/text01/:0:0","tags":["JavaScript"],"title":"【Js】JS 中Object和String互转方法","uri":"/text01/"},{"categories":["前端"],"content":"利用来JS控制页面控件显示和隐藏有两种方法，两种方法分别利用HTML的style中的两个属性，两种方法的不同之处在于控件隐藏后是否还在页面上占空位。 ","date":"2022-01-09","objectID":"/text013/:0:0","tags":["javascript"],"title":"【Js】JS控制元素的显示和隐藏","uri":"/text013/"},{"categories":["前端"],"content":"方法一 document.getElementById(\"EleId\").style.visibility=\"hidden\"; document.getElementById(\"EleId\").style.visibility=\"visible\"; 利用上述方法实现隐藏后，页面的位置还被控件占用，显示空白。 ","date":"2022-01-09","objectID":"/text013/:0:1","tags":["javascript"],"title":"【Js】JS控制元素的显示和隐藏","uri":"/text013/"},{"categories":["前端"],"content":"方法二 document.getElementById(\"EleId\").style.display=\"none\"; document.getElementById(\"EleId\").style.display=\"inline\"; 利用上述方法实现隐藏后，页面的位置不被占用。 ","date":"2022-01-09","objectID":"/text013/:0:2","tags":["javascript"],"title":"【Js】JS控制元素的显示和隐藏","uri":"/text013/"},{"categories":["前端"],"content":"方法三 显示元素进行隐藏 document.getElementById(\"ID名\").hidden=ture; 根据页面元素ID名获得页面元素值，进而将其属性设置成隐藏。 将隐藏元素进行显示对于已经隐藏的页面元素如果要将其再次显示，不是将 document.getElementById(\"ID名\").hidden=false; 而是将其隐藏属性删除 document.getElementById(\"ID名\").removeAttribute(\"hidden\"); ","date":"2022-01-09","objectID":"/text013/:0:3","tags":["javascript"],"title":"【Js】JS控制元素的显示和隐藏","uri":"/text013/"},{"categories":["前端"],"content":"一些基本定义 ","date":"2021-07-01","objectID":"/text22/:1:0","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"1、万维网 （world wide web ===\u003e www）作用：实现资源共享 ​ 是Internet上基于客户/服务器体系结构的分布式多平台的超文本超媒体信息服务系统，它是Internet最主要的信息服务，允许用户在一台计算机上通过Internet读取另一台计算机上的信息。 ","date":"2021-07-01","objectID":"/text22/:1:1","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"2、网页 （web page） ​ 是存放在web服务器上供客户端用户浏览的文件，可以在Internet上传输。网页是按照网页文档规范编写的一个或多个文件，这种格式的文件由超文本标记语言创建，能将文字、图片、声音等各种多媒体文件组合在一起，这些文件被保存在特定计算机的特定目录中。 ","date":"2021-07-01","objectID":"/text22/:1:2","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"3、网站 （web site） ​ 也称站点，定义为已注册的域名、主页或web服务器。 ​ “网站 = 域名（网站地址）+ 网站空间” ​ 网站是一系列网页的组合，这些网站拥有相同或者相似的属性，并通过各种链接相关联。 相同或者相似的属性\r相同实现目的、相似设计、共同描述相关主导体\r浏览器 ——\u003e 地址栏 ——\u003e 网站地址 ——\u003e网络服务器 ——\u003e 默认网页（首页/主页） 浏览器作用\r浏览器：简译和显示 网页数据包\r","date":"2021-07-01","objectID":"/text22/:1:3","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"4、web标准 ​ 不是某一种标准，而是一系列标准的集合。 ​ “网页组成 = 结构 + 行为 + 表现” 对应三类标准： ​ 1、结构化标准语言：XHMTL、XML、【HTML: 超文本标记语言HyperText Markup Lauguage】 ​ 2、表现标准语言：CSS【Cascading Style Sheets 层叠样式表】 ​ 3、行为标准语言：对象模型W3C DOM 【Document Object Model 文档对象模型】、ECMAScript【API应用接口：连接“网站文件”与“js”的接口】 ","date":"2021-07-01","objectID":"/text22/:1:4","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"5、Inter网 ​ 由双绞线通过物理连接构成网。（路由器、交换机） ","date":"2021-07-01","objectID":"/text22/:1:5","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"6、http ​ 超文本传输协议资源 ","date":"2021-07-01","objectID":"/text22/:1:6","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"7、URL 统一资源定位符 ","date":"2021-07-01","objectID":"/text22/:1:7","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"8、UML 统一建模语言 ","date":"2021-07-01","objectID":"/text22/:1:8","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"9、DNS 域名解析服务器 ","date":"2021-07-01","objectID":"/text22/:1:9","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"10、网页工作原理 ​ 1、静态网页（工作原理） ​ 2、动态网页（工作原理） ","date":"2021-07-01","objectID":"/text22/:1:10","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"11、Java Script ​ 运行在客户端的一段程序。 ","date":"2021-07-01","objectID":"/text22/:1:11","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"12、架构 ​ BS架构：浏览器/服务器 ​ CS架构：客户端（下载APP）/服务器 ","date":"2021-07-01","objectID":"/text22/:1:12","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"13、网页图形图像处理工具 ​ 网页图形图像处理工具可以设计图像： ​ Fireworks （背景透明 jpg.不支持） ​ PhotoShop （背景透明 gif.动画 支持） ​ CorelDraw （背景透明 png.支持） ps处理图像 -使用位图 文件尾缀.psd 1024×768：表示横纵向像数点（位图放大会失真、会模糊） cd处理图像 - 使用矢量图算法记录图像的轮廓，内部颜色填充。文件尾缀 .cdr（随意放大，不会失真） ","date":"2021-07-01","objectID":"/text22/:1:13","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"14、网页维护 ​ 1、上传网页：ftp文件传输协议 ​ 2、网站管理员：修改文件 ​ 3、服务器管理员：远程桌面 ​ 4、 网站风格布局：位置、疏密、颜色、装饰、线条、排版 ","date":"2021-07-01","objectID":"/text22/:1:14","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"15、网页设计流程 目标 -图片- 加工-优化 色彩：暖色（红橙黄）、冷色（青、蓝）、中色（紫、黑、白） 色彩搭配：单色搭配、类比色（相近色、近似色120°内）搭配、互补色[搭配/对比]、三元配色 用户体验：浏览、相交互、信任 颜色的属性： ​ 色相：一个物体的颜色（H色相环） ​ 明相：亮度B ​ 纯色：相对于白色的亮度S 三元色：发光体（红、绿、蓝）、反射光（红【品红】、黄、蓝【青绿】） RGB色彩值：（#000000 黑、#666666 灰、 #FFFFFF 白）16进制、0~256、最大值为FF之间元素在此过渡 ","date":"2021-07-01","objectID":"/text22/:1:15","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"16、网页布局 “国”字型、“厂”字型、“框架”型、“封面”型（表格+框架+DIV+CSS） ","date":"2021-07-01","objectID":"/text22/:1:16","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"HTML编译规范 ","date":"2021-07-01","objectID":"/text22/:2:0","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"1、标签 标签：告诉浏览器以下是什么内容。（“英文、半角”下输入，不能有空格） \u003c起始标签\u003e 受标签影响的内容 \u003c/结束标签\u003e 单标记：类似于\u003c/p\u003e以下是一个段落、 \u003cbr/\u003e换行、 \u003cimg/\u003e引用图片 双标记：类似于\u003cfont\u003e\u003c/font\u003e文字 、\u003ctr\u003e\u003c/tr\u003e表格的一行、\u003ctd\u003e\u003c/td\u003e表格的一个单元格 【双标记要标识出作用范围】 ","date":"2021-07-01","objectID":"/text22/:2:1","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"2、属性 属性：告诉浏览器、以下内容如何显示 ①不同的标签有不同的属性，标签可以有很多种属性。 ②“属性”与“属性”之间由“空格”间隔。“属性”与“属性值”之间由“=”连接。 \u003c标签 属性1 = \"属性值1\" 属性2 = \"属性值2\" ...\u003e xxx \u003c/标签\u003e This is a warning\r像\u003cb\u003e \u003cstrong\u003e \u003ci\u003e \u003cem\u003e等与表现css标准有关的标签， 在软件改进中，或许可以生效，通常不再直接使用。 标签可以嵌套，但不允许交叉 显示文件后缀的方法：计算机 - 组织 - 查看 - 显示文件后缀。【直接改.txt 为 .html可以直接编译静态网页】 ","date":"2021-07-01","objectID":"/text22/:2:2","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"3、文档的基本结构 \u003c!-- 支持规范，符合html5 编写规范 --\u003e \u003c!DOCTYPE html\u003e \u003c!-- 告诉浏览器，以下是html代码，语言使用en --\u003e \u003chtml lang=\"en\"\u003e \u003c!-- 告诉浏览器房网页文档的相关信息 --\u003e \u003chead\u003e \u003c!-- 元标签，编码方式为“UTF-8” --\u003e \u003c!-- 修改页面编码方式：页面 - 编码 - UTF-8 --\u003e \u003c!-- 1B=8bt 指 1字节=8位 ，一般2个字节存放一个字符 --\u003e \u003c!-- ASCII编码，为2的8次方=256个字符对应不同的文字和字母 --\u003e \u003c!-- GB2312简体中文 --\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c!-- 网页名称，显示在每个打开在浏览器的页面标签头上 --\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003c!-- 告诉浏览器，放网页要显示的内容 --\u003e \u003cbody\u003e 网页内容 \u003c/body\u003e \u003c!-- 告诉浏览器，模版结束 --\u003e \u003c/html\u003e ","date":"2021-07-01","objectID":"/text22/:2:3","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"4、超链接标签（跳转页面） \u003c!-- a标签 表示“锚点标记”，即超链接标记 --\u003e \u003c!-- href地址属性 #内部的锚点名称标记 记号名：链接的目标+路径URL--\u003e \u003c!-- target打开窗口方式属性 _blank在新窗口打开 _self本窗口打开 --\u003e \u003c!-- 热点：点击时跳转的对象（可以是图片、文字） --\u003e \u003ca href=\"# 记号名\" target=\"_blank\"\u003e热点\u003c/a\u003e 点击的时候是图片（或者跳转链接是图片）： \u003ca href=\"C:\\Users\\Administrator\\Desktop\\123.jpg\" \u003e\u003cimg src=\"123.jpg\" \u003e\u003c/a\u003e 阐述【URL相对/绝对 路径】 网络路径：http://www.baidu.com - 在线网络文档路径（优点：不占空间。缺点：保证网络通畅、别人正常维护可访问） 本地路径：绝对路径 - 有盘符、斜杠方向向右（C:\\Users\\……\\xxxx.jpg） 相对路径 - 以编辑网页文件所在的文件夹位置为原点（../父级文件/父上一级）优点：加载快。缺点：位置不能随意更改） ","date":"2021-07-01","objectID":"/text22/:2:4","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"5、书签标记 \u003ca name=\"# 记号名\" \u003e目标文本附近的内容\u003c/a\u003e 例： \u003ca name=\"#z1\" \u003e第一章\u003c/a\u003e ","date":"2021-07-01","objectID":"/text22/:2:5","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"6、文字标签（排版） ①\u003cbr\u003e强制换行符 ②\u0026nbsp空格符 ③\u0026转义字符 ④lt小于 ⑤qt大于 ⑥;结束 ⑦\u003cnobr\u003e...\u003c/nobr\u003e不换行，当窗口大小化时 ⑧\u003c!-- 注释 --\u003e单行注释标记 ⑨\u003cp align=\"left/center/right\"\u003e……\u003c/p\u003e段落 - 段前，段后均会有一排空行，独占一行显示 ⑩\u003cdiv\u003e……\u003c/div\u003e独占一行显示，没有空行 ⑪\u003cpre\u003e……\u003c/pre\u003e预先排版标记，按照你输入进行排版，没有便会自动识别为所有格式为一个空格 ⑫\u003chr\u003e单标记，插入一条水平线，独占一行显示 （属性：位置、颜色、粗细。width没有宽度） ⑬\u003ch#\u003e标题，h#1~6字体的大小，\u003ch1\u003e……\u003c/h1\u003e一级标题 ⑭\u003cfont\u003e……\u003c/font\u003e字体标题，属性：size字体大小，1~7逐渐变大，color=颜色，face = 字体 ⑮ \u003csub\u003e……\u003c/sub\u003e下标标记 ⑯\u003csup\u003e……\u003c/sup\u003e上标标记 ","date":"2021-07-01","objectID":"/text22/:2:6","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"7、图片标签 图片标签\u003cimg\u003e跟属性 \u003cimg src=\"\" - 图片的路径 width=\"\" - 宽：默认单位为像素 height=\"\" - 长：默认单位为像素 border=\"\" - 边框宽度 hspace=\"\" - 图片与文字之间、留白设置（xx像素） vspace=\"\" - 垂直方向上、留白设置 align=\"\" - 环绕方式（left/right）、对齐方式（top/mindle/bottom） alt=\"\" - 简单说明（无法正常显示的时候给出的提示） title=\"\" - 简单说明（鼠标移动到正常上出现的说明文字） usemap=\"\" - 分隔一张图中的各个板块 /\u003e \u003c!-- name定义地图的名称 --\u003e \u003cmap name=\"\"\u003e\u003c/map\u003e \u003c!-- shape 形状（circle圆形/ rect矩形 / poly多边形）--\u003e \u003c!-- coords 位置：圆（圆心坐标x轴,圆心坐标y轴,半径）、矩形（左顶点左边,右顶点坐标）--\u003e \u003c!-- href 链接--\u003e \u003carea shape=\"\" coords=\"\" href=\"\" alt=\"\"\u003e \u003c!-- 左顶格、上顶格 --\u003e \u003cbody leftmargin=\"0\" topmargin=\"0\"\u003e \u003c/body\u003e ","date":"2021-07-01","objectID":"/text22/:2:7","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"8、表格标签 表格标签\u003ctable\u003e \u003ctable border=\"\" - 表格的边框 width=\"x|x%\" - 是body的百分比，占父级容器的百分比 cellspacing=\"\" - 单元格的间距 cellpadding=\"\" - 内容和边框的间距 colspan=\"\" - 占2个横向单元格 rowspan=\"\" - 占2个纵向单元格 \u003e \u003ctr\u003e \u003ctd\u003e\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003ccaption\u003e显示表格的标题\u003c/caption\u003e可以写在所有的\u003ctr\u003e之前或者之后，但不可以写在之间 background背景图片，\u003ctr\u003e表示单元格表头，默认会加粗、居中显示 属性：（●disc ○circle） ","date":"2021-07-01","objectID":"/text22/:2:8","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"9、表单 表单：收集客户端信息发送给服务器的某个动态网页的目标程序，完成客户端与服务器之间的交互。 \u003cform name=\"\" - 表单名称 action=\"\" - URL路径，当action为空时，传递给自己 method=\"\" - 用什么方式进行传输 get/post ，get：以明文字符串进行传输≤256字符，post以表单整体进行传输 \u003e \u003c/form\u003e 注：①一切内容都要在“表单之内”才能被提交 ②一个网页可以有多个表单 ③表单只是一个区域、内容需要加入表单元素 ④表单内的元素 一定要有名称 才能被提交 input输入框 \u003c!-- 下面都是表单元素 --\u003e \u003cinput type=\"text\" name=\"text\"\u003e \u003c!--单行文本≤255个字符 --\u003e \u003cinput type=\"button\" value=\"按钮\" name=\"button\"\u003e \u003c!-- 按钮类型 --\u003e \u003cinput type=\"submit\" value=\"提交\" name=\"submit\"\u003e \u003c!-- 提交类型--\u003e \u003c!-- 表单输入框元素的详解 --\u003e \u003cinput type=\"表项类型\" - password 密码类型 、reset重置类型(使表单回到初始状态)、radio单选框、checkbox多选框、hidden隐藏域、date时间域、file文件选择框、image图片作为按钮 name=\"表项名\" - 一组单选框的name必须相同，不同组的单选框name必须不相同 value=\"默认值\" - 初始值 size=\"x\" - 控制输入框的大小，单位为“x”个字符 maxlength=\"y\" - 最大输入长度，单位为“y”个字符 \u003e \u003cinput type=\"button\" - 点击触发onclick事件 value=\"\" - 按钮名字 onclick=\"\" - 事件函数 readonly=\"\" - 只读 true/false disabled=\"\" - 不可更改，框为灰色 \u003e 文本域 \u003c!-- name名称 rows行数 cols列数 --\u003e \u003ctextarea name=\"\" id=\"\" rows=\"\" cols=\"\"\u003e多行文本\u003c/textarea\u003e 选择栏 \u003c!-- name传输的名称 size可选择的个数：1单选 2多选 --\u003e \u003cselect name=\"\" id=\"\" size=\"\" multiple=\"\"\u003e \u003c!-- 下拉框 可选择的内容 --\u003e \u003coption value=\"\"\u003exxx\u003c/option\u003e \u003c/select\u003e 列表标签 \u003c!-- 列表格式显示为：项目符号 列表项 --\u003e \u003c!-- 有序列表 ol--\u003e \u003col\u003e \u003cli start=\"开始序号\"\u003e列表项1\u003c/li\u003e \u003cli start=\"1\"\u003e列表项2\u003c/li\u003e \u003cli\u003e列表项3\u003c/li\u003e \u003c/ol\u003e \u003c!-- 无序列表 ul --\u003e \u003cul\u003e \u003cli type=\"符号类型\"\u003e列表项1\u003c/li\u003e \u003cli type=\"disc\"\u003e列表项2\u003c/li\u003e \u003cli type=\"disc\"\u003e列表项3\u003c/li\u003e \u003c/ul\u003e 注意！！！\r注：html中是无法使用图片作为项目符号的！！ \u003c!-- 去掉无序前面的点 --\u003e \u003cstyle\u003e ul li { list-style: none; } \u003c/style\u003e ","date":"2021-07-01","objectID":"/text22/:2:9","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"CSS部分 ","date":"2021-07-01","objectID":"/text22/:3:0","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"一、基本选择符 1、标签选择符（所有的读标签下都使用这个样式）【4】 //html中标签的名字 标签{属性：属性值} 例： td { width : 100px } 2、class类选择符（自由定义）【2】 //class=\"自定义的名称\"（字母开头，下划线数，数字） ·类名称{属性：属性值} 例： \u003cp class=\"abc\"\u003e\u003c/p\u003e .abc{ font-size : 18px} 3、id选择符（能且只能使用一次）【1】 #id名{属性：属性值} 例： \u003cp id=\"abc\"\u003e\u003c/p\u003e #abc{ font-size : 18px} 4、复合选择符【3】 ①“交集”选择符（两个基本选择符、直接连接、且同时满足 ） ②“并集”选择符（两者择其一） ③“后代/包含”选择符（x y{ }，表示在x中的y标签，应用{ }中的样式内容） 5、标签默认样式【5】 This is a tip\r【编号】中的数字表示层叠使用时的优先级。若要提高优先级，则需要使用\u003c!important\u003e\r","date":"2021-07-01","objectID":"/text22/:3:1","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"二、 css层叠样式表 1、后缀.css层叠样式表（格式设定） 层叠：发生样式冲突时，系统以上面编号的优先级进行展示 继承：\u003cdiv\u003e\u003cp\u003e\u003c/p\u003e\u003c/div\u003e继承父级的样式设定 将css文件单独拎出来，放置在html文件的同级根目录下，可以使用style引用该路径下的css使得多个html同时可以使用同一个css css实现的4种形式 ①行内样式表 \u003c!-- style=\"\"双引号中的内容，即为css代码 --\u003e \u003cdiv style=\"font-size: 10px;color: black;\"\u003e\u003c/div\u003e ②内部样式表 \u003c!-- 放在html的head中 --\u003e \u003chead\u003e \u003c!-- 使用style标签，之间为css代码 --\u003e \u003cstyle\u003e div{ font-size: 10px; color: black; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e\u003c/body\u003e ③链入外部样式表 \u003c!-- 引用同级根目录下的css文件 --\u003e \u003clink rel=\"stylesheet\" href=\"根目录.css\" type=\"text/css\"\u003e ④导入外部样式表 \u003c!-- 这种引入外部css的方法必须写在第2种的前面才会生效 --\u003e \u003cstyle @import url=\"根目录.css\"\u003e\u003c/style\u003e 2、通用选择符* ：所有的网页元素都会被改变 3、属性选择符：【优先级高于标签选择符】 格式为：元素[属性] 或者 元素[属性 * = 属性值] ， 例：E[alt]{ css代码 } 如果我们用E代表元素、alt代表属性、val代表属性值。则下面： E [alt] { } - 属性名选择符 E [alt = val] { } - 属性值选择符 E [alt ~ = val ] { } - 属性值选择符（其中一个匹配） E [alt 1 = val ] { } - 属性值选择符（连字符匹配、空白匹配） E [alt = val- ] { } - 属性值选择符（连字符匹配、空白匹配） E [alt^ = val ] { } - 属性值子串选择符（前缀匹配） E [alt$ = val ] { } - 属性值子串选择符（后缀匹配） E [alt* = val ] { } - 属性值子串选择符（子字符串匹配） 4、伪类选择符 UI元素 - 表单元素 ： hover：当鼠标移动到上面的时的状态 fous：当聚焦在上面时的状态 active：按下激活时的状态 link：未访问时的状态 锚点标签： a : link { } 未访问的链接状态 a : visited { } 已访问的链接状态 a : hover { }鼠标悬停在链接上的状态 a : active { }被激活的链接状态 text-indent : 2em ; 文章首行缩进：2个字符 色彩RGB rgba函数（R G B A ）A为透明通道，也叫透明度 == filter : opacity(0.5) 透明滤镜 This is a tip\r①HTML： 超文本标记语言【不是编程语言】，【超文本】比普通文本功能更高的文本文件，【标记语言】使用一组标签对内容进行描述的语言 ②语法规范： A、后缀为 -.html 或 -.htm B、头文件 + 体文件（head + body） C、开头标签 + 结束标签 D、不区分大小写，常用小写 ③JavaScript语法规范 变量（字母、数字、下划线）区分大小写，toSum：以小驼峰来进行命名，尽量避免使用a，b，c这种单字母命名。 ","date":"2021-07-01","objectID":"/text22/:3:2","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"三、CSS盒模型 针对块级元素 {padding：__ } 一个值：上下左右 {padding：__ __ } 两个值：上下/左右 {padding：__ __ __ __ } 四个值：上/下/左/右 我们一般用类似于3px这样的长度单位来设定css盒模型某元素属性的长宽，由此这里对长度单位进行了梳理 长度单位有： em - 首行缩进 - 相对长度单位 px - 像素 - 绝对长度单位 pt - 点 - 绝对长度单位 in - 英寸 - 绝对长度单位 cm - 厘米 - 绝对长度单位 css中的一些属性: 1、brackground-image:url(跟图片的位置) 2、【居中】margin: 0px auto 上下间距为0，左右平均分配 3、【两端对齐】text-align: justify 4、【首字下沉】first-letter 5、【设置行高】line-height：length| normal 6、【设置文本换行】word-warp：normal|break-word 7、【设置图像位置】background-position（百分比/长度） 长度：左上角顶点距离背景两边移动的长度 百分比：中心与中心重叠，占整体的百分比大小 边框属性： 1、所有边框宽度（border-width）：1+7同时使用、才有效果 medium - 默认宽度 thin - 小于默认宽度 thick - 小于默认宽度 length - 数字+单位标识符（长度值），不可为负值 （4个）上下左右 、 （2个）上下/左右 、（1个）四周、（3个）上/左右/下 2、上边框宽度（border-top）：border-width || border-style || border - color 3、右边框宽度（border-right） 4、左边框宽度（border-left） 5、下边框宽度（border-bottom） 6、边框颜色（border-color）： 6和7一起使用 7、边框样式（border - style）：是个复合属性 none 无边框样式 solid实线 hidden 隐藏样式 double 双线 dotted 点虚线 groove 三维凹槽 inset 三维凹边 outset三维凸边 dashed 长矩线 ridge 菱形边框 使用时+height + width 设定position：absolute 内边距 内边距padding，和内容在一层，且不允许为负数 上内边距padding-top 下内边距padding-bottom 左内边距padding-right 右内边距padding-right 外边距 外边距margin length：数字+单位标识符（长度值/百分比） 上外边距margin-top 下外边距margin-bottom 左外边距margin- left 右外边距margin-right 定位方式 定位方式position width宽 height高 min-height最小高度 static【默认】静态定位/无特殊定位 relative 相对定位（左、右）表偏移量 absolute 绝对定位（上、下、左、右）属性 fixed 绝对定位（相对于浏览器窗口）-固定定位 z-index浮动序列 可见性 可见性visibility inherit 继承上一个对父对象的可见性 visible 对象可见 collapse 隐藏表格的行列 hidden 对象隐藏 水平叠加问题 span1\\span2 :两个行级元素紧邻不重叠 垂直叠加问题 div1/div2 ：两个块级元素垂直相遇，会产生叠加，形成一个新的外边距，以大的为准 div1/div2：两个块级元素包含相遇，也会产生叠加，面积以大的为准 浮动清除浮动 浮动float none不浮动 left向左浮动 right向右浮动 清除浮动clear none允许浮动 left清除左浮动 right清除右浮动 both两边均清除 ","date":"2021-07-01","objectID":"/text22/:3:3","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"div+css布局 常见的“三行两列”布局 文本控制 文本控制font font-family 字体名称类别 font-size 字体尺寸||绝对尺寸||相对尺寸 12px正文文字大小 font-weight 字体的粗细（bold粗体，normal默认400、number、lighter默认细、100~900越小字体越细） font-style 字体的倾斜（normal默认、italic斜体、obligue倾斜体） color 颜色值 background-color（color颜色、transparent透明） text-decoration文本的修饰（underline下划线、blink闪烁、overline上划线、line-through贯穿线、none无装饰） 段落控制 段落控制text text-align 设置文本的水平对齐方式 （left左对齐、right右对齐、center居中、justify两端对齐） text-indent 设置段落的首行缩进 first-letter 设置首字母下沉 line-height 设置行高 letter-spacing 设置字符间距（word-spacing：length|normal词间距） text - overflow 设置文字的截断（clip 简单的裁切、不能显示省略标记 | ellipsis 文本溢出时 显示省略标记 ） background-image 背景图像设置（URL+none） background-repeat 图像重复方式（no-不平铺、-x水平平铺、~-y垂直平铺） ","date":"2021-07-01","objectID":"/text22/:3:4","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"JavaScript部分 JavaScript网页行为语言（代码区分大小写） 核心部分：ECMAScript核心、BOM、DOM（包含：基本语法、变量、关键字、保留字、数据类型、语句、函数） ——是基于对象和事件驱动、并具有相对安全性的客户端脚本语言 使用的三种方法 直接加入HTML文档 \u003cscript type=\"text/javascript\"\u003e ....js代码 \u003c/script\u003e 链接脚本文件 \u003chead\u003e \u003cscript type=\"text/javascript\" src=\"脚本文件名.js\"\u003e\u003c/script\u003e \u003c/head\u003e 在HTML标签内添加脚本，在HTML表单的输入标签内添加脚本 javascript交互基本方法 document.write() 文档输出函数 alert() 窗口对象方法（对话框） confirm() 选择对话框（提示文字） prompt() 提示文字内容对话框 javascript相关概念 变量 变量：开辟在内存中的一块空间 变量声明 var \u003c变量\u003e[=值] //（任何）变量声明的关键词、弱变量，不区分数据类型 数据类型 整形 浮点型 字符串型 表达式/运算符 取反 - ! “或”用于嵌套 基本编程命令/语句 单行注释 // 多行注释 /*。。。*/ 转义字符 \\ \\\" 双引号 \\' 单引号 \\n 换行 \\r 回车 条件结构if if(i%10 == 0) cout \u003cbr\u003e //每10个换行 循环结构for for(变量=初始值;循环条件;循环变量的改变) {\u003c语句\u003e} ----------------------------------- while(循环条件) break 直接中断，跳出 continue 只中断该次循环 函数function 有返回值的称为函数，没有返回值的称为操作 函数名(形参) {函数体;} haha(a,b){return a+b;} 调用方式： 返回值 = 函数名(参数1,参数2) b = haha(data1，data2) 全局变量：函数在方法外声明的变量 局部变量：函数内部声明的变量（在函数被调用时激活，才开辟一个存储单元，在函数结束时被释放） 递归 递归调用 - 递归体 - 出口 //阶乘 function jc(n){ if(n=1){ return 1; //留出口，否则死循环 }else{ return n*jc(n-1); //调用自身函数，以形成递归体 } } docment.write(jc(5)); 面向对象的程序设计 对象：属性+方法+事件 number对象 number对象为【数值】，可以使用toString()：将数值转化为字符串 String对象 String对象【字符串】属性： length()：返回字符串的长度 chatAt(*) ：返回 * 所在位置的字符，下标从0开始 chatCodeAt(*)：返回 * 所在位置字符的ASCII码 indexOf(**)：返回 xx所在位置的下标，找不到返回“-1” lastIndexOf(xx，x)：同上，下标也同上，只是倒序查找 split()：返回一个数组 join()：将一个数组返回字符串 Substring(始，终)：截取字符串 substr（始，长度）：截取子字符串 toUpperCase()：小写全转化大写 Array对象 Array对象【数组】属性 var \u003c数组名\u003e = new Array(); //javaScript中数组没有二维数组 Math对象 Math对象【数学】属性 E 返回e=2.71828…. PI 返回π = 3.1415926… random() 返回0到1中的一个随机数 parseInt 构造整数、取整 parseInt(Math.random()*(100-60)+60) //生成60-100间的随机整数 round() 四舍五入 Date对象 Date对象【日期】 var d = new Date(); //获取当前客户端的时间 g/set[UTC]year - 设置年份 g/set[UTC]month - 设置月份 g/set[UTC]Date- 设置日 g/set[UTC]Day- 设置星期几 Global全局对象 eval() 字符串当作表达式处理 parseInt() 括号内的转化为数值（整数），若以字母开头，返回“NAN” parseFloat() 转化为浮点数 toString() 转化为字符串 Dom文档对象 Dom是Bom中的一小部分 Bom浏览器对象（navigate 浏览器对象、screen屏幕对象、window窗口对象：“history历史、location地址、document文档”） Dom（open打开一个窗口）（open（\u003cURL字符串\u003e,\u003c窗口名称字符串\u003e,\u003cxx属性\u003e）） menubar = \" no \" 无菜单栏 toolbar 工具栏 scrollbar滚动条 resizable 可拉动 location 地址栏 d.导航栏 navigate 浏览器对象 appCodeName 返回“码名” appName 返回“浏览器名称” appVersion 返回“浏览器版本” javaEnable 返回“一个布尔型，允不允许使用java” window窗口对象 Name 窗口的名称 Status “状态栏” 可读可写，在最下方 opener 返回打开该窗口的上一窗口 close 关闭一个打开的窗口 window.close() //self.close //setInterval(\"funl,time\")定时器（函数体，时间，单位毫秒） blur() 失去焦点 focus() 获得焦点 scrollTo() 滚动到 scrollBy() 滚动多少 reSizeTo() 调整到 setInterval（funl，time）每隔多少时间执行该函数 setFimeout（funl，time）延迟多少时间执行该函数 history历史对象 length - 访问的窗口数 back - 后退 forward - 前进 history.go(x) - 前进到第x个窗口 history.go(0) - history.reload - 刷新 location地址栏对象 protocol - 返回协议 hostname - 返回地址的主机名 port - 地址端口 host - 地址路径 document文档对象 lastModified - 输出到修改网页最后一次的时间 referrer - 返回打开它的网页窗口 tittle - 返回tittle的名称 fgcolor - 文字颜色 bgcolor - 背景颜色 write() - 输出一个文档流（在\u003c/html时结束）（\u003chtml到\u003c/html算一个文档流，文档流结束会新开一个窗口） getElementById() 通过ID来获取网页上的元素 getElementByName() 通过名称ID来获取网页上的元素 body.clientwidth() / clientwidth() 获取客户端网页窗口大小 offsettop()、offsetleft()、offset() 获取匹配元素在当前视的相对偏移 内联元素 内联元素（行内元素） -属性display：inline； 这个属性能够修复著名的IE双倍浮动边界问题（html规范中的概念-外文名：inline element） 内联元素又名行内元素和其对应的是块元素 内联元素的显示，为了帮助理解，可以形象的称为“文本模式”。即一个挨着一个，都在用一行按从左至右的顺序显示，不单独占一行。display：vnone表示隐藏 加入css控制 内联元素+display = block属性，可以从新行开始 ；块元素+display = inline属性，可以在一行上排列 常见的块级元素address地址/特点：总是在新行上开始 内联元素（特点） 和其他元素都在一行上（左右可以改变设置） 高度，行高和顶以及底边距都不可改变 宽度就是它的文字或图片的宽度不可改变 总的来说，内联元素一般都是基于语义级的基本元素，它只能容纳“文本或其他内联元素，通常被包括在块级元素中使用，常见的内联元素： a - 锚点 b - 粗体 br - 换行 font - 字体 abbr - 编写 acronym - 首字母 big - 大字体 cite - 引用 em - 强调 块级元素 块级元素特点： 总是在新行上开始 高度、行高以及外边距和内边距都可以控制 宽度缺省是它的容器的100%，除非设定一个宽度 它可以容纳内联元素和其他块元素 常见的块级元素： address - 地址 blockquote - 块引用 center -居中对齐块 div - 常用块容器 h1 - 一级大标题 HBuilder：编写软件（放html代码，生成js文件） frameset框架集： \u003c!--横向分割--\u003e \u003cframeset row=\"20%,*\"\u003e \u003cframe src=\"上\"\u003e\u003c/frame\u003e \u003c!--纵向分割--\u003e \u003cframeset cols=\"20%,*\"\u003e \u003cframe src=\"左\"\u003e\u003c/frame\u003e \u003cframe src=\"右\"\u003e\u003c/frame\u003e \u003c/frameset\u003e \u003c/frameset\u003e 图解： 如何控制表单提交？ 关于事件onsubmit：一般用于表单提交的位置 那么需要在定义函数的时候，给出一个返回值 onsubmit = return checkForm()； 返回","date":"2021-07-01","objectID":"/text22/:3:5","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["SQL"],"content":"Oracle查询sql 查询系统当前日期 select sysdate from dual; 请查询每个员工的名字、薪水和加薪15.5%之后的薪水（trunc取整） Select 名字,薪水,trunc(薪水*1.155) \"new salary\" from employees; 请显示所有以’J’，‘A’，‘M’打头的员工的名字和名字长度，且按照名字排升序 select 名字,LENGTH(名字) from employees where substr(名字,0,1) in ('J','A','M') order by 名字 asc; 请查询员工名和工作时间（换算成月并取整），并按工作时间排降序 Select 名,trunc(months_between(sysdate,时间),0) from employees order by trunc(months_between(sysdate,时间),0) desc; 请查询员工的名字和薪水，并将薪水列变成15个字符长度，左边填充“$”符号 select 名字,lpad(薪水,15,'$') from employees; 请查询部门id为90的所有员工的名字和他们参加工作的星期数(保留2位小数，不需要四舍五入)使用 select 名字 , trunc((参加工作星期数)/7,2) from employees where 员工id=90 创建报告，显示员工名和奖金系数,如果奖金系数为空,则显示$无奖金 select 名字,decode(奖金系数,'','无奖金',奖金系数) from employees; 请使用case语句，查询员工的job_id和级别.例如: select t.job_id, decode(t.job_id, 'AD_PRES', 'A','ST_MAN', 'B','IT_PROG', 'C','SA_REP', 'D','ST_CLERK', 'E','0') from employees t; 或者 Select job_id, case job_id when 'AD_PRES' then 'A' when 'ST_MAN' then 'B' when 'IT_PROG' then 'C' when 'SA_REP' then 'D' when 'ST_CLERK' then 'E' else '0' end \"Grage\" from employees; ","date":"2021-07-01","objectID":"/text18/:0:0","tags":["sql","Oracle"],"title":"【SQL语句】Oracle查询sql","uri":"/text18/"},{"categories":["SQL"],"content":"一、聚合函数 有一个学生表如下： ","date":"2021-07-01","objectID":"/text11/:1:0","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"count 1、统计记录总个数 SELECT COUNT (*) FROM 学生表 若要命名 SELECT COUNT (* ) as 学生总人数 FROM 学生表 2、统计指定列的值的数目（NULL 值不计入） SELECT COUNT (专业代码) FROM 学生表 3、统计指定列，拥有不同值的数目（NULL 值不计入） SELECT COUNT (distinct 专业代码) FROM 学生表 ","date":"2021-07-01","objectID":"/text11/:1:1","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"sum 4、计算某一列值的总和 SELECT sum(高考分数) as 高考总分数 FROM 学生表 ","date":"2021-07-01","objectID":"/text11/:1:2","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"MAX、MIN、AVG 5、求某一列值的最大值 This is a tip\rMAX 函数返回一列中的最大值。NULL 值不包括在计算中。 注释：MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。 SELECT MAX(高考分数) as 高考最高分数 FROM 学生表 6、求某一列值的最小值 SELECT MIN(高考分数) as 高考最低分数 FROM 学生表 7、求某一列值的平均值 SELECT AVG(高考分数) as 高考最高分数 FROM 学生表 ","date":"2021-07-01","objectID":"/text11/:1:3","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"FIRST、ROUND 6、取指定字段的第一个记录的值 select first(column_name) from table_name 7、ROUND() 函数（四舍五入规则）、用于把数值字段舍入为指定的小数位数。 SELECT round(列名,小数位数) FROM table_name ","date":"2021-07-01","objectID":"/text11/:1:4","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"MID 8、MID() 函数 ：用于从文本字段中提取字符。 SELECT MID(列名,开始截取位置,结束截取位置) FROM table_name This is a tip\rSELECT MID(列名,1,3) FROM table_name 3不写，默认返回剩余的所有字段 ","date":"2021-07-01","objectID":"/text11/:1:5","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"LEN 9、LEN 函数返回文本字段中值的长度。 SELECT LEN(列名) FROM table_name ","date":"2021-07-01","objectID":"/text11/:1:6","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"二、数据库查询前10条数据 Oracle中查询 select * from table where rownum\u003c=10; DB2中查询 select * from table fetch first 10 rows only; MySql中查询 select * from table limit 10; ","date":"2021-07-01","objectID":"/text11/:2:0","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"三、SQL语言多表关联查询 一、外连接 外连接可分为：左连接、右连接、完全外连接。 select * from A表 left join B表 on A表条件 = B表条件 This is a tip\r左外连接包含left join左表所有行，如果左表中某行在右表没有匹配，则结果中对应行右表的部分全部为空(NULL) select * from A表 right join B表 on A表条件 = B表条件 This is a tip\r右外连接包含right join右表所有行，如果左表中某行在右表没有匹配，则结果中对应左表的部分全部为空(NULL)。 select * from A表 full join B表 on A表条件 = B表条件 This is a tip\r完全外连接包含full join左右两表中所有的行，如果右表中某行在左表中没有匹配，则结果中对应行右表的部分全部为空(NULL)，如果左表中某行在右表中没有匹配，则结果中对应行左表的部分全部为空(NULL)。 二、内连接 join 或 inner join select * from A表 join B表 on A表条件 = B表条件 This is a tip\rinner join 是比较运算符，只返回符合条件的行。\r","date":"2021-07-01","objectID":"/text11/:3:0","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["服务器"],"content":"打开命令行，输入mstsc 点击确认 出现以下界面 输入ip地址及端口号，然后点击连接 提示页面均点，连接 提示页面均点，是 输入用户名和密码即可 ","date":"2021-07-01","objectID":"/text06/:0:0","tags":["远程"],"title":"【服务器】远程登陆服务器教程","uri":"/text06/"},{"categories":["计算机网络"],"content":"路由表 路由表操作 ipconfig route print route delete 0.0.0.0 route delete 10.163.0.0 route delete 10.164.0.0 route delete 10.160.0.0 route delete 10.1.0.0 route add -p 0.0.0.0 mask 0.0.0.0 192.168.9.1 metric 20 route add -p 10.163.0.0 mask 255.255.0.0 192.168.8.1 metric 30 route add -p 10.164.0.0 mask 255.255.0.0 192.168.8.1 metric 30 route add -p 10.160.0.0 mask 255.255.0.0 192.168.8.1 metric 30 route add -p 10.1.0.0 mask 255.255.0.0 192.168.8.1 metric 30 ","date":"2021-07-01","objectID":"/text21/:0:0","tags":["路由"],"title":"【计算机网络】路由表","uri":"/text21/"},{"categories":null,"content":"此网站建立于2024年七夕…… ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我们","uri":"/about/"},{"categories":null,"content":"\rHugo\rhugo官方文档中文版\rLovelt\r一个简洁、优雅且高效的 Hugo 主题\r","date":"0001-01-01","objectID":"/friend/:0:0","tags":null,"title":"友情链接","uri":"/friend/"}]