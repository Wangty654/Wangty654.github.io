[{"categories":["后端"],"content":"【Spring-boot】启动报错注入bean失败Mapper找不到 报错信息： A component required a bean of type ‘com...Mapper‘ that could not be found. Consider defining a bean of type ‘com.yinhai.msg.localResource.msgtpl.mapper 检查配置： pom文件（项目总） \u003cmodules\u003e ..... \u003cmodule\u003emsg-center\u003c/module\u003e ..... \u003c/modules\u003e pom文件（项目启动类） \u003cdependencies\u003e .... \u003cdependency\u003e \u003cgroupId\u003ecom.yinhai\u003c/groupId\u003e \u003cartifactId\u003emsg-center\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e .... \u003c/dependencies\u003e pom文件（所在包） \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cparent\u003e \u003cgroupId\u003ecom.yinhai\u003c/groupId\u003e \u003cartifactId\u003eyhch-base-backend\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cartifactId\u003emsg-center\u003c/artifactId\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.yinhai\u003c/groupId\u003e \u003cartifactId\u003ecommon\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e application-datasource.yml （启动类配置文件） ta404: datasource: datasource-list: * type: * druid: ta404ds: datasource: url: jdbc:oracle:* username: * password: * # 初始化连接数 initial-size: 5 # 连接池最大连接数量 max-active: 20 # 获取链接超时时间 （毫秒） max-wait: 60000 mybatis: mapper-locations: # mapper映射文件路径 - classpath*:mapper/msg-center/**.xml base-packages: # 包路径 - com.yinhai.msg.**.mapper mybatis-plus: db-type: oracle ","date":"2024-10-11","objectID":"/text28/:0:0","tags":["Spring-boot"],"title":"【Spring-boot】启动报错注入bean失败Mapper找不到","uri":"/text28/"},{"categories":["office基本操作"],"content":"\rThis is a tip\rword 页码不连续可通过以下步骤解决：1. 检查并删除分节符；2. 更改页码格式为连续编号；3. 更新整篇文档页码；4. 检查页眉或页脚中的页码设置，确保与正文一致；5. 取消页眉或页脚之间的链接。\r1. 检查分节符： 分节符可以将文档分成不同的部分，每个部分可以有自己的页码。 将光标放在页码中断处，然后转到“布局”选项卡 \u003e “分隔符”组。 如果有分节符插入，请删除它。 2. 更改页码格式： 转到“插入”选项卡 \u003e “页码”组。 选择“页码格式”选项，然后选择连续页码选项。 确保“页码起始编号”设置为 1。 3. 更新页码： 更新页码后，需要更新整个文档的页码。 转到“插入”选项卡 \u003e “页码”组，然后单击“更新页码”。 选择“更新整篇文档”选项。 4. 检查页眉或页脚： 有时，页眉或页脚中的页码设置可能与文档正文不匹配。 双击页眉或页脚区域进行编辑。 检查页码设置是否正确，并将其与文档正文中的页码保持一致。 5. 取消链接页眉或页脚： 如果页眉或页脚之间存在链接，可能会导致页码不连续。 双击要更改页眉或页脚的页面。 转到“设计”选项卡 \u003e “页眉和页脚”组，然后取消选中“链接到前一节”复选框。 ","date":"2024-10-08","objectID":"/text27/:0:0","tags":["office"],"title":"【word文档】word页脚页码不连续解决办法","uri":"/text27/"},{"categories":["Hugo系列"],"content":"hugo访问统计功能 由于静态网站静态的属性，所以一些动态的内容，如评论、计数等模块就需要借助外来平台。而不蒜子就是这么一个访问统计模块，但与百度统计谷歌分析不同的是，它可直接将访问次数显示在在网页上。因此我们可以通过不蒜子快速便捷地添加访问统计功能。 当然除了不蒜子，valine 评论系统也附带了单页的阅读人数统计。但是由于不蒜子除了单页的阅读人数统计还可以提供全站的访问统计，外加我用的不是 valine 评论系统，所以不蒜子是更加普适且好用的访问统计模块。 在下文中，由于不涉及主题的参数，所以有可能很多的 Hugo 主题都适用，但本文仍以 LoveIt 主题为例。 ","date":"2024-09-13","objectID":"/text24/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加 Html 模板 在your_site\\layouts\\partials\\plugin\\路径下添加文件busuanzi.html，并将下面的配置输入至该文件 在配置文件中添加参数 找到your_site\\config.toml配置文件，在最后面添加不蒜子的参数如下： # 添加不蒜子计数 [params.busuanzi] enable = true # 是否开启全站独立访客数 site_uv = true # 全站独立访客数前的图标或提示语 site_uv_pre = '\u003ci class=\"fa fa-user\"\u003e\u003c/i\u003e' # 全站独立访客数后的图标或提示语 site_uv_post = '' # 是否开启全站浏览量 site_pv = true # 全站浏览量前的图标或提示语 site_pv_pre = '\u003ci class=\"fa fa-eye\"\u003e\u003c/i\u003e' # 全站浏览量后的图标或提示语 site_pv_post = '' # 是否开启单页浏览量 page_pv = true # 单页浏览量前的图标或提示语 page_pv_pre = '\u003ci class=\"far fa-eye fa-fw\"\u003e\u003c/i\u003e' # 单页浏览量后的图标或提示语 page_pv_post = '' ","date":"2024-09-13","objectID":"/text24/:1:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"在对应处引入不蒜子 开启页脚的全站统计 把your_site\\themes\\LoveIt\\layouts\\partials\\footer.html复制粘贴到路径your_site\\layouts\\partials\\下。 再修改文件your_site\\layouts\\partials\\footer.html，在最后三行 \u003c/div\u003e \u003c/footer\u003e {{- end -}} 的前面添加 {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.busuanzi \"bsz_type\" \"footer\") -}} 添加后代码如下图： 最后的呈现结果如下图： This is a tip\r如果只想简单地开启全站统计，我们可以忽略## 添加 Html 模板和## 在配置文件中添加参数，直接从开启页脚的全站统计开始，但需把要添加的 {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.busuanzi \"bsz_type\" \"footer\") -}} 换为 \u003cscript async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"\u003e\u003c/script\u003e \u003cspan id=\"busuanzi_container_site_pv\"\u003e \u003ci class=\"fa fa-eye\"\u003e\u003c/i\u003e \u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e 次 \u003c/span\u003e | \u003cspan id=\"busuanzi_container_site_uv\"\u003e \u003ci class=\"fa fa-user\"\u003e\u003c/i\u003e \u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e 位 \u003c/span\u003e 但这种方法不好添加单页阅读 开启单页的阅读统计 把your_site\\themes\\LoveIt\\layouts\\posts\\single.html复制粘贴到路径your_site\\layouts\\posts\\下。再在your_site\\layouts\\posts\\single.html中找到第二个\u003cdiv class=\"post-meta-line\"\u003e标签，并在该标签下添加下面的代码 {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.busuanzi \"bsz_type\" \"page-reading\") -}} 添加后代码如下： 最后的呈现结果如下图： This is a tip\r参考文章：不蒜子官方\r","date":"2024-09-13","objectID":"/text24/:1:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"Permalinks 参数修改 修改这个参数，可以使我们之后修改网站文章的 url 更便捷，不需再采用hugo new posts/your_post.md新建文章的方式来修改，我们甚至还可以做到文章文件名与其 url 不一致。 This is a tip\r文章文件名就是指你使用hugo new posts/your_post.md后生成的文章的文件名，本例子中是your_post；而网站文章 url，是指这篇文章在你的 blog 网站中的 url，在本例中如果按照 LovIt 主题默认的方式，那么网站文章 url 为 https://stilig.me/your_post/\r","date":"2024-09-13","objectID":"/text24/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 Permalink 配置 找到博客根目录下的配置文件your_site/config.toml，找到参数Permalinks，按照下面的代码块修改： # Permalinks 配置 [Permalinks] # 原来是 posts = \":filename\"，其意为以文件名为 url posts = \"/posts/:slug\" # 如果你不想改变原来的 url（比如说文章已被搜索网站收录）,可以去掉/posts/，那么其将变为 posts= \":slug\" ","date":"2024-09-13","objectID":"/text24/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"将 slug 参数添加至.md文件的模版 在你博客的根目录下找到your_site\\archetypes\\default.md并打开，把 slug 参数 添加到 title 参数下，如下代码块： --- title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" slug: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" \u003c!-- 注意：这里 \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" 表示参数取文章的文件名，这只是为了防止参数为空而设定的默认值 --\u003e ... ... --- 这样我们新建的文章中就都会有 slug 参数了，然后我们只需要修改slug=\"\" 的\"\"中的值，就可以改变文章 url 了。 而对于之前那些文章，我们也只需要在文章头中添加参数 slug 就可以了，如下图： ","date":"2024-09-13","objectID":"/text24/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加自定义404页面 在博客根目录的your_site\\layouts\\文件夹下，放入你想放的404.html文件，这样它就会覆盖掉原主题的your_blog\\themes\\LoveIt\\layouts\\404.html文件。 This is a tip\r生成 public 文件时，Hugo 会优先读取根目录的文件，然后再读取主题里文件（也就是your_blog\\themes\\LoveIt\\layouts\\里的文件）。 我们当然也可以直接修改主题里的文件，但是如果这样做，那么在更新主题后我们之前的修改也会一并地消失。因此在本文的后面，我们宁愿把主题里的文件复制到根目录对应位置后再修改，也不直接修改。 ","date":"2024-09-13","objectID":"/text24/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加文章数量统计 其实就是利用 hugo 提供的变量来获取文章数量，再通过 html 里的sup标签，把文章数量在上标中显示出来，如下图： ","date":"2024-09-13","objectID":"/text24/:4:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 list.html 文件 复制your_site\\themes\\LoveIt\\layouts\\taxonomy\\list.html到your_site\\layouts\\taxonomy\\路径下。 然后打开your_site\\layouts\\taxonomy\\list.html，找到下面的内容： {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else if eq $taxonomy \"tag\" -}} \u003ci class=\"fas fa-tag fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else -}} 将其改为： {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }}\u003csup\u003e{{ len .Pages }}\u003c/sup\u003e {{- else if eq $taxonomy \"tag\" -}} \u003ci class=\"fas fa-tag fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }}\u003csup\u003e{{ len .Pages }}\u003c/sup\u003e {{- else -}} 继续找到： {{- range $pages.PageGroups -}} \u003ch3 class=\"group-title\"\u003e{{ .Key }}\u003c/h3\u003e 将其改为： {{- range $pages.PageGroups -}} \u003ch3 class=\"group-title\"\u003e{{ .Key }} \u003csup\u003e{{ len .Pages }}\u003c/sup\u003e\u003c/h3\u003e 因为 LoveIt 博客是以年份来分组的，但是我的博文没有那么多，以月份来分组更加有记录感，所以可以把下面内容： {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \"2006\" -}} 改为： {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \"2006-01\" -}} 从而达到以月份分组。 ","date":"2024-09-13","objectID":"/text24/:4:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 terms.html 文件 复制your_site\\themes\\LoveIt\\layouts\\taxonomy\\terms.html到your_site\\layouts\\taxonomy\\路径下。 然后打开your_site\\layouts\\taxonomy\\terms.html，找到下面的内容： \u003cdiv class=\"page archive\"\u003e {{- /* Title */ -}} \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- .Params.Title | default (T $taxonomies) | default $taxonomies | dict \"Some\" | T \"allSome\" -}} \u003c/h2\u003e 改成： \u003cdiv class=\"page archive\"\u003e {{- /* Title */ -}} \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- .Params.Title | default (T $taxonomies) | default $taxonomies | dict \"Some\" | T \"allSome\" -}}\u003csup\u003e{{ len .Pages }}\u003c/sup\u003e \u003c/h2\u003e 继续找到： \u003ch3 class=\"card-item-title\"\u003e \u003ca href=\"{{ .RelPermalink }}\"\u003e \u003ci class=\"far fa-folder fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Page.Title }} \u003c/a\u003e \u003c/h3\u003e 然后改成： \u003ch3 class=\"card-item-title\"\u003e \u003ca href=\"{{ .RelPermalink }}\"\u003e \u003ci class=\"far fa-folder fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Page.Title }} \u003csup\u003e{{ len .Pages }}\u003c/sup\u003e \u003c/a\u003e \u003c/h3\u003e ","date":"2024-09-13","objectID":"/text24/:4:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 section.html 文件 复制your_site\\themes\\LoveIt\\layouts\\_default\\section.html到your_site\\layouts\\_default\\路径下。 然后打开your_site\\layouts\\_default\\section.html，找到下面的内容： \u003cdiv class=\"page archive\"\u003e {{- /* Title */ -}} \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- .Params.Title | default (T .Section) | default .Section | dict \"Some\" | T \"allSome\" -}} \u003c/h2\u003e 改成： \u003cdiv class=\"page archive\"\u003e {{- /* Title */ -}} \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- .Params.Title | default (T .Section) | default .Section | dict \"Some\" | T \"allSome\" -}}\u003csup\u003e{{ len .Pages }}\u003c/sup\u003e \u003c/h2\u003e 继续找到： {{- range $pages.PageGroups -}} \u003ch3 class=\"group-title\"\u003e{{ .Key }}\u003c/h3\u003e 然后改成： {{- range $pages.PageGroups -}} \u003ch3 class=\"group-title\"\u003e{{ .Key }} \u003csup\u003e{{ len .Pages }}\u003c/sup\u003e\u003c/h3\u003e 同样，这里是以年份分组的，若要改为以月份分组，则要把下面代码： {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \"2006\" -}} 改为： {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \"2006-01\" -}} 这样操作后，以我的网站为例，归档、分类和标签页面就都能加上文章数量统计了。 ","date":"2024-09-13","objectID":"/text24/:4:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加文章密码 有时候我们并不想把一部分网页展示给所有人，那么我们可以加密我们的网页，使其要通过密码访问，如下图: ","date":"2024-09-13","objectID":"/text24/:5:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 single.html 将your_site\\themes\\LoveIt\\layouts\\posts\\single.html复制粘贴到your_site\\layouts\\posts\\路径下。打开your_site\\layouts\\posts\\single.html文件，在{{- $params := .Scratch.Get \"params\" -}}下添加下面内容： {{- $password := $params.password | default \"\" -}} {{- if ne $password \"\" -}} \u003cscript\u003e (function(){ if({{ $password }}){ if (prompt('请输入文章密码') != {{ $password }}){ alert('密码错误！'); if (history.length === 1) { window.opener = null; window.open('', '_self'); window.close(); } else { history.back(); } } } })(); \u003c/script\u003e {{- end -}} ","date":"2024-09-13","objectID":"/text24/:5:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"将 password 参数添加至.md文件的模版 之后我们只要将 password 参数添加到文章头即可。 但为了方便起见，我这里直接把它加到了模板文件中，即在博客的根目录下找到your_site\\archetypes\\default.md并打开，把 password 参数添加进去，如下代码块： --- title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" slug: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" ... ... password: \"\" ... ... --- This is a tip\rpassword= \"\"的\"\"中的字符即为密码，若无字符，则文章不加密无需密码登录。\r","date":"2024-09-13","objectID":"/text24/:5:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加_custom.scss以自定义 css Hugo 会优先读取博客根目录下的同名目录和文件，所以我们在博客根目录下添加文件your_site\\assets\\css\\_custom.scss This is a tip\r我们要使用hugo_extended版本的 Hugo 才可使_custom.scss文件生效\r","date":"2024-09-13","objectID":"/text25/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"添加custom.js以自定义 JavaScript 我们要创建一个.js文件来自定义 JavaScript，但是由于 LoveIt 主题本身并没有提供这样的一个文件，所以除了创建文件，我们还要修改一下 LoveIt 主题的模版。 ","date":"2024-09-13","objectID":"/text25/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"创建custom.js文件 在博客根目录添加文件your_site\\static\\js\\custom.js，之后我们自定义 JavaScript 的修改就都是在这个文件中进行的。 ","date":"2024-09-13","objectID":"/text25/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"修改 LoveIt 模版 把your_site\\themes\\LoveIt\\layouts\\partials\\assets.html文件复制到your_site\\layouts\\partials\\路径下。 在your_site\\layouts\\partials\\assets.html文件内容的最尾部找到{{- partial \"plugin/analytics.html\" . -}}，并在其上一行中添加如下内容： {{- /* 自定义 js 文件 */ -}} \u003cscript type=\"text/javascript\" src=\"/js/custom.js\"\u003e\u003c/script\u003e 由于本系列文章的部分功能会用到 jQuery（如网站运行时间和背景图片），因此强烈建议与自定义的 js 文件一起引入，即在刚才添加的内容的上一行再添加如下的内容： \u003cscript type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js\"\u003e\u003c/script\u003e ","date":"2024-09-13","objectID":"/text25/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"添加网站运行时间 把your_site\\themes\\LoveIt\\layouts\\partials\\footer.html复制到your_site\\layouts\\partials\\路径下。 打开文件your_site\\layouts\\partials\\footer.html，在其中找到\u003cdiv class=\"footer-container\"\u003e，并在其下方添加如下内容： \u003cdiv class=\"footer-line\"\u003e \u003cspan id=\"run-time\"\u003e\u003c/span\u003e \u003c/div\u003e 之后，在我们刚刚新建的your_site\\static\\js\\custom.js文件中添加如下内容： /* 站点运行时间 */ function runtime() { window.setTimeout(\"runtime()\", 1000); /* 请修把这里的建站时间换为你自己的 */ let startTime = new Date('05/23/2023 08:00:00'); let endTime = new Date(); let usedTime = endTime - startTime; let days = Math.floor(usedTime / (24 * 3600 * 1000)); let leavel = usedTime % (24 * 3600 * 1000); let hours = Math.floor(leavel / (3600 * 1000)); let leavel2 = leavel % (3600 * 1000); let minutes = Math.floor(leavel2 / (60 * 1000)); let leavel3 = leavel2 % (60 * 1000); let seconds = Math.floor(leavel3 / (1000)); let runbox = document.getElementById('run-time'); runbox.innerHTML = '本站已运行\u003ci class=\"far fa-clock fa-fw\"\u003e\u003c/i\u003e ' + ((days \u003c 10) ? '0' : '') + days + ' 天 ' + ((hours \u003c 10) ? '0' : '') + hours + ' 时 ' + ((minutes \u003c 10) ? '0' : '') + minutes + ' 分 ' + ((seconds \u003c 10) ? '0' : '') + seconds + ' 秒 '; } runtime(); ","date":"2024-09-13","objectID":"/text25/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"lightgallery 图片相册功能的改进 lightgallery 是 LoveIt 支持的图片相册功能（就是点击图片能放大观察的功能）。如果要开启，则先要在your_site/config.toml配置文件中，令参数lightgallery为 true。 但是若要真正的启用这个功能，那么我们要对每个图片起一个标题（引入图片的形式为![图片说明](https://picture.com\"图片标题\")），但是懒惰的我一般不会给图片起标题（因为要打两个双引号），所以要是图片说明能当图片标题就好了。 为了达到上面的效果，我们只需要创建your_site/layouts/_default/_markup/render-image.html文件，并在该文件中添加如下内容： {{ $figcap := or .Title .Text }} {{ $caption := or .Text \" \" }} {{- if eq $figcap $caption -}} {{ $caption = \" \" }} {{- end -}} {{- if $figcap -}} \u003cfigure\u003e {{- dict \"Src\" .Destination \"Title\" $figcap \"Caption\" $caption \"Linked\" true \"Resources\" .Page.Resources | partial \"plugin/image.html\" -}} \u003cfigcaption class=\"image-caption\"\u003e {{- $figcap | safeHTML -}} \u003c/figcaption\u003e \u003c/figure\u003e {{- else -}} {{- dict \"Src\" .Destination \"Title\" (path.Base .Destination) \"Resources\" .Page.Resources | partial \"plugin/image.html\" -}} {{- end -}} 但是如果你真的不需要标题，而且嫌标题很丑的话，那么可以在your_site\\assets\\css\\_custom.scss文件中添加如下内容： /* 图片 */ figcaption { display: none !important; } 然后标题就可以消失了。 ","date":"2024-09-13","objectID":"/text25/:4:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"文章过期提醒 像这种科技博文，一般都有时效性，所以添加一个文章过期提醒就显得很有必要了。 ","date":"2024-09-13","objectID":"/text25/:5:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"修改配置及模版文件 在your_site/config.toml配置文件中，添加如下内容： # Display a message at the beginning of an article to warn the readers that it's content may be outdated. # 在文章末尾显示提示信息，提醒读者文章内容可能过时。 [params.outdatedInfoWarning] enable = true hint = 90 # Display hint if the last modified time is more than these days ago. # 如果文章最后更新于这天数之前，显示提醒 warn = 180 # Display warning if the last modified time is more than these days ago. # 如果文章最后更新于这天数之前，显示警告 但是我们总不可能每一篇都是这种有时效性的科技博客，所以我们要添加一个参数来控制其是否开启。为了方便起见，这里我选择直接在模版文件your_site\\archetypes\\default.md里添加变量： outdatedInfoWarning: true This is a tip\r这里默认文章过期提醒开启，若想修改默认，直接将 true 改为 false 即可。之前创建的文章直接在文章头添加该参数即可。\r","date":"2024-09-13","objectID":"/text25/:5:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"修改国际化文件 把your_site\\themes\\LoveIt\\i18n\\zh-CN.toml复制到your_site\\i18n\\路径下，打开your_site\\i18n\\zh-CN.toml文件，添加如下内容： [outdatedInfoWarningBefore] other = \"本文最后更新于 \" [outdatedInfoWarningAfter] other = \"，文中内容可能已过时，请谨慎使用。\" ","date":"2024-09-13","objectID":"/text25/:5:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"添加outdated-info-warning.html文件 在your_site/layouts/partials/single/路径下添加outdated-info-warning.html文件，内容如下： {{- if or .Params.outdatedInfoWarning (and .Site.Params.outdatedInfoWarning.enable (ne .Params.outdatedInfoWarning false)) }} {{- $daysAgo := div (sub now.Unix .Lastmod.Unix) 86400 }} {{- $hintThreshold := .Site.Params.outdatedInfoWarning.hint | default 30 }} {{- $warnThreshold := .Site.Params.outdatedInfoWarning.warn | default 180 }} {{- $updateTime := .Lastmod }} {{- if .GitInfo }} {{- if lt .GitInfo.AuthorDate.Unix .Lastmod.Unix }} {{- $updateTime := .GitInfo.AuthorDate }} {{- end }} {{- end -}} {{- if gt $daysAgo $hintThreshold }} {{- $iconDetails := \"fas fa-angle-right fa-fw\" -}} {{- if gt $daysAgo $warnThreshold }} {{- $type := \"warning\" -}} {{- $icon := \"fas fa-exclamation-triangle fa-fw\" -}} \u003cdiv class=\"details admonition {{ $type }} open\"\u003e \u003cdiv class=\"details-summary admonition-title\"\u003e \u003ci class=\"icon {{ $icon }}{{ $type }}\"\u003e\u003c/i\u003e{{ T $type }}\u003ci class=\"details-icon {{ $iconDetails }}\"\u003e\u003c/i\u003e {{- else }} {{- $type := \"question\" -}} {{- $icon := \"fas fa-exclamation-triangle fa-fw\" -}} \u003cdiv class=\"details admonition {{ $type }} open\"\u003e \u003cdiv class=\"details-summary admonition-title\"\u003e \u003ci class=\"icon {{ $icon }}{{ $type }}\"\u003e\u003c/i\u003e{{ T $type }}\u003ci class=\"details-icon {{ $iconDetails }}\"\u003e\u003c/i\u003e {{- end }} \u003c/div\u003e \u003cdiv class=\"details-content\"\u003e \u003cdiv class=\"admonition-content\"\u003e {{ T \"outdatedInfoWarningBefore\" -}} \u003cspan class=\"timeago\" datetime=\"{{ dateFormat \"2006-01-02T15:04:05\" $updateTime }}\" title=\"{{ dateFormat \"January 2, 2006\" $updateTime }}\"\u003e {{- dateFormat \"January 2, 2006\" $updateTime -}} \u003c/span\u003e{{ T \"outdatedInfoWarningAfter\" -}} \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e {{- end -}} {{- end -}} ","date":"2024-09-13","objectID":"/text25/:5:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"修改single.html文件 把your_site/themes/LoveIt/layouts/posts/single.html复制到your_site/layouts/posts/路径下，然后打开your_site/layouts/posts/single.html找到下面内容： {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e 修改为： \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} {{- /* Outdated Info Warning */ -}} {{- partial \"single/outdated-info-warning.html\" . -}} \u003c/div\u003e ","date":"2024-09-13","objectID":"/text25/:5:4","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"双击生成颜表情 在your_site\\static\\js\\custom.js文件中，添加如下内容： /* 返回随机颜色 */ function randomColor() { return \"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"; } /* 点击生成字符特效 */ var a_idx = 0; var a_click = 1; /* 生成的字符内容 */ var a = new Array(\"乀(ˉεˉ乀)\",\"𓂃𓂃𓂃𓊝𓄹𓄺𓂃𓂃𓂃\",\"˘ᗜ˘\",\"(╥╯^╰╥)\",\"╰(*´︶`*)╯\",\"✧(◍˃̶ᗜ˂̶◍)✩\",\"｡◕‿◕｡\", \"(๑ت๑)\",\"(๑❛ᴗ❛๑)\",\"w(ﾟДﾟ)w\",\"Σ( ° △ °|||)︴\",\"(⊙ˍ⊙)\",\"(๑ˉ∀ˉ๑)\",\"\u003c(￣︶￣)\u003e\",\"╰(*°▽°*)╯\",\"✿\", \"(,,•́ . •̀,,)\",\"վ'ᴗ' ի\",\"(◔◡◔)\",\"⚝\",\"₍ᐢ. ֑ .ᐢ₎\"); jQuery(document).ready(function($) { $(\"body\").click(function(e) { /* 点击频率，点击几次就换文字 */ var frequency = 2; if (a_click % frequency === 0) { var $i = $(\"\u003cspan/\u003e\").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css({ \"z-index\": 9999, \"top\": y - 20, \"left\": x, \"position\": \"absolute\", \"font-weight\": \"bold\", \"color\": randomColor(), \"-webkit-user-select\": \"none\", \"-moz-user-select\": \"none\", \"-ms-user-select\": \"none\", \"user-select\": \"none\" }); $(\"body\").append($i); $i.animate({ \"top\": y - 180, \"opacity\": 0 }, 1500, function() { $i.remove(); }); } a_click ++; }); }); ","date":"2024-09-13","objectID":"/text25/:6:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"离开进入网站的标题变化 可以发现，若离开我的网站去其他页面，那么我的网站的标题和图标会发生变化。若再次回到我的网站，则标题和图标会再次发生变化。想要达到这个效果，只需在your_site\\static\\js\\custom.js文件中添加如下内容： /* 离开当前页面时修改网页标题，回到当前页面时恢复原来标题 */ window.onload = function() { var OriginTitile = document.title; var titleTime; document.addEventListener('visibilitychange', function() { if(document.hidden) { $('[rel=\"icon\"]').attr('href', \"/failure.ico\"); $('[rel=\"shortcut icon\"]').attr('href', \"/failure.ico\"); document.title = '哦~该回码头了'; clearTimeout(titleTime); } else { $('[rel=\"icon\"]').attr('href', \"/favicon.ico\"); $('[rel=\"shortcut icon\"]').attr('href', \"/favicon.ico\"); document.title = '哈~又整到薯条了'; titleTime = setTimeout(function() { document.title = OriginTitile; }, 2000); } }); } 其中文字部分改为自己喜欢的就可以了，而至于网站图标文件favicon.ico和failure.ico如果不清楚，具体可见我之前的文章 Hugo的Lovelt主题美化（一）。 这里只简单的说一下：一般而言，我们会把网站图标放到your_site\\static\\路径下，而在当前的目的下，我们可以只调用48*48的.ico文件作为显示图标。此外，favicon.ico一般是我们原来的网站图标，所以我们只需要在创建一个failure.ico作为离开页面时显示的图标即可。 ","date":"2024-09-13","objectID":"/text25/:7:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"二级标题样式 为了使文章的可读性更强，在这里最好修改一下 LoveIt 主题的文章样式。 ","date":"2024-09-13","objectID":"/text26/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"二级标题的修改 原主题的二级标题我不好评价，它跟下一级的标题几乎区分不开，这导致文章看起来没有条理。因此在这里我们将修改二级标题的样式以做区分。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 标题 */ .page.single h2 { box-shadow: rgb(95, 90, 75) 0px 0px 0px 1px, rgba(10, 10, 0, 0.5) 1px 1px 6px 1px; color: rgb(255, 255, 255); font-family: 微软雅黑, 宋体, 黑体, Arial; font-weight: bold; line-height: 1.3; text-shadow: rgb(34, 34, 34) 2px 2px 3px; background: rgb(43, 102, 149); border-radius: 6px; border-width: initial; border-style: none; border-color: initial; border-image: initial; padding: 7px; margin: 18px 0px 18px -5px !important; } ","date":"2024-09-13","objectID":"/text26/:1:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"行内代码 原主题的行内代码能用，但只能用一点点，实在是与正文区分不开，所以在这修改一下它的样式。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 行内代码块 */ code { margin: 0 .2rem; font-size: .9em; border: 1px solid #d6d6d6; border-radius: .2rem; } /* 预格式代码块(用tab键插入的代码块) */ pre code { margin: 0; border: none; font-size: .875rem; } /* 标题里的代码块样式 */ .page.single .content\u003eh2 code { color: #f7ab01; background: transparent !important; border: none; } ","date":"2024-09-13","objectID":"/text26/:1:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"分割线 在原主题中分割线几乎看不到，这里修改一下。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 分隔线 */ hr { border: none; border-bottom: 2px dashed #7a7a7a !important; } ","date":"2024-09-13","objectID":"/text26/:1:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"页脚分割线 页脚内容与其他内容连在一起有点杂乱，因此添加一个页脚的分割线还是很有必要的。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 页脚分割线 */ .footer { display: block; border-top-width: 3px; border-top-style: solid; border-top-color: #96c1db; position: relative; z-index: -1; max-width: 800px; width: 60%; margin: .5rem auto 0 auto; padding-left: 0rem; padding-right: 0rem; } @media only screen and (max-width: 1440px) { .footer { width:54.5% } } @media only screen and (max-width: 1200px) { .footer { width:50.5% } } @media only screen and (max-width: 960px) { .footer { width: 77% } } @media only screen and (max-width: 680px) { .footer { width: 95% } } ","date":"2024-09-13","objectID":"/text26/:1:4","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"首页头像旋转 这是一个没什么用的功能，但是好玩。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 头像旋转 */ .home .home-profile .home-avatar img { width: 5rem; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ease-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; \u0026:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } } ","date":"2024-09-13","objectID":"/text26/:1:5","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"更新时间设置 原主题是有最近更新时间参数的，只不过藏的比较深，一般不显示。但实际上，更新时间是要比发布时间更好用的（毕竟老文章改改也就成新文章了）。 ","date":"2024-09-13","objectID":"/text26/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"首页显示最近更新时间 虽然我们有最近更新时间，但首页并不显示，这好吗？这不好！所以我劝年轻人们都把它加上。 把your_site/themes/LoveIt/layouts/_default/summary.html复制到your_site/layouts/_default/路径下，然后打开your_site/layouts/_default/summary.html文件，找到如下内容： {{- with .Site.Params.dateFormat | default \"2006-01-02\" | .PublishDate.Format -}} \u0026nbsp;\u003cspan class=\"post-publish\"\u003e {{- printf `\u003ctime datetime=\"%v\"\u003e%v\u003c/time\u003e` . . | dict \"Date\" | T \"publishedOnDate\" | safeHTML -}} \u003c/span\u003e {{- end -}} 把它修改为下面的内容： {{- with .Site.Params.dateFormat | default \"2006-01-02\" | .PublishDate.Format -}} \u0026nbsp;\u003cspan class=\"post-publish\"\u003e {{- printf `\u003ctime datetime=\"%v\"\u003e%v\u003c/time\u003e` . . | dict \"Date\" | T \"publishedOnDate\" | safeHTML -}}, \u003c/span\u003e {{- end -}} {{- with .Site.Params.dateFormat | default \"2006-01-02\" | .Lastmod.Format -}} \u0026nbsp;\u003cspan class=\"post-publish\"\u003e {{- printf `\u003ctime datetime=\"%v\"\u003e%v\u003c/time\u003e` . . | dict \"Date\" | T \"updatedOnDate\" | safeHTML -}}, \u003c/span\u003e {{- end -}} ","date":"2024-09-13","objectID":"/text26/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"显示最近更新的十篇文章 一般来说，归档页面只有按发布时间排序的列表，但是我们最新的动态往往会涉及到修改以前的文章，所以我们最好加一栏用来显示最近更新的文章。 首先，在your_site/config.toml配置文件中添加新参数： [params.section] # 显示最近更新文章的数量 lastUpdatedSize = 10 然后，把your_site/themes/LoveIt/layouts/_default/section.html复制到your_site/layouts/_default/路径下，然后打开your_site/layouts/_default/section.html文件，找到如下内容： {{- /* Paginate */ -}} 在它的上面添加如下内容： {{- /* Last Modified */ -}} {{- $lastUpdatedSize := .Site.Params.section.lastUpdatedSize -}} {{- if $lastUpdatedSize -}} {{- if .Pages -}} {{- $pages := .Pages.ByLastmod.Reverse -}} \u003ch3 class=\"group-title\"\u003e{{ T \"RecentUpdate\" -}} \u003csup\u003e{{- $lastUpdatedSize -}}\u003c/sup\u003e\u003c/h3\u003e {{- range first $lastUpdatedSize $pages -}} \u003carticle class=\"archive-item\"\u003e \u003ca href=\"{{ .RelPermalink }}\" class=\"archive-item-link\"\u003e {{- .Title -}} \u003c/a\u003e \u003cspan class=\"archive-item-date2\"\u003e {{- \"2006-01-02\" | .Lastmod.Format -}} \u003c/span\u003e \u003c/article\u003e {{- end -}} {{- end -}} {{- end -}} 接着来修改国际化文件，把your_site\\themes\\LoveIt\\i18n\\zh-CN.toml复制到your_site\\i18n\\路径下，打开your_site\\i18n\\zh-CN.toml文件，添加如下内容： [RecentUpdate] other = \"最近更新\" 如果还设置了其他语言，那么我们只需将这个参量添加到对应的文件，再把 other 的内容改掉即可。 然后在your_site/assets/css/_custom.scss中添加如下内容： .archive-item-date2 { color: #7c7c88; } 最后，为了区分开发布时间和最近更新时间，我们要在每篇文章中添加最近更新时间的 meta。把your_site/themes/LoveIt/layouts/posts/single.html复制到your_site/layouts/posts/路径下，然后打开your_site/layouts/posts/single.html文件，找到如下内容： {{- with .Site.Params.dateformat | default \"2006-01-02\" | .PublishDate.Format -}} \u003ci class=\"far fa-calendar-alt fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;\u003ctime datetime=\"{{ . }}\"\u003e{{ . }}\u003c/time\u003e\u0026nbsp; {{- end -}} 将其改为： {{- with .Site.Params.dateformat | default \"2006-01-02\" | .PublishDate.Format -}} \u003ci class=\"far fa-calendar fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;\u003ctime datetime=\"{{ . }}\"\u003e{{ . }}\u003c/time\u003e\u0026nbsp; {{- end -}} {{- with .Site.Params.dateformat | default \"2006-01-02\" | .Lastmod.Format -}} \u003ci class=\"far fa-calendar-plus fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;\u003ctime datetime=\"{{ . }}\"\u003e{{ . }}\u003c/time\u003e\u0026nbsp; {{- end -}} ","date":"2024-09-13","objectID":"/text26/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"添加友链卡片 为了我们的友链显得更加的好看，这里我们引入友链卡片。 ","date":"2024-09-13","objectID":"/text26/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"添加friend.html文件 在your_site\\layouts\\shortcodes\\路径下，新创建文件friend.html，并且在里面添加如下内容： {{ if .IsNamedParams }} {{- $src := .Get \"logo\" -}} {{- $small := .Get \"logo_small\" | default $src -}} {{- $large := .Get \"logo_large\" | default $src -}} \u003cdiv class=\"friend-div\"\u003e \u003ca target=\"_blank\" href={{ .Get \"url\" | safeURL }} title={{ .Get \"name\" }} \u003e \u003cimg class=\"lazyload\" src=\"/svg/loading.min.svg\" data-src={{ $src | safeURL }} alt={{ .Get \"name\" }} data-sizes=\"auto\" data-srcset=\"{{ $small | safeURL }}, {{ $src | safeURL }} 1.5x, {{ $large | safeURL }} 2x\" /\u003e \u003cspan class=\"friend-name\"\u003e{{ .Get \"name\" }}\u003c/span\u003e \u003cspan class=\"friend-info\"\u003e{{ .Get \"word\" }}\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e {{ end }} ","date":"2024-09-13","objectID":"/text26/:3:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"添加_friend.scss文件 在your_site\\assets\\css\\_partial\\_single\\路径下（如果没有就自己创建），新建文件_friend.scss，并在里面添加如下内容： #article-container { word-wrap: break-word; overflow-wrap: break-word } #article-container a { color: #49b1f5 } #article-container a:hover { text-decoration: underline } #article-container img { margin: 0 auto .8rem } .flink#article-container .friend-list-div \u003e .friend-div a .friend-info, .flink#article-container .friend-list-div \u003e .friend-div a .friend-name { overflow: hidden; -o-text-overflow: ellipsis; text-overflow: ellipsis; white-space: nowrap } .flink#article-container .friend-list-div { overflow: auto; padding: 10px 10px 0; text-align: center; } .flink#article-container .friend-list-div \u003e .friend-div { position: relative; float: left; overflow: hidden; margin: 15px 7px; width: calc(100% / 3 - 15px); height: 90px; border-radius: 8px; line-height: 17px; -webkit-transform: translateZ(0) } @media screen and (max-width: 1100px) { .flink#article-container .friend-list-div \u003e .friend-div { width: calc(50% - 15px) !important } @media screen and (max-width: 600px) { .flink#article-container .friend-list-div \u003e .friend-div { width: calc(100% - 15px) !important } } } .flink#article-container .friend-list-div \u003e .friend-div:hover { background: rgba(87, 142, 224, 0.15); } .flink#article-container .friend-list-div \u003e .friend-div:hover img { -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -o-transform: rotate(360deg); -ms-transform: rotate(360deg); transform: rotate(360deg) } .flink#article-container .friend-list-div \u003e .friend-div:before { position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: -1; background: var(--text-bg-hover); content: ''; -webkit-transition: -webkit-transform .3s ease-out; -moz-transition: -moz-transform .3s ease-out; -o-transition: -o-transform .3s ease-out; -ms-transition: -ms-transform .3s ease-out; transition: transform .3s ease-out; -webkit-transform: scale(0); -moz-transform: scale(0); -o-transform: scale(0); -ms-transform: scale(0); transform: scale(0) } .flink#article-container .friend-list-div \u003e .friend-div:hover:before, .flink#article-container .friend-list-div \u003e .friend-div:focus:before, .flink#article-container .friend-list-div \u003e .friend-div:active:before { -webkit-transform: scale(1); -moz-transform: scale(1); -o-transform: scale(1); -ms-transform: scale(1); transform: scale(1) } .flink#article-container .friend-list-div \u003e .friend-div a { color: var(--font-color); text-decoration: none } .flink#article-container .friend-list-div \u003e .friend-div a img{ float: left; margin: 15px 10px; width: 60px; height: 60px; border-radius: 35px; -webkit-transition: all .3s; -moz-transition: all .3s; -o-transition: all .3s; -ms-transition: all .3s; transition: all .3s } .flink#article-container .friend-list-div \u003e .friend-div a .friend-name { display: block; padding: 16px 10px 0 0; height: 40px; font-weight: 700; font-size: 20px } .flink#article-container .friend-list-div \u003e .friend-div a .friend-info { display: block; padding: 1px 10px 1px 0; height: 50px; font-size: 13px } ","date":"2024-09-13","objectID":"/text26/:3:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"在_single.scss中引入代码 把your_site\\themes\\LoveIt\\assets\\css\\_page\\_single.scss复制粘贴到路径your_site\\assets\\css\\_page\\下。 再在文件your_site\\assets\\css\\_page\\_single.scss里添加如下内容： @import \"../_partial/_single/friend\"; ","date":"2024-09-13","objectID":"/text26/:3:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"调用友链卡片 至此，我们便可以使用如下的shortcodes在我们文章.md的任意地方调用友链卡片了： \u003cdiv class=\"flink\" id=\"article-container\"\u003e \u003cdiv class=\"friend-list-div\" \u003e {{ \u003c friend name=\"友链名称1\" url=\"友链地址1\" logo=\"友链图片链接1\" word=\"友链描述1\" \u003e }} {{ \u003c friend name=\"友链名称2\" url=\"友链地址2\" logo=\"友链图片链接2\" word=\"友链描述2\" \u003e }} \u003c/div\u003e \u003c/div\u003e This is a tip\r不能省略这两个div\r","date":"2024-09-13","objectID":"/text26/:3:4","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"创建友链页面 有了友链卡片，我们最好还要有一个页面来专门放置友链。之前我讲过如何添加关于页面，而其实这次与添加关于页面差不多。 ","date":"2024-09-13","objectID":"/text26/:4:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"创建friend/index.md文件 于终端中来到博客的根目录，我们来创建一个.md文件作为友链页面， 本站友链 friend name=\"Ty Note\" url=\"https://Wangty654.github.io\" logo=\"https://Wangty654.github.io/apple-touch-icon.png\" word=\"一个简单的私人博客网站 (˘◡˘)\" ","date":"2024-09-13","objectID":"/text26/:4:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"自定义网站图标 ","date":"2024-09-13","objectID":"/text23/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"1. 主页头像 在 blog 根目录下找到文件夹assets，打开该文件夹并新建文件夹images，把我们的主页头像图片avatar.png放到文件夹images中。 在 blog 根目录下找到配置文件config.toml ,在配置文件中找到# 主页配置 -\u003e # 主页显示头像的 URL的参数avatarURL = \"\"。在\"\"中填入主页头像图片在assets下的路径（这里填图片的URL亦可），最后则为avatarURL = \"images/avatar.png\"。 然后我们的 blog 主页就有头像了，如下图： ","date":"2024-09-13","objectID":"/text23/:1:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"2. 网站名前的logo 同前面一样，先将 logo 图标logo.png放到assets/images下。 在配置文件config.toml中找到# 页面头部导航栏配置 -\u003e # LOGO 的 URL的参数logo = \"\"。填入路径后将变为logo = \"images/logo_ico.png\"（当然图片URL亦可）。 This is a tip\r这里我发现，如果使用.png的图片，图片大小控制不好的话,会导致图与文字排列奇怪。图标会将标题顶开一定的位置。 但是如果我们使用.ico的图片，那么这种情况就不会出现。然而logo这个参数本身并不支持.ico图片。因此我们需要把作为 logo 的.ico图片的后缀名改为.png，这样logo才能读取图片文件。 而如果你的 logo 图一开始是.png图片，那么可以通过这个网站在线修改为.ico图片。 然后我们的 blog 就有了显示正常的 logo 了，如下图： ","date":"2024-09-13","objectID":"/text23/:1:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"3. 网站图标 注意与上面不同的是，我们要先将网站图标放到 blog 根目录的static文件夹下，而对于要放什么类型的图标我们有两种选择： 使用.svg后缀的伸缩矢量图形： 如果你的图标是.png文件（其他的类似），则可以通过这个网站，在线地把.png转换为.svg文件。然后把这个.svg文件放到static文件夹即可。 然后在配置文件config.toml中找到# 应用图标配置的参数svgFavicon = \"\"，不妨认为我们的.svg图标名为safari-pinned-tab.svg，那么我们只需修改参数为svgFavicon = \"/safari-pinned-tab.svg\"即可。 使用多尺寸的图标： 我们可以找到 LoveIt 主题文件里的配置文件config.toml（路径为your_blog\\themes\\LoveIt\\config.toml），可以发现svgFavicon参数为空，但是它的官网却也有网站图标。我们观察一下主题自带的exampleSite文件里的static（路径为your_blog\\themes\\LoveIt\\exampleSite\\static），可以发现里面有大小各异的网站图标，如下图： 因此我们可以依葫芦画瓢，在我们 blog 根目录的static文件夹里，放入我们各种大小的网站图标，如下图：（采用此方法，svgFavicon参数一定要为空，且各种大小的图标命名要和官方一致）在这里可以传入你想要的图片，很容易的生成这些文件。 然后我们的 blog 就有网站图标了，如下图： ","date":"2024-09-13","objectID":"/text23/:1:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"文章头的参数 我们在根目录archetypes文件夹下修改的default.md。这个default.md实际是我们每篇文章头（如下图）的模板。 ","date":"2024-09-13","objectID":"/text23/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"tags 此参数意为文章的标签，可以有多个，若要添加多个标签，只需按照如下形式即可（即用\"\"引住标签内容，而,作为标签内容间的分隔）： tags: [\"博客\",\"LoveIt 美化\"] ","date":"2024-09-13","objectID":"/text23/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"categories 此参数意为文章的分类，一篇文章可以同时存在于多个分类下（与 tags 参数类似），若要文章处于多个分类下，只需按照如下形式即可（即用\"\"引住分类名称，而,作为分类名称间的分隔）： categories: [\"Hugo 博客\",\"Markdown\"] ","date":"2024-09-13","objectID":"/text23/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"share 此参数意为是否开启文章底部的分享功能。 ","date":"2024-09-13","objectID":"/text23/:2:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"comment 此参数意为是否开启文章底部的评论功能。 ","date":"2024-09-13","objectID":"/text23/:2:4","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"hiddenFromHomePage 此参数意为是否在主页隐藏本文章。 ","date":"2024-09-13","objectID":"/text23/:2:5","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"hiddenFromSearch 此参数意为是否在搜索时隐藏本文章。 ","date":"2024-09-13","objectID":"/text23/:2:6","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"summary 在主页中显示的对文章的描述性语言，如下图： 但如果不加，如下图： 那么hugo会自动将文章内容前半部分取过来，显示在描述这里，文章描述会很杂乱。 ","date":"2024-09-13","objectID":"/text23/:2:7","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"featuredImagePreview 这个参数为在主页显示的文章配图：我们可以对该参数添加图片URL，那么主页对应文章标题上方便会出现被裁剪后的配图，如下图： 但如果我们不加配图，如下图： 那么主页文章间的分割不明显，且不够花里胡哨。 ","date":"2024-09-13","objectID":"/text23/:2:8","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"featuredImage 这个参数与上个参数类似，但它在为主页添加配图的同时，也将图片（未裁剪的）添加至文章内容的开头，如下图： This is a tip\r加到 featuredImagePreview 中的图片的宽高比尽量为 10:3 ，不然会自动裁剪为 10:3 ，这样有可能损失内容。同时为了使网页背景与图片可区分，我们不要让图片以纯白或深灰为底。我一般选# f6f6f6 或# f6f6ff代替纯白。\r","date":"2024-09-13","objectID":"/text23/:2:9","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"链接和提示框 ","date":"2024-09-13","objectID":"/text23/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"link 如果我们在 Markdown 文件中输入{{ \u003c link \"https://Wangty654.github.io\" \u003e }}，则在网页上会显示为https://Wangty654.github.io。 ","date":"2024-09-13","objectID":"/text23/:3:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"admonition 横幅 我们若在任意一个 Mardown 中输入： 则会出现如下效果： This is a tip\r一个 技巧 横幅\r其中参数 admonition type 为横幅的类型，一共有12种，分别为 note，abstract，info，tip，success，question，warning，failure，danger，bug，example，quote（其中默认值为note）。 参数 title 顾名思义是横幅的标题 参数 open 为横幅是否自动打开，默认是 true 打开。 ","date":"2024-09-13","objectID":"/text23/:3:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"其他的拓展 Shortcode 具体可见这里，而一些 Hugo 内置的 Shortcode 可见这里 This is a note\r一个 技巧 横幅\rThis is a abstract\r一个 技巧 横幅\rThis is a info\r一个 技巧 横幅\rThis is a tip\r一个 技巧 横幅\rThis is a success\r一个 技巧 横幅\rThis is a question\r一个 技巧 横幅\rThis is a warning\r一个 技巧 横幅\rThis is a failure\r一个 技巧 横幅\rThis is a danger\r一个 技巧 横幅\rThis is a bug\r一个 技巧 横幅\rThis is a example\r一个 技巧 横幅\rThis is a quote\r一个 技巧 横幅\r","date":"2024-09-13","objectID":"/text23/:3:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"关于页面 我们的 blog 往往会有一个\"关于\"页面来介绍自己，但我们一开始所给的配置参数并不包含这个页面，因此我们可以来添加该页面。 首先我们要在终端中来到 blog 的根目录，执行下面命令，在content文件夹下创建一个about文件夹，并使其有文件index.md。一般读取都是读取路径包下的index.md文件，若没有多个文件，也可以建成单独的about.md 这个index.md或者about.md就是我们的\"关于\"页面。 然后我们还要在菜单栏配置中添加\"关于\"这一栏。在 blog 根目录下找到 config.toml,再在该配置下找到# 菜单配置，在这一项下添加： [[menu.main]] name = \"关于\" # weight 参数可以看做菜单栏上各项的排序，越大的排在电脑网页的越右边 weight = 4 identifier = \"about\" url = \"/about/\" title = \"About\" 这样，“关于\"页面就创建好了。 ","date":"2024-09-13","objectID":"/text23/:4:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["前端"],"content":"第1章：Vue核心 ","date":"2024-08-21","objectID":"/vue2/:0:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"1.vue简介： vue是一套用于构建用户界面的渐进式javaScript框架 This is a tip\rvue可以自底向上逐层的应用 简单应用：只需要一个轻量小巧的核心库 复杂应用：可以引入各式各样的vue插件 This is a warning\rvue2.0发布于2016年10月1日，vue3.0发布于2020年9月18日\r","date":"2024-08-21","objectID":"/vue2/:1:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"vue的特点： 组件化 采用组件化模式，提高代码复用率、且让代码更好维护 声明式 声明式编码，让编码人员无需直接操作DOM，提高开发效率 说明： 当有一个需求如下，需要将数据persons，放入容器list中： //数据persons [ {id:'001',name:'张三',age:18}, {id:'002',name:'李四',age:19}, {id:'003',name:'王五',age:20} ] //list \u003cul id=\"list\" \u003e\u003c/ul\u003e 效果为： 命令式编码实现方式： 原生javaScript写法 //准备html字符串 let htmlStr = '' //遍历数据拼接html字符串 persons.forEach( p =\u003e{ htmlStr += `\u003cli\u003e${p.id} - ${p.name} - ${p.age}\u003c/li\u003e` }); //获取list元素 let list = document.getElementById('list') //修改内容(亲自操作Dom) list.innerHTML = htmlStr 声明式编码实现方式： \u003cul id=\"list\" \u003e \u003cli v-for=\"p in persons \"\u003e {{p.id}} - {{p.name}} - {{p.age}} \u003c/li\u003e \u003c/ul\u003e 虚拟dom 3.使用虚拟DOM+优秀的Diff算法，尽量复用DOM节点 This is a tip\rdiff算法： 新生成的虚拟dom会和之前生成的虚拟dom比较，这个比较算法称为diff算法。 当新的虚拟dom中，存在与旧dom中相同的属性和内容值时， vue就直接将旧的真实dom直接拿到页面渲染出来，再处理不同的部分 原生js 4.学习vue之前需要掌握的javaScript基础知识 ES6语法规范：结构赋值、模板字符串、箭头函数等。ES6基础-久远银海内部链接 ES6模块化：默认暴露、分别暴露、统一暴露、import、isport等 包管理器：npm、yram、cnpm 原型、原型链： 数组常用方法：过滤一个数组、加工一个数组、筛选最值 axios： promise：异步请求 ","date":"2024-08-21","objectID":"/vue2/:1:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"2. vue官网使用指南 地址：vue官网操作手册 ","date":"2024-08-21","objectID":"/vue2/:2:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"3.搭建vue开发环境 在没有脚手架的情况下，最原始的使用vue框架，就是在.html 文件中，引入vue.js包 \u003c!-- 开发环境版本，包含了有帮助的命令行警告 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"\u003e\u003c/script\u003e 或者 \u003c!-- 生产环境版本，优化了尺寸和速度 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2\"\u003e\u003c/script\u003e 在vue2的官方文档中，解释了两种引入vue的方式 ","date":"2024-08-21","objectID":"/vue2/:3:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"script直接引入 首先先看第一种安装vue的方式： CDN：阿里云CND操作文档 我们在写script的时候，里面有一个属性，叫src，可以指定资源的位置 如果把src写成：\"./xxx\"的形式，为引入一个本地文件。如果写成\"https\"的形式，一般为了加速，会在其中加入一个CDN的标识 This is a tip\rCDN 内容分发网络（Content Delivery Network，CDN）是建立并覆盖在承载网上，由不同区域的服务器组成的分布式网络。将源站资源缓存到全国各地的边缘服务器，供用户就近获取，降低源站压力。 官网两个vue版本，点击后均会进行下载，但下载的文件有些不同 为方便演示，将两个版本均下载在桌面，并新建一个文件夹取名为vue_basic，并用vscode打开 将引入写入html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e初识Vue\u003c/title\u003e \u003c!-- 引入vue --\u003e \u003cscript type=\"text/javascript\" src=\"../js/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-08-21","objectID":"/vue2/:3:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"控制台提示 直接引入产生的控制台提示 打开写好的html页面，在控制台会出现两个小提示 提示解析： Download the Vue Devtools extension for a better development experinence: //表示：请你下载vue的开发者工具，到达一个更好的开发体验 You are running Vue in development mode. //表示：你正在运行一个开发者模版的vue. Make sure to turn on production mode when deploying for production. //请确认你的项目不在生产时使用 [此句话意思表明，你引入的是vue.js其中带有很多提示和警告，包比较大，不适合上线项目使用] 开发者工具 解决 下载vue开发者工具 的问题 国外网络可以正常访问谷歌商城： 正常能打开gitHub，点击官网的下载链接过去，选择谷歌浏览器选项 进入谷歌网上应用商店，点击添加，完成 国内无法正常访问谷歌商城： Vue开发者工具扩展链接： 【下载开发者工具】： https://pan.baidu.com/s/1MtYvMPew4lb14piIrs9x6w 提取码：6666 【安装开发者工具】： 一、Chrome浏览器安装方式： ①：点击右上角三个点 ②：点击更多工具 ③：点击扩展程序 ④：点击右上角的开发者模式，将他启用 ⑤：将下载的Vue.crx文件直接拖动到浏览器窗口即可 ⑥：点到扩展的详细信息界面，再开启【允许访问文件URL】选项再试试看 二：Edge浏览器安装方式 ①：点击浏览器右上角的三个点 ②：点击扩展 ③：点击左下角的开发人员模式，将他启用 ④：将Vue.crx文件拖动到浏览器即可 解决 vue.js不建议在上线项目中使用的提示 Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列 property(属性) 首先验证，Vue.config 是否存在： 这里的属性，是对vue的全局配置。一次修改，到处都可以使用。 此处的：productionTip: true 小提示默认为true，是默认开启状态 代码的body中键入下方代码，可以对提示进行关闭： \u003cbody\u003e \u003c!--关闭生产提示--\u003e \u003cscript type=\"text/javascript\"\u003eVue.config.productionTip = false\u003c/script\u003e \u003c/body\u003e 【注意：上方代码如果失效，则进入vue.js文件，直接对productionTip属性进行修改为false】 开端开发编辑工具vscode下载地址：开端开发编辑工具vscode下载地址 ","date":"2024-08-21","objectID":"/vue2/:3:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"4. Hello小案例 ","date":"2024-08-21","objectID":"/vue2/:4:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"html的基础写法 hello代码示例 【注意：此段代码是html的基础写法，并没有用到vue】 \u003cbody\u003e \u003c!-- 准备一个容器 --\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003c/div\u003e \u003c/body\u003e ","date":"2024-08-21","objectID":"/vue2/:4:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Live Server 插件运行 右键打开页面，控制台错误如下： favicon.ico - 指网站的页签图标 打开控制台的Network选项卡，强制刷新一下[ 按住shift 点击刷新]，可以看见请求了本地5500服务器访问该图标 关于本地5500服务器的解释说明： 在vscode中，右键，使用Live Server 插件打开的页面：Live Server会自动先帮你打开当前选择的这个页面，并在你的电脑的5500的端口上开了一台小型的内置服务器，并且进行了“把你所有工程的文件和文件夹，作为这个服务器的根资源去使用”的一个操作。 验证内置5500端口服务器，可以地址栏直接访问127.0.0.1:5500。显示的一定是当前工程下的所有文件夹。 解决图标访问404的问题，只需要在根目录中放置一个叫favicon.ico的图片文件，页面刷新即可 This is a tip\rlive server 插件是一个具有实时加载功能的小型服务器，它的作用： 模拟服务器的方式打开页面 代码改动后,会自动刷新页面 vsCode中装Live Server插件。 ","date":"2024-08-21","objectID":"/vue2/:4:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"vue的写法演示 使用vue进行hello的显示 理解：引入的vue相当于外部引入的一个函数。要使用vue函数，需要new Vue \u003c!-- 准备一个容器 --\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e //创建Vue实例 /* * 注意Vue()中只传一个参数，这个参数是一个配置对象{} * 配置对象中，都以 key : value 的形式书写 * 配置对象中，key的名称不得更改，value的值必须符合key的数据类型 */ const x = new Vue({ //vue的第一个key是el，el是element元素的简写。 //键值对象类似于css中的id选择器 //el用于指定当前Vue实例为哪个容器，值通常为css选择器字符串。 el:'#root' //还有一种写法，一般不用，但是可以这样写 //指 人为找到这个元素，再给他配置到el里去 el:document.getElementById('root') }) \u003c/script\u003e \u003c!-- 如果用class不用id --\u003e \u003cdiv class=\"root\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const x = new Vue({ //el就写成css中类选择器的写法 el:'.root' }) \u003c/script\u003e 利用插值语法 \u003c!-- 如果用class不用id --\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello,{{name}}\u003c/h1\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const x = new Vue({ el:'#root', data:{ //data中用于存储数据，数据供el所指定的容器去使用 name:'wangty' } }) \u003c/script\u003e 注意：data中的数据需要在指定的容器中使用，没在容器中使用data内数据并不会生效 This is a tip\r三个注意事项： 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；目前这里为：el、data root容器里的代码依然符合html规范，只不过混入一些特殊的Vue语法； root容器里的代码被称为【Vue模版】 对于vue模版的解释： 我们写的为一个Vue模板，经过解析，形成一个全新的正常的html片段块，然后替换掉模板的位置，显示在页面上 容器的作用： 1、为Vue提供模板 2、把Vue解析后的html片段，指定位置放置 ","date":"2024-08-21","objectID":"/vue2/:4:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"5. 分析Hello案例 ","date":"2024-08-21","objectID":"/vue2/:5:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"一对一关系 演示说明：容器和实例是一对一，一一对应关系 有两个同名的容器的情况： 首先，能运行成功，且控制台不报错 说明，一个Vue实例不能同时接管两个容器 有两个Vue实例指向同一个容器的情况： 首先，第一个Vue内容显示正常，第二个内容不显示，且控制台报错 说明，一个容器只能被一个Vue实例接管和解析 ","date":"2024-08-21","objectID":"/vue2/:5:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"{{ }} 中为js表达式 This is a tip\r注意：{{ }} 中可以写的内容，不一定是Vue实例中声明过的。只要是js里的表达式，Vue都是可以解析的\r注意区分:js表达式 和js代码(语句) ​ 1.表达式: 一个表达式会生成一个值，可以放在任何一个需要值的地方: ​ (1).a ​ (2).a+b ​ (3).demo(1) ​ (4).x === y ? ‘a’ : ‘b’ ​ 2.js代码(语句) ​ (1).if( ){ } ​ (2).for( ){ } ","date":"2024-08-21","objectID":"/vue2/:5:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue的开发者工具 打开控制台右侧Vue选项卡 Root这里代表唯一的那一个Vue实例，点击这里的Root，能看的data里的所有数据 点击配置对象旁边的编辑按钮，可以对其值进行修改 \u003c!-- 前端小写内容全部转换为大写的方法使用 .toUpperCase() --\u003e \u003ch1\u003e{{name.toUpperCase()}} \u003c/h1\u003e //name:'wangty' // WANGTY ","date":"2024-08-21","objectID":"/vue2/:5:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生产包和开发包 关于 vue.js 和vue.min.js 在new Vue实例对象时候的区别 当不写new的时候，vue.js： 当不写new的时候，vue.min.js并不报这个warning ","date":"2024-08-21","objectID":"/vue2/:5:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"6. 模板语法 ","date":"2024-08-21","objectID":"/vue2/:6:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"6.1 插值语法 把指定的值，放到指定的位置，使用方法，见上述hello案例 【注意：插值语法多用于指定标签体内容。即，两标签之间的内容。不可以用于标签属性和属性值】 ","date":"2024-08-21","objectID":"/vue2/:6:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"6.2 指令语法（内置语法） 【注：指令语法小结示例里包含了很多后面的东西，建议先跳过看完后面再看这一节比较好理解】 普通html，点击跳转地址写法 \u003ca href=\"https://www.baidu.com\"\u003e点我去百度\u003c/a\u003e v-bind vue写法 \u003cdiv id=\"root\"\u003e \u003ch1\u003e指令语法\u003c/h1\u003e \u003ca :href=\"url\"\u003e点我去百度\u003c/a\u003e \u003c!--等价于\u003ca v-bind:href=\"url\"\u003e点我去百度\u003c/a\u003e --\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root' , data:{ url:'https://www.baidu.com' //注意，这里如果写两个一模一样的属性名，控制台不会报错 //Vue会默认读取第二个属性名的内容，这里就会默认跳转淘宝 //url:'https://www.taobao.com' } }) \u003c/script\u003e 注意：这里的 “:href\"中的冒号，是v-bind的简写。我们把类似于v-bind这样的语法称为，指令语法。 This is a tip\r在html标签中，如果标签中的属性没有使用指定语法，则就是普通的属性和属性值 如果使用了指定语法，Vue就会把属性值引号内的东西，取出来当做表达式进行执行 Class 与 Style 绑定 操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 绑定样式: 1.class样式 ​ 写法:class=“xxx”xxx可以是字符串、对象、数组。 ​ 字符串写法适用于: 类名不确定，要动态获取。 ​ 对象写法适用于: 要绑定多个样式，个数不确定，名字也不确定。 ​ 数组写法适用于:要绑定多个样式，个数确定，名字也确定，但不确定用不用。 ​ 2.style样式 ​ :style=\"{fontSize:xxx}“其中xxx是动态值。 ​ :style=\"[a,b]“其中a、b是洋式对象 绑定class样式 \u003c!--正常的样式正常写，绑定的样式传值，字符串写法--\u003e \u003cdiv class=\"basic\" :class=\"normal\"\u003e\u003c/div\u003e .... data(){ normal:'red' } .... \u003c!--html解析后显示为 class=\"basic red\"--\u003e \u003c!----------------------------或者--------------------------------\u003e \u003c!--正常的样式正常写，绑定的样式传值，数值写法--\u003e \u003cdiv class=\"basic\" :class=\"arr\"\u003e\u003c/div\u003e .... data(){ arr:['red'，'yellow'，'buld'] } .... \u003c!--html解析后显示为 class=\"basic red yellow buld\"--\u003e \u003c!--按钮事件动态操作arr数组可以实现样式的改变--\u003e \u003c!----------------------------或者--------------------------------\u003e \u003c!--正常的样式正常写，绑定的样式传值，对象写法--\u003e \u003cdiv class=\"basic\" :class=\"Obj\"\u003e\u003c/div\u003e .... data(){ Obj:{ red:false, yellow:false } } .... \u003c!--按钮事件动态操作Obj对象可以实现样式的改变--\u003e 绑定style样式 v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名： \u003cdiv v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"\u003e\u003c/div\u003e data: { activeColor: 'red', fontSize: 30 } 直接绑定到一个样式对象通常更好，这会让模板更清晰： \u003cdiv v-bind:style=\"styleObject\"\u003e\u003c/div\u003e data: { styleObject: { color: 'red', fontSize: '13px' } } 同class一样，也可以写成数组，v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上： \u003cdiv v-bind:style=\"[baseStyles, overridingStyles]\"\u003e\u003c/div\u003e v-model 数据绑定 \u003cdiv id=\"root\"\u003e 单项数据绑定：\u003cinput type=\"text\" v-bind:value=\"name\"\u003e \u003cbr/\u003e 双向数据绑定：\u003cinput type=\"text\" v-model:value=\"name2\" \u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root' , data:{ name:'wangty', name2:'wangty', } }) \u003c/script\u003e 页面效果： Vue中有2种数据绑定的方式: 1.单向绑定(v-bind):数据只能从data流向页面, 2.双向绑定(v-model):数据不仅能从data流向页面，还可以从页面流向data。 只适用于表单元素 注意：不是任意的所有的地方都能使用v-model来进行双向绑定 例： \u003cdiv id=\"root\"\u003e \u003ch3 v-bind:x=\"name\"\u003ewangty\u003c/h3\u003e \u003ch3 v-model:x=\"name\"\u003ewangty\u003c/h3\u003e \u003c!-- 该行代码是有问题的 --\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root' , data:{ name:'wangty', } }) \u003c/script\u003e 上面的几行代码，首先在页面查看效果如下： 说明：v-model只能应用在表单元素上（输入类元素，有value值的元素）。 简写形式 和v-bind一样，v-model有他的简写形式 \u003c!-- v-bind简写 --\u003e \u003cinput type=\"text\" v-bind:value=\"name\"\u003e 等价于 =====\u003e \u003cinput type=\"text\" :value=\"name\"\u003e ---------------------------------------------------------------------- \u003c!-- v-model简写 --\u003e \u003cinput type=\"text\" v-model:value=\"name2\" \u003e 等价于 =====\u003e \u003cinput type=\"text\" v-model=\"name2\" \u003e v-on 事件处理 事件的基本使用: 1.使用v-on:xxx或@xxx定事件，其中xxx是事件名; ​ 2.事件的回调需要配置在methods对象中，最终会在vm上; ​ 3.methods中配置的的数，不要用箭头函数。否则this就不是vm了; ​ 4.methods中配置的的数，都是被Vue所管理的函数，this的指向是vm或组件实例对象 ​ 5.@click=“demo\"和 @click=“demo($event)”效果一致，但后者可以传参; \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello,{{name}} \u003c/h1\u003e \u003c!-- 简写形式 v-on:click =====\u003e 等价于 @click --\u003e \u003cbutton v-on:click=\"showInfo\"\u003e点击实现提示信息\u003c/button\u003e \u003cbutton @click=\"showInfo\"\u003e点击实现提示信息\u003c/button\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e //创建Vue实例 new Vue({ el:'#root', data(){ return{} }, //注意showInfo需要放在methods里。 //这儿有个问题：可不可以放进data里呢？ 是可以的。 //能够正常运行，且控制台不报错。但是会被Vue执行数据代理，加重Vue的负荷。 methods:{ //注意这里的showInfo方法也会存储在vm身上，打印vm时可以看见 showInfo(a,b,c,d){ //alert(\"提示\"); console.log(a,b,c,d); } } }) \u003c/script\u003e 方法写在data里的情况，会使得vm对此方法进行数据代理。详解请看【数据代理】小结。 所以我们一般写点击事件只传一个参数，格式写为 showInfo(event){ console.log(event); //获取点击时间的触发目标，一般指按钮对象 //使用event.target console.log(event.target.innerText); //按钮名称 //这里的this也是Vue实例 //这里showInfo如果写成箭头","date":"2024-08-21","objectID":"/vue2/:6:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"7. el与data的两种写法 我们知道，Vue实例和容器之间是通过el属性进行关联的，如果不写el，则标签引用的Vue数据不会被解析，如下面这段代码： \u003c!-- 如果不写el,则Vue不工作，name不被解析 --\u003e \u003cdiv id=\"root\"\u003e \u003ch3\u003e{{name}}\u003c/h3\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ //el:'#root' ,将该行代码注释，页面不解析name，且控制台不报错 data:{ name:'wangty', } }) \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:7:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"v.$mount(’’) 那么有没有什么办法能替代el，使得Vue工作呢 \u003cdiv id=\"root\"\u003e \u003ch3\u003e{{name}}\u003c/h3\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const v = new Vue({ //我们使用一个恒定不变的对象来承接整个Vue实例，取名叫v data:{ name:'wangty', } }) console.log(v); //打印这个v，我们能够看到整个Vue的实例对象 v.$mount('#root') //使用Vue实例的$mount方法，指向root容器，以实现解析和挂载 \u003c/script\u003e 在控制台，这是我们第一个看见Vue的整个实例对象 通过这种写法，我们可以很容易的控制Vue解析页面的时间 //让Vue等一秒钟，再进行页面的解析 setTimeout(()=\u003e{ v.$mount('#root') },1000) 图解 ","date":"2024-08-21","objectID":"/vue2/:7:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"data函数式写法 在Vue实例中，我们把data: { }，这种写法形式称为对象式写法，花括号{}里包含的是对象属性。 除此之外，data在Vue实例里还能写成函数的形式： new Vue({ //data的第一种写法：对象式 data:{ name:'wangty', } //data的第二种写法：函数式 data:function(){ return{ name:'wangty' } } }) ","date":"2024-08-21","objectID":"/vue2/:7:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"关于this 注意：这里的data函数不是我们手动调用的，是Vue帮我们调用的 在这里我们打印输入一下，data方法中的this new Vue({ data:function(){ console.log(\"this\",this); return{ name:'wangty' } } }) 这里this指向的是整个Vue实例对象 注意，如果把data写成箭头函数，例： new Vue({ data:()=\u003e{ console.log(\"this\",this); return{ name:'wangty' } } }) 这里的this指向就会有问题，就会指向全局的window。（箭头函数是没有自己的this的，他默认就会向外去找指向，就会找到外层全局的window，当做他的this去使用） ","date":"2024-08-21","objectID":"/vue2/:7:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"简写形式 我们通常写普通的函数时，一般用（）来代替:function()，所以写成： new Vue({ //data:function() =====\u003e 等价于 =====\u003e data() data(){ console.log(\"this\",this); return{ name:'wangty' } } }) This is a tip\r注意：由Vue所管理的函数，一定不能写成箭头函数，例：data()，watch()，computer()等\r","date":"2024-08-21","objectID":"/vue2/:7:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"8. 理解MVVM Vue在最初的设计的时候，很大程度上参考了MVVM模型官网解释地址 1.M：模型（Model) :对应 data 中的数据 2.V：视图(View):模板 3.VM：视图模型(ViewModel)：Vue 实例对象 这块注意有个现象：写在data里的属性，会同步出现在Vue实例对象的属性里面，原理我们在数据代理时会进行阐述。 同时{{ }}中，Vue实体内中能够看到的所有属性，也能够使用 【Vue实体内的所有属性，Vue模板都可以使用】 例如： \u003ch1\u003e{{$options}}\u003c/h1\u003e \u003ch1\u003e{{$emit}}\u003c/h1\u003e \u003ch1\u003e{{_c}}\u003c/h1\u003e ","date":"2024-08-21","objectID":"/vue2/:8:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"9. Object.defineProperty 数据劫持、数据代理、计算属性，的底层均用到了Object.defineProperty这个方法 作用：给一个方法或者一个对象定义属性 用法：Object.defineProperties(操作的对象名,‘添加的属性名’,{配置项键值对}) \u003cscript type=\"text/javascript\"\u003e let person = { name:'wangty', address:'chengdu' } //给person对象添加一个属性，叫age，值为18 Object.defineProperty(person,'age',{ value:18 }) console.log(person); \u003c/script\u003e 注意这块添加进去的age属性，在控制台的呈现样子 这个颜色的区别，表示这个age不可以被枚举，及age这个属性不参与遍历 ","date":"2024-08-21","objectID":"/vue2/:9:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"enumerable配置项 //我们通过Object的keys方法对其进行验证 // Object.keys()传入一个对象，将对该对象的属性名进行提取，并拼合成一个数组 console.log(Object.keys(person)); 这里可以明显看到，没有age属性 如果想让age属性能够正常被遍历和枚举，我们引入defineProperty中的另一个配置项enumerable //enumerable可枚举的，默认为false Object.defineProperty(person,'age',{ value:18, enumerable:true }) ","date":"2024-08-21","objectID":"/vue2/:9:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"writable配置项 我们在控制台分别操作一下name属性和age属性，再次打印，我们发现age并不能操作成功 这说明defineProperty设置的属性的属性值是不能被修改的 若要使其同正常属性一样能够修改其属性值，则需要使用另一个配置项writable //writable 能否被修改，默认为false Object.defineProperty(person,'age',{ value:18, writable:true }) console.log(person); ","date":"2024-08-21","objectID":"/vue2/:9:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"configurable配置项 我们对属性进行删除操作，这里同样操作name和age： 这说明defineProperty设置的属性的属性值是不能被删除的 若要使其同正常属性一样能够删除，则需要使用另一个配置项configurable //configurable能否被删除，默认为false Object.defineProperty(person,'age',{ value:18, configurable:true, }) console.log(person); ","date":"2024-08-21","objectID":"/vue2/:9:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"getter get函数 当我有一个从变量number中获取年龄的age需求时，希望：当变量发生变化时，年龄属性也同步发生变化。 \u003cscript type=\"text/javascript\"\u003e let number = 18 let person = { name:'wangty', address:'chengdu' } Object.defineProperty(person,'age',{ //注意简写： //get:function() ========\u003e 等价于 get() get:function(){ //当有人读取person的age属性时，get函数就会被调用,且返回值就是age的值 return 'hello' //设置成变量 //return number } }) console.log(person); \u003c/script\u003e 控制台效果为： 注意：每一次使用或者涉及读取age这个属性的时候，都会现调用getter ","date":"2024-08-21","objectID":"/vue2/:9:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"setter 和getter相同的，有一个控制写入的配置项函数，set函数 //当有人修改person的age属性时，set函数就会被调用,且入参是修改的age值 set(value){ console.log(\"有人修改age,且修改值为：\"+value); number = value } ","date":"2024-08-21","objectID":"/vue2/:9:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"10.数据代理 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写） 例： \u003cscript type=\"text/javascript\"\u003e let obj={x:100} let obj2 ={y:200} 0bject.defineProperty(obj2,'x',{ get(){ return obj.x }， set(value){ obj.x = value }) \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:10:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue中的数据代理 1.Vue中的数据代理: 通过vm对象来代理data对象中属性的操作(读/号) 2.Vue中数据代理的好处: 更加方便的操作data中的数据 3.基本原理: 通过object.defineProperty()把data对象中所有属性添加到vm上。 为每一个添加到vm上的属性，都指定一个getter/setter。 在getter/setter内部去操作(读/号)data中对应的属性 这个时候我们来看MVVM小结里的Vue实例中的现象，就很好理解： 首先，Vue在设置data方法的时候，将data内的数据复制了一份，放进了Vue实例对象的_data里 此时使用设置的name，可以用_data.name。 此时还没有进行数据代理。 然后，Vue对所有的data内属性和值使用数据代理，在Vue实体中添加name等属性，自动为其设置getter、setter方法，使得： vm._data.name = vm.name 此时：vm._data = options.data = data 【注意后面这个=成立需要将data要放到整个全局】 关于_data 注意：这块展开_data能够看到和vm中一样的结构，但他并不是数据代理，他主要用来监听data内容变化，用于影响页面解析显示 Vue中的数据劫持主要是通过ES6的Object.defineProperty()方法来实现。Vue会遍历data选项中的属性，并使用Object.defineProperty()将它们转为带有getter和setter的属性，这样Vue就能监控和响应数据的变化。 数据劫持：我们把原始的data内容，复制后增加了getter和setter方法用于数据监测的这种改写和加工操作，称为数据劫持。 ","date":"2024-08-21","objectID":"/vue2/:10:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"11.Computed ","date":"2024-08-21","objectID":"/vue2/:11:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"姓名案例 \u003c!-- 写一个姓名案例：实现输入框输入姓名的时候，自动拼成全名 --\u003e \u003cdiv id=\"root\"\u003e 姓：\u003cinput type=\"text\" v-model=\"xing\"\u003e 名：\u003cinput type=\"text\" v-model=\"ming\"\u003e \u003c!-- 插值语法的正常写法 --\u003e 全名：\u003cspan\u003e{{xing}} - {{ming}}\u003c/span\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root', data(){ return{ xing:'wang', ming:'ty' } }, }) \u003c/script\u003e 页面效果为 这个时候，当input内无限输入姓名的长度，却只取前4位时，插值的写法 \u003c!-- 当需求越复杂，插值语法中的内容就越多 --\u003e \u003c!-- 这种写法不报错，但是不推荐 --\u003e 全名：\u003cspan\u003e{{xing.slice(0,3)}} - {{ming}}\u003c/span\u003e 在Vue官方文档中，风格指南中明确表示，组件模板中应当只包含简单表达式： methods的写法： \u003c!-- fullName不加()返回的是整个函数体 --\u003e \u003c!-- fullName加()返回的是return里的东西 --\u003e 全名：\u003cspan\u003e{{fullName()}}\u003c/span\u003e methods:{ fullName(){ //return 'wangty' return this.xing +'-'+this.ming } } ","date":"2024-08-21","objectID":"/vue2/:11:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"计算属性 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e computed:{ fullName:{ \u003c!-- get原理和defineProperty一样 --\u003e get(){ return 'wangty' } } } 计算属性加载后依旧会放在vm中 在Vue开发者工具的结构中也能够很清晰的区分普通属性和计算属性 Vue对计算属性的缓存处理： \u003c!-- 写一个姓名案例：实现输入框输入姓名的时候，自动拼成全名 --\u003e \u003cdiv id=\"root\"\u003e 姓：\u003cinput type=\"text\" v-model=\"xing\"\u003e 名：\u003cinput type=\"text\" v-model=\"ming\"\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第一次调用 --\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第二次调用 --\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第三次调用 --\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第四次调用 --\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ el:'#root', data(){ return{ xing:'wang', ming:'ty' } }, computed:{ fullName:{ //有人读取fullname时，被调用 get(){ console.log(\"get被调用\"); return this.xing + '-' + this.ming } } } }) \u003c/script\u003e 注意控制台，这个地方对get的调用只调了一次！ 实际上，在第一次调用fullName属性的时候，Vue向计算属性要了返回结果，并进行了缓存处理。在后面再次请求fullName属性的时候，直接使用了缓存中的值。 那么这个缓存在数据变化时是否会对显示造成影响呢？是不会的。 计算属性中的get有两个被调用时机： ​ 1、初次读取fullName属性时 ​ 2、当依赖的数据发生变化时 此处就可以区分methods写法和computed写法之间的优劣了。对的，methods会反复调用！！ \u003cscript type=\"text/javascript\"\u003e ..... ,computed:{ fullName:{ //有人读取fullname时，被调用 get(){ console.log(\"get被调用\"); return this.xing + '-' + this.ming }, //有人修改fullname时，被调用 //传入value为‘李-四’ set(value){ console.log(\"set被调用,被修改的值：\",value); const arr = value.split('-') this.xing = arr[0]; this.ming = arr[1]; } } }, ....... \u003c/script\u003e 计算属性总结： 1.定义：要用的属性不存在，要通过已有属性计算得来。 2.原理：底层借助了objcet.defineproperty方法提供的getter和setter。 3.get函效什么时候执行？ （1）.初次读取时会执行一次。 （2）.当依赖的数据发生改变时会被再次调用。 4.优势：与methods实现相比。内部有缓存机制（复用），效奉更高，调试方便。 5.备注： 1.计算属性最终会出现在vm上，直接读取使用即可。 2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生 ","date":"2024-08-21","objectID":"/vue2/:11:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"计算属性 简写 通常情况下，我们多使用计算属性的读取，不怎么使用修改。当确定计算属性只读不改时： 我们简化计算属性的写法： 1、删除掉set方法； 2、将fullName由对象写法改成函数写法： ​ fullName:{ } ===\u003e fullName:function( ){ } ===\u003e fullName(){ } ​ 并将这个函数，当作get函数使用 \u003cscript type=\"text/javascript\"\u003e ..... ,computed:{ fullName(){ return this.xing + '-' + this.ming }, }, ....... \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:11:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"12.watch ","date":"2024-08-21","objectID":"/vue2/:12:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"天气案例 \u003c!-- 写一个按钮点击后，实现页面天气的切换，并且输出切换前的天气和切换后的天气 --\u003e \u003cdiv id=\"root\"\u003e \u003ch3\u003e今天天气很{{info}}\u003c/h3\u003e \u003cbutton @click=\"isHost = !isHost\"\u003e点击切换天气\u003c/button\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ el:'#root', data(){ return{ isHost:true, } }, methods:{ }, computed:{ info(){ return this.isHost? '炎热':'凉爽' } } }) \u003c/script\u003e 效果是，点击按钮，天气能在炎热凉爽之间来回切换 注意：这样的写法，在Vue开发者工具上会有个bug \u003cdiv id=\"root\"\u003e \u003c!-- 当我将下面这行代码 --\u003e \u003ch3\u003e今天天气很{{info}}\u003c/h3\u003e \u003c!-- 改为 --\u003e \u003ch3\u003e今天天气很一般\u003c/h3\u003e ..... \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e .... ,computed:{ info(){ return this.isHost? '炎热':'凉爽' } }, .... \u003c/script\u003e 此处，computed中info的属性依旧随着isHost值的变化，而计算了 但是在Vue开发者工具中却并不能提现。但是我们可以通过vm验证，计算属性是变化了的。 即，当页面没有使用计算属性和基本属性的时候，Vue开发者工具，就不更新data中被修改的基本属性的值了。但是实际上vm中的data属性值和计算属性值都是被更改了的。 此处属于Vue开发者工具的一个小坑，后续可能Vue开发者工具会进行维护。 ","date":"2024-08-21","objectID":"/vue2/:12:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"监视属性 \u003cscript type=\"text/javascript\"\u003e new Vue({ ..... ,watch:{ //isHost：监视谁，这儿就写谁的名字，这里指监视isHost的变化 isHost:{ //handler函数什么时候调用？在isHost被修改的时候。 handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //初始化时是否执行handler,默认为false immediate:true } }, }) \u003c/script\u003e 控制台效果 第二种写法，可以通过Vue实例对象，实现效果都是一样的 \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ ........ }) //注意这里监视对象要加''引号。里面的配置项内容和watch里的写法一样 vm.$watch('isHost',{ handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //immediate:true }) \u003c/script\u003e 监视属性watch 1.当被监视的属性变化时，回调函数自动调用，进行相关操作 2.监视的属性必须存在，才能进行监视！！ 没有不会报错，但是监视前后数据都是undefined 3.监视的两种写法： （1）. new Vue时传入watch配置 ​ （2）. 通过vm.$watch监视 ","date":"2024-08-21","objectID":"/vue2/:12:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"深度监视 深度监视： （1）Vue中的watch默认不监测对象内部值的改变（一层）。 （2）配置deep:true可以监测对象内部值改变（多层）。 备注： （1）Vue自身可以监测对象内部值的改变，但vue提供的watch默认不可以！ （2）使用watch时根据数据的具体结构，决定是否采用深度监视。 \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ el:'#root', data(){ return{ number:{ a:1, b:1 } } }, watch:{ //监视多级结构中，某个属性的变化 'number.a':{ handler(){ console.log('a被修改了'); }, } }, }) \u003c/script\u003e 注意：这块儿监视的number是指number：{ }对象所在的地址值 如果写成watch：{ number：{ } } 地址永远不会变化，则永远不会触发监听。 如果想要监视到number中任意一个值变化，那么需要加上监视穿透deep \u003cscript type=\"text/javascript\"\u003e ........., watch:{ number:{ deep:true, handler(){ console.log('a被修改了'); }, } }, ....... \u003c/script\u003e 注意：这块两个概念，Vue实例是可以监测到多层级数据中属性的变化的，这个可以在控制台通过打印vm验证。只是Vue提供给开发者的watch属性中，无法直接监测到多层级数据的变化，需要设置默认检测层级或者使用deep。 ","date":"2024-08-21","objectID":"/vue2/:12:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"监视的简写形式 如果监视的对象不适用其他配置项，例如deep，immediate等，只使用handler，可简写成： \u003cscript type=\"text/javascript\"\u003e ........., watch:{ //正常写法 isHost:{ handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //简写，isHost对象式写成函数式，当handler用 isHost(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, }, ....... \u003c/script\u003e 或者 \u003cscript type=\"text/javascript\"\u003e ........., //正常写法 vm.$watch('isHost',{ handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //deep:true //immediate:true }) //简写 vm.$watch('isHost',function(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }) ....... \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:12:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"13.watch对比computed 计算属性 vs 侦听属性 Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子： \u003cdiv id=\"demo\"\u003e{{ fullName }}\u003c/div\u003e var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' }, watch: { firstName: function (val) { this.fullName = val + ' ' + this.lastName }, lastName: function (val) { this.fullName = this.firstName + ' ' + val } } }) 上面代码是命令式且重复的。将它与计算属性的版本进行比较： var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar' }, computed: { fullName: function () { return this.firstName + ' ' + this.lastName } } }) 好得多了，不是吗？ 我们发现，好多功能在使用watch和computed属性都可以完成： 不过呢。。。computed完全依赖return的内容。 但是，目前还没有办法可以让computed等待一段时间再进行return返回。 说明，计算属性中，是不能够开启异步任务去处理数据的。 那这个时候就需要依赖watch watch不依赖return，watch中的数据修改，依赖于数据处理语句，例如：a = b ，给a的赋值语句 所以当有：想要某值改变，但是延迟一秒操作的时候。使用watch进行处理 这里注意一个小细节哦： //这里的setTimeout很自然的使用了箭头函数 //之前我们说过，尽量不适用箭头函数以免改变了方法体中this的指向 //这里： //isHost是Vue管理下的函数。 //但是setTimeout定时器所指定的回调，是不受Vue控制的。浏览器定时器管理模块控制的。最后到时间了，也是js引擎帮我们调的函数 //------------------------------------------------------ //所以这儿，必须写成箭头函数 //如果这儿写成普通函数，js引擎会认为this是它引擎控制的整个window //------------------------------------------------------ //原理： //当这儿写成箭头函数的时候，由于箭头函数没有this，就会默认往外层找 //这儿setTimeout的外层是isHost函数 //而isHost函数的this就是Vue //由此使得this的指向正常 watch:{ isHost(val){ setTimeout(()=\u003e{ this.isHost = val },1000); } 小结： computed利watch之间的区别： 1.computed能完成的功能，watch都可以完成。 2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。 两个重要的小原则： 1.所被vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。 2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数、Promise的回调函数等，只要是没引入Vue都可以调用的函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象 ","date":"2024-08-21","objectID":"/vue2/:13:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"14.列表过滤 两种实现方式，先用watch写一遍再用computed写一遍 watch写法： \u003cbody\u003e \u003cdiv\u003e \u003ch3\u003e列表过滤\u003c/h1\u003e \u003c/div\u003e \u003cdiv id=\"root\"\u003e \u003cinput type=\"text\" v-model=\"keyWord\"\u003e \u003cul\u003e \u003cli v-for=\"(p,index) of filPersons\" :key=\"p.id\"\u003e {{p.name}}-{{p.age}}-{{p.sex}} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#root', computed:{ }, watch:{ keyWord:{ immediate:true, handler(val){ //这块注意，filter要返回满足条件的新数组 this.filPersons = this.persons.filter((p)=\u003e{ //indexOf对于包含的内容返回索引，不包含的内容返回-1 //这里注意，都包含空字符串：任何字符串.indexOf('')都返回0 return p.name.indexOf(val) !== -1 }) }, } }, data:{ keyWord:'', persons:[ {id:'001',name:'马冬梅',age:18,sex:'女'}, {id:'002',name:'周冬雨',age:19,sex:'女'}, {id:'003',name:'周杰伦',age:20,sex:'男'}, {id:'004',name:'温兆伦',age:21,sex:'男'}, ], filPersons:[] }, }) \u003c/script\u003e \u003c/body\u003e computed写法： \u003cbody\u003e \u003cdiv\u003e \u003ch3\u003e列表过滤\u003c/h1\u003e \u003c/div\u003e \u003cdiv id=\"root\"\u003e \u003cinput type=\"text\" v-model=\"keyWord\"\u003e \u003cul\u003e \u003cli v-for=\"(p,index) of filPersons\" :key=\"p.id\"\u003e {{p.name}}-{{p.age}}-{{p.sex}} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#root', computed:{ filPersons(){ return this.persons.filter((p)=\u003e{ return p.name.indexOf(this.keyWord) !== -1 }) } }, data:{ keyWord:'', persons:[ {id:'001',name:'马冬梅',age:18,sex:'女'}, {id:'002',name:'周冬雨',age:19,sex:'女'}, {id:'003',name:'周杰伦',age:20,sex:'男'}, {id:'004',name:'温兆伦',age:21,sex:'男'}, ], }, }) \u003c/script\u003e \u003c/body\u003e ","date":"2024-08-21","objectID":"/vue2/:14:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"15.列表排序 排序和搜索都能同时控制使用 computed写法： \u003cbody\u003e \u003cdiv\u003e \u003ch3\u003e列表排序\u003c/h1\u003e \u003c/div\u003e \u003cdiv id=\"root\"\u003e \u003cinput type=\"text\" v-model=\"keyWord\"\u003e \u003cbutton @click = \"sortType = 2\"\u003e年龄升序\u003c/button\u003e \u003cbutton @click = \"sortType = 1\"\u003e年龄降序\u003c/button\u003e \u003cbutton @click = \"sortType = 0\"\u003e原顺序\u003c/button\u003e \u003cul\u003e \u003cli v-for=\"(p,index) of filPersons\" :key=\"p.id\"\u003e {{p.name}}-{{p.age}}-{{p.sex}} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#root', computed:{ filPersons(){ const arr = this.persons.filter((p)=\u003e{ return p.name.indexOf(this.keyWord) !== -1 }) //为0时不进该判断 if(this.sortType){ //升降序方法.sort(a,b)两个入参。升序-前减后，降序-后减前 arr.sort((p1,p2)=\u003e{ return this.sortType === 1? p2.age - p1.age : p1.age - p2.age }) } return arr; } }, data:{ keyWord:'', sortType:0, // 0原顺序 1降序 2升序 persons:[ {id:'001',name:'马冬梅',age:18,sex:'女'}, {id:'002',name:'周冬雨',age:19,sex:'女'}, {id:'003',name:'周杰伦',age:20,sex:'男'}, {id:'004',name:'温兆伦',age:21,sex:'男'}, ], }, methods:{ } }) \u003c/script\u003e \u003c/body\u003e ","date":"2024-08-21","objectID":"/vue2/:15:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"16.Vue监测数据改变的原理 这里注意，修改更新data中的数据时存在这样一个问题： \u003cbody\u003e \u003cdiv\u003e \u003ch3\u003e人员列表\u003c/h1\u003e \u003c/div\u003e \u003cdiv id=\"root\"\u003e \u003cbutton @click=\"updataMei\"\u003e点击更改马冬梅的数据\u003c/button\u003e \u003cul\u003e \u003cli v-for=\"(p,index) of persons\" :key=\"p.id\"\u003e {{p.name}}-{{p.age}}-{{p.sex}} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e const vm = new Vue({ el:'#root', computed:{ }, data:{ persons:[ {id:'001',name:'马冬梅',age:18,sex:'女'}, {id:'002',name:'周冬雨',age:19,sex:'女'}, {id:'003',name:'周杰伦',age:20,sex:'男'}, {id:'004',name:'温兆伦',age:21,sex:'男'}, ], }, methods:{ updataMei(){ //这里挨个修改data中的第一行数据 this.persons[0].name = '马老师'; this.persons[0].age = '50'; this.persons[0].sex = '男'; //这里整体修改data中的第一行数据 【会发现此种写法它不生效】 this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} } } }) \u003c/script\u003e \u003c/body\u003e 运行结果： 可以看出，逐条修改数据，可以成功修改Vue中的数据，并且更新页面上的显示；但是整体修改，Vue中的数据确实被修改了，这里通过vm可以看出，页面上却不更新显示。 由此我们在这里探讨：Vue监测数据改变的原理。（Vue是如何监测数据改变的） ","date":"2024-08-21","objectID":"/vue2/:16:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"响应式解析过程 data中数据的解析过程： ​ 在数据代理小节：我们知道，Vue将data中的数据复制一份,形成了_data。Vue通过_data进行数据代理生成页面上的data。 ​ 但是，这儿能看出我们写的data和vm中的_data，_data结构上比我们写的多了些东西。这里说明Vue不是单纯的复制了我们写的data，它对data进行了加工。 ​ 它对data进行加工的作用，使得我们在修改data中的数据的时候，它通过setter方法重新解析模板。这就是响应式。 ​ 整个响应式流程：data中name修改，形成新的_data.name，调用setter方法、重新解析模版，生成虚拟dom，新旧dom对比算法，复用旧dom/生成新dom。 ","date":"2024-08-21","objectID":"/vue2/:16:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"模拟数据监测 这里我们不使用Vue，单独写一个对象的数据监测： \u003c!--Vue的数据检测类似 --\u003e \u003cscript text=\"text/javascript\"\u003e let data = { name: 'username', age:'12' } //这里创建一个监视的实力对象，用于监视数据data中的数据变化 const obs = new Observer(data); console.log(obs); //这里的obs打印输出来和data一致 //Observer函数：入参为需要监视的数据对象 function Observer(obs){ //取对象中所有的属性形成一个数组 ，这里是[name,age] const keys = Object.keys(obs) //遍历 keys.forEach((k)=\u003e{ //k为每一个属性,this为整个obs实例对象 //Object.defineProperty(对象,'属性',{}) Object.defineProperty(this,k,{ //读：就把改属性的值返回去 get(){ console.log(\"被读\"); return obs[k] }, //改：就把收到的值替换到对应属性 set(val){ console.log(\"被改\"); obs[k] = val } }) }) } \u003c/script\u003e 注意不能直接对data使用defineProperty，防止死循环 //死循环代码 //这种监视会反复调用读取，导致卡死 Object.defineProperty(data,'name',{ get(){ return data.name } }) ","date":"2024-08-21","objectID":"/vue2/:16:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue里的对象监测原理 ​ Vue底层的对象监测类似于此，依赖于Vue.set() ","date":"2024-08-21","objectID":"/vue2/:16:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue.set() 注意，Vue里模版中使用一个对象中不存在的属性，则值默认为undefined。如果Vue在页面中遇到undefined，则默认成什么都不展示，且控制台无报错。 当Vue里模版中使用vm身上不存在的属性，控制台就会报错告诉你未定义。 所以这里，我们设置一个属性时，将其定义在对象中。保证我们的演示效果，写法如上图左侧 我们需要对student.sex实时追加属性值，使得页面上同时进行实时更新。 这里使用Vue.set() 官网API地址 //Vue提供函数 target改动对象，key操作的属性，val修改的值 Vue.set(target,key,val) //vm._data取对象 Vue.set(vm._data.student,'sex','男') //或者vm.data取对象，数据代理原理 Vue.set(vm.student,'sex','男') 或者使用vm.$set() vm.$set(target,key,val) //vm._data取对象 vm.$set(vm._data.student,'sex','男') //或者vm.data取对象，数据代理原理 vm.$set(vm.student,'sex','男') 注意：对象不能是 Vue 实例，或者 Vue 实例的根数据对象。Vue.set()不是万能的，其设定了禁止直接对vm进行操作。即，只能操作data里的对象，不能操作data对象，例如： //使用Vue.set()直接在vm中加入sex属性 //此操作会报错，告诉你禁止直接操作vm下的data对象。 //下面是两种错误写法 Vue.set(vm._data.sex,'sex','男') Vue.set(vm.sex,'sex','男') ","date":"2024-08-21","objectID":"/vue2/:16:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue里的数组监测原理 Vue如何检测数组里的数据改变 我们将data中设置一组对象数据，和一组数组数据，我们在页面控制台输出的data中可以看到两个数据的差别 Vue在加工的时候，给对象都创建了getter和setter方法。但是数组却没有。 当我们修改数组的时候 this.school[0] = '大学' //页面不生效 原因这儿就找到了！页面模版的重新解析，依赖了数据中的setter方法，而数组没有setter。所以当我们修改数组时，vm的data中确实数据发生了更改，而页面却没有任何变化。这就也解释了为什么人员列表的时候，persons数组列表中直接修改第一行的数据，vm被改动，但页面不生效的现象了。 在Vue 的设计者认为中，数组应使用修改数组的一些方法对其进行修改。只有当使用数组的通用修改方法时，Vue才承认数组被改变了，才能够监测到数组数据的改变。 修改数组的一些常用方法： ​ push：在数组尾部添加一个元素 ​ pop：删除最后一个元素 ​ shift：删除第一个元素 ​ unshift：在数组头部添加一个元素 ​ splice：在某索引处进行删除、修改、添加 ​ sort：数组排序 ​ reverse：数组翻转 当使用上面这些方法时，Vue则可以成功监测到数据改变，同步更新页面。例如： vm._data.school.push('大学') 当然，提供的Vue.set() 依旧对数组有效 Vue.set(vm._data.school,0,'大学') 不过需要注意的是，这里vm使用的push及其以上方法，并是不原生态的Array数组使用的push方法。Vue对其进行了包装。官网API地址 //控制台验证 vm._data.school.push === Array.prototype.push //false ","date":"2024-08-21","objectID":"/vue2/:16:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"17.表单数据收集 表单数据收集时： ajax前台往后台传参数的时候，把一组数据转成JSON格式的 JSON.statiy()数据转换成JSON格式 收集表单数据：可以用this._data，但是一般不推荐直接使用 建议整个表单数据，前面包一个对象，通过 对象收集 this.queryInfo v-model的修饰符： v-model.trim =\u003e 不收集输入的空格（所有的空格都不收集） v-model.number =\u003e 收集的数据自动转成数值类型 v-model.lazy =\u003e 收集时，需要失去焦点后再记录 小结： 如果input框的type类型是text，v-model收集的是value，用户输入的也是value 如果类型是radio，需要给标签配置value值 如果类型是checkbox， 没有设置value，收集的是是否被选中，true/false 配置了value，初始值是数组，收集的是选中的数组。是非数组，收集的是布尔值 ","date":"2024-08-21","objectID":"/vue2/:17:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"18.过滤器 小案例：当前时间戳的转换。【日期第三方库 moment.js 、 dayjs】 我们用三种实现方式：计算属性、methods、过滤器 分别实现 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e过滤器\u003c/title\u003e \u003cscript src=\"js/vue.js\"\u003e\u003c/script\u003e \u003c!-- 日期转换方法第三方库引入 --\u003e \u003c!-- 有互联网也可以引在线的 --\u003e \u003c!-- https://www.bootcdn.cn/ 搜索dayjs 复制链接 另存为 --\u003e \u003cscript src=\"js/dayjs.min.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003e过滤器 时间戳切换\u003c/h1\u003e \u003ch3\u003e当前时间：{{time}}\u003c/h3\u003e \u003c!-- 计算属性 实现 --\u003e \u003ch3\u003e当前时间：{{timeComputed}}\u003c/h3\u003e \u003c!-- methods 实现 --\u003e \u003ch3\u003e当前时间：{{getNowTime()}}\u003c/h3\u003e \u003c!-- filter 实现 --\u003e \u003c!-- | 管道符前面的为入参 后面的为过滤器函数 --\u003e \u003c!-- 后面的函数return的内容 整个替换掉插值位置的所有内容 显示 --\u003e \u003ch3\u003e当前时间：{{time | timeFormater}}\u003c/h3\u003e \u003c!-- filter传参 --\u003e \u003c!-- 默认第一位参数为 | 前参数，第二位参数为小括号内参数 --\u003e \u003ch3\u003e当前时间：{{time | timeFormater(\"YYYY年MM月DD日\")}}\u003c/h3\u003e \u003c!-- filter串联 --\u003e \u003c!-- 串联不影响传参 --\u003e \u003c!-- mySlice只接受timeFormater返回地方值进行计算 挨着串联 只处理该函数 | 前的返回值为入参--\u003e \u003ch3\u003e当前年份：{{time | timeFormater(\"YYYY年MM月DD日\") | mySlice}}\u003c/h3\u003e \u003c/div\u003e \u003cscript\u003e //定义全局过滤器 //一次只能定义一个 //Vue.filter('注册全局过滤器名称',function(入参){方法体} Vue.filter('mySlice',function(val){ return val.slice(0,4) }) new Vue({ el:'#root', data:{ time:Date.now(), }, computed:{ timeComputed(){ return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss') } }, methods:{ getNowTime(){ return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss') } }, //注意：new Vue中的filters 可以写多个。里面的每一个filter都属于局部过滤器。当这个Vue是组件时，A组件和B组件的filter不能相互使用。 filters:{ //timeFormater(val){ 没有第二入参的写法 timeFormater(val,str = 'YYYY-MM-DD HH:mm:ss'){ //有第二入参用入参，没有用默认的 = 后的这个 //return 'hello' 返回啥页面就是啥，完全依赖此处return return dayjs(val).format('YYYY-MM-DD HH:mm:ss') }, mySlice(val){ return val.slice(0,4) } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ⚠️注意：new Vue中的filters 可以写多个。里面的每一个filter都属于局部过滤器。当这个Vue是组件时，A组件和B组件的filter不能相互使用。 \u003c!-- 过滤器使用方式 --\u003e \u003c!-- 插值语法 --\u003e \u003ch3\u003e当前时间：{{time | timeFormater}}\u003c/h3\u003e \u003c!-- 单向属性绑定（双向用不了，这种形式也用的比较少） --\u003e \u003ch3 :x=\"time | timeFormater\"\u003e\u003c/h3\u003e 🏷小结：一般用于 对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理） ","date":"2024-08-21","objectID":"/vue2/:18:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"19.生命周期 定义\r生命周期: 1.又名: 生命周期回调函数、生命周期函数、生命周期钩子。（只需要准备好函数，在特定的时间，将函数钩出来使用。） 2.是什么: Vue在关键时刻帮我们调用的一些特殊名称的函数。 3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的 4.生命周期函数中的this指向是vm或组件实例对象。 实现一个幻灯片渐隐渐现的效果 \u003c!-- 定时器写在外部(不推荐) --\u003e \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003c!-- 此处为 :style=\"{opacity:opacity}\" 因为style中为js函数体，函数体同名可以省略，由此写成下面的这种形式--\u003e \u003ch2 :style=\"{opacity}\"\u003e一个渐隐渐现的效果\u003c/h2\u003e \u003c/div\u003e \u003cscript\u003e const vm = new Vue({ el:'#el', data:{ opacity:1 //初始化：默认透明度为1 }, }) //再Vue外面写一个定时器，循环操作vm setInterval(()=\u003e{ //每次透明度减小0.01 vm.opacity -= 0.01 //注意此处写成 \u003c=0 ,而不是写成 ==0 ，因为在js中 0.1 +0.1 不一定等于0.2 ，所以在-0.01的时候不一定会刚好减到0，有可能直接奔负数就去了 //一旦发现透明度减完了，就使其恢复到1 if(vm.opacity \u003c= 0) vm.opacity =1 },16) //每隔16毫秒就减一次透明度 \u003c/script\u003e \u003c/body\u003e 使用声明周期函数，使得定时器能够自然的存在于Vue的内部 原理：Vue在解析完模板，由虚拟DOM生成真实DOM之后，会默认调用的几个函数，帮我们完成在元素加载后，自动调用需要调用的函数 【在Vue整个干活过程中，特殊的时间点，去调用的函数，统称为生命周期函数】 \u003c!-- mounted()生命周期函数 写法--\u003e \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003ch2 :style=\"{opacity}\"\u003e一个渐隐渐现的效果\u003c/h2\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#el', data:{ opacity:1 //初始化：默认透明度为1 }, //Vue完成模版的解析并把真实的DOM元素放入页面后（挂载完成）调用mounted //只在真DOM放入时调用一次，后面解析模板不会再被调用 mounted(){ setInterval(()=\u003e{ this.opacity -= 0.01 if(this.opacity \u003c= 0) this.opacity =1 },16) } }) \u003c/script\u003e \u003c/body\u003e 官方操作手册中给出了非常完整的Vue生命周期图示：如这里 ， 同时也给了详细的解释。这里我们仅仅将图拿过来，进行简单的备注和阐述。 阅读此图注意： 实色填充图形均为 生命周期 流程 红色圆角矩形框 均为 生命周期 函数 绿色填充和黄色填充圆角矩形框和菱形框 均为 生命周期 某环节 ","date":"2024-08-21","objectID":"/vue2/:19:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生命周期_挂载流程 beforeCreate() 第一个生命周期函数： 数据创建前 首先打印函数名称，确定函数执行；其次验证vm上并没有data的数据代理 \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003ch2\u003e当前的n值是：{{n}}\u003c/h2\u003e \u003cbutton @click = \"add\"\u003e点我n+1\u003c/button\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#el', data:{ n:1 }, methods:{ add(){ n++} }, beforeCreate(){ console.log('beforeCreate'); console.log(this); debugger; } }) \u003c/script\u003e \u003c/body\u003e 控制台表现 created() 第二个生命周期函数： 数据创建完毕 首先打印函数名称，确定函数执行；其次验证vm上完成了data的数据代理 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); console.log(this); } }) \u003c/script\u003e \u003c/body\u003e 控制台表现 beforeMount() 第三个生命周期函数 数据挂载前 首先打印函数名称，确定函数执行；其次验证vm中有值，但此时并没有将解析结果（值）放入页面 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); }, beforeMount(){ console.log('beforeMount'); console.log(this); debugger; }, }) \u003c/script\u003e \u003c/body\u003e 控制台表现 验证此处对DOM的所有操作，最终都不会有效 mounted() 第四个生命周期函数 数据挂载完毕 首先打印函数名称，确定函数执行；其次，确定页面上所有的元素都被解析完成，且挂载完毕 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); }, beforeMount(){ console.log('beforeMount'); }, mounted(){ console.log('mounted'); console.log(this); debugger; }, }) \u003c/script\u003e \u003c/body\u003e 控制台效果 到此，整个挂载流程结束。 挂载流程 - 图解： 注意\r在使用template模版对象时，有多个节点只能用\u003cdiv\u003e标签进行包裹，不能使用\u003ctemplate\u003e标签。 \u003cscript\u003e ..... //只能使用div template:` \u003cdiv\u003e \u003ch2\u003e当前的n值是：{{n}}\u003c/h2\u003e \u003cbutton @click = \"add\"\u003e点我n+1\u003c/button\u003e \u003c/div\u003e `, ...... //不能使用template template:` \u003ctemplate\u003e \u003ch2\u003e当前的n值是：{{n}}\u003c/h2\u003e \u003cbutton @click = \"add\"\u003e点我n+1\u003c/button\u003e \u003c/template\u003e `, \u003c/script\u003e 我们知道\u003ctemplate\u003e标签，在页面解析的时候，会自动隐藏掉最外的一层，只显示\u003ctemplate\u003e标签里面的内容。所以，容易产生\u003ctemplate\u003e标签里面多根节点的问题。导致template模版对象编译失败报错 ","date":"2024-08-21","objectID":"/vue2/:19:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生命周期_更新流程 beforeUpdate() 第五个生命周期函数 在页面数据更新完成前 首先打印函数名称，确定函数执行；其次，验证此环节：数据已经更改，但页面并未更新 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); }, beforeMount(){ console.log('beforeMount'); }, mounted(){ console.log('mounted'); }, beforeUpdate(){ console.log('beforeUpdate'); console.log(this.n); debugger; }, }) \u003c/script\u003e \u003c/body\u003e 控制台效果 updated() 第六个生命周期函数 在页面数据更新完毕 首先打印函数名称，确定函数执行；其次，验证此环节：数据已经更改，页面完成更新 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); }, beforeMount(){ console.log('beforeMount'); }, mounted(){ console.log('mounted'); }, beforeUpdate(){ console.log('beforeUpdate'); }, updated(){ console.log('updated'); console.log(this.n); debugger; }, }) \u003c/script\u003e \u003c/body\u003e 控制台效果 到此，整个更新流程结束。 更新流程 - 图解： ","date":"2024-08-21","objectID":"/vue2/:19:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生命周期_销毁流程 This is a tips\rvm被销毁： 使得该vm不再工作（数据变化时，不再继续解析了） 但是原来工作的成果还在（即，已经被解析挂载的页面不会有变化）。 官方解释：https://cn.vuejs.org/v2/api/#vm-destroy beforeDestroy() 第七个生命周期函数 将要销毁前 这里是可以访问所有的vm中的所有数据和方法的，但是此时所有对数据的修改都不会再返过去触发更新流程了。即，这里所有的数据修改操作，页面都不会有任何效果。（值可以随便用，方法可以随便调，页面不会有变化） \u003cscript\u003e new Vue({ ..... beforeDestroy(){ console.log('beforeDestroy'); console.log(this.n); //能正常拿到 this.n = 99 //改行操作无用 }, }) \u003c/script\u003e destroyed() 第八个生命周期函数 销毁完毕 \u003cscript\u003e new Vue({ ..... beforeDestroy(){ console.log('beforeDestroy'); }, destroyed(){ console.log('destroyed'); } }) \u003c/script\u003e 到此，整个销毁流程结束。 销毁流程 - 图解： ","date":"2024-08-21","objectID":"/vue2/:19:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生命周期_总结 整个生命周期 - 图解： 4对生命周期钩子： vm的一生(vm的生命周期): 将要创建========\u003e调用beforeCreate函数。 创建完毕========\u003e调用created函数。 将要挂载========\u003e调用beforeMount。 (重要)挂载完毕==\u003e调用mounted函数========\u003e【重要的钩子】 将要更新========\u003e调用beforeUpdate数。 更新完毕========\u003e调用updated函数。 (重要)将要销毁==\u003e调用beforeDestroy函数。========\u003e【重要的钩子】 销毁完毕========\u003e调用destroyed函数。 这块流程中：主要阐述8个钩子。还有3个常用的钩子，需要在特殊的场景才能被调用，我们会在路由小节中进行详细描述。 第2章：Vue组件化编程 ","date":"2024-08-21","objectID":"/vue2/:19:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"20.组件 Vue组件化编程 传统方式编写应用，存在2个问题： 1、依赖关系混乱不好维护（一堆html引用一堆js和css）； 2、代码复用率不高。 组件的定义： 实现应用中局部功能代码(html、js、css)和资源(mp3、gif)的集合 模块化： 当用js来写的，并且将一个大的js按照模块分成多个不同的js来编写应用，就称为一个模块化应用 组件化： 当用组件来写，并且应用中的功能都是多个组件来编写的，就称为一个组件化的应用。 组件复用不需要复制粘贴，只需要引用即可。非常方便。 ","date":"2024-08-21","objectID":"/vue2/:20:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"非单文件组件 一个文件中包含有n个组件。例如：a.html中有4个组件 ","date":"2024-08-21","objectID":"/vue2/:20:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"单文件组件 一个文件中只包含有1个组件。例如：a.vue中有且只有唯一一个组件 ","date":"2024-08-21","objectID":"/vue2/:20:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue中使用组件的三步 1、创建组件 \u003cscript\u003e //创建school组件 const school = Vue.extend({ //组件定义时，一定不要写el配置项 //因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器 //el:'#el', //data这里必须写成函数形式 data(){ //在return中返回你要设置的data内容 //这个问题在el于data的写法小节有铺垫过 //原因就是：data对象式直接使用了同一个对象，导致多方调用时，相互影响。 //而data函数形式，每一次调用都是return创建的一个新的对象，解决了多方调用被相互影响的问题。 return{ name:'某学校', address:'某地址' } }, template:` \u003cdiv\u003e \u003ch2\u003e学校名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学校地址：{{address}}\u003c/h2\u003e \u003c/div\u003e ` }) //创建student组件 const student = Vue.extend({ data(){ return{ name:'张三', age:'18' } }, template:` \u003cdiv\u003e \u003ch2\u003e学生名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学生年龄：{{age}}\u003c/h2\u003e \u003c/div\u003e ` }) new Vue({ el:'#el', }) \u003c/script\u003e 2、注册组件 This is a tip\r全局注册 Vue.component('school',school) \u003cscript\u003e new Vue({ el:'#el', //全新配置项 //注册组件（局部注册） components:{ school:school, student:student } }) \u003c/script\u003e 3、编写组件标签，使用组件 \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003c!-- 编写组件标签 --\u003e \u003cschool\u003e\u003c/school\u003e \u003cstudent\u003e\u003c/student\u003e \u003c/div\u003e \u003c/body\u003e 实现效果以及Vue开发者工具节点体现如图： ","date":"2024-08-21","objectID":"/vue2/:20:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"细节点注意 1.关于组件名: 一个单词组成: 第一种写法(首字母小写):school 第二种写法(首字母大写):School 多个单词组成: 第一种写法(kebab-case命名):my-school \u003cmy-school\u003e\u003c/my-school\u003e components:{ 'my-school':school, } 第二种写法(CamelCase命名):MySchool(需要Vue脚手架支持) \u003c!-- 不在Vue脚手架里会报错 --\u003e \u003cMySchool\u003e\u003c/MySchool\u003e components:{ MySchool:school, } 备注: (1).组件名尽可能回避HTML中已有的元素名称，例如:h2、H2都不行。 (2).可以使用name配置项指定组件在开发者工具中呈现的名字。 \u003cscript\u003e const student = Vue.extend({ //自定义组件名字 - 没有这个就取注册时候的key:value的key值 name:'student' data(){ return{ .... } }, template:.... }) \u003c/script\u003e 2.关于组件标签: 第一种写法:\u003cschool\u003e\u003c/school\u003e 第二种写法:\u003cschoo1/\u003e 备注:不用使用脚手架时，\u003cschool/\u003e会导致后续组件不能渲染 \u003c!-- 两种写法：页面均可正常渲染school组件 --\u003e \u003cmyshool\u003e\u003c/myshool\u003e \u003cmyshool/\u003e \u003c!-- 页面渲染三个school组件 --\u003e \u003cmyshool\u003e\u003c/myshool\u003e \u003cmyshool\u003e\u003c/myshool\u003e \u003cmyshool\u003e\u003c/myshool\u003e \u003c!-- 页面只渲染一个school组件，后面的不再渲染 --\u003e \u003cmyshool/\u003e \u003cmyshool/\u003e \u003cmyshool/\u003e 3.一个简写方式: const school =Vue.extend(options)可简写为:const school = options \u003cscript\u003e //主动调用组件扩展方法extend const student = Vue.extend({ data(){ return{ ... } }, template:.... }) //简写 const student = { data(){ return{ ... } }, template:.... } new Vue({ el:'#el', //注册组件时判断：有写extend直接使用组件，没有则帮忙调用extend之后使用组件 components:{ school:school, } }) \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:20:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"组件的嵌套 下方是三个组件的嵌套。 所有的组件都嵌在app组件中，app组件中有同级school组件、hello组件，school组件中含有student组件、 代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"../js/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003capp\u003e\u003c/app\u003e \u003c/div\u003e \u003cscript\u003e //创建student组件 const student = Vue.extend({ data(){ return{ name:'张三', age:'18' } }, template:` \u003cdiv\u003e \u003ch2\u003e学生名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学生年龄：{{age}}\u003c/h2\u003e \u003c/div\u003e ` }) //创建school组件 const school = Vue.extend({ data(){ return{ name:'某学校', address:'某地址' } }, template:` \u003cdiv\u003e \u003ch2\u003e学校名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学校地址：{{address}}\u003c/h2\u003e \u003c!-- 2在哪里注册的，在哪个模版中写 --\u003e \u003cstudent\u003e\u003c/student\u003e \u003c/div\u003e `, //注册组件 components:{ //1定义组件的代码，要写在注册组件之前（比如这里的14~27行代码，必须在49行代码之前） //简写 student } }) const hello = Vue.extend({ template:`\u003ch1\u003e你好鸭！欢迎来进行学习~\u003c/h1\u003e` }) const app = Vue.extend({ template:` \u003cdiv\u003e \u003chello\u003e\u003c/hello\u003e \u003cschool\u003e\u003c/school\u003e \u003c/div\u003e `, components:{ hello, school } }) new Vue({ el:'#el', //注册组件 components:{ //简写 app } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 页面及控制台运行效果： This is a tip\r1 定义组件的代码，要写在注册组件之前 2 子组件只能写在，注册的父组件的模版template中 ","date":"2024-08-21","objectID":"/vue2/:20:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"VueComponent结构函数 关于VueComponent： 1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的 const school = Vue.extend({}) //定义组件后，打印组件 console.log(\"@\",school); 控制台输出为： 这里可以看出，其是一个函数。严谨上来讲，我们称其为构造函数，其调用方式应该为new VueComponent() 我们打开Vue.js查找VueComponent函数，打印一段文字。我们会发现，当我们使用组件时候，使用一次就调一次该函数。即，有一个\u003cschool\u003e\u003c/school\u003e调一次new，有三个，就调3次。 2.我们只需要写\u003cschool/\u003e或\u003cschool\u003e\u003c/school\u003e，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)。 3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！ const school = Vue.extend({}) const student = Vue.extend({}) //定义组件后，打印组件 console.log(\"@\",school); console.log(\"@\",student); //打印出来的东西，看起来都是长一样的，都是VueComponent //但是是两个全新的，各自独立的，功能长相都一样的 VueComponent //-----------------验证----------------- console.log(school === student); //false school.a = 99 console.log(school.a); //99 console.log(student.a); //undefind 4.关于this指向： (1).组件配置中： data函数、methods中的函数、watch中的函数、computed中的函数它们的this均是【VueComponent实例对象】 (2).new Vue()配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】 5.VueComponent的实例对象，以后简称vc(也可称之为:组件实例对象)。 Vue的实例对象，以后简称vm。 控制台输出vm，结构里面能通过$children很清晰的看见各个组件的 结构关系，和上下管理层级关系。 ","date":"2024-08-21","objectID":"/vue2/:20:6","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue实例 \u0026 组件实例 vm和vc从结构上来看基本上一致，但并不是完全一致，并不是完全相等的两个东西。 首先，vm是Vue创建实例的时候，生成的实例对象；vc是VueComponent创建实例的时候，生成的实例对象。 Vue生成实例对象和VueComponent生成实例对象的缔造过程并不是一模一样的！所以他们两并不是完全一样的 其次，vm中是可以使用el配置项的，用于指定服务于哪个容器；vc中是不能使用el的 再有，vm中的data可以写成data:{}，也可以写成data(){}；但是vc中data只能写成data(){return }函数形式 ","date":"2024-08-21","objectID":"/vue2/:20:7","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"内置关系 首先复习一个js上的属性概念：.prototype \u0026 .__proto__ \u003cscript type=\"text/javascript\"\u003e //定义一个构造函数 function Demo(){ this.a = 1 this.b = 2 } //创建一个Demo的实例对象 const d = new Demo() //显式原型属性 //只有function函数才有这个属性，实例对象是没有的 //一般通过该条:程序员追加值 console.log(Demo.prototype); //打印输出为 原型对象{} //隐式原型属性 //实例对象默认都带有这个属性 //一般通过该条程序自动访问值 console.log(d.__proto__);//也打印输出为 原型对象{} ,且与上面的长得一样 //通过 显式原型属性 操作原型对象，追加一个x属性 Demo.prototype.x = 99 //手动通过这种方式访问值 //发现是同步更新到值的 console.log(d.__proto__.x); //99 //验证两个原型对象是否是完全相同的 console.log(Demo.prototype === d.__proto__); //true //通过Demo的实例对象访问 console.log(d); //Demo{a=1,b=2} 这里，Demo表示后面的{}里的对象内容，是由Demo缔造出来的 console.log(d.x); //99 //为什么输出的d带着Demo //表示这个{}对象是谁构造出来的 //例如 function school(){} function student(){} const s = new school() const ss = new student() console.log(s); //school{} console.log(ss);//student{} //这里如果没有前面的这个名字，则分不清对象来自于哪里 \u003c/script\u003e 由此引入一个重要的内置关系： VueComponent.prototype.__proto__ === Vue.prototype 这个关系的作用： 让组件实例对象vc可以访问到Vue原型上的属性、方法 这是Vue独有的：增加了，vc原型对象的原型对象指向vm的原型对象。 \u003c!-- 因为有这个内置关系：使得组件里this.x打印输出为99 得以实现 --\u003e \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003cschool\u003e\u003c/school\u003e \u003c/div\u003e \u003cscript\u003e Vue.prototype.x = 99 //创建school组件 const school = Vue.extend({ data(){ return{ name:'某学校', address:'某地址' } }, template:` \u003cdiv\u003e \u003ch2\u003e学校名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学校地址：{{address}}\u003c/h2\u003e \u003cbutton @click=\"onChange\"\u003e点击获取x的值\u003c/button\u003e \u003c/div\u003e `, methods:{ onchange(){ alert(\"当前x的值是\"+this.x) } } }) new Vue({ el:'#el', components:{ school } }) \u003c/script\u003e \u003c/body\u003e ","date":"2024-08-21","objectID":"/vue2/:20:8","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"单文件组件 单文件组件，均是以xxxx.vue的文件 命名规范： 一个单词的文件命名为：school.vue，School.vue 多个单词的文件命名为：my-school.vue，MySchool.vue 一般我们都使用大写字母开头进行命名，主要是为了和开发者工具那边的根节点结构展示的名字一样【这边写成小写开头，那边也会默认显示为大写】。 1新建一个单文件组件School.vue \u003c!-- .vue文件中主要是：页面资源的合集，即html、css、js 为了迎合常见的前端三种资源显示的写法，vue提供了三个标签 分别是： 1、组件的结构标签\u003ctemplate\u003e 2、组件的交互标签\u003cscript\u003e 3、组件的样式标签\u003cstyle\u003e --\u003e \u003c!-- 这里就能看出“非单文件”的一个弊端： 组件的样式是不能单独写的，是公共写公共引用的 “单文件”的样式，一个文件一个，是独立的 --\u003e \u003c!-- 组件的结构标签 --\u003e \u003ctemplate\u003e \u003cdiv class=\"demo\"\u003e \u003ch2\u003e学校名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学校地址：{{address}}\u003c/h2\u003e \u003cbutton @click=\"onChange\"\u003e点击获取x的值\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003c!-- 组件的交互标签 --\u003e \u003cscript\u003e //组件需要被引用，外部使用import //这儿有三种暴露方式： // export const school = Vue.extend({})//1分别暴露 // export{school}//2统一暴露 // export default school //3默认暴露 //我们一般使用默认暴露，因为引用时比较简单，只需要import 起名 from vue文件的位置； //export default Vue.extend({}) //由于Vue.extend不写vue也会自动帮我们调用，所以这里可以简写 export default{ name:'School',//和文件名保持一致，开发者工具呈现的是这儿的名字 data(){ return{ name:'某学校', address:'某地址', x:1 } }, methods:{ onchange(){ alert(\"当前x的值是\"+this.x) } } } \u003c/script\u003e \u003c!-- 组件的样式标签 --\u003e \u003cstyle\u003e .demo{ background-color: aqua; } \u003c/style\u003e 2新建一个总体管理的顶级父组件App.vue \u003ctemplate\u003e \u003c!-- 这儿的div必须有，保证根节点 --\u003e \u003cdiv\u003e \u003cSchool\u003e\u003c/School\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e //引入组件 import School from './School.vue'; import School from './School.vue'; export default{ name:'App', //注册 components:{ School } } \u003c/script\u003e 3新建一个入口文件main.js //vue脚手架选择了main.js用来调用new Vue()创建vm实例对象 //引入App import App from \"./App.vue\"; new Vue({ el:\"#root\", componements:{App} }) 4新建一个根容器文件index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 指定容器 --\u003e \u003cdiv id=\"root\"\u003e \u003c!-- 引用App --\u003e \u003cApp\u003e\u003c/App\u003e \u003c/div\u003e \u003c!-- 在模块加载完毕后引入 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/vue.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"./main.js\"\u003e\u003c/script\u003e \u003c!-- main.js入口文件 --\u003e \u003c/body\u003e \u003c/html\u003e 整个单文件组件引用流程和书写规范就结束了，主要的文件如图： xxxx.vue文件运行，借助： 1、自己单独使用webpack 搭建工作流，借助一些第三方插件和node将.vue文件转换 成 .html 文件使得浏览器能够运行 2、Vue脚手架【vue官方团队，也是通过webpack经过一些node借助一些第三方插件打造的一个工作流，是一个搭建好的一个编译环境，可以直接使用】 ———————-所以，我们这里阐述vue脚手架的内容———————– 第3章：使用Vue脚手架 ","date":"2024-08-21","objectID":"/vue2/:20:9","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"21.Vue脚手架 ","date":"2024-08-21","objectID":"/vue2/:21:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"创建Vue脚手架 1说明 Vue脚手架是Vue官方提供的标准化开发工具（开发平台） 最新的版本是4.x 官方文档：https://cli.vuejs.org/zh/。 CLI的全称是 command line interface 直译过来是：命令行接口工具 2具体步骤 第一步（仅第一次执行）：全局安装@vue/cli npm install -g @vue/cli 第二步：切换到你要创建项目的目录，然后使用命令创建项目 vue create xxxx 提示选择用哪个版本的Vue创建项目，这里移动光标，选择Vue2，回车 babel：ES6转ES5需要用到的语法编译器 eslint：语法检查器 等待创建 创建完成 第三步：启动项目 npm run serve 按步骤执行 启动成功 打开页面 停止程序 crtl+c 连续两次即可 This is a tip\r备注： 1、如果出现下载缓慢请配置npm淘宝镜像： //该镜像已经过期 npm config set registry https://registry.npm.taobao.org //请使用下面的最新的镜像 npm config set registry https://registry.npmmirror.com 2、Vue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，请执行 vue inspect \u003e output.js 3、执行完install命令，退出命令窗口，重新cmd打开，再输入vue测试是否安装成功。 //退回到上一层目录 cd //清空上面所有记录 cls //新建一个文件夹 mkdir 4、vue create xxxx命令创建的项目中，包含 vue脚手架 官方给你写好的HelloWord例子 ","date":"2024-08-21","objectID":"/vue2/:21:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"分析脚手架结构 将项目用vscode打开，同样用终端启动。分析项目中对应文件的作用。 .gitignore 哪些文件或者文件夹不想接受git管理，在.gitignore这个文件中配置 babel.config.js demo的控制文件。配置一些ES6转ES5的规则。【不需要我们去修改】 package.json 包的说明书。你的包叫什么名字，什么版本，使用的一些依赖，引入的一些库，一些短命令。 package-lock.json 包管理器。包版本控制文件。 README.md 对整个工程进行一个说明或者一个描述 src 下面的4个四个文件： assets - 一般放前端的静态资源：例如图片 components App.vue - 顶级父组件 main.js - 入口文件 public 下面两个文件： favicon.ico - 网站图标 index.html - 主页面 ","date":"2024-08-21","objectID":"/vue2/:21:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"22.render函数 new Vue({ render: h =\u003e h(App), }).$mount('#app') 替换成 new Vue({ render(createElement){ return createElement('h1','你好啊') } }).$mount('#app') 发现页面正常显示： 由此可以知道，render：是vue帮我们调用的，且利用入参createElement函数帮我们编译模板。 上面的代码： render(createElement){ return createElement('h1','你好啊') } 简化可以写成： //函数写成箭头函数 //render:(createElement) =\u003e{return createElement('h1','你好啊')} //一个入参，可以去掉括号 //render:createElement =\u003e{return createElement('h1','你好啊')} //一个唯一返参，可以去掉return render:createElement =\u003ecreateElement('h1','你好啊') //这便是main.js中写入模版精简的形式 render: h =\u003e h(App) 讨论main.js中的render函数的作用 我们之前独自写过main.js，格式是这样的： import App from \"./App.vue\"; new Vue({ el:\"#root\", template:`\u003cApp\u003e\u003c/App\u003e`, componements:{App} }) 那为什么vue创建的main.js不这么写呢。 我们将上面这段代码copy后，放入脚手架中，编译项目，可以看见控制台报错： 我们去调查，为什么vue不完整 在Es6引入第三方库的时候，我们一般写到某个路径下具体某个文件xxx.js 在vue引入第三方库的时候，我们一般只写到它的名字。 那么它具体引入的是哪个js，按住ctrl键，点击： 点击引用的vue文件，可以看到来到了node_moudles中 这儿能看见整个vue包含的文件。其实，main.js中import Vue from 'vue'只写到了这个vue包文件夹，具体指向的哪个js文件，需要依赖配置项： package.json中的module的配置js。 这里可以看到是dist/vue.runtime.esm.js。这个js是个精简版的vuejs，它将模版解析器精简掉了，所以他没办法解析template配置项，产生报错。 打开dist文件夹，我们可以看见他下方有很多个vuejs，但是只有Vue.js是完整版的，其余的都是在它的基础上精简或者稍加改变的。 那么问题找到了，我们将main.js包中的引入换成完整版的： import Vue from 'vue' 替换为： import Vue from 'vue/dist/vue' 重新编译后，页面和控制台： 模版编译成功，控制台无报错。 为什么不使用这个完整版的vue呢。 vue.runtime.esm.js体积小，打包以后体积还能更小一点。且模版编译器最终，不应该出现在我们最终打包好的文件内。 This is a tip\r注意： 组件中也有template标签，但是不用render函数去编译解析。 在package.json中专门引入了依赖包，去解析组件中的模版标签。 只有vm中的模版标签它解析不了，需要使用render函数 脚手架中一般只有一个vm，render也只会在vm中出现一次 ","date":"2024-08-21","objectID":"/vue2/:22:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"23.修改默认配置 脚手架的默认配置 为了安全Vue将配置的文件隐藏起来，使用下面的这个命令可以将隐藏的文件形成一个.js文件显示在项目的根目录： Vue inspect \u003e output.js 虽然output.js是可以看见默认配置的，但是对这个文件的修改是无效果的。 如果要自定义配置，可以在项目的根目录下，新建一个文件vue.config.js 修改脚手架默认配置 官方文档解释位置：https://cli.vuejs.org/zh 例如，我们把main入口文件的名字改成自定义 原理： Vue底层基于webpack，webpack基于node 使用文件vue.config.js中的这块，重写webpack中修改的这一部分 使得核心部分能有修改入口，且不会对基本核心内部进行破坏造成影响 ","date":"2024-08-21","objectID":"/vue2/:23:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"24.ref属性 This is a tip\rref属性 1.被用来给元素或子组件注册引用信息(id的替代者) 2.应用在htmi标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象(vc) 3.使用方式: 打标识:\u003ch1 ref=\"xxx\"\u003e.....\u003c/h1\u003e或\u003cSchool ref=\"xxx\"\u003e\u003c/School\u003e获取:this.$refs.xxx 获取Dom元素，原始写法： document.getElementById(\"text\") 用ref写法 \u003cdiv\u003e \u003ch1 ref=\"text\" id=\"text\"\u003etext\u003c/h1\u003e \u003cSchool ref=\"sch\" id=\"sch\"/\u003e \u003c/div\u003e \u003cscript\u003e .... methods:{ showDOM(){ //组件里的this都是vc //输出的是h1的整个DOM元素 - 基本标签ref可以当id用 console.log(this.$refs.text) console.log(document.getElementById(\"text\"))//结果同上 //输出的是组件school的vc实例对象 console.log(this.$refs.sch) //输出的是组件模版解析后的真实DOM console.log(document.getElementById(\"sch\")) } } \u003c/script\u003e 看一下输出ref： 看一下输出id： ","date":"2024-08-21","objectID":"/vue2/:24:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"25._props配置 props的作用：让组件接收外部传过来的数据 组件外属性传值： \u003cstudent name=\"张三\" sex=\"男\" age=\"18\"\u003e 组件内接受，三种写法： //简单接受 props:['name','age','sex'] //接受的同时对数据进行类型限制 props:{ name:String, sex:String, age:Number } //接受时限制是否必传、默认值以及类型 props:{ name:{ type:String, //限制name类型为String required:true //且为必传 }, sex:{ type:Number, default:99 //不必传，没传时默认99 }, age:{ type:String, required:true }, } This is a tip\r备注:props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。 例如： this.age = 19; //页面有效果，控制台有警告 Vue不建议在组件内部，修改外部传入的属性的属性值。 一般做法： //使用一个中间变量 data(){ return{ changeAge:this.age } } //修改中间变量，并使用中间变量 this.changeAge = 19 ","date":"2024-08-21","objectID":"/vue2/:25:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"26.mixin混入 两个组件共享一个配置 ，实现复用方法的效果 //新建一个共有.js文件 《hunhe.js》 //该文件中暴露共用配置方法 //export const为分别暴露，引入的时候需要带{} export const hunhe ={ methods:{ ...... } } //需要的组件中引入.js文件 import {hunhe} from '../hunhe.js' //组件中使用mixins配置项 mixins:[hunhe] This is a tip\r混合中data中的数据以及methods冲突，以组件为主，例如： //《hunhe.js》中 export const hunhe ={ data(){ return{ a:1 } } } //《组件student中》 data(){ return{ a:99 } },mixins:[hunhe] console.log(this.a) //输出为99，以组件为准 但是！！！ 生命周期冲突，不以任何为主，都会执行 //《hunhe.js》中 export const hunhe ={ ..., mounted(){ console.log(\"11\") } } //《组件student中》 ..., mounted(){ console.log(\"22\") },mixins:[hunhe] //启动后控制台输出： //11 //22 ","date":"2024-08-21","objectID":"/vue2/:26:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"27.插件 插件实际上是一个{ }对象 自定义插件必须有有个install函数 //新建《plugins.js》 export default{ install(Vue){ ... //install的入参是Vue。 //此函数中可以设定所有全局Vue能够设定的方法，并且让组件均能使用 } } //main.js中引入插件 import pligins from './pligins.js' //main.js中使用插件 Vue.use(pligins) //这句话或默认帮我们调用《plugins.js》中的install方法 This is a tip\r插件功能:用于增强Vue 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\r","date":"2024-08-21","objectID":"/vue2/:27:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"28.scoped样式 scoped作用：让样式在局部生效，防止冲突 先看一个冲突 解决这个问题 在style标签里加上scoped属性 \u003cstyle scoped\u003e .... \u003c/style\u003e 原理：scoped原本就有作用域的意思，它在每个负责的标签样式后面都随机生成一个属性，配合样式选择器完成每个组件中引用同名样式的区分 ","date":"2024-08-21","objectID":"/vue2/:28:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"29.浏览器本地存储 在浏览器打开某网页，未登录情况下搜索某关键字，发现能够有对应的历史记录。 此历史记录是浏览器将信息存在了本机的硬盘上，也叫浏览器本地存储 浏览器本地存储统称webStorage 1、存储内容大小一般支持5MB左右(不同浏览器可能还不一样) 2、浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。 localStorage sessionStorage ","date":"2024-08-21","objectID":"/vue2/:29:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"localStorage.setItem 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。 浏览器本地存储不是Vue独有的，是js就有的，用.html文件就可以实现编译。 保存本地存储 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003elocalStorage\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch2\u003elocalStorage\u003c/h2\u003e \u003cbutton onclick=\"s()\"\u003e点击保存一个数据\u003c/button\u003e \u003cscript type=\"text/javascript\"\u003e function s(){ //第一个API叫setItem，两个入参必须为字符串 //重复添加同名的，会覆盖之前的值 localStorage.setItem('msg','hello!') //msg hello! localStorage.setItem('msg2',666) //msg2 666 localStorage.setItem('msg3',{'id':'001'})//不是字符串的会自动调toString，对象会存成[Object object] localStorage.setItem('msg4',JOSN.stringify(对象)) } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-08-21","objectID":"/vue2/:29:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"localStorage.getItem 该方法接受一个键名作为参数，返回键名对应的值 读取本地存储 \u003cscript type=\"text/javascript\"\u003e function s(){ //第二个API叫getItem,会给一个字符串的返回值 localStorage.getItem('msg') console.log(localStorage.getItem('msg')); //hello! console.log(JSON.parse(对象字符串));//对象的需要手动转换一下 } \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:29:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"localStorage.removeItem 该方法接受一个键名作为参数，并把该键名从存储中删除 删除本地存储 \u003cscript type=\"text/javascript\"\u003e function s(){ //第三个API叫removeItem localStorage.removeItem('msg') } \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:29:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"localStorage.clear 该方法会清空存储中的所有数据。 清空本地存储 \u003cscript type=\"text/javascript\"\u003e function s(){ //第四个API叫clear localStorage.clear() } \u003c/script\u003e This is a tip\r关闭浏览器，并不会自动清空浏览器本地存储。 但是！！！清除缓存，会清空浏览器本地存储。 ","date":"2024-08-21","objectID":"/vue2/:29:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"sessionStorage sessionStorage的4个API和localStorage使用和功能效果是一样的。 控制台位置，在localStorage下面 This is a tip\r备注: 1、SessionStorage存储的内容会随着浏览器窗口关闭而消失。 2、LocalStorage存储的内容，需要手动清除才会消失。 3、xxxxxstorage.getItem(xxx)如果xxx对应的value获取不到，那么getltem的返回值是null. 4、JSON.parse(null)的结果依然是null。\r","date":"2024-08-21","objectID":"/vue2/:29:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"30.组件自定义事件 ","date":"2024-08-21","objectID":"/vue2/:30:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"绑定【子传父】 子组件给父组件传值，三个写法： function \u003c!--父组件App.vue--\u003e \u003cSchool :getSchoolName=\"getSchoolName\"/\u003e props:['getSchoolName'], methods:{ getSchoolName(name){ console.log(\"学校名：\"+name) } } \u003c!--子组件School.vue--\u003e this.getSchoolName(this.name) $emit （自定义事件） \u003c!--父组件App.vue--\u003e \u003cStudent v-on:student=\"getStudentName\"/\u003e \u003cStudent @student=\"getStudentName\"/\u003e\u003c!--简写--\u003e methods:{ getStudentName(name){ console.log(\"学生名：\"+name) } } \u003c!--子组件Student.vue--\u003e this.$emit('student',this.name) ref （自定义事件） \u003c!--父组件App.vue--\u003e \u003cStudent ref=\"student\"/\u003e methods:{ getStudentName(name){ console.log(\"学生名：\"+name) } }, mounted:{ this.$refs.student.$on('studentTest',this.getStudentName) } \u003c!--子组件Student.vue--\u003e this.$emit('studentTest',this.name) This is a tip\r如果子传父的参数很多，三个办法： 挨个写入参 this.$emit('demo',x,y,z,p...) this.$refs.组件名.$on('demo',x,y,z,p...) 写成一个对象 this.$emit('demo',{params}) this.$refs.组件名.$on('demo',{params}) ES6写法，…a this.$emit('demo',this.name,...params) this.$refs.组件名.$on('demo',this.name,...params) ","date":"2024-08-21","objectID":"/vue2/:30:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"解绑 解绑一个自定义事件 $off \u003c!--父组件App.vue--\u003e \u003cStudent @student=\"getStudentName\"/\u003e \u003c!--子组件Student.vue--\u003e this.$off('student') 解绑多个自定义事件 $off([事件名]) \u003c!--父组件App.vue--\u003e \u003cStudent @student=\"getStudentName\" @demo=\"getDemo\"/\u003e \u003c!--子组件Student.vue--\u003e this.$off(['student','demo']) 解绑所有的自定义事件 $off() \u003c!--父组件App.vue--\u003e \u003cStudent @student=\"getStudentName\" @demo=\"getDemo\"/\u003e \u003c!--子组件Student.vue--\u003e this.$off() This is a tip\r组件上也可以绑定原生DOM事件，需要使用native修饰符. 不使用native修饰符.会默认@click为自定义事件 \u003cStudent @student=\"getStudentName\" @click.native=\"getDemo\"/\u003e this.$refs.组件名.$on('事件名',回调函数)里的回调函数需要写成箭头函数，或者直接定义在当前组件的methods中。否则this指向会有问题 this.$refs.组件名.$on('事件名',()=\u003e{}) //或者 methods:{ demo(){} } this.$refs.组件名.$on('事件名',this.demo) ","date":"2024-08-21","objectID":"/vue2/:30:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"31.全局事件总线 ","date":"2024-08-21","objectID":"/vue2/:31:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"GlobalEventBus 一种组件间通讯的方式，适用于任意组件间的通讯 安装全局事件总线 //《main.js》 new Vue({ .... beforeCreate(){ Vue.prototype.$bus = this //定义全局事件总线 }, ...... }) 使用事件总线： 1、接受数据 //《School.vue》 this.$bus.$on(\"事件名\",回调函数) 2、提供数据 //《Student.vue》 this.$bus.$emit(\"事件名\",传递入参数据) 3、关闭总线中不用的自定义事件 //《School.vue》 beforeDestroy(){ this.$bus.$off('demo') } ","date":"2024-08-21","objectID":"/vue2/:31:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"32.消息订阅与发布 ","date":"2024-08-21","objectID":"/vue2/:32:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"_pubsub pubsub.js是一个第三方库，引用这个库可以在任意框架实现消息的订阅和发布。 npm i pubsub-js pubsub是publish发布和subscribe订阅的组合简写 在组件中引入 import pubsub from 'pubsub-js' 订阅消息 pubsub.subscribe('事件名'，回调函数(事件名，收到的数据){}) 发布消息 pubsub.publish('事件名'，事件名，传递入参数据) 销毁消息（ 取消订阅） //在订阅的组件内,通过id取消订阅 this.pubId = pubsub.subscribe('事件名'，回调函数(事件名，收到的数据){}) beforeDestroy(){ pubsub.unsubscribe(this.pubId) } ","date":"2024-08-21","objectID":"/vue2/:32:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"33.$nextTick 语法this.$nextTick(回调函数) 作用：在下一次DOM更新结束后执行其指定的回调 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在$nextTick所指定的回调函数中执行 This is a tip\r不写$nextTick，用定时器也是可以解决，等待DOM更新结束后执行的操作。 setTimeout(( )=\u003e{ 基于更新后的新DOM进行某些操作 },2000) 只是官方推荐使用$nextTick ","date":"2024-08-21","objectID":"/vue2/:33:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"34.动画效果 实现一块元素从左边缓缓进入再离开的动画效果 原始css3的写法： \u003c!-- 合适时候换成go --\u003e \u003ch1 class=\"come\"\u003e\u003c/h1\u003e \u003cstyle scoped\u003e h1{ background-color: burlywood; } .come{ /* 播放这个动画 持续1s钟 */ animation: demo 1s; } .go{ /* 反转播放这个动画 持续1s钟 */ animation: demo 1s reverse; } /* 动画：定义一个关键帧 起名叫demo */ @keyframes demo { /* 左右来回变换 */ from{ /* 从左边 */ transform: translateX(-100%); } to{ transform: translateX(0px); } } \u003c/style\u003e Vue的实现写法 \u003c!--transition标签包裹的就是过度动画 --\u003e \u003ctransition\u003e \u003ch1\u003e\u003c/h1\u003e \u003c/transition\u003e \u003cstyle scoped\u003e h1{ background-color: burlywood; } /* 进入时激活：来 */ .v-enter-active{ /* 播放这个动画 持续1s钟 */ animation: demo 1s; } /* 离开时激活：离开 */ .v-leave-active{ /* 反转播放这个动画 持续1s钟 */ animation: demo 1s reverse; } /* 动画：定义一个关键帧 起名叫demo */ @keyframes demo { /* 左右来回变换 */ from{ /* 从左边 */ transform: translateX(-100%); } to{ transform: translateX(0px); } } \u003c/style\u003e This is a tip\r如果\u003ctransition\u003e有名字，则.v-enter-active开头需要将v替换成取的名字 \u003ctransition name=\"aaa\"\u003e\u003c/transition\u003e \u003cstyle scoped\u003e .aaa-enter-active{ } .aaa-leave-active{ } \u003c/style\u003e 如果要第一次页面就显示动画，需要加上appear属性 \u003ctransition name=\"aaa\" :appear=\"true\"\u003e\u003c/transition\u003e Vue的实现第二种写法 \u003ctransition\u003e \u003ch1\u003e\u003c/h1\u003e \u003c/transition\u003e \u003cstyle scoped\u003e h1{ background-color: burlywood; } .v-enter-active,.v-leave-active{ transition: 0.5s linear; /* 动画持续0.5s 匀速 */ } /* 进入起点，离开终点 */ .v-enter,.v-leave-to{ transform: translateX(-100%); } /* 进入终点，离开起点 */ .v-leave,.v-enter-to{ transform: translateX(-100%); } \u003c/style\u003e 多个元素过度 \u003c!-- 多个元素使用transition-group --\u003e \u003ctransition-group\u003e \u003c!-- 且每个元素必须有key值 --\u003e \u003ch1 key=\"1\"\u003e\u003c/h1\u003e \u003ch1 key=\"2\"\u003e\u003c/h1\u003e \u003c/transition-group\u003e 集成第三方动画 有时候我们也集成一些好用的第三方库来帮我们完成好看的动画效果，npm网站：https://npmjs.com 上有这么这一个库，叫animate.css 这是一个成型的动画库，只需要引入，就能直接使用这个链接里的动画 用一个简单的例子： 安装这个库 npm install animate.css --save 组件里引入这个库 import 'animate.css' 使用这个库 先选一个样式动画，复制 \u003ctransition-group apper name=\"animate__animated animate__bounce\" enter-active-class=\"animate__swing\" \u003e \u003c/transition-group\u003e ","date":"2024-08-21","objectID":"/vue2/:34:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"35.插槽 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 ====\u003e子组件 分类：默认插槽、具名插槽、作用域插槽 使用方式： 默认插槽 父组件中: \u003cCategory\u003e \u003cdiv\u003ehtml结构1\u003c/div\u003e \u003c/Category\u003e 子组件中: \u003ctemplate\u003e \u003cdiv\u003e \u003c!--定义插槽 --\u003e \u003cslot\u003e插槽默认内容...\u003c/slot\u003e \u003c/div\u003e \u003c/template\u003e 具名插槽 父组件中: \u003cCategory\u003e \u003c!-- 基本写法 --\u003e \u003cdiv slot=\"center\"\u003e \u003cdiv\u003ehtml结构1\u003c/div\u003e \u003c/div\u003e \u003c!-- 只有template可以这样写 --\u003e \u003ctemplate v-slot:footer\u003e \u003cdiv\u003ehtm1结构2\u003c/div\u003e \u003c/template\u003e \u003c/Category\u003e 子组件中: \u003ctemplate\u003e \u003cdiv\u003e \u003c!--定义插槽 --\u003e \u003cslot name=\"center\"\u003e插槽默认内容...\u003c/slot\u003e \u003cslot name=\"footer\"\u003e插槽默认内容...\u003c/slot\u003e \u003c/div\u003e \u003c/template\u003e 作用域插槽 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。 具体编码： 父组件中: \u003cCategory\u003e \u003c!-- scope没有d，注意和style那块区分--\u003e \u003c!-- scope收到传来的整个插槽对象的数据 --\u003e \u003c!-- scope里面入参scopeData包含有多个属性的值，如solt :a=\"11\" :b=\"11\" --\u003e \u003c!-- 引用则写成scopeData.a 或者scopeData.b --\u003e \u003ctemplate scope=\"scopeData\"\u003e \u003c!-- 生成的是u1列表--\u003e \u003cu1\u003e \u003cli v-for=\"g in scopeData.games\" :key=\"g\"\u003e{{g}}\u003c/li\u003e \u003c/u1\u003e \u003c/template\u003e \u003c/Category\u003e \u003cCategory\u003e \u003ctemplate slot-scope=\"scopeData\"\u003e \u003c!--生成的是h4标题 --\u003e \u003ch4 v-for=\"g in scopeData.games\" :key=\"g\"\u003e{{g}}\u003c/h4\u003e \u003c/template\u003e \u003c/Category\u003e 子组件中: \u003ctemplate\u003e \u003cdiv\u003e \u003cslot :games=\"games\"\u003e\u003c/slot\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e .... data(){ return{ games:['1','2','3'] } } \u003c/script\u003e 最新写法 \u003c!-- 旧的写法，现在还能用 --\u003e \u003c!-- scope里面入参有多个，如solt :a=\"11\" :b=\"11\" --\u003e \u003ctemplate scope=\"{dataList}\"\u003e \u003c!-- 最新写成 --\u003e \u003ctemplate solt-scope=\"{dataList}\"\u003e 第四章：Vue中的ajax ","date":"2024-08-21","objectID":"/vue2/:35:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"配置代理 在开发的过程中，如何借助Vue脚手架，去解决ajax跨域的问题。 发送一个ajax的方法： xhr new XMLHttpRequest() ： xhr.open() 和 xhr.send() jQuery 对xhr进行封装 $.get 和 $.post 【因为jQuery中80%内容都是用于对DOM操作的封装，Vue避免对DOM进行操作，所以它不常用在Vue中】 axios 【Vue推荐使用】 fetch 我们这里选择使用axios 安装axios库 npm i axios 引入axios库 import axios from 'axios' 使用 methods:{ demo(){ //服务器地址 axios.get('http://localhost:5000/demo').then( //成功回调 response =\u003e{ console.log(response.data)}, //失败回调 error =\u003e{ console.log(error.message)} ) } } 跨域报错警告\rAccess to XMLHttpRequest at 'http://localhost:5000/demo' from origin 'http://localhost:8080' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 访问规定：协议名，主机名，端口号 。三个一致，允许访问。 不一致，会请求，会查到数据，但是返回给请求方的时候报跨域错误。 解决跨域： 服务器位置：通过配置cors，允许某部分请求头能够访问，解决跨域的问题。 jsonp ：借助script标签里的src属性，在引入外部资源的时候，不受同源策略限制的特点实现的。【只能解决get请求，post解决不了】 配置代理服务器 ","date":"2024-08-21","objectID":"/vue2/:36:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"4.1 配置代理 方式一 请求方 \u003c======\u003e 代理服务器 \u003c=======\u003e 目标服务器 niginx 反向代理服务器 vue-cli 借助vue脚手架帮我们开启一个服务器 官方文档位置：https://cli.vuejs.org/zh/config/#devserver-proxy 写法： 在vue.config.js里添加下面的代码： //开启代理服务器 devServer:{ proxy:'http://localhost:5000' //指向目标服务器 } 调用 这里只能找代理服务器发请求，代理服务器端口是8080 methods:{ demo(){ //服务器地址 axios.get('http://localhost:8080/demo').then( //成功回调 response =\u003e{ console.log(response.data)}, //失败回调 error =\u003e{ console.log(error.message)} ) } } 注意！！！\r这样的代理配置有两个缺点： 只能配置一个目标服务器 如果public根文件夹下有静态资源，则直接返回了静态资源，不会请求代理服务器，如： http://localhost:8080/demo会直接请求demo.txt文件，没有才请求代理服务器，有就直接返回demo.txt的信息。 ","date":"2024-08-21","objectID":"/vue2/:36:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"4.2 配置代理 方式二 写法： 在vue.config.js里添加下面的代码： devServer: { proxy: { '/api': { target: '\u003curl\u003e', ws: true, changeOrigin: true }, '/foo': { target: '\u003cother_url\u003e' } } } 先看第一部分 devServer: { proxy: { '/api': { //请求前缀，如果是以这个名字为前缀的，代理就转发 target: 'http://localhost:5000', //请求的目标服务器 ws: true, //支持：websocket客户端与服务器间的一种通讯方式 changeOrigin: true,//用于控制请求头重host的值。请求来源 返回成和目标服务器一致 pathRewrite:{'^/api':''} //重写路径，正则匹配以api开头的路径，全部替换成空。不然，访问目标服务器时也会带着请求前缀，导致接口404 }, } //前缀写在端口号后，方法名称前 axios.get('http://localhost:8080/api/demo').then() ","date":"2024-08-21","objectID":"/vue2/:36:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"4.3 vue-resource vue-resource也是一个发送ajax请求的库，也是对xhr进行封装的，vue1.0使用广泛，现在官方已不再维护。 安装vue-resource npm i vue-resource main.js中引入插件 import vueResource from 'vue-resource' Vue.use(vueResource) 使用同axios this.$http.get('http://localhost:8080/demo').then( //成功回调 response =\u003e{ console.log(response.data)}, //失败回调 error =\u003e{ console.log(error.message)} ) ","date":"2024-08-21","objectID":"/vue2/:36:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":" 第五章：Vuex 第六章：Vue UI组件库 第七章：vue-router ","date":"2024-08-21","objectID":"/vue2/:37:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["Hugo系列"],"content":"官网下载Typora 安装 网址：Typora 官方中文站 (typoraio.cn) 点立即下载，下载下来的安装包，双击Typora.exe 完成安装 ","date":"2024-08-11","objectID":"/text08/:1:0","tags":["Typora"],"title":"【Typora】破解/安装激活 Typora 2024 教程","uri":"/text08/"},{"categories":["Hugo系列"],"content":"本地激活Typora 激活方法 安装路径下找到：Typora\\resources\\page-dist\\static\\js 右键用记事本打开这个文件，ctrl+F定位到 e.hasActivated=\"true\"==e.hasActivated 替换为 e.hasActivated=\"true\"==\"true\" 这样就已经后台激活完成，但是每次开软件开始会提醒激活。 关闭软件每次启动时的已激活弹窗 继续在安装路径下resources\\page-dist\\license.html，找到 依旧ctrl+F 定位到： \u003c/body\u003e\u003c/html\u003e 替换为 \u003c/body\u003e\u003cscript\u003ewindow.onload=function(){setTimeout(()=\u003e{window.close();},5);}\u003c/script\u003e\u003c/html\u003e 特别注意！！！\r复制粘贴上面这段代码的时候： 有些系统会将window.onload 中onload的英文字母o和n变成其他希腊字母或其他Unicode字符（例如，ο是希腊字母omicron，而ο和o在视觉上非常相似） 这会导致这段代码没有起作用！！！！ 如果这段代码替换后没反应，请务必手敲onload保存后再试。。。。 去除软件左下角“未激活”提示 按照安装路径，找到 resources\\locales\\zh-Hans.lproj\\Panel.json 文件中查找： \"UNREGISTERED\":\"未激活\"， 替换为： \"UNREGISTERED\":\" \" 最后，重新打开Typora，手动关掉激活窗口，之后就不会再出现。 ","date":"2024-08-11","objectID":"/text08/:2:0","tags":["Typora"],"title":"【Typora】破解/安装激活 Typora 2024 教程","uri":"/text08/"},{"categories":["Hugo系列"],"content":"引用图片 注意：Typora 使用带图片的文件，使用相对路径，创建带图片的笔记时，.md文件命名需为index。自动访问路径中的index文件，剪切图片时自动生成image文件夹，使得图片相对路径访问正常 【注意：我的安装路径位置在 C:\\Program Files\\Typora】 ","date":"2024-08-11","objectID":"/text08/:3:0","tags":["Typora"],"title":"【Typora】破解/安装激活 Typora 2024 教程","uri":"/text08/"},{"categories":["Hugo系列"],"content":"Hugo 是 Go 编写的静态网站生成器，速度快，易用，可配置。 Hugo 依赖于 Markdown 文件，元数据字体 。用户可以从任意的目录中运行 Hugo，支持共享主机和其他系统。只需要几分之一秒就可以渲染一个经典的中型网站，非常适合博客，文档等等网站的生成。 ","date":"2024-08-09","objectID":"/text07/:0:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"HUGO下载安装 ","date":"2024-08-09","objectID":"/text07/:1:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"安装环境 安装好Windows版本的 git： git官网：https://git-scm.com/downloads git安装教程请参考：【 Windows系统Git安装教程（详解Git安装过程） - 学为所用 - 博客园 (cnblogs.com)】 下载并安装Windows版本的 GO： go的中文官网：https://go.p2hp.com/ 下载并安装Windows版本的 hugo： hugo·GitHub 地址 https://github.com/gohugoio/hugo/releases 本教程中下载的项目压缩包名为：hugo_extended_0.128.2_windows-amd64 压缩包下载路径：https://github.com/gohugoio/hugo/releases/download/v0.128.2/hugo_extended_0.128.2_windows-amd64.zip ","date":"2024-08-09","objectID":"/text07/:1:1","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"配置环境变量 创建程序目录 在C盘新建一个名为hugo的文件夹，进入文件夹后再创建一个名为bin的文件夹 将下载好的Windows版本hugo应用程序压缩包解压到这个bin文件夹 配置环境变量 然后在Windows搜索栏中搜索环境变量，点击环境变量 选择系统变量中的Path，点击新建 将 C:\\hugo\\bin 这个路径添加到环境变量 查看程序版本 然后打开powershell终端，输入下方命令查看 hugo version 显示版本号，即为成功安装了hugo程序。 ","date":"2024-08-09","objectID":"/text07/:1:2","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"创建博客网站 现在我们就可以使用hugo搭建一个属于自己的博客网站了。 创建站点 首先，我们进入到C盘下的hugo文件夹，点击鼠标右键选择在终端中打开 执行下方命令创建一个静态站点：（本例创建的站点名为myblog，大家可以自定义） hugo new site myblog 创建后，我们回到hugo目录，可以看到新增了一个名为myblog的文件夹： 进入该文件夹后，就能看到刚刚创建的博客网站程序： 在站点中创建一篇文章 创建好了站点后，现在网站中还什么内容都没有，我们可以创建一篇文章来进行一下测试： 现在我们在终端中执行下方命令，进入站点目录： 进入网站目录后，执行下方命令创建一篇markdown格式的文章： hugo new posts/Articles01.md 执行后可以看到提示已经创建了一篇名为Articles01的文章与其所属路径。 进入这个路径，就能看到文章了。 打开这篇文章后能看到这篇文章的标题，日期等相关信息 在这里我们需要把draft（草稿） = true 修改为 draft = false 来表示这并不是一篇草稿。 然后随便在文档中写一些内容，比如： 然后保存关闭即可。 为网站添加主题 现在我们已经创建好了一个博客网站，并在网站中发布了一篇文章，不过现在我们还不能在浏览器中运行这个本地网站进行查看，因为在这之前，我们需要先给网站添加一个主题。 我们可以登录下方的hugo官网页面来挑选一个你喜欢的网站主题： https://themes.gohugo.io/themes 这里我们随便选择一个主题，点击进入页面后，可以看到安装方式： 可以看到，想要安装这个网站主题，需要先在终端中进入站点目录： cd myblog 也可以想上边一样，在myblog目录中右键在终端中打开。 然后执行下方命令： git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c 然后在打开名为 hugo 的 toml源文件，添加主题配置即可。 网站标题修改为myblog，然后再把theme = “m10c”这行代码加进去保存即可。 现在，我们在myblog目录下的主题文件夹中就能看到刚才添加的主题文件目录了： 本地访问测试 现在，我们在终端中执行下方代码启动本地网站进行测试： hugo server 本地清除缓存运行 hugo server --disableFastRender --gc --noHTTPCache --noBuildLock --logLevel debug 可以看到成功启动，在浏览器中输入 localhost:1313/ 即可访问这个本地站点： 可以看到网站标题为myblog，里边有刚才我们发布的第一篇文章Article01： 点击文章标题Article01，即可进入文章页面。 这样我们就成功使用HUGO在Windows本地快速部署了一个静态博客网站。 ","date":"2024-08-09","objectID":"/text07/:2:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"部署到公网 This is a tip\r下面是三种部署网站到公网的办法\r","date":"2024-08-09","objectID":"/text07/:3:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"安装内网穿透工具 目前我们在本机成功部署了一个博客网站，但如果没有公网IP的话，只能在本地局域网环境使用，有一定局限性。如果出差在外想要远程使用的话，可以结合Cpolar内网穿透生成公网地址，免去了本地重新部署过程，只需要使用公网地址直接就可以访问本地部署的网站，进行演示。 点击进入cpolar官网注册一个账号，并下载最新版本的Cpolar https://www.cpolar.com/ 登录成功后，点击下载Cpolar到本地并安装（一路默认安装即可）本教程选择下载Windows版本。 Cpolar安装成功后，在浏览器上访问 localhost:9200，使用cpolar账号登录,登录后即可看到Cpolar web 配置界面,结下来在web 管理界面配置即可。 http://localhost:9200/#/login?redirect=%2Fdashboard 【hugo-账户：1437059026@qq.com 密码：Wty201408.】 配置公网地址 接下来配置一下本地 博客网站 的公网地址， 登录后，点击左侧仪表盘的隧道管理——创建隧道， 创建一个 博客网站 的公网地址隧道： 隧道名称：可自定义命名，注意不要与已有的隧道名称重复 协议：选择 本地地址：1313 域名类型：选择随机域名 地区：选择China VIP 点击创建 隧道创建成功后，点击左侧的状态——在线隧道列表,查看所生成的公网访问地址，有两种访问方式。 使用任意一个上面生成的公网地址,在电脑或任意设备在浏览器进行登录访问,即可成功看到 本地博客网站 界面,这样一个可以远程访问的公网地址就创建好了,使用了Cpolar的公网域名,无需自己购买云服务器,即可在公网访问本地部署的服务了！ ","date":"2024-08-09","objectID":"/text07/:3:1","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"搭建本地服务器 内网穿透地址会随着ip的更新而变化，为了保证不一直修改baseUrl，配置服务器来搭载网站。 配置本地服务器，将编译后的网站文件运行与服务器后，本地可以不启动hugo server 在控制面板打开命令提示符窗格，键入npm install -g anywhere 9999 npm install -g anywhere 9999 9999这里是设置端口号，端口号自行设置，也可以不输入xxx会默认8000端口号 安装成功anywhere后，可以直接使用anywhere指令启动服务，但是默认是查看全部文件列表 编译网站文件并运行于本地服务器 进入myblog根目录下，输入hugo命令进行编译 hugo 编译后，生成public文件夹，进入该文件夹根目录，并输入anywhere使编译文件运行在上面 cd public anywhere 【特别注意：运行在服务器上的一定是：\"编译后的文件！！！！\"】 ","date":"2024-08-09","objectID":"/text07/:3:2","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"BaseUrl配置 使用hugo server本地运行的程序，每次跳转都将走localhost或者127.0.0.1，此处理解和其他程序启动一样，访问及跳转都将走本地。 若要使baseURL配置每次跳转时，自动请求的域名地址为服务器地址，则需要设置.toml文件中的baseURL。 baseURL = 'http://136c5bcc.r16.vip.cpolar.cn/' //内网穿透地址 baseURL = 'http://192.168.9.125/' //本地服务器地址 内网穿透地址需先将本地服务器内网地址先生成，再配置。配置方法同小结6相同，配置好后如图 逻辑为： 1、配置本地baseURL为内网穿透地址，使每次访问均可访问内网穿透地址 2、编译文件后，跳转路径指向内网穿透地址 3、内网穿透地址配置localhost:8000指向本地服务器 4、启动本地服务器，使内网穿透访问正常 5、使跳转路径正常 当此处修改为内网穿透地址后，需先进行编译，再通过本地服务器启动后的地址后，记得编译之后再运行本地服务器 ","date":"2024-08-09","objectID":"/text07/:3:3","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"创建 GitHub Pages 站点 GitHub提供了Github pages用于挂在类似于hugo，hexo这样的博客静态网页， 官方教程：https://docs.github.com/zh/enterprise-server@3.12/pages/getting-started-with-github-pages/creating-a-github-pages-site GitHub登陆后，新建仓库Wangty654.github.io 注意仓库名需要和账户名一致 修改博客配置文件.toml中的默认跳转地址为仓库名 baseURL = 'https://Wangty654.github.io' //仓库服务器地址 仓库建好后，进入博客根目录，编译网站 cd myblog C:/hugo/myblog \u003e hugo 生成的编译后文件夹public为所有html、css、js组成的静态网站文件 上传GitHub cd public C:/hugo/myblog/public \u003e git init git add . git commit -m '1' git push 请求成功后直接访问https://Wangty654.github.io即可 ","date":"2024-08-09","objectID":"/text07/:3:4","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"腾讯云服务器部署 配置的后台的代理 静态资源服务器 如果是放我的静态网页 只需要将dist配置在root上，并对其刷新页面的位置进行配置就行 dist内存在index页面等同于，hugo的public页面 ftp传文件 、shell 输入命令 ","date":"2024-08-09","objectID":"/text07/:3:5","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"网站样式自定义设置 This is a tip\r一些基础样式调整，具体样式美化可以参考：Hugo的LoveIt主题美化（一、二、三、四）\r","date":"2024-08-09","objectID":"/text07/:4:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"关于themes主题 themes主题为git拉取下来用于整个静态网站的样式代码，均可按照需求进行修改 头像设置 1、在layouts包下，有一个baseof.html文件，将其中的首页文件指向调整为你想要的图片 2、并同时更改static文件夹中的图片，使指向和文件名一致。 主题颜色设置 1、拷取themes中配置文件config.toml里默认设置主题颜色的部分代码 默认主题有三种样式 选择其中一种样式，放入我们的配置文件hugo.toml，可以对其中的文字颜色也进行修改，本主题改为粉色 主页文字设置 更改layouts包下，baseof.html文件中书写首页介绍文字的位置 主页分类菜单设置 1、配置文件hugo.html中配置菜单栏 2、并在每条笔记中，使用yaml格式书写抬头 主页关于菜单设置 取主题中content包下的about文件放入myblog的content包根目录下。about内的内容可以自行定义 关于代码块样式设置 配置文件中写入设置样式的命令模块，根据需要更改其中style的值。 hugo中文文档中 ：https://hugo.opendocs.io/getting-started/ 选择“内容管理” - “语法高亮” 在style中选择想要更改的样式，放入配置文件中：https://xyproto.github.io/splash/docs/ ","date":"2024-08-09","objectID":"/text07/:4:1","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["腾讯云"],"content":"腾讯云直播推流器TXLivePusher ：https://webrtc-demo.myqcloud.com/push-sdk/v2/docs/TXLivePusher.html 这里是：直播和点播播放的 Web 播放器（ TCPlayer ）的相关参数以及 API 1.直播推流 直播推流需要第三方库 \u003cscript src=\"https://video.sdk.qcloudecdn.com/web/TXLivePusher-2.0.3.min.js\" charset=\"utf-8\"\u003e\u003c/script\u003e 直播推流代码 var livePusher = new TXLivePusher(); console.log(livePusher); livePusher.setRenderView('id_local_video'); // 设置视频质量 livePusher.setVideoQuality('720p'); // 设置音频质量 livePusher.setAudioQuality('standard'); // 自定义设置帧率 livePusher.setProperty('setVideoFPS', 25); // 采集完摄像头和麦克风之后自动推流 Promise.all([livePusher.startScreenCapture(), livePusher.startMicrophone()]) .then(function () { //传入的是一个推流地址，后端返回的，把后端返回的一个地址前边的rtmp换成webrtc就可以了 livePusher.startPush(推流地址) .then(() =\u003e { console.log('pushing'); if (livePusher.isPushing()) { console.log('pushing'); } }) .catch(err =\u003e { console.log(err); }) }) .catch(err =\u003e { console.log(err); }) 2.直播拉流 直播拉流所需第三方库 \u003clink href=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/tcplayer.min.css\" rel=\"stylesheet\" /\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 Webrtc 视频，需要在 tcplayer.vx.x.x.min.js 之前引入 TXLivePlayer-x.x.x.min.js。--\u003e \u003c!--有些浏览器环境不支持 Webrtc，播放器会将 Webrtc 流地址自动转换为 HLS 格式地址，因此快直播场景同样需要引入hls.min.x.xx.xm.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/TXLivePlayer-1.2.3.min.js\"\u003e\u003c/script\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 HLS 协议的视频，需要在 tcplayer.vx.x.x.min.js 之前引入 hls.min.x.xx.xm.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/hls.min.1.1.6.js\"\u003e\u003c/script\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 FLV 格式的视频，需要在 tcplayer.vx.x.x.min.js 之前引入 flv.min.x.x.x.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/flv.min.1.6.3.js\"\u003e\u003c/script\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 DASH 视频，需要在 tcplayer.vx.x.x.min.js 之前引入 dash.min.x.x.x.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/dash.all.min.4.5.2.js\"\u003e\u003c/script\u003e \u003c!--播放器脚本文件--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/tcplayer.v4.7.2.min.js\"\u003e\u003c/script\u003e 播放容器 \u003cvideo id=\"player-container-id\" preload=\"auto\" playsinline webkit-playsinline\u003e\u003c/video\u003e 拉流js var player = TCPlayer('player-container-id', {}); // player-container-id 为播放器容器 ID，必须与 html 中一致 player.src(url); // url 播放地址 This is a warning\r直播视频全屏canvas元素无法在最上层 直播弹幕无法在最上层，将z-index设置为最大也没效果，那是因为第三方库用了一个toplayer的东西将播放视频的元素放到最顶层了，用css设置的东西没效果，解决方案就是设置个延时器，等到第三方库把元素放置到页面之后dom操作canvas元素，将其放置到设置toplayer的盒子里边，这样就可以了 ","date":"2024-08-09","objectID":"/text16/:0:0","tags":["腾讯云直播"],"title":"【腾讯云】腾讯云直播前端","uri":"/text16/"},{"categories":["版本控制工具"],"content":" //报错信息 Failed to connect to github.com port 443: Connection refused. //报错翻译 连接github.com 443端口失败:连接拒绝 解决办法： 排查代理问题 尝试重置代理或者取消代理的方式： git config --global --unset http.proxy git config --global --unset https.proxy 如果没效果，接着添加全局代理试试： git config --global http.proxy git config --global https.proxy 如果以上问题还未得到解决 排查DNS解析问题 在DNS解析前先会尝试走hosts，然后在找不到的的情况下再DNS解析,修改hosts文件域名解析就会先走hosts中的ip和域名的映射关系。 我们可以修改hosts文件，修改ip地址和域名的映射关系： Windows：位于C:\\Windows\\System32\\drivers\\etc ping gitHub.com 20.205.243.166 github.com 140.82.112.4 github.com 151.101.1.6 github.global.ssl.fastly.net 185.199.108.153 assets-cdn.github.com 185.199.109.153 assets-cdn.github.com 185.199.110.153 assets-cdn.github.com 185.199.111.153 assets-cdn.github.com 【注意：用“管理员身份运行记事本”进行hosts文件的修改】 刷新DNS ipconfig /flushdns ","date":"2024-08-03","objectID":"/text09/:0:0","tags":["git","gitHub"],"title":"【git】git克隆失败解决办法","uri":"/text09/"},{"categories":["前端"],"content":"1.变量定义 ES6新增了 let 和 const，分别用来声明变量和常量，应该尽可能使用 let 和 const 来定义变量，而不是 var ","date":"2024-07-21","objectID":"/es6/:1:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"1.1 let 关键字 let 用于声明变量，声明的变量只在当前代码块能被访问到 // 外部代码块不能访问到内部代码块定义的变量 if(true) { let a = 1; } console.log(a); // 报错：Uncaught ReferenceError: a is not defined /*-----------------分隔线-----------------*/ // 内部代码块能访问到外部代码块的变量 let arr = [] for(let i = 0; i \u003c 10; i++) { arr.push(i); } console.log(arr.join()); // 打印：0,1,2,3,4,5,6,7,8,9 /*-----------------分隔线-----------------*/ // 注意：在for循环中，循环在一个代码块，循环体在一个代码块 for (let i = 0; i \u003c 3; i++) { let i = 'abc'; console.log(i); } // 打印如下： // abc // abc // abc ","date":"2024-07-21","objectID":"/es6/:1:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"1.2 const 关键字 const 声明一个只读的常量 一旦声明，常量的值就不能改变，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值 const foo; // SyntaxError: Missing initializer in const declaration /*-----------------分隔线-----------------*/ const a = 1; a = 2; // 报错：Uncaught TypeError: Assignment to constant variable. /*-----------------分隔线-----------------*/ // 对于对象 const obj = { str: '123'} console.log(obj.str) // 打印：123 obj.str = '456' console.log(obj.str) // 打印：456 obj = {} // 报错：Uncaught TypeError: Assignment to constant variable. // 或者 let newObj = { str: '123' } obj = newObj // 报错：Uncaught TypeError: Assignment to constant variable. ","date":"2024-07-21","objectID":"/es6/:1:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"2. 模板字符串 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，即换行和缩进将会被保留，或者在字符串中嵌入变量。 let name = 'Ryan'; let age = 23; let str = ` name: ${name} age: 23` console.log(str) ","date":"2024-07-21","objectID":"/es6/:2:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3. 数组常用方法 这里列举数组的常用方法，并不都是ES6新增的方法 ","date":"2024-07-21","objectID":"/es6/:3:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.1 forEach 遍历数组，没有返回值，不改变原数组，处理函数可以接收三个参数，分别是当前位置元素item，当前位置下标index，当前遍历的数组 let arr = [1, 2, 3] arr.forEach(function(item) { console.log(item) }) // 打印： //1 //2 //3 ","date":"2024-07-21","objectID":"/es6/:3:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.2 map 遍历数组，不在源数组上进行操作，返回一个新的数组，处理函数可以接收三个参数，分别是当前位置元素item，当前位置下标index，当前遍历的数组 let arr = [1, 2, 3] let arr1 = arr.map(function(item) { console.log(item) item *= 2 return item }) // 打印： //1 //2 //3 console.log(arr.join()) // 打印：1,2,3 console.log(arr1.join()) //打印：2,4,6 //map一定要返回一个新数组，需要一个新的数组变量来接受 This is a tip\rforEach 和 map 的区别 map方法： map它返回一个新数组，原数组的结构不会被改变。 如果需要对原数组进行操作并返回一个新的数组，map是更合适的选择。 map经常用于转换数组中的每个元素。 forEach方法： forEach直接在原数组上进行操作，不返回任何值（或者说返回undefined）。 它没有能力中断循环，也就是说，即使出现错误，forEach中的函数也会继续执行。 如果需要在数组上直接进行修改，并不需要一个新数组，那么可以使用forEach。 ","date":"2024-07-21","objectID":"/es6/:3:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.3 filter 不在源数组上进行操作，返回一个新的数组，处理函数可以接收三个参数，分别是当前位置元素item，当前位置下标index，当前遍历的数组 let arr = [1, 2, 3, 4] let arr1 = arr.filter(function(item) { return item \u003e 2 }) console.log(arr1.join()) // 打印：3,4 ","date":"2024-07-21","objectID":"/es6/:3:3","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.4 includes 返回一个布尔值，表示某个数组是否包含给定的值，该方法的第二个参数表示搜索的起始位置 let arr = [1, 2, 3, 4] console.log(arr.includes(2)) // 打印：true // 从下标为2的位置开始向数组末尾搜索，没找到，返回false console.log(arr.includes(2, 2)) // 打印：false // 如果第二个参数为负数，则表示倒数的位置，从倒数第二个开始搜索，没找到，返回false console.log(arr.includes(2, -2)) // 打印：false // 如果这时它大于数组长度，则会重置为从0开始，倒数第五个，超过数组长度，则从数组开头向数组末尾搜索 console.log(arr.includes(2, -5)) // 打印：true ","date":"2024-07-21","objectID":"/es6/:3:4","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.5 find() find()方法在JavaScript中用于在数组中查找满足特定条件的第一个元素。它接受一个回调函数作为参数，该函数返回布尔值来确定元素是否匹配。如果找到匹配项，则返回该元素，否则返回undefined。此方法不会改变原始数组，适用于寻找单个匹配项。 array.find((item,index)=\u003e{ console.log(item,index); }) array.find(callback(element[, index[, array]])[, thisArg]) 参数解释： callback：必需。要在数组中每个元素上执行的函数。 element：必需。当前正在处理的数组元素。 index：可选。正在处理的元素的索引。 array：可选。调用该方法的数组本身。 thisArg：可选。当执行回调函数时使用的 this 值。 find() 方法的第一个参数 callback 是一个函数，用于测试每个元素是否符合条件，接收三个 参数： element：表示当前正在被处理的元素。 index：表示正在被处理的元素的索引。 array：表示当前正在被处理的数组对象。 回调函数应该返回一个布尔值，表示当前元素是否符合我们的条件。如果返回 true，则会停止遍历并返回该元素的值；否则，继续遍历直到遇到符合条件的元素或者整个数组都被遍历完毕。 find() 方法实际应用： **实例 1：**查找数组中的第一个负数。 const arr = [1, 2, -3, 4, -5]; const negativeNum = arr.find(num =\u003e num \u003c 0); console.log(negativeNum); // 输出：-3 **实例 2：**从对象数组中查找符合条件的对象。 const users = [ {id: 1, name: 'Alice'}, {id: 2, name: 'Bob'}, {id: 3, name: 'Charlie'} ]; const user = users.find(u =\u003e u.id === 2); console.log(user); // 输出：{id: 2, name: 'Bob'} **实例 3：**使用 thisArg 参数指定回调函数中的 this 值。 function isEven(num) { return num % 2 === 0; } const nums = [1, 3, 4, 7, 8]; const evenNum = nums.find(isEven, this); console.log(evenNum); // 输出：4 ★注意事项 find() 方法会遍历整个数组，直到找到满足条件的元素或者遍历完整个数组。 如果数组为空，那么返回 undefined。 在回调函数中修改数组本身不是一个好习惯。如果要修改数组，请使用 map() 或者 filter() 方法。 当多个元素符合条件时，find() 方法只会返回第一个符合条件的元素。 find() 方法是 ES6 中新增的方法，在较旧的浏览器中可能不被支持。 ","date":"2024-07-21","objectID":"/es6/:3:5","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.6 findIndex() findIndex返回满足条件的第一个元素的索引，而find返回满足条件的元素本身。这两个方法都不会改变原数组，且在找到匹配项后停止遍历剩余元素。 findIndex方法常用来查找数组中满足条件的第一项元素的下标 const arr = [1, 2, 3, 4, 5, 3, 3, 2, 4, 5 ] // 可以这么写 const index = arr.findIndex(item =\u003e { return item \u003e 2 }) console.log(index) // 2 //------------------------------------------ // 也可以这么写 const index = arr.findIndex(item =\u003e item \u003e 2) console.log(index) // 2 返回的index是满足条件的第一项元素的下标，这要注意的是findIndex会给数组中的每一项执行一个函数来判断是否满足表达式，如果满足条件后，剩下的元素则不再执行 ","date":"2024-07-21","objectID":"/es6/:3:6","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.7 indexOf() indexOf方法可返回某个指定的字符串值在字符串中首次出现的位置。 如果没有找到匹配的字符串则返回 -1 注意： indexOf() 方法区分大小写。 let str = 'orange'; str.indexOf('o'); //0 str.indexOf('n'); //3 str.indexOf('c'); //-1 //这里 0 和 3 分别是 o 和 n 在字符串中出现的位置。起始下标是 0。而 -1 代表未匹配 **注意：**indexOf 会做简单的类型转换 let numStr = '2016'; numStr.indexOf('2'); //0 numStr.indexOf(2); //0 //把会先把数字转换成字符串 '2' 然后再执行。 **注意：**number 类型有没有 indexOf 方法 let num = 2016; num.indexOf(2); //Uncaught TypeError: num.indexOf is not a function 对 number 类型使用 indexOf 方法，需要先转换成字符串 //二逼青年的写法 num = '2016'; num.indexOf(2); //0 //普通青年的写法 num.toString().indexOf(2); //0 //文艺青年的写法 ('' + num).indexOf(2); //0 //这里注意，第一种写死的写法在num为变量的时候会显得很蠢。第二种比较常用，第三种则比较精明 **注意：**Array 类型 indexOf() 方法在数组中搜索指定项目，并返回其位置。 搜索将从指定位置开始，如果未指定开始位置，则从头开始，并在数组末尾结束搜索。 如果未找到该项目，则 indexOf() 返回 -1。 如果该项目出现多次，则 indexOf() 方法返回第一次出现的位置。 注释：第一项的位置为 0，第二项的位置为 1，依此类推。 提示：如果您想从尾到头搜索，请使用 lastIndexOf() 方法。 array.indexOf(item, start) 参数值 参数 描述 item 必需。要搜索的项目。 start 可选。从哪里开始搜索。负值给定的位置将从结尾计数，然后搜索到最后。 示例 let arr = ['orange', '2016', '2016']; arr.indexOf('orange'); //0 arr.indexOf('o'); //-1 arr.indexOf('2016'); //1 arr.indexOf(2016); //-1 This is a tip\rfind 与 findIndex find返回元素，findIndex返回索引 找不到时find返回undefined，findlIndex返回-1 findIndex 与 indexOf findlndex比indexOf更强大一些，可以查找 对象数组， indexOf只能查找 数组 中指定时值，不过indexOf可以指定开始查找位置的索引 ","date":"2024-07-21","objectID":"/es6/:3:7","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"4. 对象常用方法 ","date":"2024-07-21","objectID":"/es6/:4:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"4.1 Object.assign() 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target），第一层属性是深拷贝，第二层属性是浅拷贝 const target1 = { a: 1 }; const source1 = { b: 2 }; const source2 = { c: 3 }; Object.assign(target1, source1, source2); console.log(target1) // 打印：{a:1, b:2, c:3} /*-----------------分隔线-----------------*/ // 第二层属性浅拷贝 const target2 = { a: 1 }; const source3 = { b: { name: 'test' }, c: 3 }; Object.assign(target2, source3); source3.b.name = 'nick' console.log(target2) // 打印：{a:1, b:{ name: 'nick' }, c:3} ","date":"2024-07-21","objectID":"/es6/:4:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5. 解构赋值 解构赋值 是一种特殊的语法，它使我们可以将数组或对象“拆包”为到一系列变量中，因为有时候使用变量更加方便 解构操作对那些具有很多参数和默认值等的函数也很奏效 “解构”并不意味着“破坏” 这种语法叫做解构赋值，因为它通过将结构中的各元素复制到变量中来达到“解构”的目的，但数组本身是没有被修改的 ","date":"2024-07-21","objectID":"/es6/:5:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5.1 数组解构赋值 基础 // 我们有一个存放了名字和姓氏的数组 let arr = [\"Ilya\", \"Kantor\"] // 解构赋值 // sets firstName = arr[0] // and surname = arr[1] let [firstName, surname] = arr; console.log(firstName); // Ilya console.log(surname); // Kantor /*-----------------分隔线-----------------*/ // 不需要第二个元素 let [firstName, , title] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"]; console.log( title ); // Consul /*-----------------分隔线-----------------*/ // 等号右侧可以是任何可迭代对象 let [a, b, c] = \"abc\"; // [\"a\", \"b\", \"c\"] let [one, two, three] = new Set([1, 2, 3]); /*-----------------分隔线-----------------*/ // 赋值给等号左侧的任何内容 let user = {}; [user.name, user.surname] = \"Ilya Kantor\".split(' '); console.log(user.name); // Ilya 我们可以将 Object.entries() 方法与解构语法一同使用，来遍历一个对象的”键—值“对： let user = { name: \"John\", age: 30 }; // 循环遍历键—值对 for (let [key, value] of Object.entries(user)) { console.log(`${key}: ${value}`); // name:John, then age:30 } ……对于 map 对象也类似： let user = new Map(); user.set(\"name\", \"John\"); user.set(\"age\", \"30\"); for (let [key, value] of user) { console.log(`${key}: ${value}`); // name:John, then age:30 } 默认值 // 默认值 let [name = \"Guest\", surname = \"Anonymous\"] = [\"Julius\"]; console.log(name); // Julius（来自数组的值） console.log(surname); // Anonymous（默认值被使用了） 剩余的 ... let [name1, name2, ...rest] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"]; console.log(name1); // Julius console.log(name2); // Caesar // 请注意，`rest` 的类型是数组 console.log(rest[0]); // Consul console.log(rest[1]); // of the Roman Republic console.log(rest.length); // 2 5.1.1关于（…）运算符 ","date":"2024-07-21","objectID":"/es6/:5:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5.2 对象解构赋值 基础 let options = { title: \"Menu\", width: 100, height: 200 }; let {title, width, height} = options; console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 /*-----------------分隔线-----------------*/ // 仅提取 title 作为变量 let { title } = options; console.log(title); // Menu /*-----------------分隔线-----------------*/ // 在options变量的基础上，改变 let {...} 中元素的顺序 let {height, width, title} = { title: \"Menu\", height: 200, width: 100 } console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 /*-----------------分隔线-----------------*/ // 在options变量的基础上，改变映射关系，冒号表示“什么值：赋值给谁” let {width: w, height: h, title} = options; // width -\u003e w // height -\u003e h // title -\u003e title console.log(title); // Menu console.log(w); // 100 console.log(h); // 200 默认值 let options = { title: \"Menu\" }; let {width = 100, height = 200, title} = options; console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 /*-----------------分隔线-----------------*/ // 改变映射关系并设置默认值 let {width: w = 100, height: h = 200, title} = options; console.log(title); // Menu console.log(w); // 100 console.log(h); // 200 剩余的 ... let options = { title: \"Menu\", height: 200, width: 100 }; // title = 名为 title 的属性 // rest = 存有剩余属性的对象 let {title, ...rest} = options; // 现在 title=\"Menu\", rest={height: 200, width: 100} console.log(rest.height); // 200 console.log(rest.width); // 100 ","date":"2024-07-21","objectID":"/es6/:5:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5.3 嵌套解构 let options = { size: { width: 100, height: 200 }, items: [\"Cake\", \"Donut\"], extra: true }; // 为了清晰起见，解构赋值语句被写成多行的形式 let { size: { // 把 size 赋值到这里 width, height }, items: [item1, item2], // 把 items 赋值到这里 title = \"Menu\" // 在对象中不存在（使用默认值） } = options; console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 console.log(item1); // Cake console.log(item2); // Donut ","date":"2024-07-21","objectID":"/es6/:5:3","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5.4 函数参数 let options = { title: \"My menu\", items: [\"Item1\", \"Item2\"] }; // 函数把对象展开成变量 function showMenu({ title = \"Untitled\", width = 200, height = 100, items = [] }) { // title, items – 提取于 options， // width, height – 使用默认值 console.log( `${title} ${width} ${height}` ); // My Menu 200 100 console.log( items ); // Item1, Item2 } showMenu(options); ","date":"2024-07-21","objectID":"/es6/:5:4","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"6. ... 运算符 ","date":"2024-07-21","objectID":"/es6/:6:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"6.1 Rest 参数 This is a warning\r注意：Rest 参数必须放到参数列表的末尾\rfunction sumAll(...args) { // 数字名为 args let sum = 0; for (let arg of args) sum += arg; return sum; } console.log( sumAll(1) ); // 1 console.log( sumAll(1, 2) ); // 3 console.log( sumAll(1, 2, 3) ); // 6 function showName(firstName, lastName, ...titles) { console.log( `${firstName} ${lastName}` ); // Julius Caesar // 剩余的参数被放入 titles 数组中 // i.e. titles = [\"Consul\", \"Imperator\"] console.log( titles[0] ); // Consul console.log( titles[1] ); // Imperator console.log( titles.length ); // 2 } showName(\"Julius\", \"Caesar\", \"Consul\", \"Imperator\"); ","date":"2024-07-21","objectID":"/es6/:6:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"6.2 Spread 语法 基础 let arr = [3, 5, 1]; console.log( Math.max(...arr) ); // 5（spread 语法把数组转换为参数列表） /*-----------------分隔线-----------------*/ let arr1 = [1, -2, 3, 4]; let arr2 = [8, 3, -8, 1]; console.log( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25 /*-----------------分隔线-----------------*/ let arr = [3, 5, 1]; let arr2 = [8, 9, 15]; let merged = [0, ...arr, 2, ...arr2]; console.log(merged); // 0,3,5,1,2,8,9,15（0，然后是 arr，然后是 2，然后是arr2） 获取一个对象或数组的副本 let arr = [1, 2, 3]; // 将数组 spread 到参数列表中，然后将结果放到一个新数组 let arrCopy = [...arr]; // 两个数组中的内容相同吗？ console.log(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true // 两个数组相等吗？ console.log(arr === arrCopy); // false（它们的引用是不同的） // 修改我们初始的数组不会修改副本： arr.push(4); console.log(arr); // 1, 2, 3, 4 console.log(arrCopy); // 1, 2, 3 /*-----------------分隔线-----------------*/ // 同样适用于对象 let obj = { a: 1, b: 2, c: 3 }; let objCopy = { ...obj }; // 将对象 spread 到参数列表中，然后将结果返回到一个新对象 // 两个对象中的内容相同吗？ console.log(JSON.stringify(obj) === JSON.stringify(objCopy)); // true // 两个对象相等吗？ console.log(obj === objCopy); // false (not same reference) // 修改我们初始的对象不会修改副本： obj.d = 4; console.log(JSON.stringify(obj)); // {\"a\":1,\"b\":2,\"c\":3,\"d\":4} console.log(JSON.stringify(objCopy)); // {\"a\":1,\"b\":2,\"c\":3} ","date":"2024-07-21","objectID":"/es6/:6:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"6.3 …语法 1.1 合并数组 //es5写法，使用concat let arr1 = [1,2]; let arr2 = [5,6]; let newArr = [20]; newArr = newArr.concat(arr1).concat(arr2); //es6写法 let arr1 = [1,2]; let arr2 = [5,6]; let newArr = [20]; newArr = [20,...arr1,...arr2]; 1.2合并对象 const baseSquirtle = { name: 'Squirtle', type: 'Water' }; const squirtleDetails = { species: 'Tiny Turtle Pokemon', evolution: 'Wartortle' }; const squirtle = { ...baseSquirtle, ...squirtleDetails }; console.log(squirtle); //Result: { name: 'Squirtle', type: 'Water', species: 'Tiny Turtle Pokemon', evolution: 'Wartortle' } 2.1 为数组新增成员 const pokemon = ['小红', '小李']; const charmander = '大大'; const pokedex = [...pokemon, charmander]; console.log(pokedex); //Result: [ '小红', '小李', '大大' ] 2.2 为对象新增属性 const aa= { name: '小红', type: '123' }; const obj= { ...aa, unit: '米', id: '1' }; console.log(obj); //Result: { name: '小红', type: '123', unit: '米', id: '1' } 将一个数组添加到另一个数组的尾部： let arr1 = [0, 1, 2]; let arr2 = [3, 4, 5]; //es5写法 Array.prototype.push.apply(arr1, arr2); //es6写法 let arr1 = [0, 1, 2]; let arr2 = [3, 4, 5]; arr1.push(...arr2); 将字符串转换成数组： //es5写法需要split和join的操作 //... //es6写法 [...'hello'] // [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 解构赋值 例1： let obj = {name:\"小明\",age:18,hobby:\"小红\"}; let newobj = { ...obj } console.log(newobj)//和obj一样 例2： let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; console.log(x); // 1 console.log(y); // 2 console.log(z); // { a: 3, b: 4 } 可以对数组进行浅克 let arr = [1,2,[1,2],3]; let arr2 = [...arr]; arr2.push(1); console.log(arr);//[1,2,[1,2],3] console.log(arr2);//[1,2,[1,2],3,1] 进阶: 复制具有嵌套结构的数据/对象 先看一个例子： const pokemon = { name: 'Squirtle', type: 'Water', abilities: ['Torrent', 'Rain Dish'] }; const squirtleClone = { ...pokemon }; pokemon.name = 'Charmander'; pokemon.abilities.push('Surf'); console.log(squirtleClone); //Result: { name: 'Squirtle', type: 'Water', abilities: [ 'Torrent', 'Rain Dish', 'Surf' ] } 当我们修改原对象的name 属性时，我们的克隆对象的 name 属性没有受影响， 这是符合我们预期的。但是当修改原对象的abilities 属性时，我们的克隆对象也被修改了。 原因: 因为复制过来的abilities 是一个引用类型， 原数据改了， 用到他的地方也会跟着改 解决办法：const squirtleClone = { …pokemon, abilities: […pokemon.abilities] }; const pokemon = { name: 'Squirtle', type: 'Water', abilities: ['Torrent', 'Rain Dish'] }; const squirtleClone = { ...pokemon, abilities: [...pokemon.abilities] }; pokemon.name = 'Charmander'; pokemon.abilities.push('Surf'); console.log(squirtleClone); //Result: { name: 'Squirtle', type: 'Water', abilities: [ 'Torrent', 'Rain Dish' ] } 增加条件属性 方式一： const pokemon = { name: 'Squirtle', type: 'Water' }; const abilities = ['Torrent', 'Rain dish']; const fullPokemon = abilities ? { ...pokemon, abilities } : pokemon; console.log(fullPokemon); 方式二：简化一下 const fullPokemon = abilities \u0026\u0026 { ...pokemon, abilities }; 短路 const pokemon = { name: 'Squirtle', type: 'Water' }; const abilities = ['Torrent', 'Rain dish']; const fullPokemon = { ...pokemon, ...(abilities \u0026\u0026 { abilities }) }; console.log(fullPokemon); 如果 abilities 为 true， 就相当于是 const fullPokemon = { ...pokemon, ...{ abilities } } ","date":"2024-07-21","objectID":"/es6/:6:3","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"7. 箭头函数 创建函数还有另外一种非常简单的语法，并且这种方法通常比函数表达式更好，它看起来像这样： ","date":"2024-07-21","objectID":"/es6/:7:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"7.1 基础 // 这里创建了一个函数 func，它接受参数 arg1..argN，然后使用参数对右侧的 expression 求值并返回其结果 let func = (arg1, arg2, ...argN) =\u003e expression /*-----------------分隔线-----------------*/ // 具体例子 let sum = (a, b) =\u003e a + b; /* 这个箭头函数是下面这个函数的更短的版本： let sum = function(a, b) { return a + b; }; */ console.log( sum(1, 2) ); // 3 ","date":"2024-07-21","objectID":"/es6/:7:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"7.2 多行箭头函数 let sum = (a, b) =\u003e { // 花括号表示开始一个多行函数 let result = a + b; return result; // 如果我们使用了花括号，那么我们需要一个显式的 “return” }; console.log( sum(1, 2) ); // 3 ","date":"2024-07-21","objectID":"/es6/:7:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"7.3 箭头函数没有 this 箭头函数没有 this。如果访问 this，则会从外部获取，例如： let group = { title: \"Our Group\", students: [\"John\", \"Pete\", \"Alice\"], showList1() { this.students.forEach( student =\u003e console.log(this.title + ': ' + student) ); } showList2() { this.students.forEach(function(student) { // Error: Cannot read property 'title' of undefined console.log(this.title + ': ' + student) }); } }; group.showList1(); // 打印： // Our Group: John // Our Group: Pete // Our Group: Alice group.showList2(); // 报错：TypeError: Cannot read property 'title' of undefined 报错是因为 forEach 运行它里面的这个函数，但是这个函数的 this 为默认值 this=undefined，因此就出现了尝试访问 undefined.title 的情况。 但箭头函数就没事，因为它们没有 this。 This is a warning\r注意：不能对箭头函数进行 new 操作 不具有 this 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor）， 即不能用 new 调用它们 ","date":"2024-07-21","objectID":"/es6/:7:3","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"8. Promise Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。 所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise 对象有以下两个特点： 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 ","date":"2024-07-21","objectID":"/es6/:8:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"8.1 用法 ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例 resolve let promise = new Promise((resolve, reject) =\u003e { // 当 promise 被构造完成时，自动执行此函数 // 1 秒后发出工作已经被完成的信号，并带有结果 \"done\" setTimeout(() =\u003e resolve(\"done\"), 1000); }); promise .then(res =\u003e console.log(res)) // 执行条件：promise内的任务处理完成，resolve被执行 .catch(error =\u003e console.log(error)) // 执行条件：reject被执行或者抛出异常 .finally(() =\u003e console.log('this promist done!')) // 执行条件：不管promise内的任务为什么状态都会执行 // 打印： // done // this promist done! reject let promise1 = new Promise(function(resolve, reject) { // 当 promise 被构造完成时，自动执行此函数 // 1 秒后发出工作执行失败的信号，并带有结果 \"failed\" setTimeout(() =\u003e reject(\"failed\"), 1000); }); promise1 .then(res =\u003e console.log(res)) // 执行条件：promise内的任务处理完成，resolve被执行 .catch(error =\u003e console.log(error)) // 执行条件：reject被执行或者抛出异常 .finally(() =\u003e console.log('this promist done!')) // 执行条件：不管promise内的任务为什么状态都会执行 // 打印： // failed // this promist done! ","date":"2024-07-21","objectID":"/es6/:8:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"子=\u003e父 子组件向父组件传参的方式通常通过事件来实现。具体步骤如下： 在子组件中定义事件：子组件可以通过 $emit 方法触发一个自定义事件，并传递参数 // 子组件 ChildComponent.vue \u003ctemplate\u003e \u003cbutton @click=\"sendDataToParent\"\u003e向父组件传参\u003c/button\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { sendDataToParent() { let data = '这是子组件传递给父组件的数据'; this.$emit('child-event', data); } } } \u003c/script\u003e 在上面的代码中，sendDataToParent 方法通过 $emit 发送了一个名为 child-event 的事件，并将 data 作为参数传递给父组件 2.在父组件中监听事件：父组件需要在使用子组件的地方监听这个事件，并处理子组件传递过来的数据 // 父组件 ParentComponent.vue \u003ctemplate\u003e \u003cdiv\u003e \u003cp\u003e从子组件接收到的数据：{{ receivedData }}\u003c/p\u003e \u003cchild-component @child-event=\"handleChildEvent\"\u003e\u003c/child-component\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import ChildComponent from './ChildComponent.vue'; export default { components: { ChildComponent }, data() { return { receivedData: '' }; }, methods: { handleChildEvent(data) { this.receivedData = data; } } } \u003c/script\u003e 在父组件中，使用 标签引入子组件，并通过 @child-event 监听子组件触发的 child-event 事件。当事件被触发时，handleChildEvent 方法会被调用，并将子组件传递的 data 参数赋值给 receivedData。 通过以上方式，子组件就能够向父组件传递数据了。 ","date":"2024-07-01","objectID":"/text17/:0:1","tags":["vue","javascript"],"title":"【Vue前端框架】vue子组件向父组件相互传参的方式","uri":"/text17/"},{"categories":["前端"],"content":"父=\u003e子 Vue项目中在父组件中直接调用子组件的方法 方案一：通过ref直接调用子组件的方法 //父组件中 \u003ctemplate\u003e \u003cdiv\u003e \u003cButton @click=\"handleClick\"\u003e点击调用子组件方法\u003c/Button\u003e \u003cChild ref=\"child\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import Child from './child'; export default { methods: { handleClick() { this.$refs.child.sing(); }, }, } \u003c/script\u003e //子组件中 \u003ctemplate\u003e \u003cdiv\u003e我是子组件\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { sing() { console.log('我是子组件的方法'); }, }, }; \u003c/script\u003e 方案二：通过组件的$emit、$on方法 //父组件中 \u003ctemplate\u003e \u003cdiv\u003e \u003cButton @click=\"handleClick\"\u003e点击调用子组件方法\u003c/Button\u003e \u003cChild ref=\"child\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import Child from './child'; export default { methods: { handleClick() { this.$refs.child.$emit(\"childmethod\") //子组件$on中的名字 }, }, } \u003c/script\u003e //子组件中 \u003ctemplate\u003e \u003cdiv\u003e我是子组件\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { mounted() { this.$nextTick(function() { this.$on('childmethods', function() { console.log('我是子组件方法'); }); }); }, }; \u003c/script\u003e ","date":"2024-07-01","objectID":"/text17/:0:2","tags":["vue","javascript"],"title":"【Vue前端框架】vue子组件向父组件相互传参的方式","uri":"/text17/"},{"categories":["idea"],"content":"1、现象如下 2、解决办法 3、或者搜索框输入ESLint，选择禁用 ","date":"2023-04-03","objectID":"/text05/:0:0","tags":["idea"],"title":"【idea】idea导入ta404前端项目代码后js文件中注释报红色波浪线解决办法","uri":"/text05/"},{"categories":["idea"],"content":"IDEA在Database中连接达梦数据库 repository-达梦8maven.zip · Jared.Yan/dameng-maven - Gitee.com This is a tip\r如果是连接项目代码中的达梦数据库，此处选择的jar包为项目代码依赖中的dm.jar\r1、idea右侧点击database 2、照着我的点就行，驱动包记得得先加上才会出现class选项 3、回到主页面，添加一个数据库连接。 4、测试连接，连接成功 ","date":"2023-04-03","objectID":"/text10/:0:0","tags":["达梦数据库"],"title":"【idea】IDEA在Database中连接达梦数据库","uri":"/text10/"},{"categories":["Java"],"content":"StringEscapeUtils类可以对html js xml sql 等代码进行转义来防止SQL注入及XSS注入 添加依赖 \u003cdependency\u003e \u003cgroupId\u003ecommons-lang\u003c/groupId\u003e \u003cartifactId\u003ecommons-lang\u003c/artifactId\u003e \u003cversion\u003e2.6\u003c/version\u003e \u003c/dependency\u003e 1.html脚本 escapeHtml转义html脚本 unescapeHtml反转义html脚本 System.out.println(StringEscapeUtils.escapeHtml(\"\u003ca\u003eabc\u003c/a\u003e\")); System.out.println(StringEscapeUtils.unescapeHtml(\"\u0026lt;a\u0026gt;abc\u0026lt;/a\u0026gt;\")); 输出 \u0026lt;a\u0026gt;abc\u0026lt;/a\u0026gt; \u003ca\u003eabc\u003c/a\u003e 2.js脚本 escapeJavaScript转义js脚本 unescapeJavaScript反转义js脚本 System.out.println(StringEscapeUtils.escapeJavaScript(\"\u003cscript\u003ealert('123')\u003cscript\u003e\")); System.out.println(StringEscapeUtils.unescapeJavaScript(\"\u003cscript\u003ealert(\\'123\\')\u003cscript\u003e\")); 输出 \u003cscript\u003ealert(\\'123\\')\u003cscript\u003e \u003cscript\u003ealert('123')\u003cscript\u003e 3.字符串Unicode　escapeJava转义成Unicode编码 unescapeJava反转义成Unicode编码 System.out.println(StringEscapeUtils.escapeJava(\"你好\")); System.out.println(StringEscapeUtils.unescapeJava(\"\\u4F60\\u597D\")); 输出 \\u4F60\\u597D 你好 4.xml escapeXML转义XML unescapeXML反转义XML System.out.println(StringEscapeUtils.escapeXml(\"\u003cname\u003e贝贝\u003c/name\u003e\")); System.out.println(StringEscapeUtils.unescapeXml(\"\u0026lt;name\u0026gt;\u0026#36125;\u0026#36125;\u0026lt;/name\u0026gt;\")); 输出 \u0026lt;name\u0026gt;\u0026#36125;\u0026#36125;\u0026lt;/name\u0026gt; \u003cname\u003e贝贝\u003c/name\u003e 5.sql escapeSql sql转义，防止sql注入攻击 转义后 StringBuffer sql = new StringBuffer(\"select * from users where 1=1 \"); String keyWord=\"aaa' or '1=1\"; if(!keyWord.isEmpty()){ sql.append(\" and username like '%\" + StringEscapeUtils.escapeSql(keyWord) + \"%'\"); } System.out.println(sql); 输出 select * from users where 1=1 and username like '%aaa'' or ''1=1%' 不进行转义的 select * from users where 1=1 and username like '%aaa' or '1=1%' ","date":"2023-04-03","objectID":"/text15/:0:0","tags":["java"],"title":"【Java】转义StringEscapeUtils的使用","uri":"/text15/"},{"categories":["Java"],"content":"String转为int，使用parseInt，或者valueOf.intValue int i = Integer.parseInt（string）; int i = Integer.valueOf(s).intValue(); int转为String，使用valueOf，或者toString，或者\"“空字符串相加 String s = String.valueOf(i); String s = Integer.toString(i); String s = \"\" + i; ","date":"2023-03-01","objectID":"/text02/:0:0","tags":["java"],"title":"【Java】Java中int与String互相转换方法","uri":"/text02/"},{"categories":["Python"],"content":"本文指导如何处理PyCharm中关于MicrosoftWebDriver.exe路径错误，需下载对应浏览器驱动，如Edge驱动，重命名并将其放置在Python安装目录下，以便PyCharm正常使用Selenium打开浏览器。edge驱动下载地址：驱动程序 将下载好的驱动程序解压。 找到python的目录文件，将Edge驱动程序放置在python根目录下。 This is a tip\r如果不知道自己的python安装在什么位置了，可以打开cmd键入“where python”\r3.完成以上步骤你得pycharm就可以正常打开浏览器了。 driver = webdriver.Edge() url = \"https://www.baidu.com\" driver.get(url) ","date":"2022-07-12","objectID":"/text19/:0:0","tags":["Python"],"title":"【Python】Python的WebDriver问题","uri":"/text19/"},{"categories":["Python"],"content":"python官网地址：https://www.python.org/ 第1步：先勾选，再安装，上面是默认安装路径，下面是自定义安装路径 等待安装 安装完成，设置MAX_PATH，授管理员权限 打开终端窗口，输入python命令，验证是否安装成功 ","date":"2022-07-08","objectID":"/text04/:0:0","tags":["Python"],"title":"【Python】Python下载与安装操作步骤","uri":"/text04/"},{"categories":["读卡器驱动"],"content":"报错信息Exception in thread “AWT-EventQueue-0” java.lang.UnsatisfiedLinkError: Unable to load library ‘c:\\dcrf32.dll’:Native library (win32-x86-64/c:\\dcrf32.dll) not found in resource path 翻译过来就是：线程“AWT-EventQueue-0”出现异常，无法加载库’c:\\dcrf32.dll’:本机库(win32-x86-64/c:\\dcrf32.dll)在资源路径中找不到 解决办法： 1、我先是检查了jdk 版本，jre是不是选择和动态库相同位数的32 or 64？ 检查jdk版本位数的方法: java -version 2、 动态库是否添加到jdk里面？我检查的时候，是加了的，但是还是报找不到 3、是不是动态库要求放到具体某一个文件夹下了？ Unable to load library ‘c:\\dcrf32.dll’:Native library (win32-x86-64/c:\\dcrf32.dll) not found 这个括号里面搜索的动态库的位置在c盘根目录下，很像是代码写死了访问位置。于是我找代码去了，确实代码里面是指定要求限制了。 解决办法：把动态库的位置移动到c盘根目录下，或者代码访问位置去掉前面的磁盘限制。 这个错找了很久，特此记录 ","date":"2022-05-18","objectID":"/text03/:0:0","tags":["dll文件引用","intellij idea","jar"],"title":"【读卡器驱动】dcrf32.dll","uri":"/text03/"},{"categories":["前端"],"content":"数字短信验证码 思路： a.两个文本框+一个获取验证码按钮，文本框用来输入手机号和获取到的验证码，按钮负责点击和记录倒计时； b.js书写定时器setTimeout，进行60秒验证码失效时间记录； c.后台提供短信获取验证的接口，我们把手机号作为参数上传，后台获取到后给该手机号下发验证码 下放代码可以直接 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cscript type=\"text/javascript\" src=\"https://libs.baidu.com/jquery/2.1.4/jquery.min.js\" \u003e //验证码 var counts = 60; function settime(val) { if(counts == 0) { val.removeAttribute(\"disabled\"); val.value = \"获取验证码\"; counts = 60; return false; } else { val.setAttribute(\"disabled\", true); val.value = \"重新发送（\" + counts + \"）\"; counts--; } setTimeout(function() { settime(val); }, 1000); } $(function(){ //获取验证码 $(\"#verCodeBtn\").click(function() { var userinfo = { \"UserPhoneNum\": '86//' + $(\"input[name='phone']\").val() } $.ajax({ url: \"https://www.xxxxx.cn/user/sendcode/\", data: userinfo, type: \"get\", success: function(data) { if(JSON.parse(data).state === 404 || JSON.parse(data).state === 202 || userinfo.UserPhoneNum === '86//') { alert(\"验证码发送失败\") } else { alert(\"验证码发送成功，请耐心等待\") } }, error: function() { alert(\"发送失败\"); } }); }); }) \u003c/script\u003e \u003cbody\u003e \u003cinput type=\"text\" name=\"phone\" id=\"phone\" value=\"\" placeholder=\"请输入手机号\" maxlength=\"11\" /\u003e \u003cinput type=\"\" name=\"verCode\" id=\"verCode\" value=\"\" placeholder=\"请输入验证码\" maxlength=\"6\"/\u003e \u003cinput type=\"button\" name=\"\" id=\"verCodeBtn\" value=\"获取验证码\" onclick=\"settime(this);\"/\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-01-09","objectID":"/text14/:0:1","tags":["JavaScript"],"title":"【JS】JS 验证码功能的三种实现方式","uri":"/text14/"},{"categories":["前端"],"content":"图形验证码 概要：一般的图形验证码就像上方的短信验证码一样，就是后台生成的验证码图片返回给前端的，那样的话就比较简单，因为复杂的都让后台解决了，我在这里主要说的是另一种，就是不调用后台接口，通过canvas画布来解决图形验证码。 思路： a.一个文本框用来输入由数字和字母组合的验证码+一个画布标签来显示图形验证码+一个提交按钮； b.提交按钮进行表单验证，输入正确或者错误进行相应的提示； c.用画布生成并渲染出验证码图形，并且得到随机的颜色值； \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e验证码\u003c/title\u003e \u003cstyle\u003e .input-val { width: 150px; height: 30px; border: 1px solid #ddd; box-sizing: border-box;/*box-sizing 属性允许你以某种方式定义某些元素，以适应指定区域。*/ } #canvas { vertical-align: middle;/*vertical-align属性设置一个元素的垂直对齐。*/ box-sizing: border-box; border: 1px solid #ddd; cursor: pointer; } .btn { display: block; margin-top: 10px; height: 30px; width: 80px; font-size: 16px; color: #fff; background-color: #409EFE; border: 1px solid #EBEDEF; border-radius: 50px; } \u003c/style\u003e \u003c/head\u003e \u003cscript type=\"text/javascript\" src=\"https://libs.baidu.com/jquery/2.1.4/jquery.min.js\" \u003e\u003c/script\u003e \u003cscript\u003e $(function(){ var show_num = []; draw(show_num); $(\"#canvas\").on('click',function(){ draw(show_num); }) $(\".btn\").on('click',function(){ var val = $(\".input-val\").val().toLowerCase(); //toLowerCase()函数将字符串中的所有字符转为小写。所以输入框不区分大小写。 var num = show_num.join(\"\"); if(val==''){ alert('请输入验证码！'); }else if(val == num){ alert('提交成功！'); $(\".input-val\").val(''); }else{ alert('验证码错误！请重新输入！'); $(\".input-val\").val(''); } }) }) function draw(show_num) {//生成并渲染出验证码图形 var canvas_width=$('#canvas').width(); var canvas_height=$('#canvas').height(); var canvas = document.getElementById(\"canvas\");//获取canvas var context = canvas.getContext(\"2d\");//获取到canvas画图的环境 canvas.width = canvas_width; canvas.height = canvas_height; var sCode = \"A,B,C,E,F,G,H,J,K,L,M,N,P,Q,R,S,T,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,m,n,p,q,r,s,t,u,v,w,x,y,z,1,2,3,4,5,6,7,8,9,0\"; var aCode = sCode.split(\",\"); var aLength = aCode.length;//获取到数组的长度 for (var i = 0; i \u003c 4; i++) { //这里的for循环可以控制验证码位数 var j = Math.floor(Math.random() * aLength);//获取到随机的索引值 var deg = Math.random() - 0.5; //产生一个随机弧度 var txt = aCode[j];//得到随机的一个内容 show_num[i] = txt.toLowerCase(); var x = 10 + i * 20;//文字在canvas上的x坐标 var y = 20 + Math.random() * 8;//文字在canvas上的y坐标 context.font = \"bold 24px 微软雅黑\"; context.translate(x, y); context.rotate(deg); context.fillStyle = randomColor(); context.fillText(txt, 0, 0); context.rotate(-deg); context.translate(-x, -y); } for (var i = 0; i \u003c= 5; i++) { //验证码上显示线条 context.strokeStyle = randomColor(); context.beginPath(); context.moveTo(Math.random() * canvas_width, Math.random() * canvas_height); context.lineTo(Math.random() * canvas_width, Math.random() * canvas_height); context.stroke(); } for (var i = 0; i \u003c= 20; i++) { //验证码上的小点 context.strokeStyle = randomColor();//随机生成 context.beginPath(); var x = Math.random() * canvas_width; var y = Math.random() * canvas_height; context.moveTo(x, y); context.lineTo(x + 1, y + 1); context.stroke(); } } function randomColor() {//得到随机的颜色值 var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return \"rgb(\" + r + \",\" + g + \",\" + b + \")\"; } \u003c/script\u003e \u003cbody\u003e \u003cdiv class=\"code\"\u003e \u003cinput type=\"text\" value=\"\" placeholder=\"请输入验证码\" class=\"input-val\"\u003e \u003ccanvas id=\"canvas\" width=\"100\" height=\"30\"\u003e\u003c/canvas\u003e \u003cbutton class=\"btn\"\u003e验证\u003c/button\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-01-09","objectID":"/text14/:0:2","tags":["JavaScript"],"title":"【JS】JS 验证码功能的三种实现方式","uri":"/text14/"},{"categories":["前端"],"content":"滑动验证码 滑块登录，是完成拼图形式的，我下面这个原理是一样的，逻辑是根据鼠标滑动轨迹，坐标位置，计算拖动速度等等来判断是否人为操作，如果小伙伴想做和博客园效果一样的，那么可以用来做参考。 思路： a.由三个div组成，构成了滑块和底部进度条的效果； b.书写js,注册鼠标按下，悬浮，松开事件； c.记录滑块移动的距离和状态进行判断是否成功； html \u003cdiv class=\"drag\"\u003e \u003cdiv class=\"bg\"\u003e\u003c/div\u003e \u003cdiv class=\"text\" onselectstart=\"return false;\"\u003e请拖动滑块解锁\u003c/div\u003e \u003cdiv class=\"btn\"\u003e\u0026gt;\u0026gt;\u003c/div\u003e \u003c/div\u003e css \u003cstyle\u003e .drag{ width: 300px; height: 40px; line-height: 40px; background-color: #e8e8e8; position: relative; margin:0 auto; } .bg{ width:40px; height: 100%; position: absolute; background-color: #75CDF9; } .text{ position: absolute; width: 100%; height: 100%; text-align: center; user-select: none; } .btn{ width:40px; height: 38px; position: absolute; border:1px solid #ccc; cursor: move; font-family: \"宋体\"; text-align: center; background-color: #fff; user-select: none; color:#666; } \u003c/style\u003e js \u003cscript\u003e //一、定义一个获取DOM元素的方法 var $ = function(selector){ return document.querySelector(selector); }, box = $(\".drag\"),//容器 bg = $(\".bg\"),//背景 text = $(\".text\"),//文字 btn = $(\".btn\"),//滑块 success = false,//是否通过验证的标志 distance = box.offsetWidth - btn.offsetWidth;//滑动成功的宽度（距离） //二、给滑块注册鼠标按下事件 btn.onmousedown = function(e){ //1.鼠标按下之前必须清除掉后面设置的过渡属性 btn.style.transition = \"\"; bg.style.transition =\"\"; //说明：clientX 事件属性会返回当事件被触发时，鼠标指针向对于浏览器页面(或客户区)的水平坐标。 //2.当滑块位于初始位置时，得到鼠标按下时的水平位置 var e = e || window.event; var downX = e.clientX; //三、给文档注册鼠标移动事件 document.onmousemove = function(e){ var e = e || window.event; //1.获取鼠标移动后的水平位置 var moveX = e.clientX; //2.得到鼠标水平位置的偏移量（鼠标移动时的位置 - 鼠标按下时的位置） var offsetX = moveX - downX; //3.在这里判断一下：鼠标水平移动的距离 与 滑动成功的距离 之间的关系 if( offsetX \u003e distance){ offsetX = distance;//如果滑过了终点，就将它停留在终点位置 }else if( offsetX \u003c 0){ offsetX = 0;//如果滑到了起点的左侧，就将它重置为起点位置 } //4.根据鼠标移动的距离来动态设置滑块的偏移量和背景颜色的宽度 btn.style.left = offsetX + \"px\"; bg.style.width = offsetX + \"px\"; //如果鼠标的水平移动距离 = 滑动成功的宽度 if( offsetX == distance){ //1.设置滑动成功后的样式 text.innerHTML = \"验证通过\"; text.style.color = \"#fff\"; btn.innerHTML = \"\u0026radic;\"; btn.style.color = \"green\"; bg.style.backgroundColor = \"lightgreen\"; //2.设置滑动成功后的状态 success = true; //成功后，清除掉鼠标按下事件和移动事件（因为移动时并不会涉及到鼠标松开事件） btn.onmousedown = null; document.onmousemove = null; //3.成功解锁后的回调函数 setTimeout(function(){ alert('解锁成功！'); },100); } } //四、给文档注册鼠标松开事件 document.onmouseup = function(e){ //如果鼠标松开时，滑到了终点，则验证通过 if(success){ return; }else{ //反之，则将滑块复位（设置了1s的属性过渡效果） btn.style.left = 0; bg.style.width = 0; btn.style.transition = \"left 1s ease\"; bg.style.transition = \"width 1s ease\"; } //只要鼠标松开了，说明此时不需要拖动滑块了，那么就清除鼠标移动和松开事件。 document.onmousemove = null; document.onmouseup = null; } } \u003c/script\u003e ","date":"2022-01-09","objectID":"/text14/:0:3","tags":["JavaScript"],"title":"【JS】JS 验证码功能的三种实现方式","uri":"/text14/"},{"categories":["前端"],"content":"利用原生JSON对象，将对象转为字符串，使用 JSON.stringify（对象名） var jsObj = {}; jsObj.testArray = [1,2,3,4,5]; jsObj.name = 'CSS3'; jsObj.date = '8 May, 2011'; var str = JSON.stringify(jsObj); alert(str); 从JSON字符串转为对象 ，使用JSON.parse（字符串名） var jsObj = {}; jsObj.testArray = [1,2,3,4,5]; jsObj.name = 'CSS3'; jsObj.date = '8 May, 2011'; var str = JSON.stringify(jsObj); var str1 = JSON.parse(str); alert(str1); ","date":"2022-01-09","objectID":"/text01/:0:0","tags":["JavaScript"],"title":"【Js】JS 中Object和String互转方法","uri":"/text01/"},{"categories":["前端"],"content":"利用来JS控制页面控件显示和隐藏有两种方法，两种方法分别利用HTML的style中的两个属性，两种方法的不同之处在于控件隐藏后是否还在页面上占空位。 ","date":"2022-01-09","objectID":"/text013/:0:0","tags":["javascript"],"title":"【Js】JS控制元素的显示和隐藏","uri":"/text013/"},{"categories":["前端"],"content":"方法一 document.getElementById(\"EleId\").style.visibility=\"hidden\"; document.getElementById(\"EleId\").style.visibility=\"visible\"; 利用上述方法实现隐藏后，页面的位置还被控件占用，显示空白。 ","date":"2022-01-09","objectID":"/text013/:0:1","tags":["javascript"],"title":"【Js】JS控制元素的显示和隐藏","uri":"/text013/"},{"categories":["前端"],"content":"方法二 document.getElementById(\"EleId\").style.display=\"none\"; document.getElementById(\"EleId\").style.display=\"inline\"; 利用上述方法实现隐藏后，页面的位置不被占用。 ","date":"2022-01-09","objectID":"/text013/:0:2","tags":["javascript"],"title":"【Js】JS控制元素的显示和隐藏","uri":"/text013/"},{"categories":["前端"],"content":"方法三 显示元素进行隐藏 document.getElementById(\"ID名\").hidden=ture; 根据页面元素ID名获得页面元素值，进而将其属性设置成隐藏。 将隐藏元素进行显示对于已经隐藏的页面元素如果要将其再次显示，不是将 document.getElementById(\"ID名\").hidden=false; 而是将其隐藏属性删除 document.getElementById(\"ID名\").removeAttribute(\"hidden\"); ","date":"2022-01-09","objectID":"/text013/:0:3","tags":["javascript"],"title":"【Js】JS控制元素的显示和隐藏","uri":"/text013/"},{"categories":["前端"],"content":"一些基本定义 ","date":"2021-07-01","objectID":"/text22/:1:0","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"1、万维网 （world wide web ===\u003e www）作用：实现资源共享 ​ 是Internet上基于客户/服务器体系结构的分布式多平台的超文本超媒体信息服务系统，它是Internet最主要的信息服务，允许用户在一台计算机上通过Internet读取另一台计算机上的信息。 ","date":"2021-07-01","objectID":"/text22/:1:1","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"2、网页 （web page） ​ 是存放在web服务器上供客户端用户浏览的文件，可以在Internet上传输。网页是按照网页文档规范编写的一个或多个文件，这种格式的文件由超文本标记语言创建，能将文字、图片、声音等各种多媒体文件组合在一起，这些文件被保存在特定计算机的特定目录中。 ","date":"2021-07-01","objectID":"/text22/:1:2","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"3、网站 （web site） ​ 也称站点，定义为已注册的域名、主页或web服务器。 ​ “网站 = 域名（网站地址）+ 网站空间” ​ 网站是一系列网页的组合，这些网站拥有相同或者相似的属性，并通过各种链接相关联。 相同或者相似的属性\r相同实现目的、相似设计、共同描述相关主导体\r浏览器 ——\u003e 地址栏 ——\u003e 网站地址 ——\u003e网络服务器 ——\u003e 默认网页（首页/主页） 浏览器作用\r浏览器：简译和显示 网页数据包\r","date":"2021-07-01","objectID":"/text22/:1:3","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"4、web标准 ​ 不是某一种标准，而是一系列标准的集合。 ​ “网页组成 = 结构 + 行为 + 表现” 对应三类标准： ​ 1、结构化标准语言：XHMTL、XML、【HTML: 超文本标记语言HyperText Markup Lauguage】 ​ 2、表现标准语言：CSS【Cascading Style Sheets 层叠样式表】 ​ 3、行为标准语言：对象模型W3C DOM 【Document Object Model 文档对象模型】、ECMAScript【API应用接口：连接“网站文件”与“js”的接口】 ","date":"2021-07-01","objectID":"/text22/:1:4","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"5、Inter网 ​ 由双绞线通过物理连接构成网。（路由器、交换机） ","date":"2021-07-01","objectID":"/text22/:1:5","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"6、http ​ 超文本传输协议资源 ","date":"2021-07-01","objectID":"/text22/:1:6","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"7、URL 统一资源定位符 ","date":"2021-07-01","objectID":"/text22/:1:7","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"8、UML 统一建模语言 ","date":"2021-07-01","objectID":"/text22/:1:8","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"9、DNS 域名解析服务器 ","date":"2021-07-01","objectID":"/text22/:1:9","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"10、网页工作原理 ​ 1、静态网页（工作原理） ​ 2、动态网页（工作原理） ","date":"2021-07-01","objectID":"/text22/:1:10","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"11、Java Script ​ 运行在客户端的一段程序。 ","date":"2021-07-01","objectID":"/text22/:1:11","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"12、架构 ​ BS架构：浏览器/服务器 ​ CS架构：客户端（下载APP）/服务器 ","date":"2021-07-01","objectID":"/text22/:1:12","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"13、网页图形图像处理工具 ​ 网页图形图像处理工具可以设计图像： ​ Fireworks （背景透明 jpg.不支持） ​ PhotoShop （背景透明 gif.动画 支持） ​ CorelDraw （背景透明 png.支持） ps处理图像 -使用位图 文件尾缀.psd 1024×768：表示横纵向像数点（位图放大会失真、会模糊） cd处理图像 - 使用矢量图算法记录图像的轮廓，内部颜色填充。文件尾缀 .cdr（随意放大，不会失真） ","date":"2021-07-01","objectID":"/text22/:1:13","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"14、网页维护 ​ 1、上传网页：ftp文件传输协议 ​ 2、网站管理员：修改文件 ​ 3、服务器管理员：远程桌面 ​ 4、 网站风格布局：位置、疏密、颜色、装饰、线条、排版 ","date":"2021-07-01","objectID":"/text22/:1:14","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"15、网页设计流程 目标 -图片- 加工-优化 色彩：暖色（红橙黄）、冷色（青、蓝）、中色（紫、黑、白） 色彩搭配：单色搭配、类比色（相近色、近似色120°内）搭配、互补色[搭配/对比]、三元配色 用户体验：浏览、相交互、信任 颜色的属性： ​ 色相：一个物体的颜色（H色相环） ​ 明相：亮度B ​ 纯色：相对于白色的亮度S 三元色：发光体（红、绿、蓝）、反射光（红【品红】、黄、蓝【青绿】） RGB色彩值：（#000000 黑、#666666 灰、 #FFFFFF 白）16进制、0~256、最大值为FF之间元素在此过渡 ","date":"2021-07-01","objectID":"/text22/:1:15","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"16、网页布局 “国”字型、“厂”字型、“框架”型、“封面”型（表格+框架+DIV+CSS） ","date":"2021-07-01","objectID":"/text22/:1:16","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"HTML编译规范 ","date":"2021-07-01","objectID":"/text22/:2:0","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"1、标签 标签：告诉浏览器以下是什么内容。（“英文、半角”下输入，不能有空格） \u003c起始标签\u003e 受标签影响的内容 \u003c/结束标签\u003e 单标记：类似于\u003c/p\u003e以下是一个段落、 \u003cbr/\u003e换行、 \u003cimg/\u003e引用图片 双标记：类似于\u003cfont\u003e\u003c/font\u003e文字 、\u003ctr\u003e\u003c/tr\u003e表格的一行、\u003ctd\u003e\u003c/td\u003e表格的一个单元格 【双标记要标识出作用范围】 ","date":"2021-07-01","objectID":"/text22/:2:1","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"2、属性 属性：告诉浏览器、以下内容如何显示 ①不同的标签有不同的属性，标签可以有很多种属性。 ②“属性”与“属性”之间由“空格”间隔。“属性”与“属性值”之间由“=”连接。 \u003c标签 属性1 = \"属性值1\" 属性2 = \"属性值2\" ...\u003e xxx \u003c/标签\u003e This is a warning\r像\u003cb\u003e \u003cstrong\u003e \u003ci\u003e \u003cem\u003e等与表现css标准有关的标签， 在软件改进中，或许可以生效，通常不再直接使用。 标签可以嵌套，但不允许交叉 显示文件后缀的方法：计算机 - 组织 - 查看 - 显示文件后缀。【直接改.txt 为 .html可以直接编译静态网页】 ","date":"2021-07-01","objectID":"/text22/:2:2","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"3、文档的基本结构 \u003c!-- 支持规范，符合html5 编写规范 --\u003e \u003c!DOCTYPE html\u003e \u003c!-- 告诉浏览器，以下是html代码，语言使用en --\u003e \u003chtml lang=\"en\"\u003e \u003c!-- 告诉浏览器房网页文档的相关信息 --\u003e \u003chead\u003e \u003c!-- 元标签，编码方式为“UTF-8” --\u003e \u003c!-- 修改页面编码方式：页面 - 编码 - UTF-8 --\u003e \u003c!-- 1B=8bt 指 1字节=8位 ，一般2个字节存放一个字符 --\u003e \u003c!-- ASCII编码，为2的8次方=256个字符对应不同的文字和字母 --\u003e \u003c!-- GB2312简体中文 --\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c!-- 网页名称，显示在每个打开在浏览器的页面标签头上 --\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003c!-- 告诉浏览器，放网页要显示的内容 --\u003e \u003cbody\u003e 网页内容 \u003c/body\u003e \u003c!-- 告诉浏览器，模版结束 --\u003e \u003c/html\u003e ","date":"2021-07-01","objectID":"/text22/:2:3","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"4、超链接标签（跳转页面） \u003c!-- a标签 表示“锚点标记”，即超链接标记 --\u003e \u003c!-- href地址属性 #内部的锚点名称标记 记号名：链接的目标+路径URL--\u003e \u003c!-- target打开窗口方式属性 _blank在新窗口打开 _self本窗口打开 --\u003e \u003c!-- 热点：点击时跳转的对象（可以是图片、文字） --\u003e \u003ca href=\"# 记号名\" target=\"_blank\"\u003e热点\u003c/a\u003e 点击的时候是图片（或者跳转链接是图片）： \u003ca href=\"C:\\Users\\Administrator\\Desktop\\123.jpg\" \u003e\u003cimg src=\"123.jpg\" \u003e\u003c/a\u003e 阐述【URL相对/绝对 路径】 网络路径：http://www.baidu.com - 在线网络文档路径（优点：不占空间。缺点：保证网络通畅、别人正常维护可访问） 本地路径：绝对路径 - 有盘符、斜杠方向向右（C:\\Users\\……\\xxxx.jpg） 相对路径 - 以编辑网页文件所在的文件夹位置为原点（../父级文件/父上一级）优点：加载快。缺点：位置不能随意更改） ","date":"2021-07-01","objectID":"/text22/:2:4","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"5、书签标记 \u003ca name=\"# 记号名\" \u003e目标文本附近的内容\u003c/a\u003e 例： \u003ca name=\"#z1\" \u003e第一章\u003c/a\u003e ","date":"2021-07-01","objectID":"/text22/:2:5","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"6、文字标签（排版） ①\u003cbr\u003e强制换行符 ②\u0026nbsp空格符 ③\u0026转义字符 ④lt小于 ⑤qt大于 ⑥;结束 ⑦\u003cnobr\u003e...\u003c/nobr\u003e不换行，当窗口大小化时 ⑧\u003c!-- 注释 --\u003e单行注释标记 ⑨\u003cp align=\"left/center/right\"\u003e……\u003c/p\u003e段落 - 段前，段后均会有一排空行，独占一行显示 ⑩\u003cdiv\u003e……\u003c/div\u003e独占一行显示，没有空行 ⑪\u003cpre\u003e……\u003c/pre\u003e预先排版标记，按照你输入进行排版，没有便会自动识别为所有格式为一个空格 ⑫\u003chr\u003e单标记，插入一条水平线，独占一行显示 （属性：位置、颜色、粗细。width没有宽度） ⑬\u003ch#\u003e标题，h#1~6字体的大小，\u003ch1\u003e……\u003c/h1\u003e一级标题 ⑭\u003cfont\u003e……\u003c/font\u003e字体标题，属性：size字体大小，1~7逐渐变大，color=颜色，face = 字体 ⑮ \u003csub\u003e……\u003c/sub\u003e下标标记 ⑯\u003csup\u003e……\u003c/sup\u003e上标标记 ","date":"2021-07-01","objectID":"/text22/:2:6","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"7、图片标签 图片标签\u003cimg\u003e跟属性 \u003cimg src=\"\" - 图片的路径 width=\"\" - 宽：默认单位为像素 height=\"\" - 长：默认单位为像素 border=\"\" - 边框宽度 hspace=\"\" - 图片与文字之间、留白设置（xx像素） vspace=\"\" - 垂直方向上、留白设置 align=\"\" - 环绕方式（left/right）、对齐方式（top/mindle/bottom） alt=\"\" - 简单说明（无法正常显示的时候给出的提示） title=\"\" - 简单说明（鼠标移动到正常上出现的说明文字） usemap=\"\" - 分隔一张图中的各个板块 /\u003e \u003c!-- name定义地图的名称 --\u003e \u003cmap name=\"\"\u003e\u003c/map\u003e \u003c!-- shape 形状（circle圆形/ rect矩形 / poly多边形）--\u003e \u003c!-- coords 位置：圆（圆心坐标x轴,圆心坐标y轴,半径）、矩形（左顶点左边,右顶点坐标）--\u003e \u003c!-- href 链接--\u003e \u003carea shape=\"\" coords=\"\" href=\"\" alt=\"\"\u003e \u003c!-- 左顶格、上顶格 --\u003e \u003cbody leftmargin=\"0\" topmargin=\"0\"\u003e \u003c/body\u003e ","date":"2021-07-01","objectID":"/text22/:2:7","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"8、表格标签 表格标签\u003ctable\u003e \u003ctable border=\"\" - 表格的边框 width=\"x|x%\" - 是body的百分比，占父级容器的百分比 cellspacing=\"\" - 单元格的间距 cellpadding=\"\" - 内容和边框的间距 colspan=\"\" - 占2个横向单元格 rowspan=\"\" - 占2个纵向单元格 \u003e \u003ctr\u003e \u003ctd\u003e\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003ccaption\u003e显示表格的标题\u003c/caption\u003e可以写在所有的\u003ctr\u003e之前或者之后，但不可以写在之间 background背景图片，\u003ctr\u003e表示单元格表头，默认会加粗、居中显示 属性：（●disc ○circle） ","date":"2021-07-01","objectID":"/text22/:2:8","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"9、表单 表单：收集客户端信息发送给服务器的某个动态网页的目标程序，完成客户端与服务器之间的交互。 \u003cform name=\"\" - 表单名称 action=\"\" - URL路径，当action为空时，传递给自己 method=\"\" - 用什么方式进行传输 get/post ，get：以明文字符串进行传输≤256字符，post以表单整体进行传输 \u003e \u003c/form\u003e 注：①一切内容都要在“表单之内”才能被提交 ②一个网页可以有多个表单 ③表单只是一个区域、内容需要加入表单元素 ④表单内的元素 一定要有名称 才能被提交 input输入框 \u003c!-- 下面都是表单元素 --\u003e \u003cinput type=\"text\" name=\"text\"\u003e \u003c!--单行文本≤255个字符 --\u003e \u003cinput type=\"button\" value=\"按钮\" name=\"button\"\u003e \u003c!-- 按钮类型 --\u003e \u003cinput type=\"submit\" value=\"提交\" name=\"submit\"\u003e \u003c!-- 提交类型--\u003e \u003c!-- 表单输入框元素的详解 --\u003e \u003cinput type=\"表项类型\" - password 密码类型 、reset重置类型(使表单回到初始状态)、radio单选框、checkbox多选框、hidden隐藏域、date时间域、file文件选择框、image图片作为按钮 name=\"表项名\" - 一组单选框的name必须相同，不同组的单选框name必须不相同 value=\"默认值\" - 初始值 size=\"x\" - 控制输入框的大小，单位为“x”个字符 maxlength=\"y\" - 最大输入长度，单位为“y”个字符 \u003e \u003cinput type=\"button\" - 点击触发onclick事件 value=\"\" - 按钮名字 onclick=\"\" - 事件函数 readonly=\"\" - 只读 true/false disabled=\"\" - 不可更改，框为灰色 \u003e 文本域 \u003c!-- name名称 rows行数 cols列数 --\u003e \u003ctextarea name=\"\" id=\"\" rows=\"\" cols=\"\"\u003e多行文本\u003c/textarea\u003e 选择栏 \u003c!-- name传输的名称 size可选择的个数：1单选 2多选 --\u003e \u003cselect name=\"\" id=\"\" size=\"\" multiple=\"\"\u003e \u003c!-- 下拉框 可选择的内容 --\u003e \u003coption value=\"\"\u003exxx\u003c/option\u003e \u003c/select\u003e 列表标签 \u003c!-- 列表格式显示为：项目符号 列表项 --\u003e \u003c!-- 有序列表 ol--\u003e \u003col\u003e \u003cli start=\"开始序号\"\u003e列表项1\u003c/li\u003e \u003cli start=\"1\"\u003e列表项2\u003c/li\u003e \u003cli\u003e列表项3\u003c/li\u003e \u003c/ol\u003e \u003c!-- 无序列表 ul --\u003e \u003cul\u003e \u003cli type=\"符号类型\"\u003e列表项1\u003c/li\u003e \u003cli type=\"disc\"\u003e列表项2\u003c/li\u003e \u003cli type=\"disc\"\u003e列表项3\u003c/li\u003e \u003c/ul\u003e 注意！！！\r注：html中是无法使用图片作为项目符号的！！ \u003c!-- 去掉无序前面的点 --\u003e \u003cstyle\u003e ul li { list-style: none; } \u003c/style\u003e ","date":"2021-07-01","objectID":"/text22/:2:9","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"CSS部分 ","date":"2021-07-01","objectID":"/text22/:3:0","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"一、基本选择符 1、标签选择符（所有的读标签下都使用这个样式）【4】 //html中标签的名字 标签{属性：属性值} 例： td { width : 100px } 2、class类选择符（自由定义）【2】 //class=\"自定义的名称\"（字母开头，下划线数，数字） ·类名称{属性：属性值} 例： \u003cp class=\"abc\"\u003e\u003c/p\u003e .abc{ font-size : 18px} 3、id选择符（能且只能使用一次）【1】 #id名{属性：属性值} 例： \u003cp id=\"abc\"\u003e\u003c/p\u003e #abc{ font-size : 18px} 4、复合选择符【3】 ①“交集”选择符（两个基本选择符、直接连接、且同时满足 ） ②“并集”选择符（两者择其一） ③“后代/包含”选择符（x y{ }，表示在x中的y标签，应用{ }中的样式内容） 5、标签默认样式【5】 This is a tip\r【编号】中的数字表示层叠使用时的优先级。若要提高优先级，则需要使用\u003c!important\u003e\r","date":"2021-07-01","objectID":"/text22/:3:1","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"二、 css层叠样式表 1、后缀.css层叠样式表（格式设定） 层叠：发生样式冲突时，系统以上面编号的优先级进行展示 继承：\u003cdiv\u003e\u003cp\u003e\u003c/p\u003e\u003c/div\u003e继承父级的样式设定 将css文件单独拎出来，放置在html文件的同级根目录下，可以使用style引用该路径下的css使得多个html同时可以使用同一个css css实现的4种形式 ①行内样式表 \u003c!-- style=\"\"双引号中的内容，即为css代码 --\u003e \u003cdiv style=\"font-size: 10px;color: black;\"\u003e\u003c/div\u003e ②内部样式表 \u003c!-- 放在html的head中 --\u003e \u003chead\u003e \u003c!-- 使用style标签，之间为css代码 --\u003e \u003cstyle\u003e div{ font-size: 10px; color: black; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e\u003c/body\u003e ③链入外部样式表 \u003c!-- 引用同级根目录下的css文件 --\u003e \u003clink rel=\"stylesheet\" href=\"根目录.css\" type=\"text/css\"\u003e ④导入外部样式表 \u003c!-- 这种引入外部css的方法必须写在第2种的前面才会生效 --\u003e \u003cstyle @import url=\"根目录.css\"\u003e\u003c/style\u003e 2、通用选择符* ：所有的网页元素都会被改变 3、属性选择符：【优先级高于标签选择符】 格式为：元素[属性] 或者 元素[属性 * = 属性值] ， 例：E[alt]{ css代码 } 如果我们用E代表元素、alt代表属性、val代表属性值。则下面： E [alt] { } - 属性名选择符 E [alt = val] { } - 属性值选择符 E [alt ~ = val ] { } - 属性值选择符（其中一个匹配） E [alt 1 = val ] { } - 属性值选择符（连字符匹配、空白匹配） E [alt = val- ] { } - 属性值选择符（连字符匹配、空白匹配） E [alt^ = val ] { } - 属性值子串选择符（前缀匹配） E [alt$ = val ] { } - 属性值子串选择符（后缀匹配） E [alt* = val ] { } - 属性值子串选择符（子字符串匹配） 4、伪类选择符 UI元素 - 表单元素 ： hover：当鼠标移动到上面的时的状态 fous：当聚焦在上面时的状态 active：按下激活时的状态 link：未访问时的状态 锚点标签： a : link { } 未访问的链接状态 a : visited { } 已访问的链接状态 a : hover { }鼠标悬停在链接上的状态 a : active { }被激活的链接状态 text-indent : 2em ; 文章首行缩进：2个字符 色彩RGB rgba函数（R G B A ）A为透明通道，也叫透明度 == filter : opacity(0.5) 透明滤镜 This is a tip\r①HTML： 超文本标记语言【不是编程语言】，【超文本】比普通文本功能更高的文本文件，【标记语言】使用一组标签对内容进行描述的语言 ②语法规范： A、后缀为 -.html 或 -.htm B、头文件 + 体文件（head + body） C、开头标签 + 结束标签 D、不区分大小写，常用小写 ③JavaScript语法规范 变量（字母、数字、下划线）区分大小写，toSum：以小驼峰来进行命名，尽量避免使用a，b，c这种单字母命名。 ","date":"2021-07-01","objectID":"/text22/:3:2","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"三、CSS盒模型 针对块级元素 {padding：__ } 一个值：上下左右 {padding：__ __ } 两个值：上下/左右 {padding：__ __ __ __ } 四个值：上/下/左/右 我们一般用类似于3px这样的长度单位来设定css盒模型某元素属性的长宽，由此这里对长度单位进行了梳理 长度单位有： em - 首行缩进 - 相对长度单位 px - 像素 - 绝对长度单位 pt - 点 - 绝对长度单位 in - 英寸 - 绝对长度单位 cm - 厘米 - 绝对长度单位 css中的一些属性: 1、brackground-image:url(跟图片的位置) 2、【居中】margin: 0px auto 上下间距为0，左右平均分配 3、【两端对齐】text-align: justify 4、【首字下沉】first-letter 5、【设置行高】line-height：length| normal 6、【设置文本换行】word-warp：normal|break-word 7、【设置图像位置】background-position（百分比/长度） 长度：左上角顶点距离背景两边移动的长度 百分比：中心与中心重叠，占整体的百分比大小 边框属性： 1、所有边框宽度（border-width）：1+7同时使用、才有效果 medium - 默认宽度 thin - 小于默认宽度 thick - 小于默认宽度 length - 数字+单位标识符（长度值），不可为负值 （4个）上下左右 、 （2个）上下/左右 、（1个）四周、（3个）上/左右/下 2、上边框宽度（border-top）：border-width || border-style || border - color 3、右边框宽度（border-right） 4、左边框宽度（border-left） 5、下边框宽度（border-bottom） 6、边框颜色（border-color）： 6和7一起使用 7、边框样式（border - style）：是个复合属性 none 无边框样式 solid实线 hidden 隐藏样式 double 双线 dotted 点虚线 groove 三维凹槽 inset 三维凹边 outset三维凸边 dashed 长矩线 ridge 菱形边框 使用时+height + width 设定position：absolute 内边距 内边距padding，和内容在一层，且不允许为负数 上内边距padding-top 下内边距padding-bottom 左内边距padding-right 右内边距padding-right 外边距 外边距margin length：数字+单位标识符（长度值/百分比） 上外边距margin-top 下外边距margin-bottom 左外边距margin- left 右外边距margin-right 定位方式 定位方式position width宽 height高 min-height最小高度 static【默认】静态定位/无特殊定位 relative 相对定位（左、右）表偏移量 absolute 绝对定位（上、下、左、右）属性 fixed 绝对定位（相对于浏览器窗口）-固定定位 z-index浮动序列 可见性 可见性visibility inherit 继承上一个对父对象的可见性 visible 对象可见 collapse 隐藏表格的行列 hidden 对象隐藏 水平叠加问题 span1\\span2 :两个行级元素紧邻不重叠 垂直叠加问题 div1/div2 ：两个块级元素垂直相遇，会产生叠加，形成一个新的外边距，以大的为准 div1/div2：两个块级元素包含相遇，也会产生叠加，面积以大的为准 浮动清除浮动 浮动float none不浮动 left向左浮动 right向右浮动 清除浮动clear none允许浮动 left清除左浮动 right清除右浮动 both两边均清除 ","date":"2021-07-01","objectID":"/text22/:3:3","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"div+css布局 常见的“三行两列”布局 文本控制 文本控制font font-family 字体名称类别 font-size 字体尺寸||绝对尺寸||相对尺寸 12px正文文字大小 font-weight 字体的粗细（bold粗体，normal默认400、number、lighter默认细、100~900越小字体越细） font-style 字体的倾斜（normal默认、italic斜体、obligue倾斜体） color 颜色值 background-color（color颜色、transparent透明） text-decoration文本的修饰（underline下划线、blink闪烁、overline上划线、line-through贯穿线、none无装饰） 段落控制 段落控制text text-align 设置文本的水平对齐方式 （left左对齐、right右对齐、center居中、justify两端对齐） text-indent 设置段落的首行缩进 first-letter 设置首字母下沉 line-height 设置行高 letter-spacing 设置字符间距（word-spacing：length|normal词间距） text - overflow 设置文字的截断（clip 简单的裁切、不能显示省略标记 | ellipsis 文本溢出时 显示省略标记 ） background-image 背景图像设置（URL+none） background-repeat 图像重复方式（no-不平铺、-x水平平铺、~-y垂直平铺） ","date":"2021-07-01","objectID":"/text22/:3:4","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"JavaScript部分 JavaScript网页行为语言（代码区分大小写） 核心部分：ECMAScript核心、BOM、DOM（包含：基本语法、变量、关键字、保留字、数据类型、语句、函数） ——是基于对象和事件驱动、并具有相对安全性的客户端脚本语言 使用的三种方法 直接加入HTML文档 \u003cscript type=\"text/javascript\"\u003e ....js代码 \u003c/script\u003e 链接脚本文件 \u003chead\u003e \u003cscript type=\"text/javascript\" src=\"脚本文件名.js\"\u003e\u003c/script\u003e \u003c/head\u003e 在HTML标签内添加脚本，在HTML表单的输入标签内添加脚本 javascript交互基本方法 document.write() 文档输出函数 alert() 窗口对象方法（对话框） confirm() 选择对话框（提示文字） prompt() 提示文字内容对话框 javascript相关概念 变量 变量：开辟在内存中的一块空间 变量声明 var \u003c变量\u003e[=值] //（任何）变量声明的关键词、弱变量，不区分数据类型 数据类型 整形 浮点型 字符串型 表达式/运算符 取反 - ! “或”用于嵌套 基本编程命令/语句 单行注释 // 多行注释 /*。。。*/ 转义字符 \\ \\\" 双引号 \\' 单引号 \\n 换行 \\r 回车 条件结构if if(i%10 == 0) cout \u003cbr\u003e //每10个换行 循环结构for for(变量=初始值;循环条件;循环变量的改变) {\u003c语句\u003e} ----------------------------------- while(循环条件) break 直接中断，跳出 continue 只中断该次循环 函数function 有返回值的称为函数，没有返回值的称为操作 函数名(形参) {函数体;} haha(a,b){return a+b;} 调用方式： 返回值 = 函数名(参数1,参数2) b = haha(data1，data2) 全局变量：函数在方法外声明的变量 局部变量：函数内部声明的变量（在函数被调用时激活，才开辟一个存储单元，在函数结束时被释放） 递归 递归调用 - 递归体 - 出口 //阶乘 function jc(n){ if(n=1){ return 1; //留出口，否则死循环 }else{ return n*jc(n-1); //调用自身函数，以形成递归体 } } docment.write(jc(5)); 面向对象的程序设计 对象：属性+方法+事件 number对象 number对象为【数值】，可以使用toString()：将数值转化为字符串 String对象 String对象【字符串】属性： length()：返回字符串的长度 chatAt(*) ：返回 * 所在位置的字符，下标从0开始 chatCodeAt(*)：返回 * 所在位置字符的ASCII码 indexOf(**)：返回 xx所在位置的下标，找不到返回“-1” lastIndexOf(xx，x)：同上，下标也同上，只是倒序查找 split()：返回一个数组 join()：将一个数组返回字符串 Substring(始，终)：截取字符串 substr（始，长度）：截取子字符串 toUpperCase()：小写全转化大写 Array对象 Array对象【数组】属性 var \u003c数组名\u003e = new Array(); //javaScript中数组没有二维数组 Math对象 Math对象【数学】属性 E 返回e=2.71828…. PI 返回π = 3.1415926… random() 返回0到1中的一个随机数 parseInt 构造整数、取整 parseInt(Math.random()*(100-60)+60) //生成60-100间的随机整数 round() 四舍五入 Date对象 Date对象【日期】 var d = new Date(); //获取当前客户端的时间 g/set[UTC]year - 设置年份 g/set[UTC]month - 设置月份 g/set[UTC]Date- 设置日 g/set[UTC]Day- 设置星期几 Global全局对象 eval() 字符串当作表达式处理 parseInt() 括号内的转化为数值（整数），若以字母开头，返回“NAN” parseFloat() 转化为浮点数 toString() 转化为字符串 Dom文档对象 Dom是Bom中的一小部分 Bom浏览器对象（navigate 浏览器对象、screen屏幕对象、window窗口对象：“history历史、location地址、document文档”） Dom（open打开一个窗口）（open（\u003cURL字符串\u003e,\u003c窗口名称字符串\u003e,\u003cxx属性\u003e）） menubar = \" no \" 无菜单栏 toolbar 工具栏 scrollbar滚动条 resizable 可拉动 location 地址栏 d.导航栏 navigate 浏览器对象 appCodeName 返回“码名” appName 返回“浏览器名称” appVersion 返回“浏览器版本” javaEnable 返回“一个布尔型，允不允许使用java” window窗口对象 Name 窗口的名称 Status “状态栏” 可读可写，在最下方 opener 返回打开该窗口的上一窗口 close 关闭一个打开的窗口 window.close() //self.close //setInterval(\"funl,time\")定时器（函数体，时间，单位毫秒） blur() 失去焦点 focus() 获得焦点 scrollTo() 滚动到 scrollBy() 滚动多少 reSizeTo() 调整到 setInterval（funl，time）每隔多少时间执行该函数 setFimeout（funl，time）延迟多少时间执行该函数 history历史对象 length - 访问的窗口数 back - 后退 forward - 前进 history.go(x) - 前进到第x个窗口 history.go(0) - history.reload - 刷新 location地址栏对象 protocol - 返回协议 hostname - 返回地址的主机名 port - 地址端口 host - 地址路径 document文档对象 lastModified - 输出到修改网页最后一次的时间 referrer - 返回打开它的网页窗口 tittle - 返回tittle的名称 fgcolor - 文字颜色 bgcolor - 背景颜色 write() - 输出一个文档流（在\u003c/html时结束）（\u003chtml到\u003c/html算一个文档流，文档流结束会新开一个窗口） getElementById() 通过ID来获取网页上的元素 getElementByName() 通过名称ID来获取网页上的元素 body.clientwidth() / clientwidth() 获取客户端网页窗口大小 offsettop()、offsetleft()、offset() 获取匹配元素在当前视的相对偏移 内联元素 内联元素（行内元素） -属性display：inline； 这个属性能够修复著名的IE双倍浮动边界问题（html规范中的概念-外文名：inline element） 内联元素又名行内元素和其对应的是块元素 内联元素的显示，为了帮助理解，可以形象的称为“文本模式”。即一个挨着一个，都在用一行按从左至右的顺序显示，不单独占一行。display：vnone表示隐藏 加入css控制 内联元素+display = block属性，可以从新行开始 ；块元素+display = inline属性，可以在一行上排列 常见的块级元素address地址/特点：总是在新行上开始 内联元素（特点） 和其他元素都在一行上（左右可以改变设置） 高度，行高和顶以及底边距都不可改变 宽度就是它的文字或图片的宽度不可改变 总的来说，内联元素一般都是基于语义级的基本元素，它只能容纳“文本或其他内联元素，通常被包括在块级元素中使用，常见的内联元素： a - 锚点 b - 粗体 br - 换行 font - 字体 abbr - 编写 acronym - 首字母 big - 大字体 cite - 引用 em - 强调 块级元素 块级元素特点： 总是在新行上开始 高度、行高以及外边距和内边距都可以控制 宽度缺省是它的容器的100%，除非设定一个宽度 它可以容纳内联元素和其他块元素 常见的块级元素： address - 地址 blockquote - 块引用 center -居中对齐块 div - 常用块容器 h1 - 一级大标题 HBuilder：编写软件（放html代码，生成js文件） frameset框架集： \u003c!--横向分割--\u003e \u003cframeset row=\"20%,*\"\u003e \u003cframe src=\"上\"\u003e\u003c/frame\u003e \u003c!--纵向分割--\u003e \u003cframeset cols=\"20%,*\"\u003e \u003cframe src=\"左\"\u003e\u003c/frame\u003e \u003cframe src=\"右\"\u003e\u003c/frame\u003e \u003c/frameset\u003e \u003c/frameset\u003e 图解： 如何控制表单提交？ 关于事件onsubmit：一般用于表单提交的位置 那么需要在定义函数的时候，给出一个返回值 onsubmit = return checkForm()； 返回","date":"2021-07-01","objectID":"/text22/:3:5","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["SQL"],"content":"Oracle查询sql 查询系统当前日期 select sysdate from dual; 请查询每个员工的名字、薪水和加薪15.5%之后的薪水（trunc取整） Select 名字,薪水,trunc(薪水*1.155) \"new salary\" from employees; 请显示所有以’J’，‘A’，‘M’打头的员工的名字和名字长度，且按照名字排升序 select 名字,LENGTH(名字) from employees where substr(名字,0,1) in ('J','A','M') order by 名字 asc; 请查询员工名和工作时间（换算成月并取整），并按工作时间排降序 Select 名,trunc(months_between(sysdate,时间),0) from employees order by trunc(months_between(sysdate,时间),0) desc; 请查询员工的名字和薪水，并将薪水列变成15个字符长度，左边填充“$”符号 select 名字,lpad(薪水,15,'$') from employees; 请查询部门id为90的所有员工的名字和他们参加工作的星期数(保留2位小数，不需要四舍五入)使用 select 名字 , trunc((参加工作星期数)/7,2) from employees where 员工id=90 创建报告，显示员工名和奖金系数,如果奖金系数为空,则显示$无奖金 select 名字,decode(奖金系数,'','无奖金',奖金系数) from employees; 请使用case语句，查询员工的job_id和级别.例如: select t.job_id, decode(t.job_id, 'AD_PRES', 'A','ST_MAN', 'B','IT_PROG', 'C','SA_REP', 'D','ST_CLERK', 'E','0') from employees t; 或者 Select job_id, case job_id when 'AD_PRES' then 'A' when 'ST_MAN' then 'B' when 'IT_PROG' then 'C' when 'SA_REP' then 'D' when 'ST_CLERK' then 'E' else '0' end \"Grage\" from employees; ","date":"2021-07-01","objectID":"/text18/:0:0","tags":["sql","Oracle"],"title":"【SQL语句】Oracle查询sql","uri":"/text18/"},{"categories":["SQL"],"content":"一、聚合函数 有一个学生表如下： ","date":"2021-07-01","objectID":"/text11/:1:0","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"count 1、统计记录总个数 SELECT COUNT (*) FROM 学生表 若要命名 SELECT COUNT (* ) as 学生总人数 FROM 学生表 2、统计指定列的值的数目（NULL 值不计入） SELECT COUNT (专业代码) FROM 学生表 3、统计指定列，拥有不同值的数目（NULL 值不计入） SELECT COUNT (distinct 专业代码) FROM 学生表 ","date":"2021-07-01","objectID":"/text11/:1:1","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"sum 4、计算某一列值的总和 SELECT sum(高考分数) as 高考总分数 FROM 学生表 ","date":"2021-07-01","objectID":"/text11/:1:2","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"MAX、MIN、AVG 5、求某一列值的最大值 This is a tip\rMAX 函数返回一列中的最大值。NULL 值不包括在计算中。 注释：MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。 SELECT MAX(高考分数) as 高考最高分数 FROM 学生表 6、求某一列值的最小值 SELECT MIN(高考分数) as 高考最低分数 FROM 学生表 7、求某一列值的平均值 SELECT AVG(高考分数) as 高考最高分数 FROM 学生表 ","date":"2021-07-01","objectID":"/text11/:1:3","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"FIRST、ROUND 6、取指定字段的第一个记录的值 select first(column_name) from table_name 7、ROUND() 函数（四舍五入规则）、用于把数值字段舍入为指定的小数位数。 SELECT round(列名,小数位数) FROM table_name ","date":"2021-07-01","objectID":"/text11/:1:4","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"MID 8、MID() 函数 ：用于从文本字段中提取字符。 SELECT MID(列名,开始截取位置,结束截取位置) FROM table_name This is a tip\rSELECT MID(列名,1,3) FROM table_name 3不写，默认返回剩余的所有字段 ","date":"2021-07-01","objectID":"/text11/:1:5","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"LEN 9、LEN 函数返回文本字段中值的长度。 SELECT LEN(列名) FROM table_name ","date":"2021-07-01","objectID":"/text11/:1:6","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"二、数据库查询前10条数据 Oracle中查询 select * from table where rownum\u003c=10; DB2中查询 select * from table fetch first 10 rows only; MySql中查询 select * from table limit 10; ","date":"2021-07-01","objectID":"/text11/:2:0","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"三、SQL语言多表关联查询 一、外连接 外连接可分为：左连接、右连接、完全外连接。 select * from A表 left join B表 on A表条件 = B表条件 This is a tip\r左外连接包含left join左表所有行，如果左表中某行在右表没有匹配，则结果中对应行右表的部分全部为空(NULL) select * from A表 right join B表 on A表条件 = B表条件 This is a tip\r右外连接包含right join右表所有行，如果左表中某行在右表没有匹配，则结果中对应左表的部分全部为空(NULL)。 select * from A表 full join B表 on A表条件 = B表条件 This is a tip\r完全外连接包含full join左右两表中所有的行，如果右表中某行在左表中没有匹配，则结果中对应行右表的部分全部为空(NULL)，如果左表中某行在右表中没有匹配，则结果中对应行左表的部分全部为空(NULL)。 二、内连接 join 或 inner join select * from A表 join B表 on A表条件 = B表条件 This is a tip\rinner join 是比较运算符，只返回符合条件的行。\r","date":"2021-07-01","objectID":"/text11/:3:0","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["服务器"],"content":"打开命令行，输入mstsc 点击确认 出现以下界面 输入ip地址及端口号，然后点击连接 提示页面均点，连接 提示页面均点，是 输入用户名和密码即可 ","date":"2021-07-01","objectID":"/text06/:0:0","tags":["远程"],"title":"【服务器】远程登陆服务器教程","uri":"/text06/"},{"categories":["计算机网络"],"content":"路由表 路由表操作 ipconfig route print route delete 0.0.0.0 route delete 10.163.0.0 route delete 10.164.0.0 route delete 10.160.0.0 route delete 10.1.0.0 route add -p 0.0.0.0 mask 0.0.0.0 192.168.9.1 metric 20 route add -p 10.163.0.0 mask 255.255.0.0 192.168.8.1 metric 30 route add -p 10.164.0.0 mask 255.255.0.0 192.168.8.1 metric 30 route add -p 10.160.0.0 mask 255.255.0.0 192.168.8.1 metric 30 route add -p 10.1.0.0 mask 255.255.0.0 192.168.8.1 metric 30 ","date":"2021-07-01","objectID":"/text21/:0:0","tags":["路由"],"title":"【计算机网络】路由表","uri":"/text21/"},{"categories":null,"content":"此网站建立于2024年七夕…… 特别鸣谢：  每天八杯水 (TL Note) 的指导和建议 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我们","uri":"/about/"},{"categories":null,"content":"\rHugo\rhugo官方文档中文版\rLovelt\r一个简洁、优雅且高效的 Hugo 主题\r每天八杯水\r反正问就是大佬的链接\r","date":"0001-01-01","objectID":"/friend/:0:0","tags":null,"title":"友情链接","uri":"/friend/"}]