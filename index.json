[{"categories":null,"content":"网页设计笔记 ","date":"2024-09-04","objectID":"/posts/text22/:0:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"1、万维网 （world wide web ===\u003e www）作用：实现资源共享 ​ 是Internet上基于客户/服务器体系结构的分布式多平台的超文本超媒体信息服务系统，它是Internet最主要的信息服务，允许用户在一台计算机上通过Internet读取另一台计算机上的信息。 ","date":"2024-09-04","objectID":"/posts/text22/:1:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"2、网页 （web page） ​ 是存放在web服务器上供客户端用户浏览的文件，可以在Internet上传输。网页是按照网页文档规范编写的一个或多个文件，这种格式的文件由超文本标记语言创建，能将文字、图片、声音等各种多媒体文件组合在一起，这些文件被保存在特定计算机的特定目录中。 ","date":"2024-09-04","objectID":"/posts/text22/:2:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"3、网站 （web site） ​ 也称站点，定义为已注册的域名、主页或web服务器。 ​ “网站 = 域名（网站地址）+ 网站空间” ​ 网站是一系列网页的组合，这些网站拥有相同或者相似的属性，并通过各种链接相关联。 [!NOTE] 相同或者相似的属性： 相同实现目的、相似设计、共同描述相关主导体 浏览器 ——\u003e 地址栏 ——\u003e 网站地址 ——\u003e网络服务器 ——\u003e 默认网页（首页/主页） [!NOTE] 浏览器：简译和显示 网页数据包 ","date":"2024-09-04","objectID":"/posts/text22/:3:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"4、web标准 ​ 不是某一种标准，而是一系列标准的集合。 ​ “网页组成 = 结构 + 行为 + 表现” 对应三类标准： ​ 1、结构化标准语言：XHMTL、XML、【HTML: 超文本标记语言HyperText Markup Lauguage】 ​ 2、表现标准语言：CSS【Cascading Style Sheets 层叠样式表】 ​ 3、行为标准语言：对象模型W3C DOM 【Document Object Model 文档对象模型】、ECMAScript【API应用接口：连接“网站文件”与“js”的接口】 ","date":"2024-09-04","objectID":"/posts/text22/:4:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"5、Inter网 ​ 由双绞线通过物理连接构成网。（路由器、交换机） ","date":"2024-09-04","objectID":"/posts/text22/:5:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"6、http ​ 超文本传输协议资源 ","date":"2024-09-04","objectID":"/posts/text22/:6:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"7、URL 统一资源定位符 ","date":"2024-09-04","objectID":"/posts/text22/:7:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"8、UML 统一建模语言 ","date":"2024-09-04","objectID":"/posts/text22/:8:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"9、DNS 域名解析服务器 ","date":"2024-09-04","objectID":"/posts/text22/:9:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"10、网页工作原理 ​ 1、静态网页（工作原理） ​ 2、动态网页（工作原理） ","date":"2024-09-04","objectID":"/posts/text22/:10:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"11、Java Script ​ 运行在客户端的一段程序。 ","date":"2024-09-04","objectID":"/posts/text22/:11:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"12、架构 ​ BS架构：浏览器/服务器 ​ CS架构：客户端（下载APP）/服务器 ","date":"2024-09-04","objectID":"/posts/text22/:12:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"13、网页图形图像处理工具 ​ 网页图形图像处理工具可以设计图像： ​ Fireworks （背景透明 jpg.不支持） ​ PhotoShop （背景透明 gif.动画 支持） ​ CorelDraw （背景透明 png.支持） ​ ps处理图像是使用的位图，生成文件尾缀~.psd ​ 1024 × 768：横纵向像数点 【位图放大、会失真、会模糊】 cd处理图像是使用的矢量图，算法记录图形的轮廓，内部颜色填充。尾缀~.cdr ","date":"2024-09-04","objectID":"/posts/text22/:13:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"14、网页维护 ​ 1、上传网页：ftp文件传输协议 ​ 2、网站管理员：修改文件 ​ 3、服务器管理员：远程桌面 ​ 4、 网站风格布局：位置、疏密、颜色、装饰、线条、排版 ","date":"2024-09-04","objectID":"/posts/text22/:14:0","tags":["html","JavaScript"],"title":"网页设计笔记","uri":"/posts/text22/"},{"categories":null,"content":"路由表 路由表操作 ipconfig route print route delete 0.0.0.0 route delete 10.163.0.0 route delete 10.164.0.0 route delete 10.160.0.0 route delete 10.1.0.0 route add -p 0.0.0.0 mask 0.0.0.0 192.168.9.1 metric 20 route add -p 10.163.0.0 mask 255.255.0.0 192.168.8.1 metric 30 route add -p 10.164.0.0 mask 255.255.0.0 192.168.8.1 metric 30 route add -p 10.160.0.0 mask 255.255.0.0 192.168.8.1 metric 30 route add -p 10.1.0.0 mask 255.255.0.0 192.168.8.1 metric 30 ","date":"2024-09-04","objectID":"/posts/text21/:0:0","tags":["路由"],"title":"路由表","uri":"/posts/text21/"},{"categories":null,"content":"1.变量定义 ES6新增了 let 和 const，分别用来声明变量和常量，应该尽可能使用 let 和 const 来定义变量，而不是 var ","date":"2024-08-21","objectID":"/posts/es6/:1:0","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"1.1 let 关键字 let 用于声明变量，声明的变量只在当前代码块能被访问到 // 外部代码块不能访问到内部代码块定义的变量 if(true) { let a = 1; } console.log(a); // 报错：Uncaught ReferenceError: a is not defined /*-----------------分隔线-----------------*/ // 内部代码块能访问到外部代码块的变量 let arr = [] for(let i = 0; i \u003c 10; i++) { arr.push(i); } console.log(arr.join()); // 打印：0,1,2,3,4,5,6,7,8,9 /*-----------------分隔线-----------------*/ // 注意：在for循环中，循环在一个代码块，循环体在一个代码块 for (let i = 0; i \u003c 3; i++) { let i = 'abc'; console.log(i); } // 打印如下： // abc // abc // abc ","date":"2024-08-21","objectID":"/posts/es6/:1:1","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"1.2 const 关键字 const 声明一个只读的常量 一旦声明，常量的值就不能改变，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值 const foo; // SyntaxError: Missing initializer in const declaration /*-----------------分隔线-----------------*/ const a = 1; a = 2; // 报错：Uncaught TypeError: Assignment to constant variable. /*-----------------分隔线-----------------*/ // 对于对象 const obj = { str: '123'} console.log(obj.str) // 打印：123 obj.str = '456' console.log(obj.str) // 打印：456 obj = {} // 报错：Uncaught TypeError: Assignment to constant variable. // 或者 let newObj = { str: '123' } obj = newObj // 报错：Uncaught TypeError: Assignment to constant variable. ","date":"2024-08-21","objectID":"/posts/es6/:1:2","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"2. 模板字符串 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，即换行和缩进将会被保留，或者在字符串中嵌入变量。 let name = 'Ryan'; let age = 23; let str = ` name: ${name} age: 23` console.log(str) ","date":"2024-08-21","objectID":"/posts/es6/:2:0","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"3. 数组常用方法 这里列举数组的常用方法，并不都是ES6新增的方法 ","date":"2024-08-21","objectID":"/posts/es6/:3:0","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"3.1 forEach 遍历数组，没有返回值，不改变原数组，处理函数可以接收三个参数，分别是当前位置元素item，当前位置下标index，当前遍历的数组 let arr = [1, 2, 3] arr.forEach(function(item) { console.log(item) }) // 打印： //1 //2 //3 ","date":"2024-08-21","objectID":"/posts/es6/:3:1","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"3.2 map 遍历数组，不在源数组上进行操作，返回一个新的数组，处理函数可以接收三个参数，分别是当前位置元素item，当前位置下标index，当前遍历的数组 let arr = [1, 2, 3] let arr1 = arr.map(function(item) { console.log(item) item *= 2 return item }) // 打印： //1 //2 //3 console.log(arr.join()) // 打印：1,2,3 console.log(arr1.join()) //打印：2,4,6 //map一定要返回一个新数组，需要一个新的数组变量来接受 forEach 和 map 的区别 map方法： map它返回一个新数组，原数组的结构不会被改变。 如果需要对原数组进行操作并返回一个新的数组，map是更合适的选择。 map经常用于转换数组中的每个元素。 forEach方法： forEach直接在原数组上进行操作，不返回任何值（或者说返回undefined）。 它没有能力中断循环，也就是说，即使出现错误，forEach中的函数也会继续执行。 如果需要在数组上直接进行修改，并不需要一个新数组，那么可以使用forEach。 ","date":"2024-08-21","objectID":"/posts/es6/:3:2","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"3.3 filter 不在源数组上进行操作，返回一个新的数组，处理函数可以接收三个参数，分别是当前位置元素item，当前位置下标index，当前遍历的数组 let arr = [1, 2, 3, 4] let arr1 = arr.filter(function(item) { return item \u003e 2 }) console.log(arr1.join()) // 打印：3,4 ","date":"2024-08-21","objectID":"/posts/es6/:3:3","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"3.4 includes 返回一个布尔值，表示某个数组是否包含给定的值，该方法的第二个参数表示搜索的起始位置 let arr = [1, 2, 3, 4] console.log(arr.includes(2)) // 打印：true // 从下标为2的位置开始向数组末尾搜索，没找到，返回false console.log(arr.includes(2, 2)) // 打印：false // 如果第二个参数为负数，则表示倒数的位置，从倒数第二个开始搜索，没找到，返回false console.log(arr.includes(2, -2)) // 打印：false // 如果这时它大于数组长度，则会重置为从0开始，倒数第五个，超过数组长度，则从数组开头向数组末尾搜索 console.log(arr.includes(2, -5)) // 打印：true ","date":"2024-08-21","objectID":"/posts/es6/:3:4","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"3.5 find() find()方法在JavaScript中用于在数组中查找满足特定条件的第一个元素。它接受一个回调函数作为参数，该函数返回布尔值来确定元素是否匹配。如果找到匹配项，则返回该元素，否则返回undefined。此方法不会改变原始数组，适用于寻找单个匹配项。 array.find((item,index)=\u003e{ console.log(item,index); }) array.find(callback(element[, index[, array]])[, thisArg]) 参数解释： callback：必需。要在数组中每个元素上执行的函数。 element：必需。当前正在处理的数组元素。 index：可选。正在处理的元素的索引。 array：可选。调用该方法的数组本身。 thisArg：可选。当执行回调函数时使用的 this 值。 find() 方法的第一个参数 callback 是一个函数，用于测试每个元素是否符合条件，接收三个 参数： element：表示当前正在被处理的元素。 index：表示正在被处理的元素的索引。 array：表示当前正在被处理的数组对象。 回调函数应该返回一个布尔值，表示当前元素是否符合我们的条件。如果返回 true，则会停止遍历并返回该元素的值；否则，继续遍历直到遇到符合条件的元素或者整个数组都被遍历完毕。 find() 方法实际应用： **实例 1：**查找数组中的第一个负数。 const arr = [1, 2, -3, 4, -5]; const negativeNum = arr.find(num =\u003e num \u003c 0); console.log(negativeNum); // 输出：-3 **实例 2：**从对象数组中查找符合条件的对象。 const users = [ {id: 1, name: 'Alice'}, {id: 2, name: 'Bob'}, {id: 3, name: 'Charlie'} ]; const user = users.find(u =\u003e u.id === 2); console.log(user); // 输出：{id: 2, name: 'Bob'} **实例 3：**使用 thisArg 参数指定回调函数中的 this 值。 function isEven(num) { return num % 2 === 0; } const nums = [1, 3, 4, 7, 8]; const evenNum = nums.find(isEven, this); console.log(evenNum); // 输出：4 ★注意事项 find() 方法会遍历整个数组，直到找到满足条件的元素或者遍历完整个数组。 如果数组为空，那么返回 undefined。 在回调函数中修改数组本身不是一个好习惯。如果要修改数组，请使用 map() 或者 filter() 方法。 当多个元素符合条件时，find() 方法只会返回第一个符合条件的元素。 find() 方法是 ES6 中新增的方法，在较旧的浏览器中可能不被支持。 ","date":"2024-08-21","objectID":"/posts/es6/:3:5","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"3.6 findIndex() findIndex返回满足条件的第一个元素的索引，而find返回满足条件的元素本身。这两个方法都不会改变原数组，且在找到匹配项后停止遍历剩余元素。 findIndex方法常用来查找数组中满足条件的第一项元素的下标 const arr = [1, 2, 3, 4, 5, 3, 3, 2, 4, 5 ] // 可以这么写 const index = arr.findIndex(item =\u003e { return item \u003e 2 }) console.log(index) // 2 //------------------------------------------ // 也可以这么写 const index = arr.findIndex(item =\u003e item \u003e 2) console.log(index) // 2 返回的index是满足条件的第一项元素的下标，这要注意的是findIndex会给数组中的每一项执行一个函数来判断是否满足表达式，如果满足条件后，剩下的元素则不再执行 ","date":"2024-08-21","objectID":"/posts/es6/:3:6","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"3.7 indexOf() indexOf方法可返回某个指定的字符串值在字符串中首次出现的位置。 如果没有找到匹配的字符串则返回 -1 注意： indexOf() 方法区分大小写。 let str = 'orange'; str.indexOf('o'); //0 str.indexOf('n'); //3 str.indexOf('c'); //-1 //这里 0 和 3 分别是 o 和 n 在字符串中出现的位置。起始下标是 0。而 -1 代表未匹配 **注意：**indexOf 会做简单的类型转换 let numStr = '2016'; numStr.indexOf('2'); //0 numStr.indexOf(2); //0 //把会先把数字转换成字符串 '2' 然后再执行。 **注意：**number 类型有没有 indexOf 方法 let num = 2016; num.indexOf(2); //Uncaught TypeError: num.indexOf is not a function 对 number 类型使用 indexOf 方法，需要先转换成字符串 //二逼青年的写法 num = '2016'; num.indexOf(2); //0 //普通青年的写法 num.toString().indexOf(2); //0 //文艺青年的写法 ('' + num).indexOf(2); //0 //这里注意，第一种写死的写法在num为变量的时候会显得很蠢。第二种比较常用，第三种则比较精明 **注意：**Array 类型 indexOf() 方法在数组中搜索指定项目，并返回其位置。 搜索将从指定位置开始，如果未指定开始位置，则从头开始，并在数组末尾结束搜索。 如果未找到该项目，则 indexOf() 返回 -1。 如果该项目出现多次，则 indexOf() 方法返回第一次出现的位置。 注释：第一项的位置为 0，第二项的位置为 1，依此类推。 提示：如果您想从尾到头搜索，请使用 lastIndexOf() 方法。 array.indexOf(item, start) 参数值 参数 描述 item 必需。要搜索的项目。 start 可选。从哪里开始搜索。负值给定的位置将从结尾计数，然后搜索到最后。 示例 let arr = ['orange', '2016', '2016']; arr.indexOf('orange'); //0 arr.indexOf('o'); //-1 arr.indexOf('2016'); //1 arr.indexOf(2016); //-1 find 与 findIndex find返回元素，findIndex返回索引 找不到时find返回undefined，findlIndex返回-1 findIndex 与 indexOf findlndex比indexOf更强大一些，可以查找 对象数组， indexOf只能查找 数组 中指定时值，不过indexOf可以指定开始查找位置的索引 ","date":"2024-08-21","objectID":"/posts/es6/:3:7","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"4. 对象常用方法 ","date":"2024-08-21","objectID":"/posts/es6/:4:0","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"4.1 Object.assign() 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target），第一层属性是深拷贝，第二层属性是浅拷贝 const target1 = { a: 1 }; const source1 = { b: 2 }; const source2 = { c: 3 }; Object.assign(target1, source1, source2); console.log(target1) // 打印：{a:1, b:2, c:3} /*-----------------分隔线-----------------*/ // 第二层属性浅拷贝 const target2 = { a: 1 }; const source3 = { b: { name: 'test' }, c: 3 }; Object.assign(target2, source3); source3.b.name = 'nick' console.log(target2) // 打印：{a:1, b:{ name: 'nick' }, c:3} ","date":"2024-08-21","objectID":"/posts/es6/:4:1","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"5. 解构赋值 解构赋值 是一种特殊的语法，它使我们可以将数组或对象“拆包”为到一系列变量中，因为有时候使用变量更加方便 解构操作对那些具有很多参数和默认值等的函数也很奏效 “解构”并不意味着“破坏” 这种语法叫做解构赋值，因为它通过将结构中的各元素复制到变量中来达到“解构”的目的，但数组本身是没有被修改的 ","date":"2024-08-21","objectID":"/posts/es6/:5:0","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"5.1 数组解构赋值 基础 // 我们有一个存放了名字和姓氏的数组 let arr = [\"Ilya\", \"Kantor\"] // 解构赋值 // sets firstName = arr[0] // and surname = arr[1] let [firstName, surname] = arr; console.log(firstName); // Ilya console.log(surname); // Kantor /*-----------------分隔线-----------------*/ // 不需要第二个元素 let [firstName, , title] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"]; console.log( title ); // Consul /*-----------------分隔线-----------------*/ // 等号右侧可以是任何可迭代对象 let [a, b, c] = \"abc\"; // [\"a\", \"b\", \"c\"] let [one, two, three] = new Set([1, 2, 3]); /*-----------------分隔线-----------------*/ // 赋值给等号左侧的任何内容 let user = {}; [user.name, user.surname] = \"Ilya Kantor\".split(' '); console.log(user.name); // Ilya 我们可以将 Object.entries() 方法与解构语法一同使用，来遍历一个对象的”键—值“对： let user = { name: \"John\", age: 30 }; // 循环遍历键—值对 for (let [key, value] of Object.entries(user)) { console.log(`${key}: ${value}`); // name:John, then age:30 } ……对于 map 对象也类似： let user = new Map(); user.set(\"name\", \"John\"); user.set(\"age\", \"30\"); for (let [key, value] of user) { console.log(`${key}: ${value}`); // name:John, then age:30 } 默认值 // 默认值 let [name = \"Guest\", surname = \"Anonymous\"] = [\"Julius\"]; console.log(name); // Julius（来自数组的值） console.log(surname); // Anonymous（默认值被使用了） 剩余的 ... let [name1, name2, ...rest] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"]; console.log(name1); // Julius console.log(name2); // Caesar // 请注意，`rest` 的类型是数组 console.log(rest[0]); // Consul console.log(rest[1]); // of the Roman Republic console.log(rest.length); // 2 5.1.1关于（…）运算符 ","date":"2024-08-21","objectID":"/posts/es6/:5:1","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"5.2 对象解构赋值 基础 let options = { title: \"Menu\", width: 100, height: 200 }; let {title, width, height} = options; console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 /*-----------------分隔线-----------------*/ // 仅提取 title 作为变量 let { title } = options; console.log(title); // Menu /*-----------------分隔线-----------------*/ // 在options变量的基础上，改变 let {...} 中元素的顺序 let {height, width, title} = { title: \"Menu\", height: 200, width: 100 } console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 /*-----------------分隔线-----------------*/ // 在options变量的基础上，改变映射关系，冒号表示“什么值：赋值给谁” let {width: w, height: h, title} = options; // width -\u003e w // height -\u003e h // title -\u003e title console.log(title); // Menu console.log(w); // 100 console.log(h); // 200 默认值 let options = { title: \"Menu\" }; let {width = 100, height = 200, title} = options; console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 /*-----------------分隔线-----------------*/ // 改变映射关系并设置默认值 let {width: w = 100, height: h = 200, title} = options; console.log(title); // Menu console.log(w); // 100 console.log(h); // 200 剩余的 ... let options = { title: \"Menu\", height: 200, width: 100 }; // title = 名为 title 的属性 // rest = 存有剩余属性的对象 let {title, ...rest} = options; // 现在 title=\"Menu\", rest={height: 200, width: 100} console.log(rest.height); // 200 console.log(rest.width); // 100 ","date":"2024-08-21","objectID":"/posts/es6/:5:2","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"5.3 嵌套解构 let options = { size: { width: 100, height: 200 }, items: [\"Cake\", \"Donut\"], extra: true }; // 为了清晰起见，解构赋值语句被写成多行的形式 let { size: { // 把 size 赋值到这里 width, height }, items: [item1, item2], // 把 items 赋值到这里 title = \"Menu\" // 在对象中不存在（使用默认值） } = options; console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 console.log(item1); // Cake console.log(item2); // Donut ","date":"2024-08-21","objectID":"/posts/es6/:5:3","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"5.4 函数参数 let options = { title: \"My menu\", items: [\"Item1\", \"Item2\"] }; // 函数把对象展开成变量 function showMenu({ title = \"Untitled\", width = 200, height = 100, items = [] }) { // title, items – 提取于 options， // width, height – 使用默认值 console.log( `${title} ${width} ${height}` ); // My Menu 200 100 console.log( items ); // Item1, Item2 } showMenu(options); ","date":"2024-08-21","objectID":"/posts/es6/:5:4","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"6. ... 运算符 ","date":"2024-08-21","objectID":"/posts/es6/:6:0","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"6.1 Rest 参数 注意 Rest 参数必须放到参数列表的末尾 function sumAll(...args) { // 数字名为 args let sum = 0; for (let arg of args) sum += arg; return sum; } console.log( sumAll(1) ); // 1 console.log( sumAll(1, 2) ); // 3 console.log( sumAll(1, 2, 3) ); // 6 function showName(firstName, lastName, ...titles) { console.log( `${firstName} ${lastName}` ); // Julius Caesar // 剩余的参数被放入 titles 数组中 // i.e. titles = [\"Consul\", \"Imperator\"] console.log( titles[0] ); // Consul console.log( titles[1] ); // Imperator console.log( titles.length ); // 2 } showName(\"Julius\", \"Caesar\", \"Consul\", \"Imperator\"); ","date":"2024-08-21","objectID":"/posts/es6/:6:1","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"6.2 Spread 语法 基础 let arr = [3, 5, 1]; console.log( Math.max(...arr) ); // 5（spread 语法把数组转换为参数列表） /*-----------------分隔线-----------------*/ let arr1 = [1, -2, 3, 4]; let arr2 = [8, 3, -8, 1]; console.log( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25 /*-----------------分隔线-----------------*/ let arr = [3, 5, 1]; let arr2 = [8, 9, 15]; let merged = [0, ...arr, 2, ...arr2]; console.log(merged); // 0,3,5,1,2,8,9,15（0，然后是 arr，然后是 2，然后是arr2） 获取一个对象或数组的副本 let arr = [1, 2, 3]; // 将数组 spread 到参数列表中，然后将结果放到一个新数组 let arrCopy = [...arr]; // 两个数组中的内容相同吗？ console.log(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true // 两个数组相等吗？ console.log(arr === arrCopy); // false（它们的引用是不同的） // 修改我们初始的数组不会修改副本： arr.push(4); console.log(arr); // 1, 2, 3, 4 console.log(arrCopy); // 1, 2, 3 /*-----------------分隔线-----------------*/ // 同样适用于对象 let obj = { a: 1, b: 2, c: 3 }; let objCopy = { ...obj }; // 将对象 spread 到参数列表中，然后将结果返回到一个新对象 // 两个对象中的内容相同吗？ console.log(JSON.stringify(obj) === JSON.stringify(objCopy)); // true // 两个对象相等吗？ console.log(obj === objCopy); // false (not same reference) // 修改我们初始的对象不会修改副本： obj.d = 4; console.log(JSON.stringify(obj)); // {\"a\":1,\"b\":2,\"c\":3,\"d\":4} console.log(JSON.stringify(objCopy)); // {\"a\":1,\"b\":2,\"c\":3} ","date":"2024-08-21","objectID":"/posts/es6/:6:2","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"6.3 …语法 1.1 合并数组 //es5写法，使用concat let arr1 = [1,2]; let arr2 = [5,6]; let newArr = [20]; newArr = newArr.concat(arr1).concat(arr2); //es6写法 let arr1 = [1,2]; let arr2 = [5,6]; let newArr = [20]; newArr = [20,...arr1,...arr2]; 1.2合并对象 const baseSquirtle = { name: 'Squirtle', type: 'Water' }; const squirtleDetails = { species: 'Tiny Turtle Pokemon', evolution: 'Wartortle' }; const squirtle = { ...baseSquirtle, ...squirtleDetails }; console.log(squirtle); //Result: { name: 'Squirtle', type: 'Water', species: 'Tiny Turtle Pokemon', evolution: 'Wartortle' } 2.1 为数组新增成员 const pokemon = ['小红', '小李']; const charmander = '大大'; const pokedex = [...pokemon, charmander]; console.log(pokedex); //Result: [ '小红', '小李', '大大' ] 2.2 为对象新增属性 const aa= { name: '小红', type: '123' }; const obj= { ...aa, unit: '米', id: '1' }; console.log(obj); //Result: { name: '小红', type: '123', unit: '米', id: '1' } 将一个数组添加到另一个数组的尾部： let arr1 = [0, 1, 2]; let arr2 = [3, 4, 5]; //es5写法 Array.prototype.push.apply(arr1, arr2); //es6写法 let arr1 = [0, 1, 2]; let arr2 = [3, 4, 5]; arr1.push(...arr2); 将字符串转换成数组： //es5写法需要split和join的操作 //... //es6写法 [...'hello'] // [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 解构赋值 例1： let obj = {name:\"小明\",age:18,hobby:\"小红\"}; let newobj = { ...obj } console.log(newobj)//和obj一样 例2： let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; console.log(x); // 1 console.log(y); // 2 console.log(z); // { a: 3, b: 4 } 可以对数组进行浅克 let arr = [1,2,[1,2],3]; let arr2 = [...arr]; arr2.push(1); console.log(arr);//[1,2,[1,2],3] console.log(arr2);//[1,2,[1,2],3,1] 进阶: 复制具有嵌套结构的数据/对象 先看一个例子： const pokemon = { name: 'Squirtle', type: 'Water', abilities: ['Torrent', 'Rain Dish'] }; const squirtleClone = { ...pokemon }; pokemon.name = 'Charmander'; pokemon.abilities.push('Surf'); console.log(squirtleClone); //Result: { name: 'Squirtle', type: 'Water', abilities: [ 'Torrent', 'Rain Dish', 'Surf' ] } 当我们修改原对象的name 属性时，我们的克隆对象的 name 属性没有受影响， 这是符合我们预期的。但是当修改原对象的abilities 属性时，我们的克隆对象也被修改了。 原因: 因为复制过来的abilities 是一个引用类型， 原数据改了， 用到他的地方也会跟着改 解决办法：const squirtleClone = { …pokemon, abilities: […pokemon.abilities] }; const pokemon = { name: 'Squirtle', type: 'Water', abilities: ['Torrent', 'Rain Dish'] }; const squirtleClone = { ...pokemon, abilities: [...pokemon.abilities] }; pokemon.name = 'Charmander'; pokemon.abilities.push('Surf'); console.log(squirtleClone); //Result: { name: 'Squirtle', type: 'Water', abilities: [ 'Torrent', 'Rain Dish' ] } 增加条件属性 方式一： const pokemon = { name: 'Squirtle', type: 'Water' }; const abilities = ['Torrent', 'Rain dish']; const fullPokemon = abilities ? { ...pokemon, abilities } : pokemon; console.log(fullPokemon); 方式二：简化一下 const fullPokemon = abilities \u0026\u0026 { ...pokemon, abilities }; 短路 const pokemon = { name: 'Squirtle', type: 'Water' }; const abilities = ['Torrent', 'Rain dish']; const fullPokemon = { ...pokemon, ...(abilities \u0026\u0026 { abilities }) }; console.log(fullPokemon); 如果 abilities 为 true， 就相当于是 const fullPokemon = { ...pokemon, ...{ abilities } } ","date":"2024-08-21","objectID":"/posts/es6/:6:3","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"7. 箭头函数 创建函数还有另外一种非常简单的语法，并且这种方法通常比函数表达式更好，它看起来像这样： ","date":"2024-08-21","objectID":"/posts/es6/:7:0","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"7.1 基础 // 这里创建了一个函数 func，它接受参数 arg1..argN，然后使用参数对右侧的 expression 求值并返回其结果 let func = (arg1, arg2, ...argN) =\u003e expression /*-----------------分隔线-----------------*/ // 具体例子 let sum = (a, b) =\u003e a + b; /* 这个箭头函数是下面这个函数的更短的版本： let sum = function(a, b) { return a + b; }; */ console.log( sum(1, 2) ); // 3 ","date":"2024-08-21","objectID":"/posts/es6/:7:1","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"7.2 多行箭头函数 let sum = (a, b) =\u003e { // 花括号表示开始一个多行函数 let result = a + b; return result; // 如果我们使用了花括号，那么我们需要一个显式的 “return” }; console.log( sum(1, 2) ); // 3 ","date":"2024-08-21","objectID":"/posts/es6/:7:2","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"7.3 箭头函数没有 this 箭头函数没有 this。如果访问 this，则会从外部获取，例如： let group = { title: \"Our Group\", students: [\"John\", \"Pete\", \"Alice\"], showList1() { this.students.forEach( student =\u003e console.log(this.title + ': ' + student) ); } showList2() { this.students.forEach(function(student) { // Error: Cannot read property 'title' of undefined console.log(this.title + ': ' + student) }); } }; group.showList1(); // 打印： // Our Group: John // Our Group: Pete // Our Group: Alice group.showList2(); // 报错：TypeError: Cannot read property 'title' of undefined 报错是因为 forEach 运行它里面的这个函数，但是这个函数的 this 为默认值 this=undefined，因此就出现了尝试访问 undefined.title 的情况。 但箭头函数就没事，因为它们没有 this。 注意 不能对箭头函数进行 new 操作 不具有 this 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor），即不能用 new 调用它们 ","date":"2024-08-21","objectID":"/posts/es6/:7:3","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"8. Promise Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。 所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise 对象有以下两个特点： 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 ","date":"2024-08-21","objectID":"/posts/es6/:8:0","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"8.1 用法 ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例 resolve let promise = new Promise((resolve, reject) =\u003e { // 当 promise 被构造完成时，自动执行此函数 // 1 秒后发出工作已经被完成的信号，并带有结果 \"done\" setTimeout(() =\u003e resolve(\"done\"), 1000); }); promise .then(res =\u003e console.log(res)) // 执行条件：promise内的任务处理完成，resolve被执行 .catch(error =\u003e console.log(error)) // 执行条件：reject被执行或者抛出异常 .finally(() =\u003e console.log('this promist done!')) // 执行条件：不管promise内的任务为什么状态都会执行 // 打印： // done // this promist done! reject let promise1 = new Promise(function(resolve, reject) { // 当 promise 被构造完成时，自动执行此函数 // 1 秒后发出工作执行失败的信号，并带有结果 \"failed\" setTimeout(() =\u003e reject(\"failed\"), 1000); }); promise1 .then(res =\u003e console.log(res)) // 执行条件：promise内的任务处理完成，resolve被执行 .catch(error =\u003e console.log(error)) // 执行条件：reject被执行或者抛出异常 .finally(() =\u003e console.log('this promist done!')) // 执行条件：不管promise内的任务为什么状态都会执行 // 打印： // failed // this promist done! ","date":"2024-08-21","objectID":"/posts/es6/:8:1","tags":["ES6"],"title":"ES6基础","uri":"/posts/es6/"},{"categories":null,"content":"Vue2.0全套教程 本章节记录vue2的所有知识点 记录时间是20240821 流程顺序： 1.vue基础 2.vue-cli 脚手架-专门用于工程开发 3.vue-router 4.vuex 5.element-ui：饿了么团队，做UI组件库的 6.vue3 ","date":"2024-08-21","objectID":"/posts/vue2/:0:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"vue简介： vue是一套用于构建用户界面的渐进式javaScript框架 vue可以自底向上逐层的应用 简单应用：只需要一个轻量小巧的核心库 复杂应用：可以引入各式各样的vue插件 vue2.0发布于2016年10月1日，vue3.0发布于2020年9月18日 ","date":"2024-08-21","objectID":"/posts/vue2/:1:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"vue的特点： 1组件化 1.采用组件化模式，提高代码复用率、且让代码更好维护 2声明式 2.声明式编码，让编码人员无需直接操作DOM，提高开发效率 说明： 当有一个需求如下，需要将数据persons，放入容器list中： //数据persons [ {id:'001',name:'张三',age:18}, {id:'002',name:'李四',age:19}, {id:'003',name:'王五',age:20} ] //list \u003cul id=\"list\" \u003e\u003c/ul\u003e 效果为： 命令式编码实现方式： 原生javaScript写法 //准备html字符串 let htmlStr = '' //遍历数据拼接html字符串 persons.forEach( p =\u003e{ htmlStr += `\u003cli\u003e${p.id} - ${p.name} - ${p.age}\u003c/li\u003e` }); //获取list元素 let list = document.getElementById('list') //修改内容(亲自操作Dom) list.innerHTML = htmlStr 声明式编码实现方式： \u003cul id=\"list\" \u003e \u003cli v-for=\"p in persons \"\u003e {{p.id}} - {{p.name}} - {{p.age}} \u003c/li\u003e \u003c/ul\u003e 3虚拟dom 3.使用虚拟DOM+优秀的Diff算法，尽量复用DOM节点 diff算法： 新生成的虚拟dom会和之前生成的虚拟dom比较，这个比较算法称为diff算法。 当新的虚拟dom中，存在与旧dom中相同的属性和内容值时， vue就直接将旧的真实dom直接拿到页面渲染出来，再处理不同的部分 4.原生js 4.学习vue之前需要掌握的javaScript基础知识 ES6语法规范：结构赋值、模板字符串、箭头函数等。ES6基础-久远银海内部链接 ES6模块化：默认暴露、分别暴露、统一暴露、import、isport等 包管理器：npm、yram、cnpm 原型、原型链： 数组常用方法：过滤一个数组、加工一个数组、筛选最值 axios： promise：异步请求 ","date":"2024-08-21","objectID":"/posts/vue2/:1:1","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"vue官网使用指南 地址：vue官网操作手册 ","date":"2024-08-21","objectID":"/posts/vue2/:2:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"搭建vue开发环境 在没有脚手架的情况下，最原始的使用vue框架，就是在.html 文件中，引入vue.js包 \u003c!-- 开发环境版本，包含了有帮助的命令行警告 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"\u003e\u003c/script\u003e 或者 \u003c!-- 生产环境版本，优化了尺寸和速度 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2\"\u003e\u003c/script\u003e 在vue2的官方文档中，解释了两种引入vue的方式 ","date":"2024-08-21","objectID":"/posts/vue2/:3:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"1.script直接引入 首先先看第一种安装vue的方式： CDN：阿里云CND操作文档 我们在写script的时候，里面有一个属性，叫src，可以指定资源的位置 如果把src写成：\"./xxx\"的形式，为引入一个本地文件。如果写成\"https\"的形式，一般为了加速，会在其中加入一个CDN的标识 CDN 内容分发网络（Content Delivery Network，CDN）是建立并覆盖在承载网上，由不同区域的服务器组成的分布式网络。将源站资源缓存到全国各地的边缘服务器，供用户就近获取，降低源站压力。 官网两个vue版本，点击后均会进行下载，但下载的文件有些不同 为方便演示，将两个版本均下载在桌面，并新建一个文件夹取名为vue_basic，并用vscode打开 将引入写入html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e初识Vue\u003c/title\u003e \u003c!-- 引入vue --\u003e \u003cscript type=\"text/javascript\" src=\"../js/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-08-21","objectID":"/posts/vue2/:3:1","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"2.直接引入产生的控制台提示 打开写好的html页面，在控制台会出现两个小提示 提示解析： Download the Vue Devtools extension for a better development experinence: //表示：请你下载vue的开发者工具，到达一个更好的开发体验 You are running Vue in development mode. //表示：你正在运行一个开发者模版的vue. Make sure to turn on production mode when deploying for production. //请确认你的项目不在生产时使用 [此句话意思表明，你引入的是vue.js其中带有很多提示和警告，包比较大，不适合上线项目使用] 2.1 解决 下载vue开发者工具 的问题 2.1.1 国外网络可以正常访问谷歌商城： 正常能打开gitHub，点击官网的下载链接过去，选择谷歌浏览器选项 进入谷歌网上应用商店，点击添加，完成 2.1.2国内无法正常访问谷歌商城： Vue开发者工具扩展链接： 【下载开发者工具】： https://pan.baidu.com/s/1MtYvMPew4lb14piIrs9x6w 提取码：6666 【安装开发者工具】： 一、Chrome浏览器安装方式： ①：点击右上角三个点 ②：点击更多工具 ③：点击扩展程序 ④：点击右上角的开发者模式，将他启用 ⑤：将下载的Vue.crx文件直接拖动到浏览器窗口即可 ⑥：点到扩展的详细信息界面，再开启【允许访问文件URL】选项再试试看 二：Edge浏览器安装方式 ①：点击浏览器右上角的三个点 ②：点击扩展 ③：点击左下角的开发人员模式，将他启用 ④：将Vue.crx文件拖动到浏览器即可 2.2 解决 vue.js不建议在上线项目中使用的提示 Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列 property(属性) 首先验证，Vue.config 是否存在： 这里的属性，是对vue的全局配置。一次修改，到处都可以使用。 此处的：productionTip: true 小提示默认为true，是默认开启状态 代码的body中键入下方代码，可以对提示进行关闭： \u003cbody\u003e \u003c!--关闭生产提示--\u003e \u003cscript type=\"text/javascript\"\u003eVue.config.productionTip = false\u003c/script\u003e \u003c/body\u003e 【注意：上方代码如果失效，则进入vue.js文件，直接对productionTip属性进行修改为false】 开端开发编辑工具vscode下载地址：开端开发编辑工具vscode下载地址 ","date":"2024-08-21","objectID":"/posts/vue2/:3:2","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"Hello小案例 ","date":"2024-08-21","objectID":"/posts/vue2/:4:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"html的基础写法 hello代码示例 【注意：此段代码是html的基础写法，并没有用到vue】 \u003cbody\u003e \u003c!-- 准备一个容器 --\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003c/div\u003e \u003c/body\u003e ","date":"2024-08-21","objectID":"/posts/vue2/:4:1","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"Live Server 插件运行 右键打开页面，控制台错误如下： favicon.ico - 指网站的页签图标 打开控制台的Network选项卡，强制刷新一下[ 按住shift 点击刷新]，可以看见请求了本地5500服务器访问该图标 关于本地5500服务器的解释说明： 在vscode中，右键，使用Live Server 插件打开的页面：Live Server会自动先帮你打开当前选择的这个页面，并在你的电脑的5500的端口上开了一台小型的内置服务器，并且进行了“把你所有工程的文件和文件夹，作为这个服务器的根资源去使用”的一个操作。 验证内置5500端口服务器，可以地址栏直接访问127.0.0.1:5500。显示的一定是当前工程下的所有文件夹。 解决图标访问404的问题，只需要在根目录中放置一个叫favicon.ico的图片文件，页面刷新即可 live server 插件是一个具有实时加载功能的小型服务器，它的作用： 模拟服务器的方式打开页面 代码改动后,会自动刷新页面 vsCode中装Live Server插件。 ","date":"2024-08-21","objectID":"/posts/vue2/:4:2","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"vue的写法演示 使用vue进行hello的显示 理解：引入的vue相当于外部引入的一个函数。要使用vue函数，需要new Vue \u003c!-- 准备一个容器 --\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e //创建Vue实例 /* * 注意Vue()中只传一个参数，这个参数是一个配置对象{} * 配置对象中，都以 key : value 的形式书写 * 配置对象中，key的名称不得更改，value的值必须符合key的数据类型 */ const x = new Vue({ //vue的第一个key是el，el是element元素的简写。 //键值对象类似于css中的id选择器 //el用于指定当前Vue实例为哪个容器，值通常为css选择器字符串。 el:'#root' //还有一种写法，一般不用，但是可以这样写 //指 人为找到这个元素，再给他配置到el里去 el:document.getElementById('root') }) \u003c/script\u003e \u003c!-- 如果用class不用id --\u003e \u003cdiv class=\"root\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const x = new Vue({ //el就写成css中类选择器的写法 el:'.root' }) \u003c/script\u003e 利用插值语法 \u003c!-- 如果用class不用id --\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello,{{name}}\u003c/h1\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const x = new Vue({ el:'#root', data:{ //data中用于存储数据，数据供el所指定的容器去使用 name:'wangty' } }) \u003c/script\u003e 注意：data中的数据需要在指定的容器中使用，没在容器中使用data内数据并不会生效 三个注意事项： 1、想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；目前这里为：el、data 2、root容器里的代码依然符合html规范，只不过混入一些特殊的Vue语法； 3、root容器里的代码被称为【Vue模版】 对于vue模版的解释： 我们写的为一个Vue模板，经过解析，形成一个全新的正常的html片段块，然后替换掉模板的位置，显示在页面上 容器的作用： 1、为Vue提供模板 2、把Vue解析后的html片段，指定位置放置 ","date":"2024-08-21","objectID":"/posts/vue2/:4:3","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"分析Hello案例 ","date":"2024-08-21","objectID":"/posts/vue2/:5:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"一对一关系 演示说明：容器和实例是一对一，一一对应关系 有两个同名的容器的情况： 首先，能运行成功，且控制台不报错 说明，一个Vue实例不能同时接管两个容器 有两个Vue实例指向同一个容器的情况： 首先，第一个Vue内容显示正常，第二个内容不显示，且控制台报错 说明，一个容器只能被一个Vue实例接管和解析 ","date":"2024-08-21","objectID":"/posts/vue2/:5:1","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"{{ }} 中为js表达式 注意：{{ }} 中可以写的内容，不一定是Vue实例中声明过的。只要是js里的表达式，Vue都是可以解析的 注意区分:js表达式 和js代码(语句) ​ 1.表达式: 一个表达式会生成一个值，可以放在任何一个需要值的地方: ​ (1).a ​ (2).a+b ​ (3).demo(1) ​ (4).x === y ? ‘a’ : ‘b’ ​ 2.js代码(语句) ​ (1).if( ){ } ​ (2).for( ){ } ","date":"2024-08-21","objectID":"/posts/vue2/:5:2","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"Vue的开发者工具 打开控制台右侧Vue选项卡 Root这里代表唯一的那一个Vue实例，点击这里的Root，能看的data里的所有数据 点击配置对象旁边的编辑按钮，可以对其值进行修改 \u003c!-- 前端小写内容全部转换为大写的方法使用 .toUpperCase() --\u003e \u003ch1\u003e{{name.toUpperCase()}} \u003c/h1\u003e //name:'wangty' // WANGTY ","date":"2024-08-21","objectID":"/posts/vue2/:5:3","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"生产包和开发包 关于 vue.js 和vue.min.js 在new Vue实例对象时候的区别 当不写new的时候，vue.js： 当不写new的时候，vue.min.js并不报这个warning ","date":"2024-08-21","objectID":"/posts/vue2/:5:4","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"模板语法 ","date":"2024-08-21","objectID":"/posts/vue2/:6:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"插值语法 把指定的值，放到指定的位置，使用方法，见上述hello案例 【注意：插值语法多用于指定标签体内容。即，两标签之间的内容。不可以用于标签属性和属性值】 ","date":"2024-08-21","objectID":"/posts/vue2/:6:1","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"指令语法 【注：指令语法小结示例里包含了很多后面的东西，建议先跳过看完后面再看这一节比较好理解】 普通html，点击跳转地址写法 \u003ca href=\"https://www.baidu.com\"\u003e点我去百度\u003c/a\u003e v-bind vue写法 \u003cdiv id=\"root\"\u003e \u003ch1\u003e指令语法\u003c/h1\u003e \u003ca :href=\"url\"\u003e点我去百度\u003c/a\u003e \u003c!--等价于\u003ca v-bind:href=\"url\"\u003e点我去百度\u003c/a\u003e --\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root' , data:{ url:'https://www.baidu.com' //注意，这里如果写两个一模一样的属性名，控制台不会报错 //Vue会默认读取第二个属性名的内容，这里就会默认跳转淘宝 //url:'https://www.taobao.com' } }) \u003c/script\u003e 注意：这里的 “:href\"中的冒号，是v-bind的简写。我们把类似于v-bind这样的语法称为，指令语法。 [!NOTE] 在html标签中，如果标签中的属性没有使用指定语法，则就是普通的属性和属性值 如果使用了指定语法，Vue就会把属性值引号内的东西，取出来当做表达式进行执行 v-model 数据绑定 \u003cdiv id=\"root\"\u003e 单项数据绑定：\u003cinput type=\"text\" v-bind:value=\"name\"\u003e \u003cbr/\u003e 双向数据绑定：\u003cinput type=\"text\" v-model:value=\"name2\" \u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root' , data:{ name:'wangty', name2:'wangty', } }) \u003c/script\u003e 页面效果： Vue中有2种数据绑定的方式: 1.单向绑定(v-bind):数据只能从data流向页面, 2.双向绑定(v-model):数据不仅能从data流向页面，还可以从页面流向data。 只适用于表单元素 注意：不是任意的所有的地方都能使用v-model来进行双向绑定 例： \u003cdiv id=\"root\"\u003e \u003ch3 v-bind:x=\"name\"\u003ewangty\u003c/h3\u003e \u003ch3 v-model:x=\"name\"\u003ewangty\u003c/h3\u003e \u003c!-- 该行代码是有问题的 --\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root' , data:{ name:'wangty', } }) \u003c/script\u003e 上面的几行代码，首先在页面查看效果如下： 说明：v-model只能应用在表单元素上（输入类元素，有value值的元素）。 简写形式 和v-bind一样，v-model有他的简写形式 \u003c!-- v-bind简写 --\u003e \u003cinput type=\"text\" v-bind:value=\"name\"\u003e 等价于 =====\u003e \u003cinput type=\"text\" :value=\"name\"\u003e ---------------------------------------------------------------------- \u003c!-- v-model简写 --\u003e \u003cinput type=\"text\" v-model:value=\"name2\" \u003e 等价于 =====\u003e \u003cinput type=\"text\" v-model=\"name2\" \u003e v-on 事件处理 事件的基本使用: 1.使用v-on:xxx或@xxx定事件，其中xxx是事件名; ​ 2.事件的回调需要配置在methods对象中，最终会在vm上; ​ 3.methods中配置的的数，不要用箭头函数。否则this就不是vm了; ​ 4.methods中配置的的数，都是被Vue所管理的函数，this的指向是vm或组件实例对象 ​ 5.@click=“demo\"和 @click=“demo($event)”效果一致，但后者可以传参; \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello,{{name}} \u003c/h1\u003e \u003c!-- 简写形式 v-on:click =====\u003e 等价于 @click --\u003e \u003cbutton v-on:click=\"showInfo\"\u003e点击实现提示信息\u003c/button\u003e \u003cbutton @click=\"showInfo\"\u003e点击实现提示信息\u003c/button\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e //创建Vue实例 new Vue({ el:'#root', data(){ return{} }, //注意showInfo需要放在methods里。 //这儿有个问题：可不可以放进data里呢？ 是可以的。 //能够正常运行，且控制台不报错。但是会被Vue执行数据代理，加重Vue的负荷。 methods:{ //注意这里的showInfo方法也会存储在vm身上，打印vm时可以看见 showInfo(a,b,c,d){ //alert(\"提示\"); console.log(a,b,c,d); } } }) \u003c/script\u003e 方法写在data里的情况，会使得vm对此方法进行数据代理。详解请看【数据代理】小结。 所以我们一般写点击事件只传一个参数，格式写为 showInfo(event){ console.log(event); //获取点击时间的触发目标，一般指按钮对象 //使用event.target console.log(event.target.innerText); //按钮名称 //这里的this也是Vue实例 //这里showInfo如果写成箭头函数，则this指向会往外找到全局window console.log(this); } 注意，点击事件处理本来也是可以传入参的，及点击事件方法名后面带了()，但是此种写法搞丢了event点击事件的对象入参： \u003cbutton @click=\"showInfo(入参id)\"\u003e点击实现提示信息\u003c/button\u003e showInfo(id){ console.log(id); //结果为：入参id } 若要使有()时，也能使用event点击事件对象，Vue中使用了$event来进行占位 \u003cbutton @click=\"showInfo(id,$event)\"\u003e点击实现提示信息\u003c/button\u003e showInfo(id,event){ console.log(id); //结果为：入参id console.log(event); //结果为：点击事件对象 } 事件修饰符 \u003c!-- 点击后，a标签会默认跳转百度页面。 --\u003e \u003c!-- 如果有需求，想要阻止默认跳转的操作 --\u003e \u003ca href=\"http://baidu.com\" @click=\"showInfo\"\u003e点击\u003c/a\u003e \u003c!-- Vue提供了事假修饰符.prevent --\u003e \u003c!-- \u003ca href=\"http://baidu.com\" @click.prevent=\"showInfo\"\u003e点击\u003c/a\u003e --\u003e showInfo(event){ //或者点击事件event对象有一个方法，可以阻止标签默认调用事件 event.preventDefault() } js里的事件流分为捕获阶段和冒泡阶段—— Vue中的事件修饰符： ​ 1、prevent：阻止默认事件（常用） ​ 2、stop：阻止事件冒泡（常用） ​ 3、once：事件只触发一次（常用） ​ 4、capture：使用事件的捕获模式 ​ 5、self：只有event.target是当前操作的元素时才触发事件 ​ 6、passive：事件的默认行为立即执行，无需等待事件回调执行完毕（多用于滚动条事件：@wheel鼠标滚轮滚动 / @scroll 滚动条滚动 - 这个不会等待事件回调执行完毕） 键盘事件 //两个键盘触发事件 @keydown //按下该按钮，不用抬起来，就触发事件 @keyup //按下该按钮，抬起来后，才触发事件 按下回车提示输入 \u003c!-- 原生js写法 --\u003e \u003cinput type=\"text\" @keyup = \"showInfo\"\u003e showInfo(e){ if(e.keyCode !== 13) return //回车的按键编码为13 console.log(e.target.value); } \u003c!--------------------------------------------------------------------\u003e \u003c!-- vue事件别名写法 --\u003e \u003cinput type=\"text\" @keyup.enter = \"showInfo\"\u003e showInfo(e){ console.log(e.target.value); } 1.Vue给常用的按键都起了别名： ​ 回车 =\u003e enter 删除 =\u003e delete （delete键和backspace退格键） ​ 退出 =\u003e esc 空格 =\u003e space ​ 上 =\u003e up 换行 =\u003e tab（特殊：必须配合keydown使用） ​ 下 =\u003e down 左 =\u003e left ​ 右 =\u003e right 注意：键盘上每一个按键都有他的名字和编码，例：回车 - Enter - 编码为13，可以通过方法查看 console.lo","date":"2024-08-21","objectID":"/posts/vue2/:6:2","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"el与data的两种写法 我们知道，Vue实例和容器之间是通过el属性进行关联的，如果不写el，则标签引用的Vue数据不会被解析，如下面这段代码： \u003c!-- 如果不写el,则Vue不工作，name不被解析 --\u003e \u003cdiv id=\"root\"\u003e \u003ch3\u003e{{name}}\u003c/h3\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ //el:'#root' ,将该行代码注释，页面不解析name，且控制台不报错 data:{ name:'wangty', } }) \u003c/script\u003e ","date":"2024-08-21","objectID":"/posts/vue2/:7:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"v.$mount(’’) 那么有没有什么办法能替代el，使得Vue工作呢 \u003cdiv id=\"root\"\u003e \u003ch3\u003e{{name}}\u003c/h3\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const v = new Vue({ //我们使用一个恒定不变的对象来承接整个Vue实例，取名叫v data:{ name:'wangty', } }) console.log(v); //打印这个v，我们能够看到整个Vue的实例对象 v.$mount('#root') //使用Vue实例的$mount方法，指向root容器，以实现解析和挂载 \u003c/script\u003e 在控制台，这是我们第一个看见Vue的整个实例对象 通过这种写法，我们可以很容易的控制Vue解析页面的时间 //让Vue等一秒钟，再进行页面的解析 setTimeout(()=\u003e{ v.$mount('#root') },1000) 图解 ","date":"2024-08-21","objectID":"/posts/vue2/:7:1","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"data函数式写法 在Vue实例中，我们把data: { }，这种写法形式称为对象式写法，花括号{}里包含的是对象属性。 除此之外，data在Vue实例里还能写成函数的形式： new Vue({ //data的第一种写法：对象式 data:{ name:'wangty', } //data的第二种写法：函数式 data:function(){ return{ name:'wangty' } } }) ","date":"2024-08-21","objectID":"/posts/vue2/:7:2","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"关于this 注意：这里的data函数不是我们手动调用的，是Vue帮我们调用的 在这里我们打印输入一下，data方法中的this new Vue({ data:function(){ console.log(\"this\",this); return{ name:'wangty' } } }) 这里this指向的是整个Vue实例对象 注意，如果把data写成箭头函数，例： new Vue({ data:()=\u003e{ console.log(\"this\",this); return{ name:'wangty' } } }) 这里的this指向就会有问题，就会指向全局的window。（箭头函数是没有自己的this的，他默认就会向外去找指向，就会找到外层全局的window，当做他的this去使用） ","date":"2024-08-21","objectID":"/posts/vue2/:7:3","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"简写形式 我们通常写普通的函数时，一般用（）来代替:function()，所以写成： new Vue({ //data:function() =====\u003e 等价于 =====\u003e data() data(){ console.log(\"this\",this); return{ name:'wangty' } } }) [!NOTE] 注意：由Vue所管理的函数，一定不能写成箭头函数，例：data()，watch()，computer()等 ","date":"2024-08-21","objectID":"/posts/vue2/:7:4","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"理解MVVM Vue在最初的设计的时候，很大程度上参考了MVVM模型官网解释地址 1.M：模型（Model) :对应 data 中的数据 2.V：视图(View):模板 3.VM：视图模型(ViewModel)：Vue 实例对象 这块注意有个现象：写在data里的属性，会同步出现在Vue实例对象的属性里面，原理我们在数据代理时会进行阐述。 同时{{ }}中，Vue实体内中能够看到的所有属性，也能够使用 【Vue实体内的所有属性，Vue模板都可以使用】 例如： \u003ch1\u003e{{$options}}\u003c/h1\u003e \u003ch1\u003e{{$emit}}\u003c/h1\u003e \u003ch1\u003e{{_c}}\u003c/h1\u003e ","date":"2024-08-21","objectID":"/posts/vue2/:8:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"Object.defineProperty 数据劫持、数据代理、计算属性，的底层均用到了Object.defineProperty这个方法 作用：给一个方法或者一个对象定义属性 用法：Object.defineProperties(操作的对象名,‘添加的属性名’,{配置项键值对}) \u003cscript type=\"text/javascript\"\u003e let person = { name:'wangty', address:'chengdu' } //给person对象添加一个属性，叫age，值为18 Object.defineProperty(person,'age',{ value:18 }) console.log(person); \u003c/script\u003e 注意这块添加进去的age属性，在控制台的呈现样子 这个颜色的区别，表示这个age不可以被枚举，及age这个属性不参与遍历 ","date":"2024-08-21","objectID":"/posts/vue2/:9:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"enumerable配置项 //我们通过Object的keys方法对其进行验证 // Object.keys()传入一个对象，将对该对象的属性名进行提取，并拼合成一个数组 console.log(Object.keys(person)); 这里可以明显看到，没有age属性 如果想让age属性能够正常被遍历和枚举，我们引入defineProperty中的另一个配置项enumerable //enumerable可枚举的，默认为false Object.defineProperty(person,'age',{ value:18, enumerable:true }) ","date":"2024-08-21","objectID":"/posts/vue2/:9:1","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"writable配置项 我们在控制台分别操作一下name属性和age属性，再次打印，我们发现age并不能操作成功 这说明defineProperty设置的属性的属性值是不能被修改的 若要使其同正常属性一样能够修改其属性值，则需要使用另一个配置项writable //writable 能否被修改，默认为false Object.defineProperty(person,'age',{ value:18, writable:true }) console.log(person); ","date":"2024-08-21","objectID":"/posts/vue2/:9:2","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"configurable配置项 我们对属性进行删除操作，这里同样操作name和age： 这说明defineProperty设置的属性的属性值是不能被删除的 若要使其同正常属性一样能够删除，则需要使用另一个配置项configurable //configurable能否被删除，默认为false Object.defineProperty(person,'age',{ value:18, configurable:true, }) console.log(person); ","date":"2024-08-21","objectID":"/posts/vue2/:9:3","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"getter get函数 当我有一个从变量number中获取年龄的age需求时，希望：当变量发生变化时，年龄属性也同步发生变化。 \u003cscript type=\"text/javascript\"\u003e let number = 18 let person = { name:'wangty', address:'chengdu' } Object.defineProperty(person,'age',{ //注意简写： //get:function() ========\u003e 等价于 get() get:function(){ //当有人读取person的age属性时，get函数就会被调用,且返回值就是age的值 return 'hello' //设置成变量 //return number } }) console.log(person); \u003c/script\u003e 控制台效果为： 注意：每一次使用或者涉及读取age这个属性的时候，都会现调用getter ","date":"2024-08-21","objectID":"/posts/vue2/:9:4","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"setter 和getter相同的，有一个控制写入的配置项函数，set函数 //当有人修改person的age属性时，set函数就会被调用,且入参是修改的age值 set(value){ console.log(\"有人修改age,且修改值为：\"+value); number = value } ","date":"2024-08-21","objectID":"/posts/vue2/:9:5","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"数据代理 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写） 例： \u003cscript type=\"text/javascript\"\u003e let obj={x:100} let obj2 ={y:200} 0bject.defineProperty(obj2,'x',{ get(){ return obj.x }， set(value){ obj.x = value }) \u003c/script\u003e ","date":"2024-08-21","objectID":"/posts/vue2/:10:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"Vue中的数据代理 1.Vue中的数据代理: 通过vm对象来代理data对象中属性的操作(读/号) 2.Vue中数据代理的好处: 更加方便的操作data中的数据 3.基本原理: 通过object.defineProperty()把data对象中所有属性添加到vm上。 为每一个添加到vm上的属性，都指定一个getter/setter。 在getter/setter内部去操作(读/号)data中对应的属性 这个时候我们来看MVVM小结里的Vue实例中的现象，就很好理解： 首先，Vue在设置data方法的时候，将data内的数据复制了一份，放进了Vue实例对象的_data里 此时使用设置的name，可以用_data.name。 此时还没有进行数据代理。 然后，Vue对所有的data内属性和值使用数据代理，在Vue实体中添加name等属性，自动为其设置getter、setter方法，使得： vm._data.name = vm.name 此时：vm._data = options.data = data 【注意后面这个=成立需要将data要放到整个全局】 关于_data 注意：这块展开_data能够看到和vm中一样的结构，但他并不是数据代理，他主要用来监听data内容变化，用于影响页面解析显示 Vue中的数据劫持主要是通过ES6的Object.defineProperty()方法来实现。Vue会遍历data选项中的属性，并使用Object.defineProperty()将它们转为带有getter和setter的属性，这样Vue就能监控和响应数据的变化。 ","date":"2024-08-21","objectID":"/posts/vue2/:10:1","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"Computed ","date":"2024-08-21","objectID":"/posts/vue2/:11:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"姓名案例 \u003c!-- 写一个姓名案例：实现输入框输入姓名的时候，自动拼成全名 --\u003e \u003cdiv id=\"root\"\u003e 姓：\u003cinput type=\"text\" v-model=\"xing\"\u003e 名：\u003cinput type=\"text\" v-model=\"ming\"\u003e \u003c!-- 插值语法的正常写法 --\u003e 全名：\u003cspan\u003e{{xing}} - {{ming}}\u003c/span\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root', data(){ return{ xing:'wang', ming:'ty' } }, }) \u003c/script\u003e 页面效果为 这个时候，当input内无限输入姓名的长度，却只取前4位时，插值的写法 \u003c!-- 当需求越复杂，插值语法中的内容就越多 --\u003e \u003c!-- 这种写法不报错，但是不推荐 --\u003e 全名：\u003cspan\u003e{{xing.slice(0,3)}} - {{ming}}\u003c/span\u003e 在Vue官方文档中，风格指南中明确表示，组件模板中应当只包含简单表达式： methods的写法： \u003c!-- fullName不加()返回的是整个函数体 --\u003e \u003c!-- fullName加()返回的是return里的东西 --\u003e 全名：\u003cspan\u003e{{fullName()}}\u003c/span\u003e methods:{ fullName(){ //return 'wangty' return this.xing +'-'+this.ming } } ","date":"2024-08-21","objectID":"/posts/vue2/:11:1","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"计算属性 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e computed:{ fullName:{ \u003c!-- get原理和defineProperty一样 --\u003e get(){ return 'wangty' } } } 计算属性加载后依旧会放在vm中 在Vue开发者工具的结构中也能够很清晰的区分普通属性和计算属性 Vue对计算属性的缓存处理： \u003c!-- 写一个姓名案例：实现输入框输入姓名的时候，自动拼成全名 --\u003e \u003cdiv id=\"root\"\u003e 姓：\u003cinput type=\"text\" v-model=\"xing\"\u003e 名：\u003cinput type=\"text\" v-model=\"ming\"\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第一次调用 --\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第二次调用 --\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第三次调用 --\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第四次调用 --\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ el:'#root', data(){ return{ xing:'wang', ming:'ty' } }, computed:{ fullName:{ //有人读取fullname时，被调用 get(){ console.log(\"get被调用\"); return this.xing + '-' + this.ming } } } }) \u003c/script\u003e 注意控制台，这个地方对get的调用只调了一次！ 实际上，在第一次调用fullName属性的时候，Vue向计算属性要了返回结果，并进行了缓存处理。在后面再次请求fullName属性的时候，直接使用了缓存中的值。 那么这个缓存在数据变化时是否会对显示造成影响呢？是不会的。 计算属性中的get有两个被调用时机： ​ 1、初次读取fullName属性时 ​ 2、当依赖的数据发生变化时 此处就可以区分methods写法和computed写法之间的优劣了。对的，methods会反复调用！！ \u003cscript type=\"text/javascript\"\u003e ..... ,computed:{ fullName:{ //有人读取fullname时，被调用 get(){ console.log(\"get被调用\"); return this.xing + '-' + this.ming }, //有人修改fullname时，被调用 //传入value为‘李-四’ set(value){ console.log(\"set被调用,被修改的值：\",value); const arr = value.split('-') this.xing = arr[0]; this.ming = arr[1]; } } }, ....... \u003c/script\u003e 计算属性总结： 1.定义：要用的属性不存在，要通过已有属性计算得来。 2.原理：底层借助了objcet.defineproperty方法提供的getter和setter。 3.get函效什么时候执行？ （1）.初次读取时会执行一次。 （2）.当依赖的数据发生改变时会被再次调用。 4.优势：与methods实现相比。内部有缓存机制（复用），效奉更高，调试方便。 5.备注： 1.计算属性最终会出现在vm上，直接读取使用即可。 2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生 ","date":"2024-08-21","objectID":"/posts/vue2/:11:2","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"计算属性 简写 通常情况下，我们多使用计算属性的读取，不怎么使用修改。当确定计算属性只读不改时： 我们简化计算属性的写法： 1、删除掉set方法； 2、将fullName由对象写法改成函数写法： ​ fullName:{ } ===\u003e fullName:function( ){ } ===\u003e fullName(){ } ​ 并将这个函数，当作get函数使用 \u003cscript type=\"text/javascript\"\u003e ..... ,computed:{ fullName(){ return this.xing + '-' + this.ming }, }, ....... \u003c/script\u003e ","date":"2024-08-21","objectID":"/posts/vue2/:11:3","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"watch ","date":"2024-08-21","objectID":"/posts/vue2/:12:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"天气案例 \u003c!-- 写一个按钮点击后，实现页面天气的切换，并且输出切换前的天气和切换后的天气 --\u003e \u003cdiv id=\"root\"\u003e \u003ch3\u003e今天天气很{{info}}\u003c/h3\u003e \u003cbutton @click=\"isHost = !isHost\"\u003e点击切换天气\u003c/button\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ el:'#root', data(){ return{ isHost:true, } }, methods:{ }, computed:{ info(){ return this.isHost? '炎热':'凉爽' } } }) \u003c/script\u003e 效果是，点击按钮，天气能在炎热凉爽之间来回切换 注意：这样的写法，在Vue开发者工具上会有个bug \u003cdiv id=\"root\"\u003e \u003c!-- 当我将下面这行代码 --\u003e \u003ch3\u003e今天天气很{{info}}\u003c/h3\u003e \u003c!-- 改为 --\u003e \u003ch3\u003e今天天气很一般\u003c/h3\u003e ..... \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e .... ,computed:{ info(){ return this.isHost? '炎热':'凉爽' } }, .... \u003c/script\u003e 此处，computed中info的属性依旧随着isHost值的变化，而计算了 但是在Vue开发者工具中却并不能提现。但是我们可以通过vm验证，计算属性是变化了的。 即，当页面没有使用计算属性和基本属性的时候，Vue开发者工具，就不更新data中被修改的基本属性的值了。但是实际上vm中的data属性值和计算属性值都是被更改了的。 此处属于Vue开发者工具的一个小坑，后续可能Vue开发者工具会进行维护。 ","date":"2024-08-21","objectID":"/posts/vue2/:12:1","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"监视属性 \u003cscript type=\"text/javascript\"\u003e new Vue({ ..... ,watch:{ //isHost：监视谁，这儿就写谁的名字，这里指监视isHost的变化 isHost:{ //handler函数什么时候调用？在isHost被修改的时候。 handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //初始化时是否执行handler,默认为false immediate:true } }, }) \u003c/script\u003e 控制台效果 第二种写法，可以通过Vue实例对象，实现效果都是一样的 \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ ........ }) //注意这里监视对象要加''引号。里面的配置项内容和watch里的写法一样 vm.$watch('isHost',{ handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //immediate:true }) \u003c/script\u003e 监视属性watch 1.当被监视的属性变化时，回调函数自动调用，进行相关操作 2.监视的属性必须存在，才能进行监视！！ 没有不会报错，但是监视前后数据都是undefined 3.监视的两种写法： （1）. new Vue时传入watch配置 ​ （2）. 通过vm.$watch监视 ","date":"2024-08-21","objectID":"/posts/vue2/:12:2","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"深度监视 深度监视： （1）Vue中的watch默认不监测对象内部值的改变（一层）。 （2）配置deep:true可以监测对象内部值改变（多层）。 备注： （1）Vue自身可以监测对象内部值的改变，但vue提供的watch默认不可以！ （2）使用watch时根据数据的具体结构，决定是否采用深度监视。 \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ el:'#root', data(){ return{ number:{ a:1, b:1 } } }, watch:{ //监视多级结构中，某个属性的变化 'number.a':{ handler(){ console.log('a被修改了'); }, } }, }) \u003c/script\u003e 注意：这块儿监视的number是指number：{ }对象所在的地址值 如果写成watch：{ number：{ } } 地址永远不会变化，则永远不会触发监听。 如果想要监视到number中任意一个值变化，那么需要加上监视穿透deep \u003cscript type=\"text/javascript\"\u003e ........., watch:{ number:{ deep:true, handler(){ console.log('a被修改了'); }, } }, ....... \u003c/script\u003e 注意：这块两个概念，Vue实例是可以监测到多层级数据中属性的变化的，这个可以在控制台通过打印vm验证。只是Vue提供给开发者的watch属性中，无法直接监测到多层级数据的变化，需要设置默认检测层级或者使用deep。 ","date":"2024-08-21","objectID":"/posts/vue2/:12:3","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"监视的简写形式 如果监视的对象不适用其他配置项，例如deep，immediate等，只使用handler，可简写成： \u003cscript type=\"text/javascript\"\u003e ........., watch:{ //正常写法 isHost:{ handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //简写，isHost对象式写成函数式，当handler用 isHost(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, }, ....... \u003c/script\u003e 或者 \u003cscript type=\"text/javascript\"\u003e ........., //正常写法 vm.$watch('isHost',{ handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //deep:true //immediate:true }) //简写 vm.$watch('isHost',function(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }) ....... \u003c/script\u003e ","date":"2024-08-21","objectID":"/posts/vue2/:12:4","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"watch对比computed 计算属性 vs 侦听属性 Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子： \u003cdiv id=\"demo\"\u003e{{ fullName }}\u003c/div\u003e var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' }, watch: { firstName: function (val) { this.fullName = val + ' ' + this.lastName }, lastName: function (val) { this.fullName = this.firstName + ' ' + val } } }) 上面代码是命令式且重复的。将它与计算属性的版本进行比较： var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar' }, computed: { fullName: function () { return this.firstName + ' ' + this.lastName } } }) 好得多了，不是吗？ 我们发现，好多功能在使用watch和computed属性都可以完成： 不过呢。。。computed完全依赖return的内容。 但是，目前还没有办法可以让computed等待一段时间再进行return返回。 说明，计算属性中，是不能够开启异步任务去处理数据的。 那这个时候就需要依赖watch watch不依赖return，watch中的数据修改，依赖于数据处理语句，例如：a = b ，给a的赋值语句 所以当有：想要某值改变，但是延迟一秒操作的时候。使用watch进行处理 这里注意一个小细节哦： //这里的setTimeout很自然的使用了箭头函数 //之前我们说过，尽量不适用箭头函数以免改变了方法体中this的指向 //这里： //isHost是Vue管理下的函数。 //但是setTimeout定时器所指定的回调，是不受Vue控制的。浏览器定时器管理模块控制的。最后到时间了，也是js引擎帮我们调的函数 //------------------------------------------------------ //所以这儿，必须写成箭头函数 //如果这儿写成普通函数，js引擎会认为this是它引擎控制的整个window //------------------------------------------------------ //原理： //当这儿写成箭头函数的时候，由于箭头函数没有this，就会默认往外层找 //这儿setTimeout的外层是isHost函数 //而isHost函数的this就是Vue //由此使得this的指向正常 watch:{ isHost(val){ setTimeout(()=\u003e{ this.isHost = val },1000); } 小结： computed利watch之间的区别： 1.computed能完成的功能，watch都可以完成。 2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。 两个重要的小原则： 1.所被vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。 2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数、Promise的回调函数等，只要是没引入Vue都可以调用的函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象 ","date":"2024-08-21","objectID":"/posts/vue2/:13:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"Class 与 Style 绑定 操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 绑定样式: 1.class样式 ​ 写法:class=“xxx”xxx可以是字符串、对象、数组。 ​ 字符串写法适用于: 类名不确定，要动态获取。 ​ 对象写法适用于: 要绑定多个样式，个数不确定，名字也不确定。 ​ 数组写法适用于:要绑定多个样式，个数确定，名字也确定，但不确定用不用。 ​ 2.style样式 ​ :style=\"{fontSize:xxx}“其中xxx是动态值。 ​ :style=\"[a,b]“其中a、b是洋式对象 ","date":"2024-08-21","objectID":"/posts/vue2/:14:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"绑定class样式 \u003c!--正常的样式正常写，绑定的样式传值，字符串写法--\u003e \u003cdiv class=\"basic\" :class=\"normal\"\u003e\u003c/div\u003e .... data(){ normal:'red' } .... \u003c!--html解析后显示为 class=\"basic red\"--\u003e \u003c!----------------------------或者--------------------------------\u003e \u003c!--正常的样式正常写，绑定的样式传值，数值写法--\u003e \u003cdiv class=\"basic\" :class=\"arr\"\u003e\u003c/div\u003e .... data(){ arr:['red'，'yellow'，'buld'] } .... \u003c!--html解析后显示为 class=\"basic red yellow buld\"--\u003e \u003c!--按钮事件动态操作arr数组可以实现样式的改变--\u003e \u003c!----------------------------或者--------------------------------\u003e \u003c!--正常的样式正常写，绑定的样式传值，对象写法--\u003e \u003cdiv class=\"basic\" :class=\"Obj\"\u003e\u003c/div\u003e .... data(){ Obj:{ red:false, yellow:false } } .... \u003c!--按钮事件动态操作Obj对象可以实现样式的改变--\u003e ","date":"2024-08-21","objectID":"/posts/vue2/:14:1","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"绑定style样式 v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名： \u003cdiv v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"\u003e\u003c/div\u003e data: { activeColor: 'red', fontSize: 30 } 直接绑定到一个样式对象通常更好，这会让模板更清晰： \u003cdiv v-bind:style=\"styleObject\"\u003e\u003c/div\u003e data: { styleObject: { color: 'red', fontSize: '13px' } } 同class一样，也可以写成数组，v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上： \u003cdiv v-bind:style=\"[baseStyles, overridingStyles]\"\u003e\u003c/div\u003e ","date":"2024-08-21","objectID":"/posts/vue2/:14:2","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"标题 列表过滤 列表排序 更新时的一个问题 Vue监测数据的原理 Vue.set()方法 Vue监测数据的原理_数组 总结Vue监视数据 收集表单数据 过滤器 v-text指令 v-html指令 v-cloak指令 v-once指令 v-pre指令 自定义指令 函数式 自走义指令 对象式 自定义指令 总结 引出生命周期 生命周期 挂载流程 生命周期 更新流程 生命周期 销毁流程 生命周期 总结 对组件的理解 非单文件组件 组件的几个注意点 组件的嵌套 VueComponent结构函数 Vue实例与组件实例 一个重要的内置关系 单文件组件 创建Vue脚手架 分析脚手架结构 render函数 修改默认配置 ref属性 props配置 mixin混入 插件 scoped样式 TodoLisl案例 静态 TodoList案例 初始 TodoList案例 添加 TodoList案例 勾选 TodoList案例 删除 TodoList案例 底部统计 TodoList案例 底部交互 TodoList案例 总结 浏览器本地存储 TodoList 本地存储 组件自定义事件 绑定 组件自定义事件 解绑 组件自定义事件 总结 TodoList案例 自定义事件 全局事件总线1 全局事件总线2 TodoList案例 事件总线 消息订阅与发布_pubsub TodoList案例 编辑 $nextTick 动画效果 过度效果 多个元素过度 集成第三方动画 总结过度与动画 配置代理 方式一 配置代理 方式二 github案例 静态组件 github案例 列表展示 github案例 完善案例 vue-resource 默认插槽 具名插槽 作用域插槽 Vuex简介 求和案例 纯vue版 Vuex工作原理图 搭建Vuex环境 求和案例 vuex版 vuex开发者工具的使用 getters配置项 mapState与mapGetters mapActions与mapMutations 多组件共享数据 vuex模块化+namespace_1 wuex模块化+namespace_2 路由的简介 路由基本使用 几个注意点 嵌套路由 路由的query参数 命名路由 路由的params参数 路由的props配置 router-link的replace属性 编程式路由导航 缓存路由组件 两个新的生命周期钩子 全局前置 路由守卫 全局后置 路由守卫 独享路由守卫 组件内路由守卫 history模式与hash模式 element-ui基本使用 element-ui按需引入 vue3简介 使用vue-cli创建工程 使用vite创建工程 分析工程结构 安装开发者工具 初识setup re数 处理基本类型 re函数 处理对象类型 reactive函数 回顾Vue2的响应式原理 Vue3响应式原理proxy Vue3响应式原理reflect reactive对比ref setup的两个注意点 computed计算属性 watch监视re定义的数据 watch监视reactive定义的数据 watch时value的问题 watchEffect函数 Vue3生命周期 自定义hook toRef与toRefs shallowReactive与shallowRef readonly与shallowReadonly toRaw与markRaw customRef provide与inject 响应式数据的判断 CompositionAPl的优势 Fragment组件 Teleport组件 Suspense组件 Vue3中其他的改变 ","date":"2024-08-21","objectID":"/posts/vue2/:15:0","tags":["vue"],"title":"Vue2.0全套教程","uri":"/posts/vue2/"},{"categories":null,"content":"本文指导如何处理PyCharm中关于MicrosoftWebDriver.exe路径错误，需下载对应浏览器驱动，如Edge驱动，重命名并将其放置在Python安装目录下，以便PyCharm正常使用Selenium打开浏览器。edge驱动下载地址：驱动程序 将下载好的驱动程序解压。 找到python的目录文件，将Edge驱动程序放置在python根目录下。 注：如果不知道自己的python安装在什么位置了，可以打开cmd键入“where python” 3.完成以上步骤你得pycharm就可以正常打开浏览器了。 driver = webdriver.Edge() url = \"https://www.baidu.com\" driver.get(url) ","date":"2024-08-19","objectID":"/posts/text19/:0:0","tags":["Python"],"title":"Python的WebDriver问题","uri":"/posts/text19/"},{"categories":null,"content":" //报错信息 Failed to connect to github.com port 443: Connection refused. //报错翻译 连接github.com 443端口失败:连接拒绝 解决办法： 排查代理问题 尝试重置代理或者取消代理的方式： git config --global --unset http.proxy git config --global --unset https.proxy 如果没效果，接着添加全局代理试试： git config --global http.proxy git config --global https.proxy 如果以上问题还未得到解决 排查DNS解析问题 在DNS解析前先会尝试走hosts，然后在找不到的的情况下再DNS解析,修改hosts文件域名解析就会先走hosts中的ip和域名的映射关系。 我们可以修改hosts文件，修改ip地址和域名的映射关系： Windows：位于C:\\Windows\\System32\\drivers\\etc ping gitHub.com 20.205.243.166 github.com 140.82.112.4 github.com 151.101.1.6 github.global.ssl.fastly.net 185.199.108.153 assets-cdn.github.com 185.199.109.153 assets-cdn.github.com 185.199.110.153 assets-cdn.github.com 185.199.111.153 assets-cdn.github.com 【注意：用“管理员身份运行记事本”进行hosts文件的修改】 刷新DNS ipconfig /flushdns ","date":"2024-08-11","objectID":"/posts/text09/:0:0","tags":["git","gitHub"],"title":"git克隆失败解决办法","uri":"/posts/text09/"},{"categories":null,"content":"官网下载Typora 网址：Typora 官方中文站 (typoraio.cn) 安装Typora 双击Typora.exe 安装完成 激活方法 安装路径下找到：Typora\\resources\\page-dist\\static\\js 右键用记事本打开这个文件，ctrl+F定位到 e.hasActivated=\"true\"==e.hasActivated 替换为 e.hasActivated=\"true\"==\"true\" 这样就已经后台激活完成，但是每次开软件开始会提醒激活。 关闭软件每次启动时的已激活弹窗 继续在安装路径下resources\\page-dist\\license.html，找到 依旧ctrl+F 定位到： \u003c/body\u003e\u003c/html\u003e 替换为 \u003c/body\u003e\u003cscript\u003ewindow.οnlοad=function(){setTimeout(()=\u003e{window.close();},5);}\u003c/script\u003e\u003c/html\u003e 去除软件左下角“未激活”提示 按照安装路径，找到 resources\\locales\\zh-Hans.lproj\\Panel.json 文件中查找： \"UNREGISTERED\":\"未激活\"， 替换为： \"UNREGISTERED\":\" \" 最后，重新打开Typora，手动关掉激活窗口，之后就不会再出现。 引用图片 注意：Typora 使用带图片的文件，使用相对路径，创建带图片的笔记时，.md文件命名需为index。自动访问路径中的index文件，剪切图片时自动生成image文件夹，使得图片相对路径访问正常 【注意：我的安装路径位置在 C:\\Program Files\\Typora】 ","date":"2024-08-11","objectID":"/posts/text08/:0:0","tags":["Typora"],"title":"破解/安装激活 Typora 2024 教程","uri":"/posts/text08/"},{"categories":null,"content":"Hugo 是 Go 编写的静态网站生成器，速度快，易用，可配置。 Hugo 依赖于 Markdown 文件，元数据字体 。用户可以从任意的目录中运行 Hugo，支持共享主机和其他系统。只需要几分之一秒就可以渲染一个经典的中型网站，非常适合博客，文档等等网站的生成。 ","date":"2024-08-09","objectID":"/posts/text07/:0:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"HUGO博客网站搭建","uri":"/posts/text07/"},{"categories":null,"content":"安装环境 安装好Windows版本的 git： git官网：https://git-scm.com/downloads git安装教程请参考：【 Windows系统Git安装教程（详解Git安装过程） - 学为所用 - 博客园 (cnblogs.com)】 下载并安装Windows版本的 GO： go的中文官网：https://go.p2hp.com/ 下载并安装Windows版本的 hugo： hugo·GitHub 地址 https://github.com/gohugoio/hugo/releases 本教程中下载的项目压缩包名为：hugo_extended_0.128.2_windows-amd64 压缩包下载路径：https://github.com/gohugoio/hugo/releases/download/v0.128.2/hugo_extended_0.128.2_windows-amd64.zip ","date":"2024-08-09","objectID":"/posts/text07/:0:1","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"HUGO博客网站搭建","uri":"/posts/text07/"},{"categories":null,"content":"配置环境变量 创建程序目录 在C盘新建一个名为hugo的文件夹，进入文件夹后再创建一个名为bin的文件夹 将下载好的Windows版本hugo应用程序压缩包解压到这个bin文件夹 配置环境变量 然后在Windows搜索栏中搜索环境变量，点击环境变量 选择系统变量中的Path，点击新建 将 C:\\hugo\\bin 这个路径添加到环境变量 查看程序版本 然后打开powershell终端，输入下方命令查看 hugo version 显示版本号，即为成功安装了hugo程序。 ","date":"2024-08-09","objectID":"/posts/text07/:0:2","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"HUGO博客网站搭建","uri":"/posts/text07/"},{"categories":null,"content":"创建博客网站 现在我们就可以使用hugo搭建一个属于自己的博客网站了。 创建站点 首先，我们进入到C盘下的hugo文件夹，点击鼠标右键选择在终端中打开 执行下方命令创建一个静态站点：（本例创建的站点名为myblog，大家可以自定义） hugo new site myblog 创建后，我们回到hugo目录，可以看到新增了一个名为myblog的文件夹： 进入该文件夹后，就能看到刚刚创建的博客网站程序： 在站点中创建一篇文章 创建好了站点后，现在网站中还什么内容都没有，我们可以创建一篇文章来进行一下测试： 现在我们在终端中执行下方命令，进入站点目录： 进入网站目录后，执行下方命令创建一篇markdown格式的文章： hugo new posts/Articles01.md 执行后可以看到提示已经创建了一篇名为Articles01的文章与其所属路径。 进入这个路径，就能看到文章了。 打开这篇文章后能看到这篇文章的标题，日期等相关信息 在这里我们需要把draft（草稿） = true 修改为 draft = false 来表示这并不是一篇草稿。 然后随便在文档中写一些内容，比如： 然后保存关闭即可。 为网站添加主题 现在我们已经创建好了一个博客网站，并在网站中发布了一篇文章，不过现在我们还不能在浏览器中运行这个本地网站进行查看，因为在这之前，我们需要先给网站添加一个主题。 我们可以登录下方的hugo官网页面来挑选一个你喜欢的网站主题： https://themes.gohugo.io/themes 这里我们随便选择一个主题，点击进入页面后，可以看到安装方式： 可以看到，想要安装这个网站主题，需要先在终端中进入站点目录： cd myblog 也可以想上边一样，在myblog目录中右键在终端中打开。 然后执行下方命令： git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c 然后在打开名为 hugo 的 toml源文件，添加主题配置即可。 网站标题修改为myblog，然后再把theme = “m10c”这行代码加进去保存即可。 现在，我们在myblog目录下的主题文件夹中就能看到刚才添加的主题文件目录了： 本地访问测试 现在，我们在终端中执行下方代码启动本地网站进行测试： hugo server 本地清除缓存运行 hugo server --disableFastRender --gc --noHTTPCache --noBuildLock --logLevel debug 可以看到成功启动，在浏览器中输入 localhost:1313/ 即可访问这个本地站点： 可以看到网站标题为myblog，里边有刚才我们发布的第一篇文章Article01： 点击文章标题Article01，即可进入文章页面。 这样我们就成功使用HUGO在Windows本地快速部署了一个静态博客网站。 【下面是三种部署网站到公网的办法】 ","date":"2024-08-09","objectID":"/posts/text07/:0:3","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"HUGO博客网站搭建","uri":"/posts/text07/"},{"categories":null,"content":"安装内网穿透工具 目前我们在本机成功部署了一个博客网站，但如果没有公网IP的话，只能在本地局域网环境使用，有一定局限性。如果出差在外想要远程使用的话，可以结合Cpolar内网穿透生成公网地址，免去了本地重新部署过程，只需要使用公网地址直接就可以访问本地部署的网站，进行演示。 点击进入cpolar官网注册一个账号，并下载最新版本的Cpolar https://www.cpolar.com/ 登录成功后，点击下载Cpolar到本地并安装（一路默认安装即可）本教程选择下载Windows版本。 Cpolar安装成功后，在浏览器上访问 localhost:9200，使用cpolar账号登录,登录后即可看到Cpolar web 配置界面,结下来在web 管理界面配置即可。 http://localhost:9200/#/login?redirect=%2Fdashboard 【hugo-账户：1437059026@qq.com 密码：Wty201408.】 配置公网地址 接下来配置一下本地 博客网站 的公网地址， 登录后，点击左侧仪表盘的隧道管理——创建隧道， 创建一个 博客网站 的公网地址隧道： 隧道名称：可自定义命名，注意不要与已有的隧道名称重复 协议：选择 本地地址：1313 域名类型：选择随机域名 地区：选择China VIP 点击创建 隧道创建成功后，点击左侧的状态——在线隧道列表,查看所生成的公网访问地址，有两种访问方式。 使用任意一个上面生成的公网地址,在电脑或任意设备在浏览器进行登录访问,即可成功看到 本地博客网站 界面,这样一个可以远程访问的公网地址就创建好了,使用了Cpolar的公网域名,无需自己购买云服务器,即可在公网访问本地部署的服务了！ ","date":"2024-08-09","objectID":"/posts/text07/:0:4","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"HUGO博客网站搭建","uri":"/posts/text07/"},{"categories":null,"content":"搭建本地服务器 内网穿透地址会随着ip的更新而变化，为了保证不一直修改baseUrl，配置服务器来搭载网站。 配置本地服务器，将编译后的网站文件运行与服务器后，本地可以不启动hugo server 在控制面板打开命令提示符窗格，键入npm install -g anywhere 9999 npm install -g anywhere 9999 9999这里是设置端口号，端口号自行设置，也可以不输入xxx会默认8000端口号 安装成功anywhere后，可以直接使用anywhere指令启动服务，但是默认是查看全部文件列表 编译网站文件并运行于本地服务器 进入myblog根目录下，输入hugo命令进行编译 hugo 编译后，生成public文件夹，进入该文件夹根目录，并输入anywhere使编译文件运行在上面 cd public anywhere 【特别注意：运行在服务器上的一定是：\"编译后的文件！！！！\"】 ","date":"2024-08-09","objectID":"/posts/text07/:0:5","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"HUGO博客网站搭建","uri":"/posts/text07/"},{"categories":null,"content":"BaseUrl配置 使用hugo server本地运行的程序，每次跳转都将走localhost或者127.0.0.1，此处理解和其他程序启动一样，访问及跳转都将走本地。 若要使baseURL配置每次跳转时，自动请求的域名地址为服务器地址，则需要设置.toml文件中的baseURL。 baseURL = 'http://136c5bcc.r16.vip.cpolar.cn/' //内网穿透地址 baseURL = 'http://192.168.9.125/' //本地服务器地址 内网穿透地址需先将本地服务器内网地址先生成，再配置。配置方法同小结6相同，配置好后如图 逻辑为： 1、配置本地baseURL为内网穿透地址，使每次访问均可访问内网穿透地址 2、编译文件后，跳转路径指向内网穿透地址 3、内网穿透地址配置localhost:8000指向本地服务器 4、启动本地服务器，使内网穿透访问正常 5、使跳转路径正常 当此处修改为内网穿透地址后，需先进行编译，再通过本地服务器启动后的地址后，记得编译之后再运行本地服务器 ","date":"2024-08-09","objectID":"/posts/text07/:0:6","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"HUGO博客网站搭建","uri":"/posts/text07/"},{"categories":null,"content":"创建 GitHub Pages 站点 GitHub提供了Github pages用于挂在类似于hugo，hexo这样的博客静态网页， 官方教程：https://docs.github.com/zh/enterprise-server@3.12/pages/getting-started-with-github-pages/creating-a-github-pages-site GitHub登陆后，新建仓库Wangty654.github.io 注意仓库名需要和账户名一致 修改博客配置文件.toml中的默认跳转地址为仓库名 baseURL = 'https://Wangty654.github.io' //仓库服务器地址 仓库建好后，进入博客根目录，编译网站 cd myblog C:/hugo/myblog \u003e hugo 生成的编译后文件夹public为所有html、css、js组成的静态网站文件 上传GitHub cd public C:/hugo/myblog/public \u003e git init git add . git commit -m '1' git push 请求成功后直接访问https://Wangty654.github.io即可 ","date":"2024-08-09","objectID":"/posts/text07/:0:7","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"HUGO博客网站搭建","uri":"/posts/text07/"},{"categories":null,"content":"腾讯云服务器部署 配置的后台的代理 静态资源服务器 如果是放我的静态网页 只需要将dist配置在root上，并对其刷新页面的位置进行配置就行 dist内存在index页面等同于，hugo的public页面 ftp传文件 、shell 输入命令 ","date":"2024-08-09","objectID":"/posts/text07/:0:8","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"HUGO博客网站搭建","uri":"/posts/text07/"},{"categories":null,"content":"网站样式自定义设置 关于themes主题 themes主题为git拉取下来用于整个静态网站的样式代码，均可按照需求进行修改 10.1.1头像设置 1、在layouts包下，有一个baseof.html文件，将其中的首页文件指向调整为你想要的图片 2、并同时更改static文件夹中的图片，使指向和文件名一致。 10.1.2 主题颜色设置 1、拷取themes中配置文件config.toml里默认设置主题颜色的部分代码 默认主题有三种样式 选择其中一种样式，放入我们的配置文件hugo.toml，可以对其中的文字颜色也进行修改，本主题改为粉色 10.1.3 主页文字设置 更改layouts包下，baseof.html文件中书写首页介绍文字的位置 10.1.4 主页分类菜单设置 1、配置文件hugo.html中配置菜单栏 2、并在每条笔记中，使用yaml格式书写抬头 10.1.5 主页关于菜单设置 取主题中content包下的about文件放入myblog的content包根目录下。about内的内容可以自行定义 10.1.6 关于代码块样式设置 配置文件中写入设置样式的命令模块，根据需要更改其中style的值。 hugo中文文档中 ：https://hugo.opendocs.io/getting-started/ 选择“内容管理” - “语法高亮” 在style中选择想要更改的样式，放入配置文件中：https://xyproto.github.io/splash/docs/ ","date":"2024-08-09","objectID":"/posts/text07/:0:9","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"HUGO博客网站搭建","uri":"/posts/text07/"},{"categories":null,"content":"String转为int，使用parseInt，或者valueOf.intValue int i = Integer.parseInt（string）; int i = Integer.valueOf(s).intValue(); int转为String，使用valueOf，或者toString，或者\"“空字符串相加 String s = String.valueOf(i); String s = Integer.toString(i); String s = \"\" + i; ","date":"2024-08-09","objectID":"/posts/text02/:0:0","tags":["java"],"title":"Java中int与String互相转换方法","uri":"/posts/text02/"},{"categories":null,"content":"利用原生JSON对象，将对象转为字符串，使用 JSON.stringify（对象名） var jsObj = {}; jsObj.testArray = [1,2,3,4,5]; jsObj.name = 'CSS3'; jsObj.date = '8 May, 2011'; var str = JSON.stringify(jsObj); alert(str); 从JSON字符串转为对象 ，使用JSON.parse（字符串名） var jsObj = {}; jsObj.testArray = [1,2,3,4,5]; jsObj.name = 'CSS3'; jsObj.date = '8 May, 2011'; var str = JSON.stringify(jsObj); var str1 = JSON.parse(str); alert(str1); ","date":"2024-08-09","objectID":"/posts/text01/:0:0","tags":["JavaScript"],"title":"JS 中Object和String互转方法","uri":"/posts/text01/"},{"categories":null,"content":"数字短信验证码 思路： a.两个文本框+一个获取验证码按钮，文本框用来输入手机号和获取到的验证码，按钮负责点击和记录倒计时； b.js书写定时器setTimeout，进行60秒验证码失效时间记录； c.后台提供短信获取验证的接口，我们把手机号作为参数上传，后台获取到后给该手机号下发验证码 下放代码可以直接 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cscript type=\"text/javascript\" src=\"https://libs.baidu.com/jquery/2.1.4/jquery.min.js\" \u003e //验证码 var counts = 60; function settime(val) { if(counts == 0) { val.removeAttribute(\"disabled\"); val.value = \"获取验证码\"; counts = 60; return false; } else { val.setAttribute(\"disabled\", true); val.value = \"重新发送（\" + counts + \"）\"; counts--; } setTimeout(function() { settime(val); }, 1000); } $(function(){ //获取验证码 $(\"#verCodeBtn\").click(function() { var userinfo = { \"UserPhoneNum\": '86//' + $(\"input[name='phone']\").val() } $.ajax({ url: \"https://www.xxxxx.cn/user/sendcode/\", data: userinfo, type: \"get\", success: function(data) { if(JSON.parse(data).state === 404 || JSON.parse(data).state === 202 || userinfo.UserPhoneNum === '86//') { alert(\"验证码发送失败\") } else { alert(\"验证码发送成功，请耐心等待\") } }, error: function() { alert(\"发送失败\"); } }); }); }) \u003c/script\u003e \u003cbody\u003e \u003cinput type=\"text\" name=\"phone\" id=\"phone\" value=\"\" placeholder=\"请输入手机号\" maxlength=\"11\" /\u003e \u003cinput type=\"\" name=\"verCode\" id=\"verCode\" value=\"\" placeholder=\"请输入验证码\" maxlength=\"6\"/\u003e \u003cinput type=\"button\" name=\"\" id=\"verCodeBtn\" value=\"获取验证码\" onclick=\"settime(this);\"/\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-08-09","objectID":"/posts/text14/:0:1","tags":["JavaScript"],"title":"JS 验证码功能的三种实现方式","uri":"/posts/text14/"},{"categories":null,"content":"图形验证码 概要：一般的图形验证码就像上方的短信验证码一样，就是后台生成的验证码图片返回给前端的，那样的话就比较简单，因为复杂的都让后台解决了，我在这里主要说的是另一种，就是不调用后台接口，通过canvas画布来解决图形验证码。 思路： a.一个文本框用来输入由数字和字母组合的验证码+一个画布标签来显示图形验证码+一个提交按钮； b.提交按钮进行表单验证，输入正确或者错误进行相应的提示； c.用画布生成并渲染出验证码图形，并且得到随机的颜色值； \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e验证码\u003c/title\u003e \u003cstyle\u003e .input-val { width: 150px; height: 30px; border: 1px solid #ddd; box-sizing: border-box;/*box-sizing 属性允许你以某种方式定义某些元素，以适应指定区域。*/ } #canvas { vertical-align: middle;/*vertical-align属性设置一个元素的垂直对齐。*/ box-sizing: border-box; border: 1px solid #ddd; cursor: pointer; } .btn { display: block; margin-top: 10px; height: 30px; width: 80px; font-size: 16px; color: #fff; background-color: #409EFE; border: 1px solid #EBEDEF; border-radius: 50px; } \u003c/style\u003e \u003c/head\u003e \u003cscript type=\"text/javascript\" src=\"https://libs.baidu.com/jquery/2.1.4/jquery.min.js\" \u003e\u003c/script\u003e \u003cscript\u003e $(function(){ var show_num = []; draw(show_num); $(\"#canvas\").on('click',function(){ draw(show_num); }) $(\".btn\").on('click',function(){ var val = $(\".input-val\").val().toLowerCase(); //toLowerCase()函数将字符串中的所有字符转为小写。所以输入框不区分大小写。 var num = show_num.join(\"\"); if(val==''){ alert('请输入验证码！'); }else if(val == num){ alert('提交成功！'); $(\".input-val\").val(''); }else{ alert('验证码错误！请重新输入！'); $(\".input-val\").val(''); } }) }) function draw(show_num) {//生成并渲染出验证码图形 var canvas_width=$('#canvas').width(); var canvas_height=$('#canvas').height(); var canvas = document.getElementById(\"canvas\");//获取canvas var context = canvas.getContext(\"2d\");//获取到canvas画图的环境 canvas.width = canvas_width; canvas.height = canvas_height; var sCode = \"A,B,C,E,F,G,H,J,K,L,M,N,P,Q,R,S,T,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,m,n,p,q,r,s,t,u,v,w,x,y,z,1,2,3,4,5,6,7,8,9,0\"; var aCode = sCode.split(\",\"); var aLength = aCode.length;//获取到数组的长度 for (var i = 0; i \u003c 4; i++) { //这里的for循环可以控制验证码位数 var j = Math.floor(Math.random() * aLength);//获取到随机的索引值 var deg = Math.random() - 0.5; //产生一个随机弧度 var txt = aCode[j];//得到随机的一个内容 show_num[i] = txt.toLowerCase(); var x = 10 + i * 20;//文字在canvas上的x坐标 var y = 20 + Math.random() * 8;//文字在canvas上的y坐标 context.font = \"bold 24px 微软雅黑\"; context.translate(x, y); context.rotate(deg); context.fillStyle = randomColor(); context.fillText(txt, 0, 0); context.rotate(-deg); context.translate(-x, -y); } for (var i = 0; i \u003c= 5; i++) { //验证码上显示线条 context.strokeStyle = randomColor(); context.beginPath(); context.moveTo(Math.random() * canvas_width, Math.random() * canvas_height); context.lineTo(Math.random() * canvas_width, Math.random() * canvas_height); context.stroke(); } for (var i = 0; i \u003c= 20; i++) { //验证码上的小点 context.strokeStyle = randomColor();//随机生成 context.beginPath(); var x = Math.random() * canvas_width; var y = Math.random() * canvas_height; context.moveTo(x, y); context.lineTo(x + 1, y + 1); context.stroke(); } } function randomColor() {//得到随机的颜色值 var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return \"rgb(\" + r + \",\" + g + \",\" + b + \")\"; } \u003c/script\u003e \u003cbody\u003e \u003cdiv class=\"code\"\u003e \u003cinput type=\"text\" value=\"\" placeholder=\"请输入验证码\" class=\"input-val\"\u003e \u003ccanvas id=\"canvas\" width=\"100\" height=\"30\"\u003e\u003c/canvas\u003e \u003cbutton class=\"btn\"\u003e验证\u003c/button\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-08-09","objectID":"/posts/text14/:0:2","tags":["JavaScript"],"title":"JS 验证码功能的三种实现方式","uri":"/posts/text14/"},{"categories":null,"content":"滑动验证码 滑块登录，是完成拼图形式的，我下面这个原理是一样的，逻辑是根据鼠标滑动轨迹，坐标位置，计算拖动速度等等来判断是否人为操作，如果小伙伴想做和博客园效果一样的，那么可以用来做参考。 思路： a.由三个div组成，构成了滑块和底部进度条的效果； b.书写js,注册鼠标按下，悬浮，松开事件； c.记录滑块移动的距离和状态进行判断是否成功； html \u003cdiv class=\"drag\"\u003e \u003cdiv class=\"bg\"\u003e\u003c/div\u003e \u003cdiv class=\"text\" onselectstart=\"return false;\"\u003e请拖动滑块解锁\u003c/div\u003e \u003cdiv class=\"btn\"\u003e\u0026gt;\u0026gt;\u003c/div\u003e \u003c/div\u003e css \u003cstyle\u003e .drag{ width: 300px; height: 40px; line-height: 40px; background-color: #e8e8e8; position: relative; margin:0 auto; } .bg{ width:40px; height: 100%; position: absolute; background-color: #75CDF9; } .text{ position: absolute; width: 100%; height: 100%; text-align: center; user-select: none; } .btn{ width:40px; height: 38px; position: absolute; border:1px solid #ccc; cursor: move; font-family: \"宋体\"; text-align: center; background-color: #fff; user-select: none; color:#666; } \u003c/style\u003e js \u003cscript\u003e //一、定义一个获取DOM元素的方法 var $ = function(selector){ return document.querySelector(selector); }, box = $(\".drag\"),//容器 bg = $(\".bg\"),//背景 text = $(\".text\"),//文字 btn = $(\".btn\"),//滑块 success = false,//是否通过验证的标志 distance = box.offsetWidth - btn.offsetWidth;//滑动成功的宽度（距离） //二、给滑块注册鼠标按下事件 btn.onmousedown = function(e){ //1.鼠标按下之前必须清除掉后面设置的过渡属性 btn.style.transition = \"\"; bg.style.transition =\"\"; //说明：clientX 事件属性会返回当事件被触发时，鼠标指针向对于浏览器页面(或客户区)的水平坐标。 //2.当滑块位于初始位置时，得到鼠标按下时的水平位置 var e = e || window.event; var downX = e.clientX; //三、给文档注册鼠标移动事件 document.onmousemove = function(e){ var e = e || window.event; //1.获取鼠标移动后的水平位置 var moveX = e.clientX; //2.得到鼠标水平位置的偏移量（鼠标移动时的位置 - 鼠标按下时的位置） var offsetX = moveX - downX; //3.在这里判断一下：鼠标水平移动的距离 与 滑动成功的距离 之间的关系 if( offsetX \u003e distance){ offsetX = distance;//如果滑过了终点，就将它停留在终点位置 }else if( offsetX \u003c 0){ offsetX = 0;//如果滑到了起点的左侧，就将它重置为起点位置 } //4.根据鼠标移动的距离来动态设置滑块的偏移量和背景颜色的宽度 btn.style.left = offsetX + \"px\"; bg.style.width = offsetX + \"px\"; //如果鼠标的水平移动距离 = 滑动成功的宽度 if( offsetX == distance){ //1.设置滑动成功后的样式 text.innerHTML = \"验证通过\"; text.style.color = \"#fff\"; btn.innerHTML = \"\u0026radic;\"; btn.style.color = \"green\"; bg.style.backgroundColor = \"lightgreen\"; //2.设置滑动成功后的状态 success = true; //成功后，清除掉鼠标按下事件和移动事件（因为移动时并不会涉及到鼠标松开事件） btn.onmousedown = null; document.onmousemove = null; //3.成功解锁后的回调函数 setTimeout(function(){ alert('解锁成功！'); },100); } } //四、给文档注册鼠标松开事件 document.onmouseup = function(e){ //如果鼠标松开时，滑到了终点，则验证通过 if(success){ return; }else{ //反之，则将滑块复位（设置了1s的属性过渡效果） btn.style.left = 0; bg.style.width = 0; btn.style.transition = \"left 1s ease\"; bg.style.transition = \"width 1s ease\"; } //只要鼠标松开了，说明此时不需要拖动滑块了，那么就清除鼠标移动和松开事件。 document.onmousemove = null; document.onmouseup = null; } } \u003c/script\u003e ","date":"2024-08-09","objectID":"/posts/text14/:0:3","tags":["JavaScript"],"title":"JS 验证码功能的三种实现方式","uri":"/posts/text14/"},{"categories":null,"content":"利用来JS控制页面控件显示和隐藏有两种方法，两种方法分别利用HTML的style中的两个属性，两种方法的不同之处在于控件隐藏后是否还在页面上占空位。 ","date":"2024-08-09","objectID":"/posts/text013/:0:0","tags":["javascript"],"title":"JS控制元素的显示和隐藏","uri":"/posts/text013/"},{"categories":null,"content":"方法一 document.getElementById(\"EleId\").style.visibility=\"hidden\"; document.getElementById(\"EleId\").style.visibility=\"visible\"; 利用上述方法实现隐藏后，页面的位置还被控件占用，显示空白。 ","date":"2024-08-09","objectID":"/posts/text013/:0:1","tags":["javascript"],"title":"JS控制元素的显示和隐藏","uri":"/posts/text013/"},{"categories":null,"content":"方法二 document.getElementById(\"EleId\").style.display=\"none\"; document.getElementById(\"EleId\").style.display=\"inline\"; 利用上述方法实现隐藏后，页面的位置不被占用。 ","date":"2024-08-09","objectID":"/posts/text013/:0:2","tags":["javascript"],"title":"JS控制元素的显示和隐藏","uri":"/posts/text013/"},{"categories":null,"content":"方法三 显示元素进行隐藏 document.getElementById(\"ID名\").hidden=ture; 根据页面元素ID名获得页面元素值，进而将其属性设置成隐藏。 将隐藏元素进行显示对于已经隐藏的页面元素如果要将其再次显示，不是将 document.getElementById(\"ID名\").hidden=false; 而是将其隐藏属性删除 document.getElementById(\"ID名\").removeAttribute(\"hidden\"); ","date":"2024-08-09","objectID":"/posts/text013/:0:3","tags":["javascript"],"title":"JS控制元素的显示和隐藏","uri":"/posts/text013/"},{"categories":null,"content":"Oracle查询sql 查询系统当前日期 select sysdate from dual; 请查询每个员工的名字、薪水和加薪15.5%之后的薪水（trunc取整） Select 名字,薪水,trunc(薪水*1.155) \"new salary\" from employees; 请显示所有以’J’，‘A’，‘M’打头的员工的名字和名字长度，且按照名字排升序 select 名字,LENGTH(名字) from employees where substr(名字,0,1) in ('J','A','M') order by 名字 asc; 请查询员工名和工作时间（换算成月并取整），并按工作时间排降序 Select 名,trunc(months_between(sysdate,时间),0) from employees order by trunc(months_between(sysdate,时间),0) desc; 请查询员工的名字和薪水，并将薪水列变成15个字符长度，左边填充“$”符号 select 名字,lpad(薪水,15,'$') from employees; 请查询部门id为90的所有员工的名字和他们参加工作的星期数(保留2位小数，不需要四舍五入)使用 select 名字 , trunc((参加工作星期数)/7,2) from employees where 员工id=90 创建报告，显示员工名和奖金系数,如果奖金系数为空,则显示$无奖金 select 名字,decode(奖金系数,'','无奖金',奖金系数) from employees; 请使用case语句，查询员工的job_id和级别.例如: select t.job_id, decode(t.job_id, 'AD_PRES', 'A','ST_MAN', 'B','IT_PROG', 'C','SA_REP', 'D','ST_CLERK', 'E','0') from employees t; 或者 Select job_id, case job_id when 'AD_PRES' then 'A' when 'ST_MAN' then 'B' when 'IT_PROG' then 'C' when 'SA_REP' then 'D' when 'ST_CLERK' then 'E' else '0' end \"Grage\" from employees; ","date":"2024-08-09","objectID":"/posts/text18/:0:0","tags":["sql","Oracle"],"title":"Oracle查询sql","uri":"/posts/text18/"},{"categories":null,"content":"子=\u003e父 子组件向父组件传参的方式通常通过事件来实现。具体步骤如下： 在子组件中定义事件：子组件可以通过 $emit 方法触发一个自定义事件，并传递参数 // 子组件 ChildComponent.vue \u003ctemplate\u003e \u003cbutton @click=\"sendDataToParent\"\u003e向父组件传参\u003c/button\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { sendDataToParent() { let data = '这是子组件传递给父组件的数据'; this.$emit('child-event', data); } } } \u003c/script\u003e 在上面的代码中，sendDataToParent 方法通过 $emit 发送了一个名为 child-event 的事件，并将 data 作为参数传递给父组件 2.在父组件中监听事件：父组件需要在使用子组件的地方监听这个事件，并处理子组件传递过来的数据 // 父组件 ParentComponent.vue \u003ctemplate\u003e \u003cdiv\u003e \u003cp\u003e从子组件接收到的数据：{{ receivedData }}\u003c/p\u003e \u003cchild-component @child-event=\"handleChildEvent\"\u003e\u003c/child-component\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import ChildComponent from './ChildComponent.vue'; export default { components: { ChildComponent }, data() { return { receivedData: '' }; }, methods: { handleChildEvent(data) { this.receivedData = data; } } } \u003c/script\u003e 在父组件中，使用 标签引入子组件，并通过 @child-event 监听子组件触发的 child-event 事件。当事件被触发时，handleChildEvent 方法会被调用，并将子组件传递的 data 参数赋值给 receivedData。 通过以上方式，子组件就能够向父组件传递数据了。 ","date":"2024-08-09","objectID":"/posts/text17/:0:1","tags":["vue","javascript"],"title":"子组件向父组件相互传参的方式","uri":"/posts/text17/"},{"categories":null,"content":"父=\u003e子 Vue项目中在父组件中直接调用子组件的方法 方案一：通过ref直接调用子组件的方法 //父组件中 \u003ctemplate\u003e \u003cdiv\u003e \u003cButton @click=\"handleClick\"\u003e点击调用子组件方法\u003c/Button\u003e \u003cChild ref=\"child\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import Child from './child'; export default { methods: { handleClick() { this.$refs.child.sing(); }, }, } \u003c/script\u003e //子组件中 \u003ctemplate\u003e \u003cdiv\u003e我是子组件\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { sing() { console.log('我是子组件的方法'); }, }, }; \u003c/script\u003e 方案二：通过组件的$emit、$on方法 //父组件中 \u003ctemplate\u003e \u003cdiv\u003e \u003cButton @click=\"handleClick\"\u003e点击调用子组件方法\u003c/Button\u003e \u003cChild ref=\"child\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import Child from './child'; export default { methods: { handleClick() { this.$refs.child.$emit(\"childmethod\") //子组件$on中的名字 }, }, } \u003c/script\u003e //子组件中 \u003ctemplate\u003e \u003cdiv\u003e我是子组件\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { mounted() { this.$nextTick(function() { this.$on('childmethods', function() { console.log('我是子组件方法'); }); }); }, }; \u003c/script\u003e ","date":"2024-08-09","objectID":"/posts/text17/:0:2","tags":["vue","javascript"],"title":"子组件向父组件相互传参的方式","uri":"/posts/text17/"},{"categories":null,"content":"腾讯云直播推流器TXLivePusher ：https://webrtc-demo.myqcloud.com/push-sdk/v2/docs/TXLivePusher.html 这里是：直播和点播播放的 Web 播放器（ TCPlayer ）的相关参数以及 API 1.直播推流 直播推流需要第三方库 \u003cscript src=\"https://video.sdk.qcloudecdn.com/web/TXLivePusher-2.0.3.min.js\" charset=\"utf-8\"\u003e\u003c/script\u003e 直播推流代码 var livePusher = new TXLivePusher(); console.log(livePusher); livePusher.setRenderView('id_local_video'); // 设置视频质量 livePusher.setVideoQuality('720p'); // 设置音频质量 livePusher.setAudioQuality('standard'); // 自定义设置帧率 livePusher.setProperty('setVideoFPS', 25); // 采集完摄像头和麦克风之后自动推流 Promise.all([livePusher.startScreenCapture(), livePusher.startMicrophone()]) .then(function () { //传入的是一个推流地址，后端返回的，把后端返回的一个地址前边的rtmp换成webrtc就可以了 livePusher.startPush(推流地址) .then(() =\u003e { console.log('pushing'); if (livePusher.isPushing()) { console.log('pushing'); } }) .catch(err =\u003e { console.log(err); }) }) .catch(err =\u003e { console.log(err); }) 2.直播拉流 直播拉流所需第三方库 \u003clink href=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/tcplayer.min.css\" rel=\"stylesheet\" /\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 Webrtc 视频，需要在 tcplayer.vx.x.x.min.js 之前引入 TXLivePlayer-x.x.x.min.js。--\u003e \u003c!--有些浏览器环境不支持 Webrtc，播放器会将 Webrtc 流地址自动转换为 HLS 格式地址，因此快直播场景同样需要引入hls.min.x.xx.xm.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/TXLivePlayer-1.2.3.min.js\"\u003e\u003c/script\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 HLS 协议的视频，需要在 tcplayer.vx.x.x.min.js 之前引入 hls.min.x.xx.xm.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/hls.min.1.1.6.js\"\u003e\u003c/script\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 FLV 格式的视频，需要在 tcplayer.vx.x.x.min.js 之前引入 flv.min.x.x.x.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/flv.min.1.6.3.js\"\u003e\u003c/script\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 DASH 视频，需要在 tcplayer.vx.x.x.min.js 之前引入 dash.min.x.x.x.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/dash.all.min.4.5.2.js\"\u003e\u003c/script\u003e \u003c!--播放器脚本文件--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/tcplayer.v4.7.2.min.js\"\u003e\u003c/script\u003e 播放容器 \u003cvideo id=\"player-container-id\" preload=\"auto\" playsinline webkit-playsinline\u003e\u003c/video\u003e 拉流js var player = TCPlayer('player-container-id', {}); // player-container-id 为播放器容器 ID，必须与 html 中一致 player.src(url); // url 播放地址 直播视频全屏canvas元素无法在最上层 直播弹幕无法在最上层，将z-index设置为最大也没效果，那是因为第三方库用了一个toplayer的东西将播放视频的元素放到最顶层了，用css设置的东西没效果，解决方案就是设置个延时器，等到第三方库把元素放置到页面之后dom操作canvas元素，将其放置到设置toplayer的盒子里边，这样就可以了 ","date":"2024-08-09","objectID":"/posts/text16/:0:0","tags":["腾讯云直播"],"title":"腾讯云直播前端","uri":"/posts/text16/"},{"categories":null,"content":"StringEscapeUtils类可以对html js xml sql 等代码进行转义来防止SQL注入及XSS注入 添加依赖 \u003cdependency\u003e \u003cgroupId\u003ecommons-lang\u003c/groupId\u003e \u003cartifactId\u003ecommons-lang\u003c/artifactId\u003e \u003cversion\u003e2.6\u003c/version\u003e \u003c/dependency\u003e 1.html脚本 escapeHtml转义html脚本 unescapeHtml反转义html脚本 System.out.println(StringEscapeUtils.escapeHtml(\"\u003ca\u003eabc\u003c/a\u003e\")); System.out.println(StringEscapeUtils.unescapeHtml(\"\u0026lt;a\u0026gt;abc\u0026lt;/a\u0026gt;\")); 输出 \u0026lt;a\u0026gt;abc\u0026lt;/a\u0026gt; \u003ca\u003eabc\u003c/a\u003e 2.js脚本 escapeJavaScript转义js脚本 unescapeJavaScript反转义js脚本 System.out.println(StringEscapeUtils.escapeJavaScript(\"\u003cscript\u003ealert('123')\u003cscript\u003e\")); System.out.println(StringEscapeUtils.unescapeJavaScript(\"\u003cscript\u003ealert(\\'123\\')\u003cscript\u003e\")); 输出 \u003cscript\u003ealert(\\'123\\')\u003cscript\u003e \u003cscript\u003ealert('123')\u003cscript\u003e 3.字符串Unicode　escapeJava转义成Unicode编码 unescapeJava反转义成Unicode编码 System.out.println(StringEscapeUtils.escapeJava(\"你好\")); System.out.println(StringEscapeUtils.unescapeJava(\"\\u4F60\\u597D\")); 输出 \\u4F60\\u597D 你好 4.xml escapeXML转义XML unescapeXML反转义XML System.out.println(StringEscapeUtils.escapeXml(\"\u003cname\u003e贝贝\u003c/name\u003e\")); System.out.println(StringEscapeUtils.unescapeXml(\"\u0026lt;name\u0026gt;\u0026#36125;\u0026#36125;\u0026lt;/name\u0026gt;\")); 输出 \u0026lt;name\u0026gt;\u0026#36125;\u0026#36125;\u0026lt;/name\u0026gt; \u003cname\u003e贝贝\u003c/name\u003e 5.sql escapeSql sql转义，防止sql注入攻击 转义后 StringBuffer sql = new StringBuffer(\"select * from users where 1=1 \"); String keyWord=\"aaa' or '1=1\"; if(!keyWord.isEmpty()){ sql.append(\" and username like '%\" + StringEscapeUtils.escapeSql(keyWord) + \"%'\"); } System.out.println(sql); 输出 select * from users where 1=1 and username like '%aaa'' or ''1=1%' 不进行转义的 select * from users where 1=1 and username like '%aaa' or '1=1%' ","date":"2024-08-09","objectID":"/posts/text15/:0:0","tags":["java"],"title":"转义StringEscapeUtils的使用","uri":"/posts/text15/"},{"categories":null,"content":"模版语法 vue示例和容器root，11对应 el：加#指定容器id，不加#指定容器class 双括号中支持的内容为：{{ js表达式}} ","date":"2024-08-05","objectID":"/posts/text20/:0:1","tags":["vue2","vue3"],"title":"尚硅谷Vue2.0+Vue3.0全套教程","uri":"/posts/text20/"},{"categories":null,"content":"数据绑定 v-bind： 单向数据绑定 ：data数据里的值发生变化，组件的值就发生变化。 v-bind:value=“id” // data:{ name:“123”} 但是组件上的值发生变化，data里的值不会发生变化 双向数据绑定 ：data数据里的值-同-组件的值，同步发生变化。 v-model:value=“id” // data:{ name:“123”} 注意：v-model只能用在输入值表单元素上 ","date":"2024-08-05","objectID":"/posts/text20/:0:2","tags":["vue2","vue3"],"title":"尚硅谷Vue2.0+Vue3.0全套教程","uri":"/posts/text20/"},{"categories":null,"content":"$mount.挂载 箭头函数，没有this，data()=\u003e{ }中调用的是实例不是vue是windows ","date":"2024-08-05","objectID":"/posts/text20/:0:3","tags":["vue2","vue3"],"title":"尚硅谷Vue2.0+Vue3.0全套教程","uri":"/posts/text20/"},{"categories":null,"content":"MVVM模型 ","date":"2024-08-05","objectID":"/posts/text20/:0:4","tags":["vue2","vue3"],"title":"尚硅谷Vue2.0+Vue3.0全套教程","uri":"/posts/text20/"},{"categories":null,"content":"数据代理 v-on:click = \"\" 等价于 @click=\"\" click默认方法里面的传参，为点击事件event event.target.innerText指获取当前点击元素的文本内容 :直接写是 v-bind 的简写 @直接写是 v-on 的简写 事件修饰符prevent，用于操作点击默认的操作 @keyup 键盘事件 ","date":"2024-08-05","objectID":"/posts/text20/:0:5","tags":["vue2","vue3"],"title":"尚硅谷Vue2.0+Vue3.0全套教程","uri":"/posts/text20/"},{"categories":null,"content":"computed计算属性 只有读取的时候，简写get为计算属性名加（）{ get方法 } ","date":"2024-08-05","objectID":"/posts/text20/:0:6","tags":["vue2","vue3"],"title":"尚硅谷Vue2.0+Vue3.0全套教程","uri":"/posts/text20/"},{"categories":null,"content":"深度监视 加deep computed计算属性不能实现异步返回，watch监听属性可以 条件渲染 v-show v-text 对所在节点传入文本内容 v-html 对所在节点传入的 带标签的内容 解析成HTML展示 ","date":"2024-08-05","objectID":"/posts/text20/:0:7","tags":["vue2","vue3"],"title":"尚硅谷Vue2.0+Vue3.0全套教程","uri":"/posts/text20/"},{"categories":null,"content":"生命周期 mounted只调一次 mounted在页面挂载完成之后调用 关键的时间点，调一些函数 这些函数，统称为生命周期函数 beforeCreate() 有vm，可用this，无法访问data和method 生命周期流程：初始化生命周期+事件[数据代理未开始] =\u003e beforeCreate() =\u003e初始化数据监测+数据代理 =\u003e created() created() =\u003e解析模板，生成虚拟dom内存，页面还不能显示解析的好的内容 beforeMount() = \u003e虚拟dom转真是dom，存在vm.$el里 mounted()=\u003e经过编译的等初始化操作 ","date":"2024-08-05","objectID":"/posts/text20/:0:8","tags":["vue2","vue3"],"title":"尚硅谷Vue2.0+Vue3.0全套教程","uri":"/posts/text20/"},{"categories":null,"content":"浏览器本地存储 ：window.localStorage.getItem(‘userInfo’) window.localStorage.setItem(Json.stringify(userInfo)) let userInfo = {} window.localStorage.removeItem(‘userInfo’) 会话存储sessionStorage： 会话会随浏览器窗口关闭而消失 nextTick()等待下一次 DOM 更新刷新的工具方法 setup() 渲染在beforeCreate之前，所有的渲染之前，不能用this，返回return为一个函数 简写形式，语法糖 decode用法 DECODE(value, if1, then1, if2, then2, …, else) ","date":"2024-08-05","objectID":"/posts/text20/:0:9","tags":["vue2","vue3"],"title":"尚硅谷Vue2.0+Vue3.0全套教程","uri":"/posts/text20/"},{"categories":null,"content":"IDEA在Database中连接达梦数据库 repository-达梦8maven.zip · Jared.Yan/dameng-maven - Gitee.com 如果是连接项目代码中的达梦数据库，此处选择的jar包为项目代码依赖中的dm.jar 1、idea右侧点击database 2、照着我的点就行，驱动包记得得先加上才会出现class选项 3、回到主页面，添加一个数据库连接。 4、测试连接，连接成功 ","date":"2024-06-13","objectID":"/posts/text10/:0:0","tags":["达梦数据库"],"title":"IDEA在Database中连接达梦数据库","uri":"/posts/text10/"},{"categories":null,"content":"打开命令行，输入mstsc 点击确认 出现以下界面 输入ip地址及端口号，然后点击连接 提示页面均点，连接 提示页面均点，是 输入用户名和密码即可 ","date":"2024-04-04","objectID":"/posts/text06/:0:0","tags":["远程"],"title":"远程登陆服务器教程","uri":"/posts/text06/"},{"categories":null,"content":"1、现象如下 2、解决办法 3、或者搜索框输入ESLint，选择禁用 ","date":"2022-10-28","objectID":"/posts/text05/:0:0","tags":["vue"],"title":"idea导入ta404前端项目代码后js文件中注释报红色波浪线解决办法","uri":"/posts/text05/"},{"categories":null,"content":"python官网地址：https://www.python.org/ 第1步：先勾选，再安装，上面是默认安装路径，下面是自定义安装路径 等待安装 安装完成，设置MAX_PATH，授管理员权限 打开终端窗口，输入python命令，验证是否安装成功 ","date":"2022-07-08","objectID":"/posts/text04/:0:0","tags":["Python"],"title":"Python下载与安装操作步骤","uri":"/posts/text04/"},{"categories":null,"content":"报错信息Exception in thread “AWT-EventQueue-0” java.lang.UnsatisfiedLinkError: Unable to load library ‘c:\\dcrf32.dll’:Native library (win32-x86-64/c:\\dcrf32.dll) not found in resource path 翻译过来就是：线程“AWT-EventQueue-0”出现异常，无法加载库’c:\\dcrf32.dll’:本机库(win32-x86-64/c:\\dcrf32.dll)在资源路径中找不到 解决办法： 1、我先是检查了jdk 版本，jre是不是选择和动态库相同位数的32 or 64？ 检查jdk版本位数的方法: java -version 2、 动态库是否添加到jdk里面？我检查的时候，是加了的，但是还是报找不到 3、是不是动态库要求放到具体某一个文件夹下了？ Unable to load library ‘c:\\dcrf32.dll’:Native library (win32-x86-64/c:\\dcrf32.dll) not found 这个括号里面搜索的动态库的位置在c盘根目录下，很像是代码写死了访问位置。于是我找代码去了，确实代码里面是指定要求限制了。 解决办法：把动态库的位置移动到c盘根目录下，或者代码访问位置去掉前面的磁盘限制。 这个错找了很久，特此记录 ","date":"2022-05-18","objectID":"/posts/text03/:0:0","tags":["dll文件引用","intellij idea","jar"],"title":"dcrf32.dll","uri":"/posts/text03/"},{"categories":null,"content":"一、聚合函数 有一个学生表如下： ","date":"2021-07-12","objectID":"/posts/text11/:1:0","tags":["SQL"],"title":"SQL语句部分写法","uri":"/posts/text11/"},{"categories":null,"content":"count 1、统计记录总个数 SELECT COUNT (*) FROM 学生表 若要命名 SELECT COUNT (* ) as 学生总人数 FROM 学生表 2、统计指定列的值的数目（NULL 值不计入） SELECT COUNT (专业代码) FROM 学生表 3、统计指定列，拥有不同值的数目（NULL 值不计入） SELECT COUNT (distinct 专业代码) FROM 学生表 ","date":"2021-07-12","objectID":"/posts/text11/:1:1","tags":["SQL"],"title":"SQL语句部分写法","uri":"/posts/text11/"},{"categories":null,"content":"sum 4、计算某一列值的总和 SELECT sum(高考分数) as 高考总分数 FROM 学生表 ","date":"2021-07-12","objectID":"/posts/text11/:1:2","tags":["SQL"],"title":"SQL语句部分写法","uri":"/posts/text11/"},{"categories":null,"content":"MAX、MIN、AVG 5、求某一列值的最大值 MAX 函数返回一列中的最大值。NULL 值不包括在计算中。 注释：MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。 SELECT MAX(高考分数) as 高考最高分数 FROM 学生表 6、求某一列值的最小值 SELECT MIN(高考分数) as 高考最低分数 FROM 学生表 7、求某一列值的平均值 SELECT AVG(高考分数) as 高考最高分数 FROM 学生表 ","date":"2021-07-12","objectID":"/posts/text11/:1:3","tags":["SQL"],"title":"SQL语句部分写法","uri":"/posts/text11/"},{"categories":null,"content":"FIRST、ROUND 6、取指定字段的第一个记录的值 select first(column_name) from table_name 7、ROUND() 函数（四舍五入规则）、用于把数值字段舍入为指定的小数位数。 SELECT round(列名,小数位数) FROM table_name ","date":"2021-07-12","objectID":"/posts/text11/:1:4","tags":["SQL"],"title":"SQL语句部分写法","uri":"/posts/text11/"},{"categories":null,"content":"MID 8、MID() 函数 ：用于从文本字段中提取字符。 SELECT MID(列名,开始截取位置,结束截取位置) FROM table_name SELECT MID(列名,1,3) FROM table_name 3不写，默认返回剩余的所有字段 ","date":"2021-07-12","objectID":"/posts/text11/:1:5","tags":["SQL"],"title":"SQL语句部分写法","uri":"/posts/text11/"},{"categories":null,"content":"LEN 9、LEN 函数返回文本字段中值的长度。 SELECT LEN(列名) FROM table_name ","date":"2021-07-12","objectID":"/posts/text11/:1:6","tags":["SQL"],"title":"SQL语句部分写法","uri":"/posts/text11/"},{"categories":null,"content":"二、数据库查询前10条数据 Oracle中查询 select * from table where rownum\u003c=10; DB2中查询 select * from table fetch first 10 rows only; MySql中查询 select * from table limit 10; ","date":"2021-07-12","objectID":"/posts/text11/:2:0","tags":["SQL"],"title":"SQL语句部分写法","uri":"/posts/text11/"},{"categories":null,"content":"三、SQL语言多表关联查询 一、外连接 外连接可分为：左连接、右连接、完全外连接。 select * from A表 left join B表 on A表条件 = B表条件 左外连接包含left join左表所有行，如果左表中某行在右表没有匹配，则结果中对应行右表的部分全部为空(NULL) select * from A表 right join B表 on A表条件 = B表条件 右外连接包含right join右表所有行，如果左表中某行在右表没有匹配，则结果中对应左表的部分全部为空(NULL)。 select * from A表 full join B表 on A表条件 = B表条件 完全外连接包含full join左右两表中所有的行，如果右表中某行在左表中没有匹配，则结果中对应行右表的部分全部为空(NULL)，如果左表中某行在右表中没有匹配，则结果中对应行左表的部分全部为空(NULL)。 二、内连接 join 或 inner join select * from A表 join B表 on A表条件 = B表条件 inner join 是比较运算符，只返回符合条件的行。 ","date":"2021-07-12","objectID":"/posts/text11/:3:0","tags":["SQL"],"title":"SQL语句部分写法","uri":"/posts/text11/"},{"categories":null,"content":"此网站建立于2024年七夕…… ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我们","uri":"/about/"}]