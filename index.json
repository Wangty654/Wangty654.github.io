[{"categories":["Java"],"content":"计算机网络 计算机网络：多台计算机+连接+信息传递/资源共享 网络编程：多台计算机+程序之间+数据交换 网络模型： TCP/IP参考模型 —— 4层 应用层 传输层 网际层 OSI参考模型 —— 7层模型 应用层：应用程序 表示层：数据解释，加/解密，人机交换 会话层：会话请求，实现通信 传输层：数据传输协议，端口号（TCP/UDP） 网络成：对数据进行IP地址（加/解封装）【设备：路由器；数据：数据包】 数据链接层：MAC地址（加/解封装）【设备：交换机；数据：帧】 物理层 ：传输比特流，定义设备标准，接口类型，传输速率（不同介质/IO流） 网络编程的3要素： IP地址：用于找到电脑 端口：用于区分该电脑上的程序 协议：按照某种规则 两个Dos命令： ipconfig查看本地IP地址 ping 测试本机与指定的IP地址之间通信是否有问题 ","date":"2024-12-27","objectID":"/text44/:1:0","tags":["Java"],"title":"【Java】Java进阶（四）计算机网络","uri":"/text44/"},{"categories":["Java"],"content":"二、IP地址（标识号） 1、定义 指定和识别计算机，网络中，计算机的唯一标识。 2、十进制表示 问：计算机只能识别二进制的数据，IP地址应该是一个二进制的数据，但我们配置的IP地址却不是二进制的为什么？ IP地址组成：网络号段+主机号段 192.168.1.100 换算 00000000 10101000 00000001 01100100 如此配置IP地址，记忆会比较麻烦，所以每一个字节换成十进制，用点分开。这种方法叫点分十进制 3、IP地址分类： A类：1.0.0.1 ~ 127.255.255.254 ​ 第一号段为网络号段（机号段 256×256×256，可配16777216台） B类：128.0.0.1 ~ 191.255.255.254 ​ 前两段为网络号段，后两位为主机号段（机号段 256×256，可配65536台） C类：192.0.0.1 ~ 233.255.255.254 (前三段为网络号段，主机号段可配256台) D类：224.0.0.1 ~ 239.255.255.254 （D类为保留地址） E类：240.0.0.1 ~ 247.255.255.254 （E类为保留地址） This is a tip\r10.x.x.x 和 192.168.x.x 为私有地址，在互联网上不使用，在局域网中使用 特殊的IP地址： 127.0.0.1 回环地址（表示本机） x.x.x.255 广播地址 x.x.x.0 网络地址 4、InetAddress InetAddress 是 Java 中的一个类，用于表示 Internet 互联网协议（IP）地址。它在网络编程中非常重要，主要用于处理与 IP 地址和主机名相关的操作。 主要功能 主机名解析：可以将主机名（例如 www.example.com）转换为对应的 IP 地址。 获取本地主机：可以通过 InetAddress.getLocalHost() 方法获取本机的 IP 地址。 处理 IP 地址：可以从 IP 地址创建 InetAddress 对象，也可以从 IP 地址获取主机名等。 常用方法 public static InetAddress getByName(String host)：返回指定主机的 IP 地址。 public static InetAddress getLocalHost()：返回本地主机的 IP 地址。 public String getHostName()：获取该 IP 地址对应的主机名。 public String getHostAddress()：返回 IP 地址的字符串表示。 public boolean isReachable(int timeout)：测试该 IP 地址在指定的超时时间内是否可达。 示例代码 以下是一个简单的 Java 示例，展示如何使用 InetAddress： import java.net.InetAddress; public class Main { public static void main(String[] args) { try { // 获取主机的 IP 地址 InetAddress inetAddress = InetAddress.getByName(\"www.example.com\"); System.out.println(\"IP 地址: \" + inetAddress.getHostAddress()); System.out.println(\"主机名: \" + inetAddress.getHostName()); // 获取本地主机 InetAddress localHost = InetAddress.getLocalHost(); System.out.println(\"本地主机 IP 地址: \" + localHost.getHostAddress()); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2024-12-27","objectID":"/text44/:1:1","tags":["Java"],"title":"【Java】Java进阶（四）计算机网络","uri":"/text44/"},{"categories":["Java"],"content":"三、 端口号： 物理端口/逻辑端口（我们指端口，一般说的是逻辑端口） 每一个网络程序都至少一个逻辑端口 用于标识进程（运行中的程序）的逻辑地址，不同进程的标识 有效端口：0~65535、0~1074系统使用或保留端口 ","date":"2024-12-27","objectID":"/text44/:1:2","tags":["Java"],"title":"【Java】Java进阶（四）计算机网络","uri":"/text44/"},{"categories":["Java"],"content":"四、协议（通信的规则） Socket Socket 是网络编程中的一个重要类，尤其在 Java 中，用于处理 TCP/IP 协议下的网络通信。它提供了一种将计算机之间建立连接并进行双向通信的方式。 主要功能 建立连接：Socket 类允许客户端通过 IP 地址和端口号与服务器建立连接。 数据传输：一旦连接建立，客户端和服务器可以通过输入流和输出流进行数据传输。 关闭连接：完成通信后，可以关闭 Socket 以释放资源。 常用方法 public InputStream getInputStream()：返回与此套接字关联的输入流，用于接收数据。 public OutputStream getOutputStream()：返回与此套接字关联的输出流，用于发送数据。 public void close()：关闭套接字并释放与之关联的资源。 public InetAddress getInetAddress()：返回与此套接字关联的远程 IP 地址。 用法示例 以下是一个简单的 Java 示例，展示如何创建一个 Socket 并进行基本的通信： 服务器端 import java.net.ServerSocket; import java.net.Socket; import java.io.InputStreamReader; import java.io.BufferedReader; import java.io.PrintWriter; public class Server { public static void main(String[] args) { try (ServerSocket serverSocket = new ServerSocket(12345)) { System.out.println(\"服务器启动，等待客户端连接...\"); Socket socket = serverSocket.accept(); // 等待客户端连接 System.out.println(\"客户端已连接: \" + socket.getInetAddress()); // 获取输入流 BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); String clientMessage; while ((clientMessage = in.readLine()) != null) { System.out.println(\"客户端消息: \" + clientMessage); out.println(\"服务器回应: \" + clientMessage); // echo back } } catch (Exception e) { e.printStackTrace(); } } } 客户端 import java.net.Socket; import java.io.PrintWriter; import java.io.BufferedReader; import java.io.InputStreamReader; public class Client { public static void main(String[] args) { try (Socket socket = new Socket(\"localhost\", 12345)) { PrintWriter out = new PrintWriter(socket.getOutputStream(), true); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); out.println(\"你好，服务器！\"); String response = in.readLine(); System.out.println(\"收到的回应: \" + response); } catch (Exception e) { e.printStackTrace(); } } } 在这个例子中，服务器在特定端口（12345）上监听客户端连接，而客户端连接到服务器并发送一条消息。服务器接受消息并返回相同的消息。 UDP协议 UDP（用户数据报协议）是一种无连接的协议，适用于发送短小的数据报，提供简单而快速的数据传输。UDP 不保证数据的完整性、顺序或重传，因此在实时应用（例如视频通话、在线游戏）中常用。 使用 Java 通过 UDP 发送数据 在 Java 中，你可以使用 DatagramSocket 和 DatagramPacket 类来发送和接收 UDP 数据报。 UDP 发送数据的基本步骤 创建 DatagramSocket：用于发送数据的套接字。 构造数据包 DatagramPacket：包含要发送的数据、目标地址和端口号。 发送数据包：使用 send() 方法发送数据包。 关闭套接字：数据发送完成后，关闭套接字。 UDP 接收数据的基本步骤 创建 DatagramSocket：在指定端口上创建一个套接字以监听接入的数据包。 创建接收数据包 DatagramPacket：定义一个缓冲区，用于存储接收到的数据。 接收数据包：使用 receive() 方法接收数据包。 处理数据：从数据包中提取数据并进行处理。 关闭套接字：完成接收后，关闭套接字。 示例代码 下面是一个简单的示例，展示如何使用 UDP 发送数据： UDP 客户端 import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; public class UDPClient { public static void main(String[] args) { DatagramSocket socket = null; try { socket = new DatagramSocket(); String message = \"Hello, UDP Server!\"; byte[] buffer = message.getBytes(); // 要发送的数据包 InetAddress address = InetAddress.getByName(\"localhost\"); DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 12345); // 发送数据包 socket.send(packet); System.out.println(\"数据已发送: \" + message); } catch (Exception e) { e.printStackTrace(); } finally { if (socket != null \u0026\u0026 !socket.isClosed()) { socket.close(); } } } } UDP 服务器 import java.net.DatagramPacket; import java.net.DatagramSocket; public class UDPServer { public static void main(String[] args) { DatagramSocket socket = null; try { // 在端口 12345 上创建 DatagramSocket socket = new DatagramSocket(12345); byte[] buffer = new byte[1024]; // 接收缓冲区 System.out.println(\"服务器已启动，等待接收数据...\"); while (true) { // 创建接收数据包 DatagramPacket packet = new DatagramPacket(buffer, buffer.length); // 接收数据包 socket.receive(packet); // 从数据包中获取消息 String receivedMessage = new String(packet.getData(), 0, packet.getLength()); System.out.println(\"接收到的消息: \" + receivedMessage); // 如果需要，可以回复给客户端（可选） // 这里可以选择是否回复数据 } } catch (Exception e) { e.printStackTrace(); } finally { if (socket != null \u0026\u0026 !socket.isClosed()) { socket.close(); } } } } 代码说明 UDP 服务器：在端口 12345 上监听来自客户端的数据报，一旦接收到数据，即打印出内容。 UDP 客户端：创建数据报并发送包含 “Hello, UDP Server!” 的消息到服务器。 通过这种方式，可以实现利用 UDP 协议在客户端和服务器之间进行数据传输。 UDP协议特点 把数据打包（数据源+目的） 数据有限制 64k 不建立连接 速度","date":"2024-12-27","objectID":"/text44/:1:3","tags":["Java"],"title":"【Java】Java进阶（四）计算机网络","uri":"/text44/"},{"categories":["Java"],"content":"类加载 类的加载：加载 → 连接【验证、准备、解析】→ 初始化 类加载器：复制将class文件加载到内存中，并生成对应的class对象 Bootstrap ClassLoader 根类·加载器：负责Java核心类的加载【jdk\\jre\\lib】 Extension ClassLoader 扩展类·加载器：负责jre的扩展目录中jar包的加载 System ClassLoader 系统类·加载器：负责jvm启动时，class文件的加载 java类中运算符优先级： () ! + - ++ -- 正负 * / % + - 加减 \u003c \u003c= \u003e= \u003e == != ^ \u0026\u0026 || ?= = += -= *= /= %= ","date":"2024-12-27","objectID":"/text44/:2:0","tags":["Java"],"title":"【Java】Java进阶（四）计算机网络","uri":"/text44/"},{"categories":["Java"],"content":"基础排序算法 在Java中，基础的排序算法 包括插入排序、冒泡排序和选择排序。这些算法相对简单易懂，适合学习排序算法的基本概念。下面是对每种算法的详细介绍，包括它们的原理、时间复杂度以及实现示例。 ","date":"2024-12-27","objectID":"/text43/:1:0","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"1. 插入排序（Insertion Sort） 原理：插入排序通过构建一个有序的子数组，将新元素插入到适当的位置，以保持数组的有序性。它的工作方式类似于在纸上排序扑克牌，逐一将每张牌放入合适的位置。 时间复杂度： 最坏情况：O(n²) 平均情况：O(n²) 最好情况：O(n)（当数组已经基本有序时） 实现： public class InsertionSort { public static void insertionSort(int[] array) { for (int i = 1; i \u003c array.length; i++) { int key = array[i]; int j = i - 1; // 将大于key的元素移动到它的后面 while (j \u003e= 0 \u0026\u0026 array[j] \u003e key) { array[j + 1] = array[j]; j--; } array[j + 1] = key; // 将key放到正确位置 } } public static void main(String[] args) { int[] array = {12, 11, 13, 5, 6}; insertionSort(array); System.out.println(java.util.Arrays.toString(array)); } } ","date":"2024-12-27","objectID":"/text43/:1:1","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"2. 冒泡排序（Bubble Sort） 原理：冒泡排序通过比较相邻的元素并交换它们的顺序，将较大的元素逐渐“冒泡”到数组的末尾。这个过程会重复进行，直到没有需要交换的元素为止。[每一轮比较完毕后，下一次比较的时候就会减少一个元素（一轮结束，最后一个元素一定为最大元素）。总共需要比较数组长度-1次] 时间复杂度： 最坏情况：O(n²) 平均情况：O(n²) 最好情况：O(n)（当数组已经基本有序时） 实现： public class BubbleSort { public static void bubbleSort(int[] array) { int n = array.length; boolean swapped; for (int i = 0; i \u003c n - 1; i++) { swapped = false; // 每次遍历都将最大元素移动到末尾 for (int j = 0; j \u003c n - 1 - i; j++) { if (array[j] \u003e array[j + 1]) { // 交换元素 int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; swapped = true; // 表示发生了交换 } } // 如果没有交换，说明数组已经有序，直接退出 if (!swapped) break; } } public static void main(String[] args) { int[] array = {64, 34, 25, 12, 22, 11, 90}; bubbleSort(array); System.out.println(java.util.Arrays.toString(array)); } } ","date":"2024-12-27","objectID":"/text43/:1:2","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"3. 选择排序（Selection Sort） 原理：选择排序分为多个步骤，每一步从未排序部分选择最小（或最大）的元素，将其放到已排序部分的末尾。这个过程重复进行，直到所有元素均在相应位置。 时间复杂度： 最坏情况：O(n²) 平均情况：O(n²) 最好情况：O(n²) 实现： public class SelectionSort { public static void selectionSort(int[] array) { int n = array.length; // 遍历数组 for (int i = 0; i \u003c n - 1; i++) { // 找到未排序部分的最小元素 int minIndex = i; for (int j = i + 1; j \u003c n; j++) { if (array[j] \u003c array[minIndex]) { minIndex = j; } } // 交换未排序部分的第一个元素和最小元素 int temp = array[minIndex]; array[minIndex] = array[i]; array[i] = temp; } } public static void main(String[] args) { int[] array = {29, 10, 14, 37, 13}; selectionSort(array); System.out.println(java.util.Arrays.toString(array)); } } 在Java中，有多种高级排序算法可以用于对数组或集合进行排序，这些算法比基础的排序算法（如插入排序或冒泡排序）更为高效。以下是一些流行的高级排序算法的介绍，包括它们的原理、时间复杂度和在Java中的实现方式。 ","date":"2024-12-27","objectID":"/text43/:1:3","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"高级排序算法 ","date":"2024-12-27","objectID":"/text43/:2:0","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"1. 归并排序（Merge Sort） 原理：归并排序是一种分治算法。它将数组分成两个子数组，分别对这两个子数组进行排序，然后将它们合并成一个排好序的数组。 时间复杂度：O(n log n) 实现： public class MergeSort { public static void mergeSort(int[] array) { if (array.length \u003c 2) { return; } int mid = array.length / 2; int[] left = new int[mid]; int[] right = new int[array.length - mid]; for (int i = 0; i \u003c mid; i++) { left[i] = array[i]; } for (int i = mid; i \u003c array.length; i++) { right[i - mid] = array[i]; } mergeSort(left); mergeSort(right); merge(array, left, right); } private static void merge(int[] array, int[] left, int[] right) { int i = 0, j = 0, k = 0; while (i \u003c left.length \u0026\u0026 j \u003c right.length) { if (left[i] \u003c= right[j]) { array[k++] = left[i++]; } else { array[k++] = right[j++]; } } while (i \u003c left.length) { array[k++] = left[i++]; } while (j \u003c right.length) { array[k++] = right[j++]; } } public static void main(String[] args) { int[] array = {38, 27, 43, 3, 9, 82, 10}; mergeSort(array); System.out.println(java.util.Arrays.toString(array)); } } ","date":"2024-12-27","objectID":"/text43/:2:1","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"2. 快速排序（Quick Sort） 原理：快速排序也是一种分治算法。它选择一个“基准”元素，将数组分成两个部分，小于基准的元素在左边，大于基准的元素在右边。然后对这两部分继续进行排序。 时间复杂度：平均情况 O(n log n)，最坏情况 O(n²) 实现： public class QuickSort { public static void quickSort(int[] array, int low, int high) { if (low \u003c high) { int pi = partition(array, low, high); quickSort(array, low, pi - 1); quickSort(array, pi + 1, high); } } private static int partition(int[] array, int low, int high) { int pivot = array[high]; int i = (low - 1); for (int j = low; j \u003c high; j++) { if (array[j] \u003c pivot) { i++; int temp = array[i]; array[i] = array[j]; array[j] = temp; } } int temp = array[i + 1]; array[i + 1] = array[high]; array[high] = temp; return i + 1; } public static void main(String[] args) { int[] array = {10, 80, 30, 90, 40, 50, 70}; quickSort(array, 0, array.length - 1); System.out.println(java.util.Arrays.toString(array)); } } ","date":"2024-12-27","objectID":"/text43/:2:2","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"3. 堆排序（Heap Sort） 原理：堆排序利用堆的数据结构。首先构建最大堆或最小堆，然后反复取出堆顶元素，将其放到已排序的数组末端。 时间复杂度：O(n log n) 实现： public class HeapSort { public static void heapSort(int[] array) { int n = array.length; for (int i = n / 2 - 1; i \u003e= 0; i--) { heapify(array, n, i); } for (int i = n - 1; i \u003e 0; i--) { int temp = array[0]; array[0] = array[i]; array[i] = temp; heapify(array, i, 0); } } private static void heapify(int[] array, int n, int i) { int largest = i; int left = 2 * i + 1; int right = 2 * i + 2; if (left \u003c n \u0026\u0026 array[left] \u003e array[largest]) { largest = left; } if (right \u003c n \u0026\u0026 array[right] \u003e array[largest]) { largest = right; } if (largest != i) { int swap = array[i]; array[i] = array[largest]; array[largest] = swap; heapify(array, n, largest); } } public static void main(String[] args) { int[] array = {12, 11, 13, 5, 6, 7}; heapSort(array); System.out.println(java.util.Arrays.toString(array)); } } ","date":"2024-12-27","objectID":"/text43/:2:3","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"4. 桶排序（Bucket Sort） 原理：桶排序将数据元素分到有限数量的桶中，每个桶再单独排序（可以使用其他排序算法），最终顺序输出。 时间复杂度：O(n + k)，其中k是桶的数量（在理想情况下）。 实现： import java.util.ArrayList; import java.util.Collections; public class BucketSort { public static void bucketSort(float[] array) { int n = array.length; if (n \u003c= 0) return; // 创建桶 ArrayList\u003cFloat\u003e[] buckets = new ArrayList[n]; for (int i = 0; i \u003c n; i++) { buckets[i] = new ArrayList\u003c\u003e(); } // 将元素分入桶中 for (float value : array) { int index = (int) (n * value); // 假设浮点数范围为[0, 1) buckets[index].add(value); } // 对每个桶进行排序 for (ArrayList\u003cFloat\u003e bucket : buckets) { Collections.sort(bucket); } // 合并结果 int index = 0; for (ArrayList\u003cFloat\u003e bucket : buckets) { for (Float value : bucket) { array[index++] = value; } } } public static void main(String[] args) { float[] array = {0.42f, 0.32f, 0.23f, 0.45f, 0.12f, 0.67f}; bucketSort(array); System.out.println(java.util.Arrays.toString(array)); } } ","date":"2024-12-27","objectID":"/text43/:2:4","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"5.希尔排序（Shell Sort） 原理： 初始时，将整个数组分成若干个子数组（根据指定的间隔），对每个子数组进行插入排序。 然后逐渐减少间隔，最终变成一个完整的数组，进行最后的插入排序。 这种方法能够显著减少需要移动的元素数，因此在大多数情况下比简单的插入排序更高效。 时间复杂度：希尔排序的时间复杂度依赖于间隔序列的选择，最坏情况下为 O(n²)，而在使用合适的间隔序列（如希尔原始间隔序列、Hibbard间隔序列、Sedgewick间隔序列等）时，希尔排序的平均时间复杂度可以达到 O(n^(3/2)) 或 O(n log² n)。 实现： 选择一个初始的“间隔” h，通常是数组长度的一半。 将数组划分成多个子数组，每个子数组之间的间隔为 h。 对每个子数组进行插入排序。 减少间隔（如 h = h / 2），重复步骤 2 和 3，直到间隔减小到 1。 最后一次插入排序，将数组完全排序。 代码示例： public class ShellSort { public static void shellSort(int[] array) { int n = array.length; // 选择初始间隔 for (int gap = n / 2; gap \u003e 0; gap /= 2) { // 对间隔为 gap 的子数组进行插入排序 for (int i = gap; i \u003c n; i++) { int key = array[i]; int j = i; // 向前移动 gap 个元素 while (j \u003e= gap \u0026\u0026 array[j - gap] \u003e key) { array[j] = array[j - gap]; j -= gap; } array[j] = key; // 将 key 放到合适的位置 } } } public static void main(String[] args) { int[] array = {12, 34, 54, 2, 3}; shellSort(array); System.out.println(java.util.Arrays.toString(array)); } } 输入：{12, 34, 54, 2, 3} 输出：{2, 3, 12, 34, 54} 当数据量较大或需要频繁的插入和删除时，选择快速排序和堆排序通常是更优的选择。 归并排序则在处理链表等数据结构时表现出色。 ","date":"2024-12-27","objectID":"/text43/:2:5","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"高级查找 基本查找为无序（从头找到尾），高级查找为有序。 在Java中，高级查找算法用于在数据集合中高效地查找元素。这些算法通常比简单的线性查找更为高效，特别是在处理较大数据集时。以下是几种常见的高级查找算法，以及它们的原理、时间复杂度和实现示例。 二分查找：适用于已排序数组。 哈希表查找：适用于需要频繁查找的场景，常用在键值对存储中。 跳跃查找：适用于较大的已排序数组，提供了更高效的查找。 插值查找：适用于均匀分布的已排序数组。 ","date":"2024-12-27","objectID":"/text43/:3:0","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"1. 二分查找（Binary Search） 原理：二分查找用于在已排序的数组中查找一个特定的元素。它通过反复将查找范围缩小为一半来快速定位目标值（折半查找）。每次比较中间元素和目标值，如果中间元素等于目标值，查找成功；如果目标值小于中间元素，则在左半部分继续查找，否则在右半部分继续查找。 时间复杂度： O(log n) 实现： public class BinarySearch { public static int binarySearch(int[] array, int target) { int left = 0; int right = array.length - 1; while (left \u003c= right) { int mid = left + (right - left) / 2; // 防止溢出 if (array[mid] == target) { return mid; // 找到目标值，返回索引 } if (array[mid] \u003c target) { left = mid + 1; // 在右半部分查找 } else { right = mid - 1; // 在左半部分查找 } } return -1; // 未找到目标值 } public static void main(String[] args) { int[] array = {2, 3, 4, 10, 40}; int target = 10; int result = binarySearch(array, target); if (result != -1) { System.out.println(\"元素在索引 \" + result + \" 处被找到\"); } else { System.out.println(\"元素未找到\"); } } } ","date":"2024-12-27","objectID":"/text43/:3:1","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"2. 哈希表查找（Hash Table Search） 原理：哈希表使用哈希函数将键映射到表中的位置，从而实现常量时间复杂度的查找。由于哈希表基于键值对存储数据，可以迅速找到目标元素。 时间复杂度： 平均情况：O(1) 最坏情况：O(n)（发生冲突时） 实现： 使用 Java 的 HashMap 进行查找： import java.util.HashMap; public class HashTableSearch { public static void main(String[] args) { HashMap\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); map.put(\"apple\", 1); map.put(\"banana\", 2); map.put(\"orange\", 3); String keyToFind = \"banana\"; Integer value = map.get(keyToFind); if (value != null) { System.out.println(\"键 \" + keyToFind + \" 的值是 \" + value); } else { System.out.println(\"未找到键 \" + keyToFind); } } } ","date":"2024-12-27","objectID":"/text43/:3:2","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"3. 瀑布流查找（Jump Search） 原理：跳跃查找是一种结合了线性查找与二分查找的查找算法。它先以固定的步长跳跃到达数组中某个位置，然后在这个位置进行线性查找。 时间复杂度： O(√n) 实现： public class JumpSearch { public static int jumpSearch(int[] array, int target) { int n = array.length; int step = (int) Math.sqrt(n); int prev = 0; // 找到块中的目标索引 while (array[Math.min(step, n) - 1] \u003c target) { prev = step; step += (int) Math.sqrt(n); if (prev \u003e= n) return -1; // 越界 } // 在线性区间内查找目标值 for (int i = prev; i \u003c Math.min(step, n); i++) { if (array[i] == target) return i; // 找到目标值 } return -1; // 未找到 } public static void main(String[] args) { int[] array = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; int target = 5; int result = jumpSearch(array, target); if (result != -1) { System.out.println(\"元素在索引 \" + result + \" 处被找到\"); } else { System.out.println(\"元素未找到\"); } } } ","date":"2024-12-27","objectID":"/text43/:3:3","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"4. 插值查找（Interpolation Search） 原理：插值查找是一种改进的二分查找，适用于均匀分布的数组。它根据目标值与最小和最大值的关系，动态计算应该查找的位置来跳过不必要的中间值查找。 时间复杂度： 最坏情况：O(n) 平均情况：O(log log n) 实现： public class InterpolationSearch { public static int interpolationSearch(int[] array, int target) { int low = 0; int high = array.length - 1; while (low \u003c= high \u0026\u0026 target \u003e= array[low] \u0026\u0026 target \u003c= array[high]) { // 计算插值位置 int pos = low + (target - array[low]) * (high - low) / (array[high] - array[low]); if (array[pos] == target) return pos; // 找到目标值 if (array[pos] \u003c target) { low = pos + 1; // 在右部分查找 } else { high = pos - 1; // 在左部分查找 } } return -1; // 未找到 } public static void main(String[] args) { int[] array = {10, 20, 30, 40, 50}; int target = 30; int result = interpolationSearch(array, target); if (result != -1) { System.out.println(\"元素在索引 \" + result + \" 处被找到\"); } else { System.out.println(\"元素未找到\"); } } } ","date":"2024-12-27","objectID":"/text43/:3:4","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"包装类 在Java中，包装类（Wrapper Classes）是为了将基本数据类型（primitive data types）包装成对象类型（object types）而提供的类。每个基本数据类型都有一个对应的包装类，这些类使得基本类型可以像对象一样使用，提供了更多的功能。 ","date":"2024-12-27","objectID":"/text43/:4:0","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"1. 基本数据类型与其包装类 基本数据类型 对应的包装类 boolean Boolean byte Byte char Character double Double float Float int Integer long Long short Short ","date":"2024-12-27","objectID":"/text43/:4:1","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"2. 包装类的主要功能 对象化：基本数据类型不能用于某些需要对象的地方，比如集合（例如：ArrayList、HashMap等），而包装类则可以。 方法的使用 ：每个包装类都提供了一些方法，例如： parseXXX：将字符串转换为基本类型，如 Integer.parseInt() valueOf：将基本类型转换为包装类对象 toString：将包装类对象转换为字符串表示 常量：各个包装类中都有一些常量，例如 Integer.MAX_VALUE 表示 int 类型的最大值。 ","date":"2024-12-27","objectID":"/text43/:4:2","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"3. 示例代码 以下展示了如何使用各个包装类： public class WrapperExample { public static void main(String[] args) { // 使用 Integer 包装类 Integer intValue = Integer.valueOf(10); // 装箱 int intPrimitive = intValue.intValue(); // 拆箱 System.out.println(\"Integer value: \" + intValue); // 使用 Double 包装类 Double doubleValue = Double.valueOf(25.5); // 装箱 System.out.println(\"Double value: \" + doubleValue); // 使用 Boolean 包装类 Boolean boolValue = Boolean.valueOf(true); // 装箱 System.out.println(\"Boolean value: \" + boolValue); // 使用 Character 包装类 Character charValue = Character.valueOf('A'); // 装箱 System.out.println(\"Character value: \" + charValue); // 包装类与集合结合使用 java.util.List\u003cInteger\u003e numberList = new java.util.ArrayList\u003c\u003e(); numberList.add(intValue); // 可以添加 Integer 对象 System.out.println(\"List contains: \" + numberList); // 自动装箱和拆箱示例 Integer autoBoxedValue = 20; // 自动装箱 int autoUnboxedValue = autoBoxedValue; // 自动拆箱 System.out.println(\"Auto-boxed value: \" + autoBoxedValue); System.out.println(\"Auto-unboxed value: \" + autoUnboxedValue); } } ","date":"2024-12-27","objectID":"/text43/:4:3","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"4. 自动装箱与拆箱 Java 1.5 引入了**自动装箱（Autoboxing）和自动拆箱（Unboxing）**的特性，允许编译器自动将基本数据类型与其对应的包装类之间的转换。例如： 将基本类型直接赋值给对应的包装类（自动装箱）： Integer num = 100; // 自动装箱 将包装类直接赋值给基本类型变量（自动拆箱）： int number = num; // 自动拆箱 ","date":"2024-12-27","objectID":"/text43/:4:4","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"5. 包装类的优缺点 优点： 提供了基本类型不具备的功能和灵活性。 允许基本类型在需要对象的地方使用（如集合）。 缺点： 包装类在内存使用上更为消耗，因为对象的开销大于基本数据类型。 自动装箱和拆箱可能导致性能问题，尤其是在高频调用中。 ","date":"2024-12-27","objectID":"/text43/:4:5","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"Biglnteger类 BigInteger类是Java中处理任意精度整数的强大工具，适用于需要高精度数值计算的场景。通过使用BigInteger，开发者可以轻松处理超出标准数据类型限制的数值计算任务。 在Java中，BigInteger类是一个用于处理任意精度的整数的类，主要用于解决整型数器范围受限的问题。它位于java.math包中，允许开发者处理比int或long更大的整数值。BigInteger类常用在需要高精度数值计算的场景，比如数学运算、密码学和大数处理等。 ","date":"2024-12-27","objectID":"/text43/:5:0","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"1. 主要特点 任意精度：BigInteger可以处理超出标准数据类型（如int、long）所能表示的范围的大整数。 不可变性：BigInteger对象是不可变的，任何对其值的修改都会返回一个新的BigInteger对象，而不会更改原对象。 数学运算：提供了丰富的方法支持各种数学运算，包括加、减、乘、除以及取模等。 ","date":"2024-12-27","objectID":"/text43/:5:1","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"2. 常用字段和方法 2.1 创建BigInteger对象 构造函数： BigInteger(String val)：根据字符串创建一个BigInteger。 BigInteger(int signum, byte[] magnitude)：根据符号和大小构造一个BigInteger。 2.2 常用方法 基本操作： BigInteger add(BigInteger val)：返回两个BigInteger的和。 BigInteger subtract(BigInteger val)：返回两个BigInteger的差。 BigInteger multiply(BigInteger val)：返回两个BigInteger的积。 BigInteger divide(BigInteger val)：返回两个BigInteger的商。 BigInteger mod(BigInteger val)：返回两个BigInteger的模。 比较方法： int compareTo(BigInteger val)：比较两个BigInteger的大小，返回负数、零或正数。 boolean equals(Object x)：判断两个BigInteger是否相等。 次幂与开方： BigInteger pow(int exponent)：返回当前BigInteger的指定次幂。 BigInteger gcd(BigInteger val)：计算当前BigInteger与另一个BigInteger的最大公约数。 转换方法： long longValue()：将BigInteger转换为long类型。 String toString()：将BigInteger转换为字符串表示。 ","date":"2024-12-27","objectID":"/text43/:5:2","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"3. 示例代码 以下是一个示例程序，演示了BigInteger的基本用法： import java.math.BigInteger; public class BigIntegerExample { public static void main(String[] args) { // 创建BigInteger对象 BigInteger bigInt1 = new BigInteger(\"123456789012345678901234567890\"); BigInteger bigInt2 = new BigInteger(\"987654321098765432109876543210\"); // 加法 BigInteger sum = bigInt1.add(bigInt2); System.out.println(\"和: \" + sum); // 减法 BigInteger difference = bigInt1.subtract(bigInt2); System.out.println(\"差: \" + difference); // 乘法 BigInteger product = bigInt1.multiply(bigInt2); System.out.println(\"积: \" + product); // 除法 BigInteger quotient = bigInt2.divide(bigInt1); System.out.println(\"商: \" + quotient); // 求模 BigInteger remainder = bigInt2.mod(bigInt1); System.out.println(\"余数: \" + remainder); // 次幂 BigInteger power = bigInt1.pow(2); System.out.println(\"平方: \" + power); // 比较 int comparison = bigInt1.compareTo(bigInt2); System.out.println(\"比较结果: \" + (comparison \u003c 0 ? \"大于\" : comparison \u003e 0 ? \"小于\" : \"等于\")); // 最大公约数 BigInteger gcd = bigInt1.gcd(bigInt2); System.out.println(\"最大公约数: \" + gcd); } } ","date":"2024-12-27","objectID":"/text43/:5:3","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"4. 使用场景 金融计算：在需要处理很大金额的金融应用中，BigInteger提供了安全的数值处理方式。 密码学应用：在进行加密和解密时，常常需要使用较大的随机数和素数，BigInteger非常适合这种用途。 大数据处理：在数据分析中，处理数值的需要超出基本数据类型的范围时，可以使用BigInteger。 ","date":"2024-12-27","objectID":"/text43/:5:4","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"正则表达式 在Java中，正则表达式（Regular Expressions）是一种用于描述字符串模式的工具，可以用来对字符串进行搜索、校验、替换等操作。Java的正则表达式支持由java.util.regex包提供，主要包含以下几个类： Pattern: 表示编译后的正则表达式。 Matcher: 用于在字符串中执行匹配操作。 PatternSyntaxException: 表示正则表达式的语法错误。 ","date":"2024-12-27","objectID":"/text43/:6:0","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"1. 基本用法 创建一个Pattern 使用Pattern.compile(String regex)方法编译一个正则表达式，返回一个Pattern对象。 import java.util.regex.Pattern; Pattern pattern = Pattern.compile(\"abc\"); 创建一个Matcher 使用Pattern.matcher(String input)方法创建一个Matcher对象，该对象对输入字符串执行匹配操作。 import java.util.regex.Matcher; String input = \"abcdef\"; Matcher matcher = pattern.matcher(input); ","date":"2024-12-27","objectID":"/text43/:6:1","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"2. 常用方法 find(): 查找下一个匹配项。 matches(): 检查整个输入字符串是否匹配正则表达式。 replaceAll(String replacement): 用替换字符串替换所有匹配的子字符串。 replaceFirst(String replacement): 用替换字符串替换第一个匹配的子字符串。 ","date":"2024-12-27","objectID":"/text43/:6:2","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"3. 示例代码 以下是一个简单的示例，演示了如何使用正则表达式来查找、替换和分割字符串。 import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexExample { public static void main(String[] args) { String input = \"Hello World! Welcome to the world of Java.\"; // 创建正则表达式 Pattern pattern = Pattern.compile(\"world\", Pattern.CASE_INSENSITIVE); // 不区分大小写 // 创建 Matcher 对象 Matcher matcher = pattern.matcher(input); // 查找匹配项 while (matcher.find()) { System.out.println(\"Found at index: \" + matcher.start()); // 输出匹配项的起始索引 } // 替换所有匹配项 String replacedString = matcher.replaceAll(\"universe\"); System.out.println(\"Replaced String: \" + replacedString); // 使用正则表达式分割字符串 String[] words = input.split(\"\\\\W+\"); // 根据非单词字符分割 for (String word : words) { System.out.println(word); } } } ","date":"2024-12-27","objectID":"/text43/:6:3","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"4. 常见正则表达式 .: 匹配任意单个字符（除换行符外）。 *: 匹配前一个字符零次或多次。 +: 匹配前一个字符一次或多次。 ?: 匹配前一个字符零次或一次。 ^: 匹配输入字符串的开始。 $: 匹配输入字符串的结束。 {n}: 精确匹配n次。 {n,}: 匹配至少n次。 {n,m}: 匹配n到m次。 []: 指定字符集，例如 [abc] 匹配a、b、或c。 |: 或操作符，例如 abc|def 匹配abc或def。 \\\\d: 匹配任何数字，等同于 [0-9]。 \\\\D: 匹配任何非数字字符。 \\\\w: 匹配任何字母数字字符，等同于 [a-zA-Z_0-9]。 \\\\W: 匹配任何非字母数字字符。 \\\\s: 匹配任何空白字符。 \\\\S: 匹配任何非空白字符。 ","date":"2024-12-27","objectID":"/text43/:6:4","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"5. 小提示 Java中的正则表达式使用双反斜杠，例如要匹配一个点.，需要使用\\\\.。 ","date":"2024-12-27","objectID":"/text43/:6:5","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"Math类 在Java中，Math类是一个提供各种数学操作的工具类，包含了一系列静态方法，方便进行常见的数学计算。Math类位于java.lang包中，因此不需要额外导入。这个类的方法可以用于浮点数和整数运算，涵盖了基本的算术运算、三角函数、对数、幂运算等。 ","date":"2024-12-27","objectID":"/text43/:7:0","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"1. 主要特点 所有方法都是静态的：可以直接通过Math类调用，而无需创建实例。 不允许实例化：Math类的构造器是私有的，不能被实例化。 提供了常量：如Math.PI和Math.E，分别表示π和自然常数e的值。 ","date":"2024-12-27","objectID":"/text43/:7:1","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"2. 常用方法 以下是Math类中一些常用方法的概述： 2.1 基本数学运算 Math.abs(x): 计算绝对值。 Math.ceil(x): 向上取整，返回大于或等于x的最小整数。 Math.floor(x): 向下取整，返回小于或等于x的最大整数。 Math.round(x): 四舍五入，返回最接近的整数。 Math.max(a, b): 返回两个值中的最大值。 Math.min(a, b): 返回两个值中的最小值。 2.2 乘方和开方 Math.pow(x, y): 计算x的y次方。 Math.sqrt(x): 计算x的平方根。 2.3 三角函数 Math.sin(x): 计算x的正弦值（x以弧度为单位）。 Math.cos(x): 计算x的余弦值。 Math.tan(x): 计算x的正切值。 Math.asin(x), Math.acos(x), Math.atan(x)：分别计算反正弦、反余弦和反正切。 2.4 指数和对数 Math.exp(x): 计算e的x次方。 Math.log(x): 计算以e为底的x的对数。 Math.log10(x): 计算以10为底的x的对数。 2.5 随机数生成 Math.random(): 返回0.0到1.0之间的随机数。 ","date":"2024-12-27","objectID":"/text43/:7:2","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"3. 示例代码 以下是一个简单示例，演示了Math类的常用方法： public class MathExample { public static void main(String[] args) { double x = -5.5; double y = 2.0; // 绝对值 System.out.println(\"绝对值: \" + Math.abs(x)); // 向上取整 System.out.println(\"向上取整: \" + Math.ceil(x)); // 向下取整 System.out.println(\"向下取整: \" + Math.floor(x)); // 四舍五入 System.out.println(\"四舍五入: \" + Math.round(x)); // 最大值和最小值 System.out.println(\"最大值: \" + Math.max(x, y)); System.out.println(\"最小值: \" + Math.min(x, y)); // 幂运算 System.out.println(\"2的3次方: \" + Math.pow(2, 3)); // 平方根 System.out.println(\"25的平方根: \" + Math.sqrt(25)); // 三角函数 double rad = Math.toRadians(30); // 角度转弧度 System.out.println(\"30度的正弦值: \" + Math.sin(rad)); // 随机数 System.out.println(\"随机数: \" + Math.random()); } } ","date":"2024-12-27","objectID":"/text43/:7:3","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"4. 常量 Math类提供了以下常量： Math.PI: 圆周率(π的值)。 Math.E: 自然对数的底数（约等于2.71828）。 ","date":"2024-12-27","objectID":"/text43/:7:4","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"5. 性能注意事项 所有Math类的方法都是静态的，无需实例化，利用这种特性可以减少不必要的开销。 对于频繁的数学计算，可以考虑使用一些其他的数学库，如Apache Commons Math等，这些库可能在特定场景下提供更好的性能或功能。 ","date":"2024-12-27","objectID":"/text43/:7:5","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"Random类 在Java中，Random类是用于生成伪随机数的工具类，位于java.util包中。它提供了多种方法来生成不同类型的随机数，包括布尔值、整数、长整数、浮点数和双精度数。Random类是通过算法生成随机数，因此生成的数列是可预测的（伪随机），但对于大多数用途来说，它们足够随机。 Random类是Java中一个非常便捷和广泛使用的工具，用于生成伪随机数。对于大部分应用场景，Random类的使用足够满足需求。如果需要更高质量的随机数（如用于安全加密），可以考虑使用java.security.SecureRandom类。 ","date":"2024-12-27","objectID":"/text43/:8:0","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"1. 主要特点 伪随机数生成：Random类使用一个种子（seed）来初始化随机数生成器。相同的种子会产生相同的随机数序列。 线程安全性：Random类的方法不是线程安全的。如果多个线程同时执行随机数生成，建议使用java.util.concurrent.ThreadLocalRandom类或java.security.SecureRandom来避免竞争条件。 ","date":"2024-12-27","objectID":"/text43/:8:1","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"2. 创建Random对象 可以通过无参构造方法创建随机数生成器，自动使用当前时间戳作为种子，或者通过提供一个特定的种子值进行初始化： import java.util.Random; // 无参构造函数，使用系统时间作为种子 Random randomDefault = new Random(); // 指定种子 Random randomWithSeed = new Random(42); ","date":"2024-12-27","objectID":"/text43/:8:2","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"3. 常用方法 以下是Random类的一些常用方法： 生成布尔值： boolean nextBoolean(): 随机生成一个布尔值（true或false）。 生成整数： int nextInt(): 生成一个随机整数（范围是 -2^31 到 2^31-1）。 int nextInt(int bound): 返回一个从 0（含）到 bound（不含）的随机整数。 生成长整数： long nextLong(): 生成一个随机长整数（范围是 -2^63 到 2^63-1）。 生成浮点数： float nextFloat(): 生成一个从 0.0（含）到 1.0（不含）的随机浮点数。 double nextDouble(): 生成一个从 0.0（含）到 1.0（不含）的随机双精度数。 生成字节： void nextBytes(byte[] bytes): 用随机数填充字节数组。 ","date":"2024-12-27","objectID":"/text43/:8:3","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"4. 示例代码 以下是一个示例，演示了如何使用Random类生成不同类型的随机数： import java.util.Random; public class RandomExample { public static void main(String[] args) { Random random = new Random(); // 使用当前时间戳生成随机数 // 生成布尔值 boolean randomBoolean = random.nextBoolean(); System.out.println(\"随机布尔值: \" + randomBoolean); // 生成随机整数 int randomInt = random.nextInt(); System.out.println(\"随机整数: \" + randomInt); // 生成从0到100之间的随机整数 int randomIntBounded = random.nextInt(100); System.out.println(\"0到100之间的随机整数: \" + randomIntBounded); // 生成随机长整数 long randomLong = random.nextLong(); System.out.println(\"随机长整数: \" + randomLong); // 生成随机浮点数 float randomFloat = random.nextFloat(); System.out.println(\"随机浮点数: \" + randomFloat); // 生成随机双精度数 double randomDouble = random.nextDouble(); System.out.println(\"随机双精度数: \" + randomDouble); // 生成随机字节 byte[] randomBytes = new byte[5]; random.nextBytes(randomBytes); System.out.print(\"随机字节: \"); for (byte b : randomBytes) { System.out.print(b + \" \"); } } } ","date":"2024-12-27","objectID":"/text43/:8:4","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"5. 使用场景 游戏开发：生成随机事件、道具或敌人位置。 模拟和建模：用于测试和模拟场景，例如生成随机样本。 抽奖或随机选择：在某个范围内随机选择一个或多个项。 ","date":"2024-12-27","objectID":"/text43/:8:5","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"System类 在Java中，System类是一个提供系统相关功能的工具类，位于java.lang包中。它提供了一系列静态方法和字段，这些方法和字段用于访问系统环境属性、I/O操作、与时间、内存等相关的功能。System类的常用静态成员包括标准输入和输出流、获取系统属性等。 ","date":"2024-12-27","objectID":"/text43/:9:0","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"1. 主要特点 静态成员: 大多数成员是静态的，可以直接通过System类调用，而无需创建实例。 不允许实例化: System类的构造器是私有的，因此无法被实例化。 与系统相关: 提供与操作系统和Java运行环境交互的接口。 ","date":"2024-12-27","objectID":"/text43/:9:1","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"2. 常用功能 2.1 输入和输出 System.out: 标准输出流，通常对应于控制台，可以使用打印方法（如 System.out.println()）输出信息。 System.err: 标准错误输出流，用于输出错误信息。 System.setIn(InputStream in): 设置标准输入流。 System.setOut(PrintStream out): 设置标准输出流。 System.setErr(PrintStream err): 设置标准错误流。 2.2 系统属性 System.getProperty(String key): 获取指定的系统属性，例如 Java 版本、操作系统名称等。 System.getProperties(): 返回系统的所有属性集合。 2.3 内存管理 System.gc(): 推荐JVM运行垃圾回收器。 System.currentTimeMillis(): 返回当前时间，以毫秒为单位。 System.nanoTime(): 返回当前时间，以纳秒为单位，侧重高精度计时。 2.4 数组操作 System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length): 复制数组的内容，可以用于对象数组、基本数据类型数组等的复制。 System.fill(): 用于填充数组的内容。 ","date":"2024-12-27","objectID":"/text43/:9:2","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"3. 示例代码 以下示例展示了System类的常见用法： public class SystemExample { public static void main(String[] args) { // 打印系统属性 System.out.println(\"Java版本: \" + System.getProperty(\"java.version\")); System.out.println(\"操作系统: \" + System.getProperty(\"os.name\")); // 使用 System.currentTimeMillis() long startTime = System.currentTimeMillis(); // 模拟一些操作 for (int i = 0; i \u003c 1000000; i++) { Math.sqrt(i); // 进行一些数学计算 } long endTime = System.currentTimeMillis(); System.out.println(\"执行时间: \" + (endTime - startTime) + \" 毫秒\"); // 数组拷贝示例 int[] sourceArray = {1, 2, 3, 4, 5}; int[] destArray = new int[5]; System.arraycopy(sourceArray, 0, destArray, 0, sourceArray.length); System.out.print(\"目标数组内容: \"); for (int num : destArray) { System.out.print(num + \" \"); } System.out.println(); // 标准错误输出 System.err.println(\"这是一个错误信息示例。\"); } } ","date":"2024-12-27","objectID":"/text43/:9:3","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"4. 常用静态方法和字段 方法/字段 描述 System.out 标准输出流，用于输出信息。 System.err 标准错误流，用于输出错误信息。 System.in 标准输入流，用于读取输入。 System.getProperty() 获取系统属性。 System.setProperty() 设置系统属性。 System.currentTimeMillis() 获取当前时间（毫秒级）。 System.nanoTime() 获取当前时间（纳秒级），用于高精度计时。 System.arraycopy() 复制数组的一个部分到另一个数组。 System.gc() 建议运行垃圾回收器。 ","date":"2024-12-27","objectID":"/text43/:9:4","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"Date概述 在Java中，Date类用于表示特定的时间点，包括日期和时间。它位于java.util包中。虽然Date类在Java的早期版本中广泛使用，但随着Java 8引入新的时间日期API（java.time包），Date类的使用逐渐减少，尤其是在需要进行更复杂的日期和时间操作时。然而，了解Date类对于处理旧代码和了解Java的时间处理仍然很重要。 ","date":"2024-12-27","objectID":"/text43/:10:0","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"1. 主要特点 表示时间的瞬间：Date对象表示一个特定的时刻，从1970年1月1日00:00:00 UTC到某个时间点的毫秒数。 包含日期和时间：Date类同时关注日期和时间，没有单独的方法表示日期、时间或时区。 不可变性：Date对象本身是可变的，但在某些情况下（如在多线程环境中），创建不可变对象会更安全。 ","date":"2024-12-27","objectID":"/text43/:10:1","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"2. 构造函数 Date类提供了几个构造函数来创建日期对象： Date date1 = new Date(); // 创建当前时间的Date对象 Date date2 = new Date(long date) // 根据给定的毫秒数创建Date对象 Date date3 = new Date(int year, int month, int day) // 根据指定的年份、月份和日期创建Date对象（不推荐使用） 注意：使用Date(int year, int month, int day)构造函数已经被弃用，建议使用Calendar类或java.time包中的类来处理日期。 ","date":"2024-12-27","objectID":"/text43/:10:2","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"3. 常用方法 获取时间戳： long getTime(): 返回自1970年1月1日00:00:00 UTC以来的毫秒数。 设置时间： void setTime(long time): 根据指定的毫秒数设置日期对象的时间。 比较日期： boolean before(Date when): 判断当前日期是否在指定日期之前。 boolean after(Date when): 判断当前日期是否在指定日期之后。 boolean equals(Object obj): 判断两个Date对象是否相等。 格式化显示： String toString(): 返回日期和时间的字符串表示形式。 ","date":"2024-12-27","objectID":"/text43/:10:3","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"4. 示例代码 以下是一个示例程序，演示了Date类的基本用法： import java.util.Date; public class DateExample { public static void main(String[] args) { // 创建当前时间的Date对象 Date now = new Date(); System.out.println(\"当前时间: \" + now); // 获取时间戳 long timestamp = now.getTime(); System.out.println(\"时间戳: \" + timestamp); // 创建指定时间的Date对象 Date specificDate = new Date(1672531199000L); // 代表2023-01-01 00:00:00 System.out.println(\"指定时间: \" + specificDate); // 比较日期 if (now.before(specificDate)) { System.out.println(\"当前时间在指定时间之前\"); } else { System.out.println(\"当前时间在指定时间之后\"); } // 设置时间 specificDate.setTime(timestamp); System.out.println(\"设置后的指定时间: \" + specificDate); // 其他日期方法 System.out.println(\"日期的字符串表示: \" + specificDate.toString()); } } ","date":"2024-12-27","objectID":"/text43/:10:4","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"5. 使用场景 尽管Date类在Java中仍然被使用，但在处理日期和时间时，新的日期时间API（特别是LocalDate、LocalDateTime和ZonedDateTime等）提供了更好的灵活性和更简洁的操作方法。 旧代码兼容性： 在阅读和维护遗留代码时，可能会遇到Date类。 简单的时间戳处理： 在需要存储和比较时间戳时，Date类仍然可以使用。 ","date":"2024-12-27","objectID":"/text43/:10:5","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"BigDecimal概述 在Java中，BigDecimal类用于处理任意精度的十进制数，主要用于金融和科学计算等需要高精度的场景。它位于java.math包中，提供了对浮点数存在精度问题的有效解决方案。BigDecimal允许开发者准确表示和操作非常大的或非常小的数字，而不会丢失精度。 ","date":"2024-12-27","objectID":"/text43/:11:0","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"1. 主要特点 任意精度：可以表示非常大的数字和非常小的数字，而不受float或double精度限制。 不可变性：BigDecimal对象是不可变的，类似于String，对其值的任何操作都会返回一个新的BigDecimal对象。 精确的数学运算：提供了多种方法精确执行加、减、乘、除等运算，同时支持舍入模式。 ","date":"2024-12-27","objectID":"/text43/:11:1","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"2. 创建BigDecimal对象 BigDecimal对象可以通过多种方式创建： BigDecimal bigDec1 = new BigDecimal(\"123.45\"); // 使用字符串构造 BigDecimal bigDec2 = new BigDecimal(12345); // 使用整数构造 BigDecimal bigDec3 = new BigDecimal(123.45); // 使用浮点数构造（不推荐，可能存在精度问题） 使用字符串构造方式通常是推荐的做法，以避免浮点数表示问题。 ","date":"2024-12-27","objectID":"/text43/:11:2","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"3. 常用方法 3.1 基本操作 加法：BigDecimal add(BigDecimal augend)：返回两个BigDecimal的和。 减法：BigDecimal subtract(BigDecimal subtrahend)：返回两个BigDecimal的差。 乘法：BigDecimal multiply(BigDecimal multiplicand)：返回两个BigDecimal的积。 除法： BigDecimal divide(BigDecimal divisor)：返回两个BigDecimal的商。 BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode)：以指定的精确度和舍入模式返回商。 比较方法： int compareTo(BigDecimal val)：比较当前对象与指定BigDecimal的大小。 boolean equals(Object x)：判断两个BigDecimal是否相等。 3.2 舍入 常用舍入模式：RoundingMode枚举提供多种舍入策略，如CEILING、FLOOR、HALF_UP等。 ","date":"2024-12-27","objectID":"/text43/:11:3","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"4. 示例代码 以下是一个示例程序，展示了如何使用BigDecimal进行基本的数学运算： import java.math.BigDecimal; import java.math.RoundingMode; public class BigDecimalExample { public static void main(String[] args) { // 创建BigDecimal对象 BigDecimal num1 = new BigDecimal(\"123.45\"); BigDecimal num2 = new BigDecimal(\"678.90\"); // 加法 BigDecimal sum = num1.add(num2); System.out.println(\"和: \" + sum); // 减法 BigDecimal difference = num1.subtract(num2); System.out.println(\"差: \" + difference); // 乘法 BigDecimal product = num1.multiply(num2); System.out.println(\"积: \" + product); // 除法 BigDecimal quotient = num2.divide(num1, 2, RoundingMode.HALF_UP); // 保留两位小数 System.out.println(\"商: \" + quotient); // 比较 int comparison = num1.compareTo(num2); System.out.println(\"比较结果: \" + (comparison \u003c 0 ? \"num1 \u003c num2\" : comparison \u003e 0 ? \"num1 \u003e num2\" : \"num1 = num2\")); } } ","date":"2024-12-27","objectID":"/text43/:11:4","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"5. 使用场景 BigDecimal类常用于以下场景： 金融应用：财务计算需要高精度以避免舍入误差和精度丢失。 科学计算：任何需要精确表示十进制数的领域（如工程、物理等）。 计算器应用：需要处理高精度数值的计算器。 ","date":"2024-12-27","objectID":"/text43/:11:5","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"Calendar概述 在Java中，Calendar类用于处理日期和时间，属于java.util包。它提供了一个抽象的类，可以帮助开发者以更灵活和易于操作的方式获取和操作日期和时间信息。虽然Calendar类在Java中是一个常用的工具，但在Java 8之后，更新的日期和时间API（如java.time包中的LocalDate、LocalDateTime等）提供了更强大和灵活的功能。 Calendar类提供了一种灵活的日期和时间处理方式，尽管在Java 8之后，新的日期时间API提供了更为简便和强大的功能，但Calendar仍然在处理遗留代码和某些特定场合中广泛使用。 ","date":"2024-12-27","objectID":"/text43/:12:0","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"1. 主要特点 可变性：Calendar对象是可变的，可以在不创建新对象的情况下修改其值。 时区支持：能够处理不同的时区，并与其他时间和日期格式进行转换。 灵活的日期和时间操作：提供了增、减、设置和获取日期或时间各组成部分（如年、月、日、时、分、秒等）的方法。 ","date":"2024-12-27","objectID":"/text43/:12:1","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"2. 创建Calendar实例 Calendar是一个抽象类，通常通过Calendar.getInstance()方法获得一个具体的Calendar子类的实例： Calendar calendar = Calendar.getInstance(); // 获取当前日期和时间的Calendar实例 ","date":"2024-12-27","objectID":"/text43/:12:2","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"3. 常用方法 3.1 获取和设置日期时间成分 获取当前日期和时间： int year = calendar.get(Calendar.YEAR); int month = calendar.get(Calendar.MONTH); // 注意：月份从0开始（0=一月） int day = calendar.get(Calendar.DAY_OF_MONTH); int hour = calendar.get(Calendar.HOUR_OF_DAY); int minute = calendar.get(Calendar.MINUTE); int second = calendar.get(Calendar.SECOND); 设置日期和时间： calendar.set(Calendar.YEAR, 2025); calendar.set(Calendar.MONTH, Calendar.JANUARY); calendar.set(Calendar.DAY_OF_MONTH, 1); 3.2 日期计算 增加或减少时间： calendar.add(Calendar.DAY_OF_MONTH, 1); // 增加一天 calendar.add(Calendar.MONTH, -1); // 减少一个月 获取特定时间的时间戳： long timeInMillis = calendar.getTimeInMillis(); Date date = calendar.getTime(); // 转换为Date对象 ","date":"2024-12-27","objectID":"/text43/:12:3","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"4. 示例代码 以下是一个简单的示例，展示了如何使用Calendar类来操作日期和时间： import java.util.Calendar; public class CalendarExample { public static void main(String[] args) { // 创建一个Calendar实例 Calendar calendar = Calendar.getInstance(); // 获取并显示当前日期和时间 System.out.println(\"当前日期和时间: \" + calendar.getTime()); // 获取年、月、日、时、分、秒 int year = calendar.get(Calendar.YEAR); int month = calendar.get(Calendar.MONTH) + 1; // 加1，因为月份从0开始 int day = calendar.get(Calendar.DAY_OF_MONTH); int hour = calendar.get(Calendar.HOUR_OF_DAY); int minute = calendar.get(Calendar.MINUTE); int second = calendar.get(Calendar.SECOND); System.out.printf(\"当前时间：%04d-%02d-%02d %02d:%02d:%02d%n\", year, month, day, hour, minute, second); // 增加一天 calendar.add(Calendar.DAY_OF_MONTH, 1); System.out.println(\"增加一天后的日期: \" + calendar.getTime()); // 设置为特定日期 calendar.set(2025, Calendar.JANUARY, 1); System.out.println(\"设置为2025年1月1日: \" + calendar.getTime()); } } ","date":"2024-12-27","objectID":"/text43/:12:4","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"5. 使用场景 日期和时间处理：在需要对日期和时间进行操作、比较、转换等场景下，Calendar非常有用。 跨时区的应用：处理涉及多时区的应用程序，可以利用Calendar类的时区功能。 ","date":"2024-12-27","objectID":"/text43/:12:5","tags":["Java"],"title":"【Java】Java语言进阶（二）","uri":"/text43/"},{"categories":["Java"],"content":"集合概述 在 Java 编程中，集合框架（Java Collections Framework）是一组用于存储、操作和处理数据的类和接口。集合框架提供了高效的方式来存储、查找、排序和操作数据元素。以下是关于集合的概述： ","date":"2024-12-27","objectID":"/text45/:1:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"集合的基本概念 集合（Collection）：集合是一个对象的聚合，可以存储多个元素。集合可以是无序的、重复的或有序的、唯一的，具体取决于所使用的集合类型。 集合框架的组件： 接口：定义集合的基本操作，如 Collection、List、Set 和 Map 等。 实现类：实现接口，提供具体的数据结构和操作，如 ArrayList、HashSet、HashMap 等。 泛型（Generics）：Java 集合框架广泛使用泛型，允许在集合中存储特定类型的对象，提供类型安全和编译时检查。 ","date":"2024-12-27","objectID":"/text45/:1:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"常用集合类型 List：有序且可重复的元素集合。常用的实现类包括： ArrayList：基于动态数组实现，支持随机访问。 LinkedList：基于双向链表实现，适合于频繁插入和删除操作。 Set：无序且不允许重复元素的集合。常用的实现类包括： HashSet：基于哈希表实现, 提供快速的查询和插入速度。 TreeSet：基于红黑树实现，提供有序性，支持按自然顺序或指定比较器排序。 Map：键值对的集合，其中每个键是唯一的，值可以重复。常用的实现类包括： HashMap：基于哈希表实现，提供快速的查询和插入速度。 TreeMap：基于红黑树实现，提供有序性，按键的自然顺序或指定比较器排序。 ","date":"2024-12-27","objectID":"/text45/:1:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"集合的主要操作 添加元素：使用 add()、put() 方法。 访问元素：通过索引（在 List 中）或键（在 Map 中）来获取。 删除元素：使用 remove() 方法。 遍历集合：通过增强的 for 循环或迭代器（Iterator）进行遍历。 ","date":"2024-12-27","objectID":"/text45/:1:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"示例 import java.util.ArrayList; import java.util.HashSet; import java.util.HashMap; public class CollectionExample { public static void main(String[] args) { // List 示例 ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"Apple\"); list.add(\"Banana\"); System.out.println(\"List: \" + list); // Set 示例 HashSet\u003cString\u003e set = new HashSet\u003c\u003e(); set.add(\"Apple\"); set.add(\"Banana\"); set.add(\"Apple\"); // 重复元素不会被添加 System.out.println(\"Set: \" + set); // Map 示例 HashMap\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); map.put(\"Alice\", 25); map.put(\"Bob\", 30); System.out.println(\"Map: \" + map); } } ","date":"2024-12-27","objectID":"/text45/:1:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"Set集合概述及特点 Set 是一种很有用的数据结构，适合用于存储唯一元素和进行集合运算。Set 的主要特点是存储不重复的元素，适合用于需要过滤重复项或需要集合间数学运算的场景。 ","date":"2024-12-27","objectID":"/text45/:2:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 概述 Set 是一个不允许重复元素的集合接口。与 List 相比，Set 没有元素的顺序（即不保证元素的插入顺序），并且不允许存在重复的元素。 ","date":"2024-12-27","objectID":"/text45/:2:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. Set 的主要实现类 Java 提供了多种 Set 的实现，最常用的有： HashSet 通过哈希表实现，提供常数时间的性能（O(1)）用于基本操作（添加、删除、包含）。 元素无序，不重复，但不保证元素的迭代顺序。 LinkedHashSet 通过链表和哈希表实现，保持插入元素的顺序。 遍历时保持元素的插入顺序，适用于需要按插入顺序访问元素的场景。 TreeSet 通过红黑树实现，提供有序的集合，元素根据自然顺序或自定义比较器进行排序。 支持范围查找（如从某个值到另一个值的查找），但基本操作的时间复杂度为 O(log n)。 ","date":"2024-12-27","objectID":"/text45/:2:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. Set 的特点 不允许重复：Set 中不能有重复的元素。如果尝试添加一个已存在的元素，添加操作将被忽略。 无序性：大多数 Set 的实现（如 HashSet）不保证元素的顺序。即使按插入顺序添加元素，迭代时的顺序可能会不同。 效率：对于频繁查找、插入和删除操作，HashSet 提供优秀的性能（O(1)），而 TreeSet 提供 O(log n) 的性能用于查找和排序。 支持集合运算：Set 支持集合间的数学运算，如并集、交集和差集。这使得在处理数据时非常灵活，特别是在对集合进行过滤或比较时。 ","date":"2024-12-27","objectID":"/text45/:2:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"4. Set常用方法 Set 接口的常用方法包括： add(E e)：添加元素，返回 true 如果元素添加成功（未存在），否则返回 false。 remove(Object o)：移除指定元素，返回 true 如果集合中存在该元素，且成功移除。 contains(Object o)：检查集合是否包含指定元素，返回 true 或 false。 size()：返回集合中元素的数量。 isEmpty()：检查集合是否为空。 clear()：清空集合所有元素。 ","date":"2024-12-27","objectID":"/text45/:2:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"5. 使用示例 以下是使用 Set 的简单示例： 4.1 HashSet 示例 import java.util.HashSet; public class HashSetExample { public static void main(String[] args) { HashSet\u003cString\u003e set = new HashSet\u003c\u003e(); set.add(\"Apple\"); set.add(\"Banana\"); set.add(\"Cherry\"); set.add(\"Apple\"); // 重复元素，不会添加 System.out.println(\"HashSet: \" + set); } } 4.2 LinkedHashSet示例 LinkedHashSet 结合了 HashSet 的哈希表性能和 LinkedList 的有序特性。它保持了元素的插入顺序，从而可以在遍历时保证按照插入顺序访问元素。LinkedHashSet 是一种功能强大的数据结构，适合需要保持元素插入顺序的场景。 1. LinkedHashSet 的特性 保持插入顺序：遍历 LinkedHashSet 时，元素将按插入的顺序出现。 不允许重复：与其他 Set 实现一样，LinkedHashSet 中不允许重复的元素。 高效的操作：提供较快速的查找、插入和删除操作，平均时间复杂度为 O(1)。 2. LinkedHashSet 使用示例 以下是一个简单的 LinkedHashSet 使用示例，演示了如何创建、添加和遍历元素。 import java.util.LinkedHashSet; public class LinkedHashSetExample { public static void main(String[] args) { // 创建一个 LinkedHashSet LinkedHashSet\u003cString\u003e linkedHashSet = new LinkedHashSet\u003c\u003e(); // 添加元素 linkedHashSet.add(\"Apple\"); linkedHashSet.add(\"Banana\"); linkedHashSet.add(\"Cherry\"); linkedHashSet.add(\"Date\"); // 尝试添加重复的元素 linkedHashSet.add(\"Apple\"); // 这个调用将被忽略 // 输出 LinkedHashSet 的内容 System.out.println(\"LinkedHashSet elements (insertion order): \" + linkedHashSet); // 遍历使用增强 for 循环 System.out.println(\"Iterating over LinkedHashSet:\"); for (String fruit : linkedHashSet) { System.out.println(fruit); } // 检查集合中是否包含某个元素 if (linkedHashSet.contains(\"Banana\")) { System.out.println(\"LinkedHashSet contains Banana.\"); } // 删除元素 linkedHashSet.remove(\"Cherry\"); System.out.println(\"After removing Cherry: \" + linkedHashSet); // 清空集合 linkedHashSet.clear(); System.out.println(\"After clearing: \" + linkedHashSet); } } 3. 示例输出 上述代码运行后，会输出以下内容： LinkedHashSet elements (insertion order): [Apple, Banana, Cherry, Date] Iterating over LinkedHashSet: Apple Banana Cherry Date LinkedHashSet contains Banana. After removing Cherry: [Apple, Banana, Date] After clearing: [] 4. 使用场景 保持顺序的唯一性：当您需要一个不允许重复元素的集合，同时还需要保持插入顺序时，LinkedHashSet 是一个理想选择。 实现缓存：LinkedHashSet 可以用于创建一些简单的缓存机制，保持最新使用的元素顺序。 4.3 TreeSet示例 TreeSet 它基于红黑树结构，维护元素的自然顺序或根据指定的比较器进行排序。由于 TreeSet 是有序的，因此它可以快速地进行范围查询和有序遍历。TreeSet 提供了有序的元素处理和快速访问的能力。使用 TreeSet 可以方便地进行排序和范围查询，是处理有序集合时的一个优秀选择。 1. TreeSet 的特性 有序集：TreeSet 根据元素的自然顺序（如果元素实现了 Comparable 接口）或者根据提供的 Comparator 进行排序。 不允许重复：和其他 Set 实现一样，TreeSet 中不允许存在重复元素。 操作时间复杂度：基本操作（添加、删除、查找）的时间复杂度是 O(log n)。 2. TreeSet 使用示例 以下是一个简单的 TreeSet 使用示例，演示了如何创建、添加、遍历和操作元素。 import java.util.TreeSet; public class TreeSetExample { public static void main(String[] args) { // 创建一个 TreeSet TreeSet\u003cInteger\u003e treeSet = new TreeSet\u003c\u003e(); // 添加元素 treeSet.add(5); treeSet.add(3); treeSet.add(8); treeSet.add(1); treeSet.add(6); // 尝试添加重复的元素 treeSet.add(3); // 这个调用将被忽略 // 输出 TreeSet 的内容 System.out.println(\"TreeSet elements (sorted order): \" + treeSet); // 遍历使用增强 for 循环 System.out.println(\"Iterating over TreeSet:\"); for (Integer number : treeSet) { System.out.println(number); } // 查询特定元素 if (treeSet.contains(5)) { System.out.println(\"TreeSet contains 5.\"); } // 获取小于指定元素的最大元素 Integer lower = treeSet.lower(5); System.out.println(\"The largest element less than 5 is: \" + lower); // 获取小于或等于指定元素的最大元素 Integer floor = treeSet.floor(5); System.out.println(\"The largest element less than or equal to 5 is: \" + floor); // 删除元素 treeSet.remove(6); System.out.println(\"After removing 6: \" + treeSet); // 清空集合 treeSet.clear(); System.out.println(\"After clearing: \" + treeSet); } } 3. 示例输出 运行上述代码，输出结果将会类似于： TreeSet elements (sorted order): [1, 3, 5, 6, 8] Iterating over TreeSet: 1 3 5 6 8 TreeSet contains 5. The largest element less than 5 is: 3 The largest element less than or equal to 5 is: 5 After removing 6: [1, 3, 5, 8] After clearing: [] 4. 使用场景 需要排序的集合：当您需要一个不允许重复元素且希望保持自然顺序或自定义顺序的集合时，TreeSet 是一个好的选择。 范围查询：TreeSet 提供了非常方便的方法（如 headSet(), tailSet(), subSet(), lower(), higher(), floor(), ceiling() 等）来进行范围查询。 实现有序的集合操作：适用于需要进行大量有序操作的情况，比如生成报告中的按顺序排列的数据。 ","date":"2024-12-27","objectID":"/text45/:2:5","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"Map集合概述及特点 在 Java 中，Map 接口表示一种将键（key）映射到值（value）的数据结构。与 Set 和 List 不同，Map 不存储重复的键，每个键只能映射到一个值。这使得 Map 特别适合于需要快速查找和关联数据的场景。 ","date":"2024-12-27","objectID":"/text45/:3:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 概述 Map 是一个包含键值对（key-value pairs）的数据结构。每个键都是唯一的，但多个键可以映射到同一个值。Map 主要用于实现关联数据，例如通过某个键查找对应的值。 ","date":"2024-12-27","objectID":"/text45/:3:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. Map 的主要实现类 Java 提供了多种 Map 的实现，最常用的有： HashMap 基于哈希表实现，提供常数时间的性能（O(1)）用于基本操作（get 和 put）。 不保证元素的顺序（即元素的迭代顺序可能不一致）。 LinkedHashMap 继承自 HashMap，维护元素的插入顺序（即迭代时按插入的顺序访问）。 适合需要按插入顺序访问 Map 项的场景。 TreeMap 基于红黑树实现，维护键的自然顺序或根据指定的比较器进行排序。 提供排序操作，适合需要对键进行顺序访问的场景。 Hashtable 也是一种哈希表实现，但不同于 HashMap，Hashtable 是同步的，因此线程安全，但效率较低。 不允许 null 键或值（HashMap 允许一个 null 键和多个 null 值）。 ","date":"2024-12-27","objectID":"/text45/:3:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. Map 的特点 键唯一性：每个键只能出现在 Map 中一次，插入相同的键会覆盖之前的值。 允许 null 值：大多数实现（如 HashMap 和 LinkedHashMap）允许 null 值和一个 null 键。 无序性或有序性：HashMap 和 Hashtable 不保证顺序，而 LinkedHashMap 和 TreeMap 提供有序性（分别按插入顺序和自然顺序）。 效率：对于查找、插入和删除操作，HashMap 提供平均 O(1) 的性能，而 TreeMap 的基本操作时间复杂度为 O(log n)，因为它需要保持排序。 ","date":"2024-12-27","objectID":"/text45/:3:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"4. 常用方法 Map 接口的常用方法包括： put(K key, V value)：将指定的键映射到指定的值。 get(Object key)：根据指定键返回其对应的值。 remove(Object key)：移除指定键及其对应的值。 containsKey(Object key)：检查集合是否包含指定的键。 containsValue(Object value)：检查集合是否包含指定的值。 size()：返回键值对的数量。 isEmpty()：检查集合是否为空。 clear()：清空所有键值对。 keySet()：返回包含所有键的 Set 视图。 values()：返回包含所有值的 Collection 视图。 entrySet()：返回包含所有键值对的 Set 视图。 ","date":"2024-12-27","objectID":"/text45/:3:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"5. 使用示例 5.1 HashMap示例 以下是一个使用 HashMap 的简单示例： import java.util.HashMap; import java.util.Map; public class MapExample { public static void main(String[] args) { // 创建 HashMap Map\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); // 添加元素 map.put(\"Alice\", 30); map.put(\"Bob\", 25); map.put(\"Charlie\", 35); // 输出 Map 的内容 System.out.println(\"Map: \" + map); // 获取指定键的值 System.out.println(\"Alice's age: \" + map.get(\"Alice\")); // 检查是否包含某个键 if (map.containsKey(\"Bob\")) { System.out.println(\"Map contains Bob.\"); } // 删除元素 map.remove(\"Charlie\"); System.out.println(\"After removing Charlie: \" + map); // 遍历 Map System.out.println(\"Iterating over Map:\"); for (Map.Entry\u003cString, Integer\u003e entry : map.entrySet()) { System.out.println(entry.getKey() + \": \" + entry.getValue()); } } } 5.2 LinkedHashMap示例 LinkedHashMap 它结合了 HashMap 的高效查找特性和 LinkedList 的顺序特性，维护元素的插入顺序。以下是关于 LinkedHashMap 的详细示例，包括如何创建、添加、访问和遍历这个数据结构。 1. LinkedHashMap 示例 以下代码展示了如何使用 LinkedHashMap 来存储学生姓名及其对应的年龄，并进行基本操作。 import java.util.LinkedHashMap; import java.util.Map; public class LinkedHashMapExample { public static void main(String[] args) { // 创建一个 LinkedHashMap LinkedHashMap\u003cString, Integer\u003e linkedHashMap = new LinkedHashMap\u003c\u003e(); // 添加元素 linkedHashMap.put(\"Alice\", 30); linkedHashMap.put(\"Bob\", 25); linkedHashMap.put(\"Charlie\", 35); linkedHashMap.put(\"David\", 28); // 尝试添加重复的元素（更新值） linkedHashMap.put(\"Alice\", 31); // 更新 Alice 的年龄 // 输出 LinkedHashMap 的内容 System.out.println(\"LinkedHashMap: \" + linkedHashMap); // 访问指定键的值 System.out.println(\"Bob's age: \" + linkedHashMap.get(\"Bob\")); // 检查是否包含某个键 if (linkedHashMap.containsKey(\"Charlie\")) { System.out.println(\"LinkedHashMap contains Charlie.\"); } // 删除元素 linkedHashMap.remove(\"David\"); System.out.println(\"After removing David: \" + linkedHashMap); // 遍历 LinkedHashMap System.out.println(\"Iterating over LinkedHashMap:\"); for (Map.Entry\u003cString, Integer\u003e entry : linkedHashMap.entrySet()) { System.out.println(entry.getKey() + \": \" + entry.getValue()); } // 清空 LinkedHashMap linkedHashMap.clear(); System.out.println(\"After clearing: \" + linkedHashMap); } } 2. 示例输出 运行上述代码，输出结果将会如下： LinkedHashMap: {Alice=31, Bob=25, Charlie=35, David=28} Bob's age: 25 LinkedHashMap contains Charlie. After removing David: {Alice=31, Bob=25, Charlie=35} Iterating over LinkedHashMap: Alice: 31 Bob: 25 Charlie: 35 After clearing: {} 3. 使用场景 保持条目顺序：当需维护元素的插入顺序时，LinkedHashMap 非常有用，例如在需要按生成顺序输出元素的情况下。 缓存实现：LinkedHashMap 可以用于实现最近最少使用（LRU）缓存，利用其顺序特性来快速查找和移除旧元素。 5.3 TreeMap示例 TreeMap 提供了灵活的存储和访问有序键数据的能力，是处理有序集合和范围查询的一个强大工具。TreeMap 基于红黑树数据结构，因此提供键的有序映射。它允许键的排序，并能够快速执行范围查找。下面是一个详细的 TreeMap 示例，展示如何创建、插入、访问和遍历这个数据结构。 1. TreeMap 示例 下面的代码示例展示了如何使用 TreeMap 存储学生姓名及其对应的分数，并进行常见操作。 import java.util.TreeMap; import java.util.Map; public class TreeMapExample { public static void main(String[] args) { // 创建一个 TreeMap TreeMap\u003cString, Integer\u003e treeMap = new TreeMap\u003c\u003e(); // 添加元素 treeMap.put(\"Alice\", 90); treeMap.put(\"Bob\", 85); treeMap.put(\"Charlie\", 95); treeMap.put(\"David\", 80); // 尝试添加重复的元素（更新值） treeMap.put(\"Alice\", 92); // 更新 Alice 的分数 // 输出 TreeMap 的内容（按键的自然顺序排序） System.out.println(\"TreeMap: \" + treeMap); // 访问指定键的值 System.out.println(\"Bob's score: \" + treeMap.get(\"Bob\")); // 检查是否包含某个键 if (treeMap.containsKey(\"Charlie\")) { System.out.println(\"TreeMap contains Charlie.\"); } // 获取小于指定键的最大键 String lowerKey = treeMap.lower(\"Charlie\"); System.out.println(\"The largest key less than 'Charlie' is: \" + lowerKey); // 获取小于或等于指定键的最大键 String floorKey = treeMap.floor(\"Charlie\"); System.out.println(\"The largest key less than or equal to 'Charlie' is: \" + floorKey); // 删除元素 treeMap.remove(\"David\"); System.out.println(\"After removing David: \" + treeMap); // 遍历 TreeMap System.out.println(\"Iterating over TreeMap:\"); for (Map.Entry\u003cString, Integer\u003e entry : treeMap.entrySet()) { System.out.println(entry.getKey() + \": \" + entry.getValue()); } // 清空 TreeMap treeMap.clear(); System.out.println(\"After clearing: \" + treeMap); } } 2. 示例输出 运行上述代码，输出结果将会类似于： TreeMap: {Alice=92, Bob=85, Charlie=95, David=80} Bob's score: 85 Tre","date":"2024-12-27","objectID":"/text45/:3:5","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"集合vs数组 在 Java 中，集合（Collection）和数组（Array）都是用于存储和处理数据的一种方式，但它们在概念、特性和使用方式上有很大区别。下面是它们之间的一些主要对比： ","date":"2024-12-27","objectID":"/text45/:4:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"数组（Array） 固定长度：数组在创建时需要指定大小，大小一旦确定，不能更改。 存储类型一致：数组中存储的元素类型必须相同（例如，整型数组只能存储整数）。 访问速度快：由于数组在内存中是连续存放，访问速度较快。 基本数据类型支持：数组可以存储基本数据类型（如 int、char 等）和引用类型（如对象）。 语法较简单：数组的声明、初始化和访问相对简单，易于理解。 ","date":"2024-12-27","objectID":"/text45/:4:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"集合（Collection） 动态长度：集合类（如 ArrayList、HashSet 等）可以动态调整大小，容量可以随着元素的增加或减少而变化。 存储类型灵活：集合可以存储不同类型的对象，使用泛型时可指定特定类型。 功能丰富：集合框架提供了丰富的功能，包括排序、查找、去重、集合运算等。 不支持基本类型：集合存储的是对象，对于基本数据类型，需要使用包装类（如 Integer、Character 等）。 接口和实现：集合框架是基于接口和实现的，具有更多设计灵活性和扩展性。 ","date":"2024-12-27","objectID":"/text45/:4:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"使用场景 数组 适合用于存储固定大小且类型相同的元素（例如，存储一组学生的分数）。 集合 更适合用于存储不定大小、需要频繁修改和操作的数据（例如，存储用户列表、购物车等）。 ","date":"2024-12-27","objectID":"/text45/:4:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"示例代码 // 数组示例 int[] numbers = new int[5]; // 创建一个整型数组，大小为5 numbers[0] = 1; numbers[1] = 2; // 访问数组元素 System.out.println(numbers[0]); // 输出: 1 // 集合示例 import java.util.ArrayList; ArrayList\u003cInteger\u003e numberList = new ArrayList\u003c\u003e(); // 创建一个动态数组（ArrayList） numberList.add(1); numberList.add(2); // 访问集合元素 System.out.println(numberList.get(0)); // 输出: 1 ","date":"2024-12-27","objectID":"/text45/:4:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"集合的遍历 在 Java 中，通过集合框架（如 List、Set、Map 等）可以实现对集合中元素的遍历。不同类型的集合有不同的遍历方式。以下是几种常用的遍历方法： ","date":"2024-12-27","objectID":"/text45/:5:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 使用增强的 for 循环（foreach） 这种方式直观且简单，适用于 Collection 接口的实现类（如 List 和 Set）。 示例： import java.util.ArrayList; import java.util.HashSet; public class EnhancedForLoopExample { public static void main(String[] args) { // 遍历 ArrayList ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"Apple\"); list.add(\"Banana\"); for (String fruit : list) { System.out.println(fruit); } // 遍历 HashSet HashSet\u003cString\u003e set = new HashSet\u003c\u003e(); set.add(\"Apple\"); set.add(\"Banana\"); for (String fruit : set) { System.out.println(fruit); } } } ","date":"2024-12-27","objectID":"/text45/:5:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 使用迭代器（Iterator） Iterator 接口提供了对集合的安全遍历，特别适合在遍历时需要删除元素的场景。 示例： import java.util.ArrayList; import java.util.Iterator; public class IteratorExample { public static void main(String[] args) { // 使用迭代器遍历 ArrayList ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"Apple\"); list.add(\"Banana\"); list.add(\"Cherry\"); Iterator\u003cString\u003e iterator = list.iterator(); while (iterator.hasNext()) { String fruit = iterator.next(); System.out.println(fruit); // 如果要在遍历时删除元素 if (fruit.equals(\"Banana\")) { iterator.remove(); // 安全删除 } } System.out.println(\"After removal: \" + list); } } ","date":"2024-12-27","objectID":"/text45/:5:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 使用 Java 8 的 Stream API Stream API 提供了一种函数式的方法来处理集合，支持更复杂的操作链。 示例： import java.util.Arrays; import java.util.List; public class StreamExample { public static void main(String[] args) { List\u003cString\u003e list = Arrays.asList(\"Apple\", \"Banana\", \"Cherry\"); list.stream() .filter(fruit -\u003e fruit.startsWith(\"A\")) // 过滤以 \"A\" 开头的元素 .forEach(System.out::println); // 打印结果 } } ","date":"2024-12-27","objectID":"/text45/:5:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"4. 遍历 Map Map 包含键值对，通常可以通过 keySet()、entrySet() 或 values() 方法进行遍历。 示例： import java.util.HashMap; import java.util.Map; public class MapTraversalExample { public static void main(String[] args) { HashMap\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); map.put(\"Alice\", 25); map.put(\"Bob\", 30); // 遍历键 for (String key : map.keySet()) { System.out.println(\"Key: \" + key + \", Value: \" + map.get(key)); } // 遍历值 for (Integer value : map.values()) { System.out.println(\"Value: \" + value); } // 遍历键值对 for (Map.Entry\u003cString, Integer\u003e entry : map.entrySet()) { System.out.println(\"Entry: \" + entry.getKey() + \" = \" + entry.getValue()); } } } ","date":"2024-12-27","objectID":"/text45/:5:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"泛型 在 Java 中，泛型（Generics）是一种强大的特性，它允许类、接口和方法操作参数化类型。泛型的引入主要是为了实现类型安全，减少类型转换错误的发生，提高代码的可复用性和可读性。以下是关于 Java 泛型的概述及基本使用。 ","date":"2024-12-27","objectID":"/text45/:6:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 泛型的概述 1.1 定义 泛型是指在定义类、接口或方法时不指定具体的数据类型，而是使用一个或多个类型参数来表示。这使得代码可以在处理不同数据类型时保持一致性。 1.2 优势 类型安全：在编译时进行类型检查，避免运行时错误。 消除强制类型转换：在使用泛型时，不需要进行显式的类型转换。 提高代码重用性：可以使用相同的代码处理不同类型的数据。 ","date":"2024-12-27","objectID":"/text45/:6:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 泛型的基本用法 2.1 泛型类 定义一个泛型类时，使用尖括号 \u003cT\u003e 来指定类型参数。 示例： public class Box\u003cT\u003e { private T item; public void setItem(T item) { this.item = item; } public T getItem() { return item; } } 使用泛型类： public class GenericClassExample { public static void main(String[] args) { Box\u003cString\u003e stringBox = new Box\u003c\u003e(); stringBox.setItem(\"Hello, Generics!\"); System.out.println(stringBox.getItem()); Box\u003cInteger\u003e integerBox = new Box\u003c\u003e(); integerBox.setItem(123); System.out.println(integerBox.getItem()); } } 2.2 泛型接口 类似于泛型类，可以定义泛型接口。 示例： interface Pair\u003cK, V\u003e { K getKey(); V getValue(); } class OrderedPair\u003cK, V\u003e implements Pair\u003cK, V\u003e { private K key; private V value; public OrderedPair(K key, V value) { this.key = key; this.value = value; } public K getKey() { return key; } public V getValue() { return value; } } 2.3 泛型方法 在方法中使用泛型，可以使方法与类型独立。 示例： public class GenericMethodExample { public static \u003cT\u003e void printArray(T[] array) { for (T element : array) { System.out.println(element); } } public static void main(String[] args) { Integer[] intArray = {1, 2, 3, 4, 5}; String[] strArray = {\"A\", \"B\", \"C\"}; printArray(intArray); printArray(strArray); } } ","date":"2024-12-27","objectID":"/text45/:6:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 使用泛型的注意事项 类型参数的命名：常见的命名约定是使用单个字母，如 T（类型）、E（元素）、K（键）、V（值）等。 不能创建泛型数组：例如 new T[10] 是不允许的。 泛型在运行时的类型擦除：在运行时，泛型类型信息会被擦除，所有泛型类型都会被替换为其边界类型（如果没有指定边界，则为 Object）。 通配符（Wildcards）：使用问号?来表示不确定的类型。常用的通配符如下： ?：无限制通配符。 ? extends T：上界通配符，表示类型 T 的子类型。 ? super T：下界通配符，表示类型 T 的超类型。 ","date":"2024-12-27","objectID":"/text45/:6:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"4. 使用通配符示例 示例： import java.util.ArrayList; import java.util.List; public class WildcardExample { public static void printList(List\u003c?\u003e list) { for (Object element : list) { System.out.println(element); } } public static void main(String[] args) { List\u003cString\u003e stringList = new ArrayList\u003c\u003e(); stringList.add(\"Hello\"); stringList.add(\"World\"); List\u003cInteger\u003e intList = new ArrayList\u003c\u003e(); intList.add(1); intList.add(2); printList(stringList); printList(intList); } } ","date":"2024-12-27","objectID":"/text45/:6:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"数据结构 数据结构（数据的组织方式）用于组织、存储和管理数据，以便高效地进行访问和修改。不同的数据结构适用于不同类型的应用和操作。以下是一些常见的数据结构及其概述。 ","date":"2024-12-27","objectID":"/text45/:7:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 基本数据结构 数组（Array） 定义：一组相同类型的元素，存储在连续的内存空间中。 特性： 固定大小。 支持随机访问，时间复杂度为 O(1)。 不支持动态调整。 链表（Linked List） 定义：由节点（Node）组成的线性数据结构，每个节点包含数据和指向下一个节点的引用。 特性： 动态大小，可以轻松地增加或删除元素。 访问元素时间复杂度为 O(n)。 ","date":"2024-12-27","objectID":"/text45/:7:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 树结构 二叉树（Binary Tree） 定义：每个节点最多有两个子节点（左节点和右节点）的树结构。 特性： 可以实现高效的查找、插入和删除操作。 二叉搜索树（Binary Search Tree, BST） 定义：一种特殊类型的二叉树，左子树的所有节点值小于父节点值，右子树的所有节点值大于父节点值。 特性： 支持 O(log n) 的查找、插入和删除操作（在平衡情况下）。 AVL树和红黑树 AVL树：一种自平衡的二叉搜索树，使得任何节点的两个子树的高度差不超过 1。 红黑树：类型的自平衡二叉搜索树，具有更广泛的应用，维护平衡的同时保证高效的动态操作。 ","date":"2024-12-27","objectID":"/text45/:7:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 图（Graph） 定义：由节点（或顶点）和连接节点的边组成的数据结构，可以是有向图或无向图。 特性： 可以表示复杂的关系，如社交网络、地图等。 常用的算法包括深度优先搜索（DFS）、广度优先搜索（BFS）、Dijkstra 算法等。 ","date":"2024-12-27","objectID":"/text45/:7:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"4. 哈希表（Hash Table） 定义：通过哈希函数将键映射到数组索引的一种数据结构，以支持快速的数据查找。 特性： 平均情况下查找、插入和删除时间复杂度为 O(1)。 处理冲突的方法有链地址法和开放寻址法。 ","date":"2024-12-27","objectID":"/text45/:7:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"5. 堆（Heap） 定义：一种特殊的完全二叉树，分为最大堆和最小堆，父节点的值总是大于或小于其子节点的值。 特性： 常用于实现优先级队列。 访问最大（或最小）元素的时间复杂度为 O(1)，插入和删除元素的时间复杂度为 O(log n)。 ","date":"2024-12-27","objectID":"/text45/:7:5","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"6. 集合与映射 集合（Set）：不允许重复元素的集合，常用的数据结构有 HashSet 和 TreeSet。 映射（Map）：键值对的集合，常用的数据结构有 HashMap 和 TreeMap。 ","date":"2024-12-27","objectID":"/text45/:7:6","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"数据结构选择的指南 选择合适的数据结构通常取决于以下几个因素： 数据操作频率：例如，频繁查找则使用哈希表或树结构；频繁插入和删除则选择链表。 存储要求：数组在存储时需要确定固定大小；动态链表可以根据需要调整大小。 算法复杂度：选择的数据结构对算法的复杂度影响巨大。例如，某些操作在树中可能为 O(log n)，而在链表中可能为 O(n)。 ","date":"2024-12-27","objectID":"/text45/:7:7","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"静态导入 在 Java 中，静态导入（Static Import）是一种便利的特性，允许您直接使用类中的静态成员（字段和方法）而无需每次都指定类名。这使得代码更加简洁和易读，特别是在频繁使用某个类的静态成员的情况下。 ","date":"2024-12-27","objectID":"/text45/:8:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 静态导入的概述 1.1 定义 使用 import static 语句，可以导入类中的静态方法和字段，使它们可以直接使用，而无需类名前缀。 1.2 优势 简化代码：使用静态导入可以减少代码中重复的类名，提高可读性。 提高可维护性：使得代码看起来更简洁，维护时更清晰。 1.3 使用限制 过多的静态导入可能会导致命名冲突，尤其是在导入多个类时。 不建议在大型类中广泛使用静态导入，以保持代码的清晰性。 ","date":"2024-12-27","objectID":"/text45/:8:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 如何使用静态导入 2.1 导入单个静态成员 您可以通过指定静态成员的名称来导入单个方法或字段。 示例： import static java.lang.Math.PI; // 导入 Math 类的 PI 常量 public class StaticImportExample { public static void main(String[] args) { System.out.println(\"Value of PI: \" + PI); } } 2.2 导入多个静态成员 如果需要导入多个静态成员，可以使用逗号分隔。 示例： import static java.lang.Math.*; public class StaticImportMultipleExample { public static void main(String[] args) { double radius = 5.0; double area = PI * pow(radius, 2); // 使用 pow() 方法 System.out.println(\"Area of Circle: \" + area); System.out.println(\"Square Root: \" + sqrt(25)); // 使用 sqrt() 方法 } } ","date":"2024-12-27","objectID":"/text45/:8:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 使用静态导入的示例 以下是一个使用静态导入的完整示例，其中导入了 java.lang.Math 类的所有静态成员。 import static java.lang.Math.*; public class CircleCalculator { public static void main(String[] args) { double radius = 7.0; // 直接使用 Math 类的静态方法和常量 double area = PI * pow(radius, 2); double circumference = 2 * PI * radius; System.out.println(\"Area of Circle: \" + area); System.out.println(\"Circumference of Circle: \" + circumference); } } ","date":"2024-12-27","objectID":"/text45/:8:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"4. 注意事项 命名冲突：当多个导入的静态成员同名时，编译器将会出现错误。您需要明确指定使用的类名。 import static java.lang.Math.*; import static java.lang.System.*; public class NamingConflictExample { public static void main(String[] args) { // 使用 System.out 以避免命名冲突 out.println(\"Hello, Static Import!\"); } } 遵循最佳实践：使用静态导入时，应保持适度，避免过度使用。此外，不建议在公共 API 中使用静态导入，以免减少可读性。 ","date":"2024-12-27","objectID":"/text45/:8:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"可变参数 在 Java 中，可变参数（Varargs）是一个强大的特性，允许方法接受不定数量的参数。这种特性简化了方法的定义和调用，可以在传递参数时更加灵活和便利。 ","date":"2024-12-27","objectID":"/text45/:9:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 可变参数的概述 1.1 定义 可变参数是 Java 方法定义的一种形式，允许方法接受零个或多个相同类型的参数。使用可变参数时，通过在参数类型后加三个点 ... 来声明。 1.2 语法 public void methodName(ParameterType... parameters) { // 方法体 } 1.3 优势 灵活性：调用时可以传递任意数量的参数。 可读性：减少了方法重载（overloading）的需要，使得代码更简洁。 简化调用：在调用方法时，不需要创建数组来传递多个参数。 ","date":"2024-12-27","objectID":"/text45/:9:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 使用可变参数 2.1 声明方法 以下是一个简单的示例，展示如何定义一个使用可变参数的方法。 示例： public class VarargsExample { // 定义一个使用可变参数的方法 public static void printNumbers(int... numbers) { for (int number : numbers) { System.out.print(number + \" \"); } System.out.println(); } public static void main(String[] args) { // 调用可变参数方法 printNumbers(1, 2, 3); // 1 2 3 printNumbers(4, 5, 6, 7, 8); // 4 5 6 7 8 printNumbers(); // 什么也不打印 } } 2.2 与其它参数结合使用 可变参数必须是方法参数列表中的最后一个参数。如果方法同时包含其它参数，可变参数必须置于最后。 示例： public class VarargsWithOtherParams { public static void displayInfo(String name, int... numbers) { System.out.print(name + \": \"); for (int number : numbers) { System.out.print(number + \" \"); } System.out.println(); } public static void main(String[] args) { displayInfo(\"Alice\", 10, 20); // Alice: 10 20 displayInfo(\"Bob\", 30, 40, 50); // Bob: 30 40 50 } } ","date":"2024-12-27","objectID":"/text45/:9:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 可变参数与数组的关系 可变参数在内部实际上被转换为数组，因此可以在方法体内以数组的形式处理。需要注意的是，当传递数组时，可以像传递可变参数一样使用。 示例： public class VarargsWithArrays { public static void sum(int... numbers) { int total = 0; for (int number : numbers) { total += number; } System.out.println(\"Sum: \" + total); } public static void main(String[] args) { // 传递多个参数 sum(1, 2, 3, 4); // Sum: 10 // 直接传递数组 int[] array = {5, 6, 7, 8}; sum(array); // Sum: 26 } } ","date":"2024-12-27","objectID":"/text45/:9:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"4. 注意事项 仅一个可变参数：每个方法只能有一个可变参数。 不能与泛型结合使用：方法不能声明可变参数与泛型类型，例如 public \u003cT\u003e void method(T... args)，这会导致编译错误。 与重载组合：如果创建了多个重载方法，其中一个方法使用了可变参数，需要小心可能发生的歧义。 ","date":"2024-12-27","objectID":"/text45/:9:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"Collections工具类 Collections 是 Java 的一个工具类，位于 java.util 包中，提供了多个静态方法来操作集合框架（如 List、Set 和 Map 等）。这个类为集合的创建、排序、搜索和同步等操作提供了许多常用的实用方法。 ","date":"2024-12-27","objectID":"/text45/:10:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 概述 Collections 类主要用于以下目的： 集合的操作：提供了操作集合的方法，如排序、查找等。 集合的创建：可用来创建空集合或不可变集合。 同步控制：提供对集合的同步支持，确保在多线程环境下进行安全操作。 算法支持：为集合提供常见算法的实现，如查找、排序和反转等。 ","date":"2024-12-27","objectID":"/text45/:10:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 常用方法 以下是 Collections 类的一些常用方法及其简单说明： 2.1 集合的排序和反转 sort(List\u003cT\u003e list)：对给定的列表进行升序排序。 sort(List\u003cT\u003e list, Comparator\u003c? super T\u003e c)：根据指定的比较器对列表进行排序。 reverse(List\u003c?\u003e list)：反转列表中元素的顺序。 shuffle(List\u003c?\u003e list)：随机打乱列表中的元素顺序。 swap(List\u003c?\u003e list, int i, int j)：交换指定列表中两个指定位置的元素。 2.2 集合的查找 binarySearch(List\u003c? extends Comparable\u003c? super T\u003e\u003e list, T key)：对已排序的列表进行二分搜索查找元素。 indexOfSubList(List\u003c?\u003e source, List\u003c?\u003e target)：返回目标子列表在源列表中的起始位置。 2.3 集合的创建 emptyList()：返回一个不可修改的空列表。 emptySet()：返回一个不可修改的空集合。 emptyMap()：返回一个不可修改的空映射。 singletonList(T o)：返回一个包含单一元素的不可修改列表。 singleton(T o)：返回一个只包含一个指定元素的不可修改集合。 singletonMap(K key, V value)：返回一个只包含一个映射关系的不可修改映射。 2.4 集合的同步 synchronizedList(List\u003cT\u003e list)：返回指定列表的同步（线程安全）视图。 synchronizedSet(Set\u003cT\u003e s)：返回指定集合的同步视图。 synchronizedMap(Map\u003cK,V\u003e m)：返回指定映射的同步视图。 2.5 集合的不可变视图 unmodifiableList(List\u003c? extends T\u003e list)：返回指定列表的不可修改视图。 unmodifiableSet(Set\u003c? extends T\u003e s)：返回指定集合的不可修改视图。 unmodifiableMap(Map\u003c? extends K, ? extends V\u003e m)：返回指定映射的不可修改视图。 2.6 其他常用方法 frequency(Collection\u003c?\u003e c, Object o)：返回指定集合中指定元素出现的次数。 disjoint(Collection\u003c?\u003e c1, Collection\u003c?\u003e c2)：判断两个集合是否没有共同元素。 ","date":"2024-12-27","objectID":"/text45/:10:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 示例 以下是一些 Collections 类方法的使用示例： import java.util.*; public class CollectionsExample { public static void main(String[] args) { // 创建一个列表 List\u003cInteger\u003e list = new ArrayList\u003c\u003e(Arrays.asList(5, 3, 8, 1, 4)); // 对列表排序 Collections.sort(list); System.out.println(\"Sorted list: \" + list); // 对列表反转 Collections.reverse(list); System.out.println(\"Reversed list: \" + list); // 随机打乱列表 Collections.shuffle(list); System.out.println(\"Shuffled list: \" + list); // 查找元素 int index = Collections.binarySearch(list, 4); System.out.println(\"Index of 4: \" + index); // 创建不可修改的列表 List\u003cInteger\u003e unmodifiableList = Collections.unmodifiableList(list); System.out.println(\"Unmodifiable list: \" + unmodifiableList); // unmodifiableList.add(6); // 这行会抛出 UnsupportedOperationException // 同步列表 List\u003cInteger\u003e synchronizedList = Collections.synchronizedList(new ArrayList\u003c\u003e()); synchronizedList.add(10); synchronizedList.add(20); System.out.println(\"Synchronized list: \" + synchronizedList); } } ","date":"2024-12-27","objectID":"/text45/:10:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"IO流 在 Java 中，IO（Input/Output）流用于读取和写入数据。Java 提供了丰富的 IO 类库，使得文件操作、网络通信、以及数据处理等变得简单而高效。Java 的 IO 流分为两大类：**字节流和字符流。**下面我们将详细介绍这两类流的特点、使用方式以及常见的类。 ","date":"2024-12-27","objectID":"/text45/:11:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. IO 流的分类 1.1 字节流 字节流用于处理原始的二进制数据，适合于所有类型的文件（如图片、音频、视频等）。字节流类通常以 InputStream 和 OutputStream 为基类。 主要类： InputStream：所有字节输入流的超类。 FileInputStream：从文件读取字节流。 BufferedInputStream：为其他 InputStream 提供缓冲功能，提高读写效率。 ByteArrayInputStream：从字节数组中读取数据。 OutputStream：所有字节输出流的超类。 FileOutputStream：将字节写入文件。 BufferedOutputStream：为其他 OutputStream 提供缓冲功能，提高输出效率。 ByteArrayOutputStream：将数据写入字节数组。 1.2 字符流 字符流专门用于处理字符数据，适合于文本文件的读写. 字符流类以 Reader 和 Writer 为基类。 主要类： Reader：所有字符输入流的超类。 FileReader：从文件读取字符流。 BufferedReader：为其他 Reader 提供缓冲功能，可高效地读取文本。 CharArrayReader：从字符数组中读取数据。 Writer：所有字符输出流的超类。 FileWriter：将字符写入文件。 BufferedWriter：为其他 Writer 提供缓冲功能，提高写入效率。 CharArrayWriter：将字符输出到字符数组。 ","date":"2024-12-27","objectID":"/text45/:11:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 示例代码 下面我们来看一个简单的示例，演示如何使用字节流和字符流读取和写入文件。 2.1 使用字节流读取和写入文件 import java.io.*; public class ByteStreamExample { public static void main(String[] args) { String filePath = \"example.txt\"; // 写入文件 try (FileOutputStream fos = new FileOutputStream(filePath); BufferedOutputStream bos = new BufferedOutputStream(fos)) { String data = \"Hello, World!\"; bos.write(data.getBytes()); System.out.println(\"Data written to file: \" + data); } catch (IOException e) { e.printStackTrace(); } // 读取文件 try (FileInputStream fis = new FileInputStream(filePath); BufferedInputStream bis = new BufferedInputStream(fis)) { int content; System.out.print(\"Data read from file: \"); while ((content = bis.read()) != -1) { System.out.print((char)content); } System.out.println(); } catch (IOException e) { e.printStackTrace(); } } } 2.2 使用字符流读取和写入文件 import java.io.*; public class CharStreamExample { public static void main(String[] args) { String filePath = \"example.txt\"; // 写入文件 try (FileWriter fw = new FileWriter(filePath); BufferedWriter bw = new BufferedWriter(fw)) { String data = \"Hello, Java I/O!\"; bw.write(data); System.out.println(\"Data written to file: \" + data); } catch (IOException e) { e.printStackTrace(); } // 读取文件 try (FileReader fr = new FileReader(filePath); BufferedReader br = new BufferedReader(fr)) { String line; System.out.println(\"Data read from file:\"); while ((line = br.readLine()) != null) { System.out.println(line); } } catch (IOException e) { e.printStackTrace(); } } } ","date":"2024-12-27","objectID":"/text45/:11:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"File类概述 在Java的IO（输入输出）中，File类是一个非常重要的类，它用于表示文件和目录的路径。通过File类，你可以创建、删除、重命名文件和目录，以及检查文件的属性，比如是否存在、可读性和写入权限等。 ","date":"2024-12-27","objectID":"/text45/:12:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"File类概述 表示：File类并不代表文件的内容，而是代表文件的路径名。它可以代表一个文件、一个目录，甚至是一个抽象的文件路径。 功能：能够执行文件的基本操作，比如创建、删除、重命名、遍历目录等。 跨平台：File对象可以在不同的操作系统中使用，Java会处理不同操作系统中的路径分隔符（如Windows的\\\\和Linux的/）。 ","date":"2024-12-27","objectID":"/text45/:12:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"常用构造方法 File类有多个构造方法，以下是最常用的几个： 使用字符串路径 File file = new File(String pathname); 创建一个表示指定路径名的文件或目录的File对象。 使用目录和文件名的组合 File file = new File(File parent, String child); 通过父目录和子文件名创建File对象，parent是一个File对象，child是文件名字符串。 使用两个File对象 File file = new File(String parent, String child); 通过路径字符串的父级路径和文件名字符串来创建File对象。 ","date":"2024-12-27","objectID":"/text45/:12:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"示例 // 创建指向文件的File对象 File file1 = new File(\"C:/example.txt\"); // 创建指向目录的File对象 File dir = new File(\"C:/exampleDir\"); // 通过目录和文件名创建File对象 File file2 = new File(dir, \"example.txt\"); ","date":"2024-12-27","objectID":"/text45/:12:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"其他常用方法 exists()：检查文件或目录是否存在。 isDirectory()：检查是否为目录。 isFile()：检查是否为文件。 createNewFile()：创建一个新文件。 delete()：删除文件或目录。 ","date":"2024-12-27","objectID":"/text45/:12:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"功能 File类在Java中的功能非常丰富，主要用于处理与文件和目录相关的操作。以下是File类提供的一些主要功能： 1. 文件和目录的创建 创建新文件： boolean created = file.createNewFile(); 该方法尝试创建一个新文件，如果文件已存在则返回false。 创建新目录： boolean created = dir.mkdir(); 如果目录不存在，创建一个新目录。如果多级目录不存在，可以使用mkdirs() 方法。 2. 文件和目录的删除 删除文件或目录： boolean deleted = file.delete(); 该方法删除文件，若是目录则需确保目录为空。 3. 文件和目录的重命名 重命名文件或目录： boolean renamed = file.renameTo(newFile); 该方法可以重命名一个文件或目录，包括移动到新位置。 4. 文件和目录的属性检查 检查文件的存在性： boolean exists = file.exists(); 检查是否为文件或目录： boolean isFile = file.isFile(); boolean isDirectory = dir.isDirectory(); 获取文件大小： long fileSize = file.length(); 获取最后修改时间： long lastModified = file.lastModified(); 5. 文件内容的读取和写入（结合其他类） File类本身不支持直接读取或写入文件内容，但它可以与FileInputStream, FileOutputStream, FileReader, FileWriter等类结合使用。 6. 文件的权限操作 检查可读性和可写性： boolean canRead = file.canRead(); boolean canWrite = file.canWrite(); 设置读写权限： boolean readable = file.setReadable(true); 7. 文件和目录的遍历 列出目录下的文件： String[] files = dir.list(); 使用listFiles()获取File对象数组： File[] files = dir.listFiles(); 8. 获取文件路径信息 获取绝对路径： String absolutePath = file.getAbsolutePath(); 获取路径名称： String path = file.getPath(); 9. 文件过滤器 使用过滤器列出特定类型的文件： FilenameFilter filter = (dir, name) -\u003e name.endsWith(\".txt\"); String[] txtFiles = dir.list(filter); 示例代码 import java.io.File; import java.io.IOException; public class FileExample { public static void main(String[] args) { File file = new File(\"example.txt\"); try { // 创建新文件 if (file.createNewFile()) { System.out.println(\"File created: \" + file.getName()); } else { System.out.println(\"File already exists.\"); } // 获取文件属性 System.out.println(\"Is file: \" + file.isFile()); System.out.println(\"File size: \" + file.length() + \" bytes\"); System.out.println(\"Absolute path: \" + file.getAbsolutePath()); // 删除文件 if (file.delete()) { System.out.println(\"File deleted successfully.\"); } else { System.out.println(\"Failed to delete the file.\"); } } catch (IOException e) { System.out.println(\"An error occurred.\"); e.printStackTrace(); } } } ","date":"2024-12-27","objectID":"/text45/:12:5","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"异常 在 Java 中，异常（Exception）是指在程序运行期间发生的不正常事件，通常会妨碍程序的正常执行。Java 提供了一种强大的异常处理机制，使程序能够应对可能出现的错误，确保应用程序的稳定性和可靠性。Java 的异常处理机制提供了一种有效的方法来捕获和处理错误。通过合理使用检查型异常和非检查型异常，以及有必要时定义自定义异常，可以提高代码的健壮性和可维护性。在开发中，应当尽量预测到可能出现的异常情况，并做好处理准备，以提升用户体验。 ","date":"2024-12-27","objectID":"/text45/:13:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 概述 Java 使用 try-catch 块来处理异常。try 块中包含可能引发异常的代码，catch 块用于捕获和处理异常。使用异常处理可以避免程序因遇到错误而崩溃，提供了应对错误的机制。 try { // 可能引发异常的代码 } catch (ExceptionType e) { // 处理异常 } This is a tip\r在try里面发现问题后，虚拟机JVM会帮我们生成一个异常对象，然后把这个对象抛出，和catch里面的类进行匹配，如果该对象是某个类型的，就会执行该catch里面的处理信息。\r","date":"2024-12-27","objectID":"/text45/:13:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 异常分类 Java 中的异常主要可以分为两大类： 2.1 检查型异常（Checked Exceptions） 检查型异常是在编译时检查的异常。它们是程序无法预料到的错误，通常是外部因素引起的，例如文件未找到、网络故障等。编译器要求程序必须处理这些异常（例如通过 try-catch 语句），或者将其声明在方法签名中。 例子： IOException：输入输出异常。 SQLException：数据库访问异常。 ClassNotFoundException：类未找到异常。 示例： try { FileInputStream file = new FileInputStream(\"nonexistent.txt\"); } catch (IOException e) { System.out.println(\"文件未找到\"); } 2.2 非检查型异常（Unchecked Exceptions） 非检查型异常是在运行时发生的异常，编译器不要求开发者处理或声明。它们通常是由于编程错误导致的，比如访问数组越界、空指针引用等。非检查型异常的继承结构通常是 RuntimeException 类及其子类。 例子： NullPointerException：空指针异常。 ArrayIndexOutOfBoundsException：数组索引越界异常。 ArithmeticException：算术运算异常（如除以零）。 示例： try { String str = null; System.out.println(str.length()); // 这将引发 NullPointerException } catch (NullPointerException e) { System.out.println(\"空指针异常\"); } ","date":"2024-12-27","objectID":"/text45/:13:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 自定义异常 Java 允许开发者定义自定义异常，通过创建一个继承自 Exception（检查型异常）或 RuntimeException（非检查型异常）的类来实现。 自定义异常示例： public class MyException extends Exception { public MyException(String message) { super(message); } } // 使用自定义异常 try { throw new MyException(\"这是一个自定义异常！\"); } catch (MyException e) { System.out.println(e.getMessage()); } ","date":"2024-12-27","objectID":"/text45/:13:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"4.多个异常情况 在 Java 中，当一个代码块中可能抛出多种不同类型的异常时，开发者需要提供相应的处理方案。Java 提供了多种方式来处理多个异常，以下是一些常见的处理方案。处理多个异常的方法有很多种，选择合适的方案主要依赖于具体的需求和代码的复杂性。合理地使用 try-catch 块、重新抛出异常，以确保代码的可读性和可维护性是非常重要的。 1. 使用多个 catch 块 最直接的方式是为每种可能的异常类型提供单独的 catch 块。这样可以为不同的异常提供针对性的处理。 示例代码： public class MultiCatchExample { public static void main(String[] args) { try { // 可能抛出不同异常的代码 String str = null; System.out.println(str.length()); // NullPointerException int[] arr = {1, 2, 3}; System.out.println(arr[5]); // ArrayIndexOutOfBoundsException } catch (NullPointerException e) { System.out.println(\"捕获空指针异常: \" + e.getMessage()); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"捕获数组越界异常: \" + e.getMessage()); } } } 2. 使用多重 catch 块（从 Java 7 开始） 从 Java 7 开始，可以使用多重 catch 块一次捕获多个异常，并在同一个 catch 块中处理它们。这对于有类似处理逻辑的异常特别有用。 示例代码： public class MultiCatchExample { public static void main(String[] args) { try { // 可能抛出不同异常的代码 String str = null; System.out.println(str.length()); // NullPointerException int[] arr = {1, 2, 3}; System.out.println(arr[5]); // ArrayIndexOutOfBoundsException } catch (NullPointerException | ArrayIndexOutOfBoundsException e) { System.out.println(\"捕获异常: \" + e.getClass().getSimpleName() + \" - \" + e.getMessage()); } } } 3. 通用异常处理 在某些情况下，可能希望捕获所有异常，并进行统一处理。在这种情况下，可以使用一个通用的 catch 块，捕获 Exception 或 Throwable 类。 示例代码： public class GeneralExceptionExample { public static void main(String[] args) { try { // 可能抛出不同异常的代码 String str = null; System.out.println(str.length()); // NullPointerException int[] arr = {1, 2, 3}; System.out.println(arr[5]); // ArrayIndexOutOfBoundsException } catch (Exception e) { // 捕获所有异常 System.out.println(\"捕获异常: \" + e.getClass().getSimpleName() + \" - \" + e.getMessage()); } } } 4. 嵌套 try-catch 在某些情况下，可以使用嵌套的 try-catch 块，根据不同的情况分别处理不同的代码块，这样可以提高代码的灵活性。 示例代码： public class NestedTryCatchExample { public static void main(String[] args) { try { // 第一个 try 块 String str = null; try { System.out.println(str.length()); // NullPointerException } catch (NullPointerException e) { System.out.println(\"捕获空指针异常: \" + e.getMessage()); } // 第二个 try 块 int[] arr = {1, 2, 3}; try { System.out.println(arr[5]); // ArrayIndexOutOfBoundsException } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"捕获数组越界异常: \" + e.getMessage()); } } catch (Exception e) { System.out.println(\"捕获中的其他异常: \" + e.getMessage()); } } } 5. 重新抛出异常 在处理完异常后，有时需要将其重新抛出，允许调用者处理异常。这可以通过在 catch 块中使用 throw 语句实现。 示例代码： public class RethrowExceptionExample { public static void main(String[] args) { try { methodThatThrows(); } catch (Exception e) { System.out.println(\"捕获异常: \" + e.getMessage()); // 进一步处理 throw e; // 重新抛出异常 } } public static void methodThatThrows() throws Exception { throw new Exception(\"这是一个示例异常\"); } } ","date":"2024-12-27","objectID":"/text45/:13:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"5.Throwable的几个常用方法 在 Java 中，Throwable 是所有错误和异常的超类。它有两个主要子类：Error 和 Exception。Throwable 提供了几种常用的方法，这些方法可以帮助我们处理异常并获取相关信息。以下是 Throwable 类的一些常用方法： 1. 常用方法 1.1 getMessage() 描述：返回异常的详细信息字符串。这个信息通常是在构造异常时通过字符串传入的。 示例： try { throw new Exception(\"这是一个异常信息\"); } catch (Exception e) { System.out.println(e.getMessage()); // 输出: 这是一个异常信息 } 1.2 printStackTrace() 描述：将异常的信息和调用堆栈的跟踪信息打印到标准错误流。这对于调试非常有用，因为它提供了异常发生时程序的状态。 示例： try { throw new Exception(\"发生了异常\"); } catch (Exception e) { e.printStackTrace(); // 打印异常的栈跟踪信息 } 1.3 getCause() 描述：返回导致此异常的原因，通常也是一个 Throwable 对象。如果没有原因，则返回 null。 示例： try { throw new Exception(\"外层异常\", new IllegalArgumentException(\"内部导致的原因\")); } catch (Exception e) { System.out.println(\"外层异常: \" + e.getMessage()); System.out.println(\"导致原因: \" + e.getCause().getMessage()); // 输出: 内部导致的原因 } 1.4 getStackTrace() 描述：返回表示当前异常的堆栈跟踪元素的数组。每个堆栈跟踪元素都是 StackTraceElement 对象，包含类名、方法名、文件名和行号。 示例： try { throw new Exception(\"这是异常\"); } catch (Exception e) { StackTraceElement[] stackTrace = e.getStackTrace(); for (StackTraceElement element : stackTrace) { System.out.println(element); // 输出每个堆栈跟踪元素 } } 1.5 toString() 描述：返回包含异常类名和详细消息的字符串。可以用于快速了解异常的类型和信息。 示例： try { throw new Exception(\"异常发生\"); } catch (Exception e) { System.out.println(e.toString()); // 输出: java.lang.Exception: 异常发生 } ","date":"2024-12-27","objectID":"/text45/:13:5","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"6.throw以及throws的区别 throw 和 throws 都与异常处理有关，但它们的用途和功能有所不同。 下面是对这两者的详细比较和解释。 throw: 用于显式地抛出一个异常实例。 发生异常后，方法会立即中止，控制权转移到异常处理器。 throws: 用于在方法声明中指示可能抛出的异常类型。 允许调用者处理这些异常，确保代码的健壮性。 1. throw 定义：throw 是一个关键字，用于显式地抛出一个异常。在执行到 throw 语句时，程序会停止执行当前方法的剩余代码，并立即跳转到最近的异常处理器（即对应的 catch 块）。 用法：通常在方法内部，配合一个实例化的异常类来使用。 示例： public class ThrowExample { public static void main(String[] args) { try { checkAge(15); // 这个调用将引发一个异常 } catch (IllegalArgumentException e) { System.out.println(\"捕获异常: \" + e.getMessage()); } } static void checkAge(int age) { if (age \u003c 18) { throw new IllegalArgumentException(\"年龄必须大于等于 18 岁\"); // 使用 throw 抛出异常 } System.out.println(\"年龄合格\"); } } 2. throws 定义：throws 是一个声明，用于在方法头中指示这个方法可能抛出的异常类型。当一个方法声明中包含 throws 时，调用这个方法的代码必须处理或声明这些异常。 用法：用于方法的定义部分，告诉调用者这个方法可能出现的异常，以便调用者能够采取适当的措施进行处理。 示例： public class ThrowsExample { public static void main(String[] args) { try { readFile(\"nonexistent.txt\"); // 调用可能抛出异常的方法 } catch (IOException e) { System.out.println(\"捕获异常: \" + e.getMessage()); } } static void readFile(String fileName) throws IOException { // 使用 throws 声明可能抛出的异常 FileInputStream fis = new FileInputStream(fileName); fis.close(); // 在此处可能抛出 IOException } } 实际应用 通常，在方法内部使用 throw 来抛出具体的异常，指示发生了问题。 在方法签名中使用 throws 使得调用者能够了解这个方法可能会出现哪些异常，并采取适当的处理措施。 ","date":"2024-12-27","objectID":"/text45/:13:6","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"finally关键字 finally 关键字是 Java 异常处理的重要组成部分，它用于定义无论是否发生异常都要执行的代码块。以下是 finally 关键字的特点和作用的详细说明。 finally 关键字确保了在异常处理后，某些重要操作总是会被执行，尤其是在处理资源和清理操作时非常有用。 创建健壮的代码时，使用 finally 块是一种良好的编程实践，可以有效管理资源生命周期。 ","date":"2024-12-27","objectID":"/text45/:14:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"特点 总是执行： finally 块中的代码会在 try 块执行完成后执行，无论 try 中是否抛出异常。即使发生了 System.exit() 或者强制终止程序，finally 块也可能被执行（但不能保证）。 与异常处理结合使用： 通常，finally 与 try 和 catch 语句结合使用，用于清理资源或执行必要的后续操作。 可以没有 catch 块： finally 块可以在没有 catch 块的情况下使用，但必须有 try 块。 可以有多个 finally 块： 一个 try 块只可以有一个对应的 finally 块，但可以嵌套多个 try-finally 组合。 ","date":"2024-12-27","objectID":"/text45/:14:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"作用 资源清理： finally 块通常用于释放系统资源，例如关闭文件流、数据库连接或网络连接等。这样可以确保即使发生异常，资源也会得到正常释放。 日志记录： 在 finally 块中可以记录日志，以便在应用程序崩溃或出现故障时进行故障排除。 执行必要操作： 在一些情况下，确保某些操作始终执行，例如状态重置、数据刷新等。 ","date":"2024-12-27","objectID":"/text45/:14:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"示例代码 下面的代码展示了 finally 的用法： public class FinallyExample { public static void main(String[] args) { System.out.println(\"开始执行方法\"); try { int result = 10 / 0; // 这里将抛出 ArithmeticException System.out.println(\"结果: \" + result); } catch (ArithmeticException e) { System.out.println(\"捕获异常: \" + e.getMessage()); } finally { System.out.println(\"这是 finally 块，无论是否发生异常都会执行\"); } System.out.println(\"程序结束\"); } } ","date":"2024-12-27","objectID":"/text45/:14:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"输出结果 开始执行方法 捕获异常: / by zero 这是 finally 块，无论是否发生异常都会执行 程序结束 在这个示例中，尽管在 try 块中抛出了异常，finally 块中的代码依然被执行，显示了它的特性。 This is a tip\r两个面试题： 1）final、finally、finalize的区别？ final：修饰符。可以修饰类（类不能被继承）、成员变量（变量为常量）、成员方法（方法不能被重写） finally：是异常处理的一部分，用于释放系统资源。 finalize：是Object类的一个方法，用于垃圾回收。 2)如果catch里面有return语句，请问finally里面的代码还会执行吗？如果会，是在return前还是后？ 会 前 finalize详解： 在 Java 中，finalize() 是 java.lang.Object 类中的一个方法，用于处理对象的终结。在对象被垃圾收集器回收之前，如果该对象有一个 finalize() 方法，则会在垃圾收集器调用这个对象之前执行这个方法。以下是关于 finalize() 方法的详细介绍。 1. finalize() 方法的特性 定义：finalize() 方法用于在对象被垃圾收集前提供一种清理资源的机会。它可以被重写，以便在垃圾收集时执行特定的清理代码。 调用时机：finalize() 方法在对象即将被垃圾回收时由 Java 虚拟机自动调用，具体时机是不确定的。 默认行为：finalize() 方法的默认实现为空，不执行任何操作。 2. 语法 finalize() 方法的定义如下： protected void finalize() throws Throwable { // 清理代码 super.finalize(); // 可调用父类的 finalize 方法 } 3. 示例 下面是一个 finalize() 方法的简单示例： public class FinalizeExample { @Override protected void finalize() throws Throwable { try { System.out.println(\"对象即将被垃圾收集\"); // 在此处释放资源或进行清理 } finally { super.finalize(); // 调用父类的 finalize 方法 } } public static void main(String[] args) { FinalizeExample obj = new FinalizeExample(); obj = null; // 使对象变为可被垃圾回收的状态 System.gc(); // 请求Java虚拟机进行垃圾回收 } } 4. 注意事项 不保证调用：虽然可以请求 JVM 进行垃圾回收（例如通过调用 System.gc()），但是 JVM 不保证会立即进行。因此，finalize() 方法的调用时机是不确定的。 性能问题：使用 finalize() 可能会引起性能问题，因为它延迟了对象的回收，导致内存使用增加。同时，finalize() 方法的执行也可能需要较长的时间，因此不推荐用于资源管理。 废弃建议：在 Java 9 及之后的版本中，finalize() 方法已经被标记为过时，被建议使用更有效的资源管理机制，例如 try-with-resources 语句和实现 AutoCloseable 接口的类。 5. 替代方案 由于 finalize() 存在各种局限性，Java 推荐使用其他方法来管理资源，例如： Try-with-resources：可以自动关闭资源，使用 AutoCloseable 接口。 try (BufferedReader br = new BufferedReader(new FileReader(\"file.txt\"))) { // 读取文件的代码 } catch (IOException e) { e.printStackTrace(); } // BufferedReader 会在此处自动关闭 注意！！！ finalize() 方法在 Java 中曾经用于执行对象被垃圾回收前的清理操作，但由于其不确定性和性能问题，推荐使用其他资源管理方式。在设计新代码时，应优先考虑使用 try-with-resources 或者手动关闭资源，以提高代码的健壮性和可维护性。 ","date":"2024-12-27","objectID":"/text45/:14:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"多线程 多线程是一种强大的编程模型，适用于需要并行处理的场景，但也带来了一些复杂性。 多线程允许程序同时执行多个线程，以提高程序的性能效率和响应能力。 以下是关于多线程的基本概述： ","date":"2024-12-27","objectID":"/text45/:15:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"多线程的定义 线程：一个线程是进程内的一个运行单位，进程可以包含一个或多个线程。每个线程拥有自己的栈、局部变量和程序计数器，但共享进程的内存和资源（如打开的文件和全局变量）。 多线程：同时运行多个线程的能力。通过将程序分解成多个执行单元，允许它们在同一时间段内并发执行。 线程的概念：线程是程序执行中的一个基本单位。 线程（Thread）是程序执行的最小单位，代表了程序中独立的执行路径。线程在进程内部运行，多个线程可以共享同一进程的资源（如内存和文件）。 线程的类型： 用户级线程：在用户空间管理，操作系统对此不可见。线程的创建与管理由用户程序控制。 内核级线程：由操作系统内核直接管理，每个线程都被操作系统识别，操作系统能够为每个线程调度CPU时间。 进程的概念：进程是操作系统中的一个核心概念，表示运行中的程序的实例。 进程（Process）是一个正在执行的程序的实例，它拥有自己的地址空间、数据、代码、文件描述符等资源。进程是操作系统进行资源分配和调度的基本单位。 线程的特点： 轻量级：创建和销毁线程的开销较小，线程的上下文切换比进程更快。 共享资源：同一进程中的多个线程共享内存空间、数据和资源，这使得线程间的通信更为高效。 并发执行：多个线程可以并发执行，尤其在多核CPU系统中，可以实现真正的并行处理。 进程的特点： 独立性：每个进程都有自己的虚拟地址空间、资源和环境，它们之间相互独立，进程的执行不会影响其他进程。 资源分配：进程是操作系统分配系统资源（如CPU时间、内存）的基本单位。 动态性：进程的状态会根据执行的进度而变化，例如从就绪、运行、阻塞等状态之间转换。 线程的生命周期： 线程的生命周期通常包括以下几个状态： 新建（New）：线程被创建但尚未启动。 就绪（Runnable）：线程已经启动并准备好执行，等待操作系统分配CPU。 运行（Running）：线程正在执行其任务。 阻塞（Blocked）：线程因等待某个资源（如I/O操作）而暂时无法执行。 终止（Terminated）：线程执行结束，无法再运行。 进程的生命周期： 进程的生命周期通常包括以下几个状态： 新建（New）：进程被创建并准备好进行初始化。 就绪（Ready）：进程已经为执行做好了准备，等待操作系统分配CPU。 运行（Running）：进程正在CPU上执行程序。 阻塞（Blocked）：进程由于等待某种事件（如I/O操作的完成）而暂时无法执行。 终止（Terminated）：进程执行完毕，释放占用的系统资源。 进程的创建： 在操作系统中，进程的创建通常涉及以下步骤： 分配资源：操作系统为新进程分配内存、文件描述符等资源。 设置进程控制块（PCB）：操作系统创建一个进程控制块，保存进程的状态、优先级、程序计数器等信息。 放入就绪队列：新创建的进程将进入就绪状态，等待CPU的调度。 进程间通信（IPC）： 由于不同进程之间是相互独立的，进程间需要使用特定的机制来进行通信和数据交换。常见的进程间通信方法包括： 管道（Pipes）：允许两个进程之间通过一个缓冲区进行数据传递。 消息队列：通过操作系统提供的消息系统进行异步消息传递。 共享内存：多个进程可以访问同一块内存区域，实现高效的数据共享。 信号量：用于控制对共享资源的访问，避免竞争条件。 进程的管理： 进程的管理是操作系统的一项重要任务，涉及到以下方面： 调度：操作系统决定哪个进程获得CPU的使用权。 上下文切换：在多个进程之间切换CPU资源，以便实现多任务处理。 资源管理：确保每个进程能够有效地使用和释放系统资源。 ","date":"2024-12-27","objectID":"/text45/:15:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"多线程的实现 在Java中，可以通过以下两种主要方式实现多线程： 继承Thread类： class MyThread extends Thread { public void run() { // 线程执行代码 System.out.println(\"Thread is running.\"); } } public class Main { public static void main(String[] args) { MyThread thread = new MyThread(); thread.start(); // 启动线程 } } 实现Runnable接口： class MyRunnable implements Runnable { public void run() { // 线程执行代码 System.out.println(\"Thread is running.\"); } } public class Main { public static void main(String[] args) { Thread thread = new Thread(new MyRunnable()); thread.start(); // 启动线程 } } ","date":"2024-12-27","objectID":"/text45/:15:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"并行VS并发 并发（Concurrency） 定义：并发指的是在同一时间段内处理多个任务或线程的能力。并发不要求任务或线程在同一时刻运行，而是可以在时间上交错进行。也就是说，从逻辑上看，多个线程可以同时进行，但实际上在单个处理器上，线程可能会轮流执行。 典型场景：如果一个程序在等待某个操作（如I/O操作），就可以同时处理其他线程的任务。此时，多个线程在逻辑上并发运行，但在物理上可能依赖于上下文切换。 示例：一个用户界面(UI)线程可以在等待用户输入时，同时处理后台数据下载。这意味着即使这两个操作不是在同一时刻完成，它们的进程在时间上重叠了。 并行（Parallelism） 定义：并行指的是在同一时间点实际同时执行多个任务或线程。这通常发生在多核处理器上，每个核心可以在同一时间独立地处理一个或多个线程，从而实现真正的并行执行。 典型场景：计算密集型的任务可以被分解成若干子任务，然后分配到不同的处理器核心上同时进行计算。 示例：一个应用程序可以将大数据集的处理任务分成多个部分，每个部分在不同的CPU核心上同时计算。例如，使用多线程计算一个复杂矩阵的乘法，每个线程处理矩阵的一部分。 并发与并行的区别 特性 并发 并行 定义 在同一时间段内逻辑上处理多个线程 在同一时间点实际同时处理多个线程 多核利用 不一定需要多核 需要多个处理器核心 实现方式 通过线程间交替执行（上下文切换） 通过多核处理器同时执行 适用场景 I/O密集型应用、需要等待的操作 CPU密集型任务 ","date":"2024-12-27","objectID":"/text45/:15:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"run() 和 start() run() 方法：用于定义线程要执行的代码。如果直接调用，会在当前线程中执行，而不是开启新线程。 start() 方法：用于启动新线程，创建一个新的线程对象，并调用该对象的 run() 方法，实际实现多线程。 在需要实现多线程功能时，应始终使用 start() 方法而不是直接调用 run() 方法。 1. run() 方法 定义：run() 方法属于 Runnable 接口（或继承自 Thread 类的实例），包含了线程将要执行的代码。 直接调用：如果你直接调用 run() 方法，这实际上并不会创建新线程，而是在当前线程中执行 run() 方法中的代码。这样就失去了多线程的效果。 示例： class MyThread extends Thread { public void run() { System.out.println(\"Running in thread: \" + Thread.currentThread().getName()); } } public class Main { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.run(); // 直接调用run()，在主线程中执行 System.out.println(\"Back in main thread: \" + Thread.currentThread().getName()); } } 输出： Running in thread: main Back in main thread: main 在上面的示例中，run() 方法在主线程中执行，而没有启动一个新线程。 2. start() 方法 定义：start() 方法用于启动一个新线程。调用这个方法会让JVM为当前 Thread 对象创建一个新的线程，并调用 run() 方法以执行线程的任务。 创建新线程：它会导致JVM创建一个新的线程，并在新线程中调用 run() 方法。因此，使用 start() 方法可以实现真正的多线程效果。 示例： class MyThread extends Thread { public void run() { System.out.println(\"Running in thread: \" + Thread.currentThread().getName()); } } public class Main { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.start(); // 启动一个新线程 System.out.println(\"Back in main thread: \" + Thread.currentThread().getName()); } } 输出（输出顺序可能不同）： Running in thread: Thread-0 Back in main thread: main 上面示例中，start() 方法创建了一个新线程来执行 run() 方法，从而实现了真正的并行执行。 ","date":"2024-12-27","objectID":"/text45/:15:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"线程调度及获取 在多线程环境中，操作系统通过调度算法确保各个线程能够公平地获得CPU的使用权，从而实现任务的并发执行。线程调度是在多线程环境中管理和分配CPU时间的重要机制，通过不同的调度算法，操作系统可以有效地管理多个线程的执行。Java中的线程调度依赖于JVM和操作系统的实现。 线程调度的基本概念 线程调度：指操作系统在多个线程之间分配CPU时间的过程。操作系统通过调度程序来决定哪个线程在何时运行以及运行多长时间。 调度算法：操作系统使用不同的调度算法来管理线程的执行。常见的调度算法包括： 先来先服务（FCFS）：按照线程请求CPU的顺序进行调度。 短作业优先（SJF）：优先调度执行时间短的线程。 轮转调度（Round Robin）：为每个线程分配一个时间片，时间片耗尽后切换到下一个线程。 优先级调度：根据线程的优先级调度高优先级的线程。 上下文切换：当操作系统从一个线程切换到另一个线程时，会需要保存当前线程的状态并加载下一个线程的状态，这个过程称为上下文切换。上下文切换会引入一定的开销，因此高频率的上下文切换会影响系统性能。 获取线程信息 在Java中，你可以使用以下方法获取线程的各种信息： 获取当前线程： 使用 Thread.currentThread() 方法可以获取当前执行的线程对象。 public class Main { public static void main(String[] args) { Thread currentThread = Thread.currentThread(); System.out.println(\"Current Thread: \" + currentThread.getName()); } } 获取线程ID： 通过 getId() 方法可以获取线程的唯一标识符。 System.out.println(\"Thread ID: \" + currentThread.getId()); 获取线程状态： 使用 getState() 方法可以检查线程的当前状态（如新建、就绪、运行、阻塞、终止等）。 System.out.println(\"Thread State: \" + currentThread.getState()); 获取线程优先级： 每个线程都有一个优先级，可以通过 getPriority() 和 setPriority(int newPriority) 方法获取和设置线程的优先级。 System.out.println(\"Thread Priority: \" + currentThread.getPriority()); 线程的调度策略 在Java中，线程调度通常由JVM的实现和操作系统共同决定。目前Java标准没有规定调度的精确算法，通常依赖于操作系统的底层实现。不同的操作系统可能以不同的方式来调度和管理线程。 时间片调度：大多数现代操作系统（如Windows、Linux）使用时间片轮转调度，Java中的线程也会按照这种方式获得CPU的时间。 实时线程调度：在某些情况下，特别是需要实时性能的应用中，Java提供了对实时线程的一定支持。例如，通过 Thread.setPriority() 方法可以为线程设置更高的优先级。 ","date":"2024-12-27","objectID":"/text45/:15:5","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"设置线程优先级 在Java中，线程优先级是用于影响线程调度的重要因素。通过设置线程的优先级，开发者可以建议调度器对不同线程的调度顺序。本质上，线程优先级可以帮助操作系统更有效地选择哪个线程应该获得CPU的使用权。 默认线程优先级 Java中的线程优先级是一个整数值，范围从 Thread.MIN_PRIORITY（1）到 Thread.MAX_PRIORITY（10）。 默认的线程优先级是 Thread.NORM_PRIORITY（5）。 设置线程优先级 可以使用 setPriority(int priority) 方法设置线程的优先级。例如： class MyThread extends Thread { public void run() { for (int i = 0; i \u003c 5; i++) { System.out.println(\"Thread: \" + Thread.currentThread().getName() + \" - Count: \" + i); } } } public class Main { public static void main(String[] args) { MyThread thread1 = new MyThread(); MyThread thread2 = new MyThread(); // 设置线程优先级 thread1.setPriority(Thread.MIN_PRIORITY); // 最低优先级 thread2.setPriority(Thread.MAX_PRIORITY); // 最高优先级 thread1.start(); thread2.start(); } } 获取线程优先级 要获取线程的当前优先级，可以使用 getPriority() 方法： System.out.println(\"Thread 1 Priority: \" + thread1.getPriority()); System.out.println(\"Thread 2 Priority: \" + thread2.getPriority()); 注意事项 调度器的实现：尽管可以设置线程的优先级，但实际的调度仍然取决于操作系统以及其线程调度算法。不同操作系统可能会对权限设置有不同的响应。 优先级的相对性：即使高优先级的线程在系统中优先获得CPU资源，也不能保证它会优先执行，特别是在负载较重的环境中，优先级的影响可能会被削弱。 优化：在大多数情况下，合理设计程序逻辑和使用合适的线程数比仅依靠线程优先级来优化性能要更有效。 ","date":"2024-12-27","objectID":"/text45/:15:6","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"线程控制相关方法 Java中提供了多种方法用于线程控制，包括各种启动、等待、睡眠和优先级设置方法。这些方法主要用于管理线程的生命周期、协调多个线程之间的执行、设置线程优先级等。以下是一些常用的线程控制相关方法： 1. 线程生命周期控制 start()： 启动线程，使其进入就绪状态，准备开始执行。 这个方法不能重复调用。 MyThread thread = new MyThread(); thread.start(); run()： 定义线程执行的任务。直接调用此方法将在调用它的线程中执行，而不会启动新线程。 public void run() { // 任务逻辑 } join()： 等待线程完成执行。当调用 join() 方法时，当前线程会被阻塞，直到被调用的线程完成。 thread.join(); // 等待thread执行完成 interrupt()： 中断线程，即发出中断信号。此方法不会立即停止线程，而是设置线程的中断状态，线程可以在适当的时候检查这一状态并作出响应。 thread.interrupt(); isAlive()： 检查线程是否仍在活动状态。如果线程已经完成执行，该方法返回 false，否则返回 true。 boolean isRunning = thread.isAlive(); 2. 线程睡眠与释放 sleep(long millis)： 使当前线程暂停执行指定的毫秒数。注意，这是一个静态方法，通常用来简单地延迟线程的执行。 try { Thread.sleep(1000); // 暂停1秒 } catch (InterruptedException e) { e.printStackTrace(); } 3. 线程优先级控制 setPriority(int newPriority)： 设置线程的优先级，优先级范围从 Thread.MIN_PRIORITY（1）到 Thread.MAX_PRIORITY（10）。 thread.setPriority(Thread.MAX_PRIORITY); // 设置为最高优先级 getPriority()： 返回线程的当前优先级。 int priority = thread.getPriority(); 4. 线程的状态与控制 yield()： 提示调度器当前线程愿意让出CPU资源，允许其他线程有机会执行。它不是强制的，具体行为取决于调度器的实现。 Thread.yield(); // 让步 suspend() 和 resume()（不推荐）： 这些方法可以暂停和恢复线程，但由于容易引入死锁问题，已被弃用。推荐使用使用 wait() 和 notify() 机制来协调线程的执行。 5. 其他的控制方法 wait()： 在对象上调用此方法会使当前线程等待，直到其他线程调用同一对象的 notify() 或 notifyAll() 方法。 synchronized (object) { object.wait(); // 释放锁并等待 } notify() 和 notifyAll()： 唤醒在对象上等待的一个或所有线程。通常在持有对象锁的情况下调用。 synchronized (object) { object.notify(); // 唤醒等待线程 } ","date":"2024-12-27","objectID":"/text45/:15:7","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"线程的生命周期图解 +---------+ | NEW | ---\u003e 创建线程 +---------+ | | start() v +---------+ | RUNNABLE| \u003c--- 就绪状态（准备运行） +---------+ | | 运行（CPU分配时间片） v +---------+ | BLOCKED | \u003c--- 阻塞状态 +---------+ | ^ | | 等待信号唤醒 | | | v +---------+ | WAITING | \u003c--- 等待状态 +---------+ | | 被其他线程唤醒 v +---------+ | TERMINATED| \u003c--- 线程结束 +---------+ 各状态说明 NEW（新建状态）： 线程被创建但尚未开始执行，此时线程还未调用 start() 方法。 RUNNABLE（可运行状态）： 线程处于就绪状态，准备运行。当调度器分配 CPU 时间给该线程时，它会开始执行。需要注意的是，处于 RUNNABLE 状态的线程并不意味着它正在执行，它可能在等待 CPU 时间。 BLOCKED（阻塞状态）： 线程因尝试获取一个已被其他线程持有的监视器锁而被阻塞。当该锁被释放时，线程会再次进入可运行状态。 WAITING（等待状态）： 线程进入此状态是为了等待其他线程的通知。线程会在调用 Object.wait()、Thread.join() 或 LockSupport.park() 时进入此状态。一旦目标线程调用了 notify()、notifyAll()或join()的线程调用完毕，等待线程会被唤醒，回到RUNNABLE` 状态。 TERMINATED（终止状态）： 线程的 run() 方法执行完毕或者由于异常而结束，线程会进入此状态。此时线程已完成其生命周期，无法再重新启动。 线程状态转换 通过调用 start() 方法，线程从 NEW 状态转变为 RUNNABLE 状态。 在线程的 run() 方法内，线程会进行实际的执行。 如果一个线程需要等待某个条件（如等待锁或资源），它将进入 BLOCKED 或 WAITING 状态。 当某个线程完成它的工作，它会进入 TERMINATED 状态。 ","date":"2024-12-27","objectID":"/text45/:15:8","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"线程安全问题及解决办法 线程安全是指多个线程同时访问同一个资源（如变量、对象等）时，程序的行为依然是正确的，而不会导致数据不一致或不正确的状态。线程安全问题通常发生在共享资源的访问和修改时。以下是一些常见的线程安全问题以及相应的解决办法。 常见的线程安全问题 竞态条件（Race Condition）： 当多个线程在并发执行时，如果不考虑线程的调度顺序，可能导致线程在相同时间访问共享资源，从而导致数据不一致。 死锁（Deadlock）： 当两个或多个线程对资源进行相互等待时，会导致所有相关线程无法继续执行。例如，线程 A 等待线程 B 的锁，而线程 B 等待线程 A 的锁。 活锁（Livelock）： 线程并不能进入等待状态，而是持续在做某些操作，导致系统无法推进，并且一直在反复尝试某种操作。 资源饥饿（Starvation）： 某些线程无法获取所需的资源，导致无法执行。这常常因为不合理的优先级策略导致某些线程长时间得不到 CPU 资源。 解决办法 使用 synchronized 关键字： Java 提供了 synchronized 关键字来锁定对象，从而使得某个代码块在任何时刻只有一个线程能执行。 该关键字可以用于方法或代码块。 public synchronized void method() { // 线程安全的代码 } public void method() { synchronized (this) { // 线程安全的代码 } } 使用 ReentrantLock： Java 提供了 java.util.concurrent.locks 包中的 ReentrantLock，这是一个更灵活的锁实现，支持公平性、可中断等特性。 import java.util.concurrent.locks.ReentrantLock; public class MyClass { private ReentrantLock lock = new ReentrantLock(); public void method() { lock.lock(); try { // 线程安全的代码 } finally { lock.unlock(); } } } 使用 volatile 关键字： 对于简单的状态共享（如布尔标志），可以使用 volatile 关键字，确保线程对变量的可见性，但不能代替锁。 private volatile boolean running = true; 使用原子类（Atomic Classes）： Java 提供 java.util.concurrent.atomic 包中的原子变量类，例如 AtomicInteger、AtomicBoolean 等，它们提供了对基本数据类型的原子操作。 import java.util.concurrent.atomic.AtomicInteger; public class Counter { private AtomicInteger count = new AtomicInteger(0); public void increment() { count.incrementAndGet(); } } 使用信号量（Semaphore）： Semaphore 可以限制同时访问某个特定资源的线程数量，从而防止资源争用。 import java.util.concurrent.Semaphore; public class MyClass { private Semaphore semaphore = new Semaphore(1); // 允许一个线程访问 public void method() { try { semaphore.acquire(); // 线程安全的代码 } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); } } } 合理设计锁策略： 合理设计应用程序的锁策略，例如避免持有多个锁、尽量缩小锁的粒度、使用读写锁等。 使用现代并发工具： Java 提供了 java.util.concurrent 包，其中有很多并发工具和集合（如 ConcurrentHashMap, CopyOnWriteArrayList），它们都默认是线程安全的。 ","date":"2024-12-27","objectID":"/text45/:15:9","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"线程的同步 线程同步是多线程编程中用于控制多个线程对共享资源访问的一种机制，以确保数据的一致性和线程的安全性。当多个线程同时访问共享资源时，可能会引起数据竞争和不一致的问题，这时候需要线程同步来协调访问。 以下是关于线程同步的一些关键点和常用方法： ","date":"2024-12-27","objectID":"/text45/:16:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 为什么需要线程同步？ 在没有同步的情况下，多个线程同时访问和修改共享数据，可能导致以下问题： 数据不一致：多个线程对同一数据的修改操作相互干扰，造成数据状态不一致。 竞态条件：多个线程争夺执行某段代码，导致错误的执行结果。 死锁：多个线程因互相等待对方释放资源而无法继续执行。 ","date":"2024-12-27","objectID":"/text45/:16:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 线程同步的机制 在Java中，有多种机制可以实现线程同步： a. 使用 synchronized 关键字 方法同步：通过在方法声明中使用 synchronized 关键字，使得该方法在任何时刻只能被一个线程执行。 public synchronized void synchronizedMethod() { // 线程安全的代码 } 代码块同步：使用 synchronized 关键字定义一个代码块，锁定特定对象。 public void method() { synchronized (someObject) { // 线程安全的代码 } } b. 使用 ReentrantLock ReentrantLock 是一种更灵活的锁实现，提供了更多功能，如公平性、获取锁的中断等待等。 import java.util.concurrent.locks.ReentrantLock; public class MyClass { private final ReentrantLock lock = new ReentrantLock(); public void method() { lock.lock(); // 获取锁 try { // 线程安全的代码 } finally { lock.unlock(); // 释放锁 } } } c. 使用 Condition 结合 ReentrantLock，可以使用 Condition 来实现更复杂的线程协调。 import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class MyClass { private final ReentrantLock lock = new ReentrantLock(); private final Condition condition = lock.newCondition(); public void await() { lock.lock(); try { condition.await(); // 等待通知 } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public void signal() { lock.lock(); try { condition.signal(); // 唤醒等待的线程 } finally { lock.unlock(); } } } d. 使用信号量（Semaphore） Semaphore 限制同时访问某个特定资源的线程数量，适用于对资源的限制控制。 import java.util.concurrent.Semaphore; public class MyClass { private final Semaphore semaphore = new Semaphore(1); // 允许一个线程 public void method() { try { semaphore.acquire(); // 获取信号量 // 线程安全的代码 } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); // 释放信号量 } } } ","date":"2024-12-27","objectID":"/text45/:16:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 其他同步策略 读写锁（ReadWriteLock）：允许多个读线程并行访问共享资源，但写线程独占访问。适用于读多写少的场景。 import java.util.concurrent.locks.ReadWriteLock; import java.util.concurrent.locks.ReentrantReadWriteLock; public class MyClass { private final ReadWriteLock lock = new ReentrantReadWriteLock(); public void read() { lock.readLock().lock(); try { // 读操作 } finally { lock.readLock().unlock(); } } public void write() { lock.writeLock().lock(); try { // 写操作 } finally { lock.writeLock().unlock(); } } } 使用并发集合：Java提供了线程安全的集合，如 ConcurrentHashMap、CopyOnWriteArrayList 等。 ","date":"2024-12-27","objectID":"/text45/:16:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"Lock锁的使用 在Java中，Lock 接口提供了比 synchronized 更加灵活的线程同步机制。与 synchronized 相比，Lock 提供了更高级的功能，包括可重入锁、公平锁、集成中断、尝试获取锁等。最常用的 Lock 实现是 ReentrantLock。 ","date":"2024-12-27","objectID":"/text45/:17:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. Lock 的基本使用 使用 Lock 时，一般的步骤如下： 创建 Lock 实例。 在需要保护的代码块前调用 lock() 方法获取锁。 在代码执行完毕后，确保调用 unlock() 方法释放锁。 以下是一个简单的 ReentrantLock 示例： import java.util.concurrent.locks.ReentrantLock; public class MyLockExample { private final ReentrantLock lock = new ReentrantLock(); public void safeMethod() { lock.lock(); // 获取锁 try { // 线程安全的代码 System.out.println(Thread.currentThread().getName() + \" is executing.\"); } finally { lock.unlock(); // 始终释放锁 } } public static void main(String[] args) { MyLockExample example = new MyLockExample(); Runnable task = example::safeMethod; Thread thread1 = new Thread(task); Thread thread2 = new Thread(task); thread1.start(); thread2.start(); } } ","date":"2024-12-27","objectID":"/text45/:17:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. Lock 的高级功能 a. 尝试获取锁 tryLock() 方法允许尝试获取锁，如果锁不可用，则不会阻塞当前线程，而是立即返回。 if (lock.tryLock()) { // 尝试获取锁 try { // 线程安全的操作 } finally { lock.unlock(); } } else { // 锁不可用时的处理逻辑 System.out.println(\"Could not acquire the lock.\"); } b. 可中断的锁 可以在获取锁时响应中断，以确保线程在等待过程中不会无期限堵塞。 try { lock.lockInterruptibly(); // 可中断地获取锁 try { // 线程安全的操作 } finally { lock.unlock(); } } catch (InterruptedException e) { // 处理中断逻辑 System.out.println(\"Thread was interrupted while waiting for lock.\"); } c. 公平锁与非公平锁 ReentrantLock 可以配置为公平锁，这意味着线程获取锁的顺序是按照请求锁的顺序，而非公平锁则可能导致某些线程长期得不到锁。 ReentrantLock fairLock = new ReentrantLock(true); // 创建公平锁 ReentrantLock unfairLock = new ReentrantLock(); // 创建非公平锁 ","date":"2024-12-27","objectID":"/text45/:17:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 结合 Condition 使用 Lock 提供 Condition 接口，用于更灵活的线程间通信。可以通过 Condition 对象实现线程之间的等待和通知机制。 import java.util.concurrent.locks.Condition; import java.util.concurrent.locks.ReentrantLock; public class ConditionExample { private final ReentrantLock lock = new ReentrantLock(); private final Condition condition = lock.newCondition(); public void awaitMethod() { lock.lock(); try { // 等待条件 condition.await(); // 等待通知 // 其他逻辑 } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } public void signalMethod() { lock.lock(); try { // 处理完毕后发送通知 condition.signal(); // 唤醒等待线程 } finally { lock.unlock(); } } } ","date":"2024-12-27","objectID":"/text45/:17:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"重要注意事项 确保释放锁：在 try-catch-finally 块中使用 lock() 和 unlock()，确保即使发生异常时也能释放锁。 避免死锁：当多个线程试图获取同一组锁时，注意获取锁的顺序，避免潜在的死锁问题。 选择合适的锁：根据具体的场景选择公平锁或非公平锁。 ","date":"2024-12-27","objectID":"/text45/:17:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"死锁问题 死锁是多线程编程中的一种常见问题，指的是两个或多个线程因相互等待对方释放资源而导致所有线程无法继续执行的状态。这种情况下，各个线程都在等待，而没有任何线程可以继续执行，程序就陷入了僵局。死锁会严重影响系统的性能和可靠性，因此要注意避免。 ","date":"2024-12-27","objectID":"/text45/:18:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"死锁的发生条件 要形成死锁，必须满足以下四个条件（也是被称为死锁的必要条件）： 互斥条件（Mutual Exclusion）： 至少有一个资源被一个线程占有，并且其他线程不能使用该资源。 占有且等待条件（Hold and Wait）： 至少有一个线程持有一个资源，并且在等待获取其他资源。 不可抢占条件（No Preemption）： 已分配给线程的资源不能被强制抢占，只有当线程释放该资源时，其他线程才能使用。 循环等待条件（Circular Wait）： 存在一个线程的循环等待关系，即线程 A 等待被线程 B 占用的资源，线程 B 等待被线程 C 占用的资源，以此类推，最终导致线程形成一个闭环。 ","date":"2024-12-27","objectID":"/text45/:18:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"示例：死锁 以下是一个简单的例子，展示了如何可能会发生死锁： public class DeadlockExample { private static final Object resource1 = new Object(); private static final Object resource2 = new Object(); public static void main(String[] args) { Thread t1 = new Thread(() -\u003e { synchronized (resource1) { System.out.println(\"Thread 1: Holding resource 1...\"); try { Thread.sleep(100); } catch (InterruptedException e) {} System.out.println(\"Thread 1: Waiting for resource 2...\"); synchronized (resource2) { System.out.println(\"Thread 1: Acquired resource 2!\"); } } }); Thread t2 = new Thread(() -\u003e { synchronized (resource2) { System.out.println(\"Thread 2: Holding resource 2...\"); try { Thread.sleep(100); } catch (InterruptedException e) {} System.out.println(\"Thread 2: Waiting for resource 1...\"); synchronized (resource1) { System.out.println(\"Thread 2: Acquired resource 1!\"); } } }); t1.start(); t2.start(); } } 在上述例子中，Thread 1 先获取了 resource1，然后尝试获取 resource2，而 Thread 2 先获取了 resource2，然后尝试获取 resource1，这就形成了一个死锁。 ","date":"2024-12-27","objectID":"/text45/:18:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"死锁的解决方法 避免死锁的条件： 尽量确保不同时满足四个条件。可以通过多种方式来避免死锁。 资源请求顺序： 确保所有线程以相同的顺序请求资源。例如，所有线程都先请求 resource1 再请求 resource2。 使用超时策略： 线程尝试获取锁时设置超时时间。如果线程在超时之前未能获取到锁，则放弃请求并释放已持有的资源，稍后再尝试。 if (lock.tryLock(timeout, TimeUnit.SECONDS)) { try { // 执行任务 } finally { lock.unlock(); } } else { // 超时处理 } 死锁检测： 在系统中实现死锁检测机制，定期检查系统状态以识别和处理死锁。可以终止某些线程或回滚一些操作以打破死锁状态。 使用非阻塞算法： 尽量采用无锁（lock-free）或非阻塞算法，这样可以减少资源争用，从而降低死锁的风险。 ","date":"2024-12-27","objectID":"/text45/:18:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"生产者/消费者问题 生产者/消费者问题是一个经典的多线程同步问题，主要涉及两个线程：一个是生产者线程，负责生成数据，另一个是消费者线程，负责消费数据。这个问题的关键在于如何有效地管理共享缓冲区以确保数据的安全和一致性，从而防止出现竞争条件。 ","date":"2024-12-27","objectID":"/text45/:19:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"问题描述 生产者： 生成数据，并将其放入共享缓冲区（如队列）。 如果缓冲区已满，生产者需要等待直到有空间可以放入新数据。 消费者： 从共享缓冲区中取出数据进行处理。 如果缓冲区为空，消费者需要等待直到有新数据可用。 ","date":"2024-12-27","objectID":"/text45/:19:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"解决方案 在 Java 中，可以使用多种方式来实现生产者/消费者模型，最常见的方法是使用 BlockingQueue 类，它是一个线程安全的队列，在满时生产者会等待，在空时消费者会等待。 以下是使用 BlockingQueue 实现的生产者/消费者示例： import java.util.concurrent.ArrayBlockingQueue; import java.util.concurrent.BlockingQueue; class Producer implements Runnable { private BlockingQueue\u003cInteger\u003e queue; public Producer(BlockingQueue\u003cInteger\u003e queue) { this.queue = queue; } @Override public void run() { try { for (int i = 0; i \u003c 10; i++) { queue.put(i); // 阻塞式插入 System.out.println(\"Produced: \" + i); Thread.sleep(100); // 模拟生产延迟 } } catch (InterruptedException e) { Thread.currentThread().interrupt(); // 恢复中断状态 } } } class Consumer implements Runnable { private BlockingQueue\u003cInteger\u003e queue; public Consumer(BlockingQueue\u003cInteger\u003e queue) { this.queue = queue; } @Override public void run() { try { for (int i = 0; i \u003c 10; i++) { Integer value = queue.take(); // 阻塞式获取 System.out.println(\"Consumed: \" + value); Thread.sleep(150); // 模拟消费延迟 } } catch (InterruptedException e) { Thread.currentThread().interrupt(); // 恢复中断状态 } } } public class ProducerConsumerExample { public static void main(String[] args) { BlockingQueue\u003cInteger\u003e queue = new ArrayBlockingQueue\u003c\u003e(5); // 容量为5的缓冲区 Thread producerThread = new Thread(new Producer(queue)); Thread consumerThread = new Thread(new Consumer(queue)); producerThread.start(); consumerThread.start(); } } ","date":"2024-12-27","objectID":"/text45/:19:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"运行机制说明 BlockingQueue： ArrayBlockingQueue 是基于数组的有界阻塞队列，生产者会在队列满时阻塞，消费者会在队列空时阻塞，确保了线程的安全。 生产者线程： 生产者使用 put() 方法将数据放入队列，如果队列已满，调用 put() 会阻塞以等待空间可用。 消费者线程： 消费者使用 take() 方法从队列中取出数据，如果队列为空，调用 take() 会阻塞以等待数据的到来。 ","date":"2024-12-27","objectID":"/text45/:19:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"注意事项 线程安全：使用 BlockingQueue 可确保线程安全，避免了复杂的同步控制。 性能：通过合理设置缓冲区的大小，可以在生产和消费之间实现平衡，避免不必要的上下文切换。 ","date":"2024-12-27","objectID":"/text45/:19:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"其他实现方法 除了使用 BlockingQueue 外，还有其他方式来实现生产者/消费者问题，例如使用 wait() 和 notify() 方法结合 synchronized 关键字手动管理线程同步，但这种方法通常比较复杂，不如 BlockingQueue 来得简单易懂。 ","date":"2024-12-27","objectID":"/text45/:19:5","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"线程组 在Java中，线程组（ThreadGroup）是一个将多个线程组织在一起的机制。它提供了一种简便的方法，以对多个线程进行管理和控制。使用线程组，我们可以对一组线程进行统一的操作，例如中断、暂停、恢复等。 ","date":"2024-12-27","objectID":"/text45/:20:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 线程组的基本概念 封装线程：线程组可以将一个或多个线程封装在一起，使得这些线程可以被当做一个整体进行管理。 层次结构：线程组可以嵌套，一个线程组可以包含其他线程组，从而形成层次结构。 ","date":"2024-12-27","objectID":"/text45/:20:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 线程组的创建 创建线程组的最简单方式是通过 ThreadGroup 类的构造函数。你可以为线程组指定名称： ThreadGroup group = new ThreadGroup(\"MyThreadGroup\"); ","date":"2024-12-27","objectID":"/text45/:20:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 将线程放入线程组 在创建线程时，你可以将其指定到一个特定的线程组中，如下示例所示： class MyRunnable implements Runnable { public void run() { System.out.println(Thread.currentThread().getName() + \" is running.\"); } } public class ThreadGroupExample { public static void main(String[] args) { ThreadGroup group = new ThreadGroup(\"MyThreadGroup\"); Thread thread1 = new Thread(group, new MyRunnable(), \"Thread-1\"); Thread thread2 = new Thread(group, new MyRunnable(), \"Thread-2\"); thread1.start(); thread2.start(); System.out.println(\"Active thread count in group: \" + group.activeCount()); } } 在这个示例中，两个线程被创建于同一个线程组 MyThreadGroup 中。 ","date":"2024-12-27","objectID":"/text45/:20:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"4. 线程组的常用方法 ThreadGroup 提供了一些常用的方法来管理线程组和线程： 获取活动线程数量： int activeCount = group.activeCount(); 获取活动线程数组： Thread[] threads = new Thread[group.activeCount()]; group.enumerate(threads); 中断所有线程： group.interrupt(); 获取线程组的名称： String name = group.getName(); ","date":"2024-12-27","objectID":"/text45/:20:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"5. 示例：使用线程组 以下是一个完整的示例，展示如何创建线程组，并对其中的线程进行管理和中断操作。 class MyRunnable implements Runnable { public void run() { try { while (!Thread.currentThread().isInterrupted()) { System.out.println(Thread.currentThread().getName() + \" is running.\"); Thread.sleep(1000); } } catch (InterruptedException e) { System.out.println(Thread.currentThread().getName() + \" is interrupted.\"); Thread.currentThread().interrupt(); // 恢复中断状态 } } } public class ThreadGroupExample { public static void main(String[] args) { ThreadGroup group = new ThreadGroup(\"MyThreadGroup\"); Thread thread1 = new Thread(group, new MyRunnable(), \"Thread-1\"); Thread thread2 = new Thread(group, new MyRunnable(), \"Thread-2\"); thread1.start(); thread2.start(); // 等待 3 秒后中断所有线程 try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"Interrupting all threads in the group.\"); group.interrupt(); // 中断所有线程 } } ","date":"2024-12-27","objectID":"/text45/:20:5","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"6. 注意事项 使用场景：线程组适合于需要管理一组相关线程的场景，例如，要求统一地中断、暂停或恢复一组线程的情况下。 过时性：需要注意的是，ThreadGroup 在 Java 的设计中逐渐被认为是不必要的，特别是在 Java 5 及更高版本中，建议使用更现代的并发工具，如 ExecutorService 和线程池。 安全性：确保在操作线程组时注意多线程环境下的安全性，避免可能的数据竞争问题。 ","date":"2024-12-27","objectID":"/text45/:20:6","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"线程池 线程池是提高多线程程序性能的有效工具，它允许在程序运行期间重用一组线程，降低线程创建和销毁的开销。能够有效复用线程、管理任务并减少系统开销。使用线程池可以在处理大量任务时，避免频繁地创建和销毁线程，从而提高系统的效率。 ","date":"2024-12-27","objectID":"/text45/:21:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 线程池的基本概念 线程复用：线程池会维护一个线程池中的多个线程，这些线程在处理任务时能够有效地复用，而不是每个任务都新创建一个线程。 任务调度：线程池会调度任务，并根据当前线程的状态决定如何分配任务。 资源管理：通过设置最大线程数和任务队列，可以限制同时运行的任务数量，避免系统资源过载。 ","date":"2024-12-27","objectID":"/text45/:21:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. Java 中的线程池 Java 从 JDK 5 开始引入了 java.util.concurrent 包，其中包含了一个线程池框架，最常用的接口是 ExecutorService 和它的实现类 ThreadPoolExecutor。 ","date":"2024-12-27","objectID":"/text45/:21:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 创建线程池 使用 Executors 工厂类可以方便地创建不同类型的线程池。以下是创建线程池的一些常用方法： 固定大小线程池： ExecutorService fixedThreadPool = Executors.newFixedThreadPool(5); // 线程数为5 缓存线程池： ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); // 根据需要创建线程 定时线程池： ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(3); // 线程数为3 ","date":"2024-12-27","objectID":"/text45/:21:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"4. 提交任务 在创建好的线程池中，可以使用 submit() 或 execute() 方法来提交任务： submit(Runnable task) 用于不返回结果的任务。 submit(Callable\u003cV\u003e task) 用于需要返回值的任务。 示例代码如下： import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPoolExample { public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(3); for (int i = 0; i \u003c 10; i++) { final int taskId = i; executorService.submit(() -\u003e { System.out.println(\"Task \" + taskId + \" is running in thread \" + Thread.currentThread().getName()); try { Thread.sleep(1000); // 模拟任务执行 } catch (InterruptedException e) { Thread.currentThread().interrupt(); } }); } executorService.shutdown(); // 关闭线程池 } } ","date":"2024-12-27","objectID":"/text45/:21:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"5. 线程池管理 关闭线程池：使用 shutdown() 可以逐步关闭线程池，等待已提交的任务完成。使用 shutdownNow() 可以立即关闭线程池，并尝试停止正在执行的任务。 获取线程池状态：可以使用 isShutdown() 和 isTerminated() 方法来检查线程池的状态。 ","date":"2024-12-27","objectID":"/text45/:21:5","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"6. 注意事项 合理配置线程数：设置合适的线程数量是一个关键，可以根据服务器的 CPU 核心数和任务特性来决定。通常，线程池的数量可以设置为 CPU 核心数的 1 到 2 倍。 避免任务堆积：如果提交的任务超过了线程池的处理能力，可能会导致任务堆积，可以通过调整线程池的策略进行管理（如使用有界队列）。 异常处理：在提交的任务中，未捕获的异常将不会传递到提交者，需在线程池管理中加以注意。 ","date":"2024-12-27","objectID":"/text45/:21:6","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"定时器 定时器是编程中用来执行定时任务的工具。它可以在指定的时间间隔后，或根据某个时间日程周期性地执行某个任务。在Java中，处理定时任务的主要方式包括使用 java.util.Timer 类和 java.util.concurrent.ScheduledExecutorService。以下是对这两种方法的概述和示例。 ","date":"2024-12-27","objectID":"/text45/:22:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 使用 java.util.Timer Timer 类用于安排一个或多个任务在指定的时间执行。它可以用来执行一次性任务和周期性任务。 主要方法： schedule(TimerTask task, long delay)：在指定的延迟后执行一次任务。 schedule(TimerTask task, Date time)：在指定的时间执行任务。 schedule(TimerTask task, long delay, long period)：周期性地执行任务。 示例代码： 以下是一个使用 Timer 类的示例，展示如何创建一个定时器任务实现每隔 1 秒执行一次特定操作： import java.util.Timer; import java.util.TimerTask; public class TimerExample { public static void main(String[] args) { Timer timer = new Timer(); TimerTask task = new TimerTask() { @Override public void run() { System.out.println(\"Task executed at: \" + System.currentTimeMillis()); } }; // 安排任务每秒执行一次 timer.schedule(task, 0, 1000); // 运行 5 秒后取消定时任务 try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } timer.cancel(); // 取消定时器 System.out.println(\"Timer cancelled.\"); } } ","date":"2024-12-27","objectID":"/text45/:22:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 使用 ScheduledExecutorService 从 Java 5 开始，ScheduledExecutorService 提供了比 Timer 更强大的定时任务管理能力，支持更丰富的功能，如更好的异常处理和线程池管理。 主要方法： schedule(Runnable command, long delay, TimeUnit unit)：安排任务在指定延迟后执行。 scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)：按固定速率周期性执行任务。 scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)：按固定延迟周期性执行任务。 示例代码： 下面是一个使用 ScheduledExecutorService 的示例，展示如何安排一个任务定期执行。 import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class ScheduledExecutorServiceExample { public static void main(String[] args) { ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); Runnable task = () -\u003e { System.out.println(\"Task executed at: \" + System.currentTimeMillis()); }; // 安排任务在 0 秒后开始，每隔 1 秒执行一次 scheduler.scheduleAtFixedRate(task, 0, 1, TimeUnit.SECONDS); // 运行 5 秒后关闭调度器 try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } scheduler.shutdown(); // 关闭调度器 System.out.println(\"Scheduled executor service shutdown.\"); } } ","date":"2024-12-27","objectID":"/text45/:22:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 比较 Timer： 简单易用，适合简单定时任务。 只支持单线程执行，若一个任务运行时间过长，可能会影响下一个任务的执行。 不适合处理任务执行中的异常；如果任务抛出未捕获异常，定时器将被取消。 ScheduledExecutorService： 支持多线程，可以管理多个并发任务。 更强大的异常处理能力，任务抛出的异常不会影响其他任务。 提供了更灵活的调度选项，适合复杂的调度需求。 ","date":"2024-12-27","objectID":"/text45/:22:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"面向对象思想设计原则 面向对象思想（Object-Oriented Programming, OOP）是软件设计中的一种重要方法论，它通过封装、继承和多态等概念来促进代码的复用和可维护性。在面向对象的设计中，有一些基本原则和设计模式可以帮助开发者编写更好的代码。以下是一些常用的面向对象设计原则： ","date":"2024-12-27","objectID":"/text45/:23:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. SOLID 原则 SOLID 原则是五个设计原则的缩写，旨在使软件设计更易于理解、扩展和维护。 S — 单一责任原则 (Single Responsibility Principle, SRP)： 每个类应仅有一个责任，即应有且只有一个引起该类变化的原因。 O — 开放/封闭原则 (Open/Closed Principle, OCP)： 软件实体（类、模块、函数等）应对扩展开放，而对修改关闭。即可以通过增量的方式进行扩展，而无需修改现有代码。 L — 里氏替换原则 (Liskov Substitution Principle, LSP)： 子类对象应能够替换父类对象，且程序的行为不会改变。即如果 S 是 T 的子类型，那么应该能够用 S 替换 T，而不导致错误。 I — 接口隔离原则 (Interface Segregation Principle, ISP)： 客户端不应依赖不需要的接口，多个具体客户特定的接口要好于一个通用的接口。即接口应该细化，客户只需依赖于它们所需要的接口。 D — 依赖倒置原则 (Dependency Inversion Principle, DIP)： 高层模块不应依赖于低层模块，二者都应依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。 ","date":"2024-12-27","objectID":"/text45/:23:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 其他重要的设计原则 DRY 原则 (Don’t Repeat Yourself)： 避免在代码中重复相同的信息。可以通过方法、类或模块的重用，提高代码的可维护性。 KISS 原则 (Keep It Simple, Stupid)： 设计应尽量简单，避免过度复杂。简单的解决方案通常更容易理解和维护。 YAGNI 原则 (You Aren’t Gonna Need It)： 不要在设计时实现当前不需要的功能。只实现当前需求，避免不必要的复杂度。 组合优于继承： 应优先考虑通过组合来构建复杂功能，而不是通过继承。这种方式能够降低类之间的耦合，提高灵活性。 ","date":"2024-12-27","objectID":"/text45/:23:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 常用的设计模式 设计模式是在特定问题下的解决方案，以下是一些常见的设计模式： 创建型模式： 单例模式 (Singleton)：保证一个类只有一个实例，并提供全局访问点。 工厂模式 (Factory)：提供一个创建对象的接口，但让子类决定要实例化的类。 结构型模式： 适配器模式 (Adapter)：允许不兼容的接口之间进行协作。 装饰者模式 (Decorator)：动态地给对象添加额外的职责。 行为型模式： 观察者模式 (Observer)：定义一对多的依赖关系，使得一个对象改变状态时，所有依赖于它的对象得到通知并自动更新。 策略模式 (Strategy)：定义一系列算法，将每个算法封装起来，并使它们可以互换。 ","date":"2024-12-27","objectID":"/text45/:23:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"常见设计模式 ","date":"2024-12-27","objectID":"/text45/:24:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 创建型模式 创建型模式主要关注对象的创建方式，帮助系统独立于对象的创建、组合和表示。 单例模式 (Singleton)： 确保一个类只有一个实例，并提供全局访问点。适合管理共享资源，如配置对象。 public class Singleton { private static Singleton instance; private Singleton() {} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 工厂方法模式 (Factory Method)： 定义一个接口用于创建对象，但让子类决定实例化哪个类。适用于需要创建复杂实例的情况。 interface Product { void use(); } class ConcreteProductA implements Product { public void use() { System.out.println(\"Using Product A\"); } } class ConcreteProductB implements Product { public void use() { System.out.println(\"Using Product B\"); } } abstract class Creator { public abstract Product factoryMethod(); } class ConcreteCreatorA extends Creator { public Product factoryMethod() { return new ConcreteProductA(); } } class ConcreteCreatorB extends Creator { public Product factoryMethod() { return new ConcreteProductB(); } } 抽象工厂模式 (Abstract Factory)： 提供一个接口用于创建一系列相关或依赖对象，而无需指定具体类。如 GUI 工具包中的组件创建。 interface GUIFactory { Button createButton(); Checkbox createCheckbox(); } class WinFactory implements GUIFactory { public Button createButton() { return new WinButton(); } public Checkbox createCheckbox() { return new WinCheckbox(); } } class MacFactory implements GUIFactory { public Button createButton() { return new MacButton(); } public Checkbox createCheckbox() { return new MacCheckbox(); } } ","date":"2024-12-27","objectID":"/text45/:24:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 结构型模式 结构型模式关注如何将类或对象组合成更大的结构，以便更高效地工作。 适配器模式 (Adapter)： 将一个类的接口转换成客户端期望的另一个接口，使得原本因接口不兼容而无法一起工作的类可以一起工作。 interface Target { void request(); } class Adaptee { void specificRequest() { System.out.println(\"Specific Request\"); } } class Adapter implements Target { private Adaptee adaptee; public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } public void request() { adaptee.specificRequest(); } } 装饰者模式 (Decorator)： 动态地给对象添加额外的职责，而不改变其结构。通过组合实现功能的扩展。 interface Coffee { double cost(); } class SimpleCoffee implements Coffee { public double cost() { return 1.0; } } class MilkDecorator implements Coffee { private Coffee coffee; public MilkDecorator(Coffee coffee) { this.coffee = coffee; } public double cost() { return coffee.cost() + 0.5; } } 组合模式 (Composite)： 将对象组合成树形结构以表示部分-整体层次结构。允许客户端统一使用单个对象和组合对象。 interface Component { void operation(); } class Leaf implements Component { public void operation() { System.out.println(\"Leaf operation\"); } } class Composite implements Component { private List\u003cComponent\u003e children = new ArrayList\u003c\u003e(); public void add(Component component) { children.add(component); } public void operation() { for (Component child : children) { child.operation(); } } } ","date":"2024-12-27","objectID":"/text45/:24:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 行为型模式 行为型模式主要关注对象之间的通信和责任分配。 观察者模式 (Observer)： 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一主题对象的变化。 class Subject { private List\u003cObserver\u003e observers = new ArrayList\u003c\u003e(); public void addObserver(Observer observer) { observers.add(observer); } public void notifyObservers() { for (Observer observer : observers) { observer.update(); } } } interface Observer { void update(); } 策略模式 (Strategy)： 定义一系列算法，将每个算法封装起来，使它们可以互换。算法的变化独立于使用算法的客户。 interface Strategy { void execute(); } class ConcreteStrategyA implements Strategy { public void execute() { System.out.println(\"Strategy A\"); } } class ConcreteStrategyB implements Strategy { public void execute() { System.out.println(\"Strategy B\"); } } class Context { private Strategy strategy; public Context(Strategy strategy) { this.strategy = strategy; } public void executeStrategy() { strategy.execute(); } } 命令模式 (Command)： 将请求转换为对象，从而可以用不同的请求、排队请求和记录请求日志，实现操作的撤销及重做。 interface Command { void execute(); } class Light { public void turnOn() { System.out.println(\"Light is ON\"); } public void turnOff() { System.out.println(\"Light is OFF\"); } } class LightOnCommand implements Command { private Light light; public LightOnCommand(Light light) { this.light = light; } public void execute() { light.turnOn(); } } ","date":"2024-12-27","objectID":"/text45/:24:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"GUI图形用户界面 图形用户界面（Graphical User Interface, GUI）是人与计算机之间交互的界面，允许用户通过图形和视觉元素（如窗口、图标、按钮、菜单等）与计算机程序进行交互。GUI相对于命令行界面（CLI）来说，更加直观和易于使用。以下是关于GUI的一些关键要素和设计原则，以及在不同编程语言中实现GUI的常见框架。 ","date":"2024-12-27","objectID":"/text45/:25:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. GUI的关键要素 窗口：提供一个区域来显示信息和与用户交互。每个应用通常有一个或多个窗口。 图标：用图形来表示程序、文件或功能。用户可以通过点击图标快速访问不同的操作。 按钮：可供用户点击以执行特定操作，如“确定”、“取消”、“提交”等。 菜单：提供一系列命令或选项，用户可以选择执行。菜单通常分为主菜单和上下文菜单。 文本框和标签：用户可以在文本框中输入信息，而标签则用于显示信息。 列表框和下拉框：用于显示多个选项，用户可以选择其中之一或多个。 滑块和进度条：允许用户在某个范围内选择值或查看操作进度。 ","date":"2024-12-27","objectID":"/text45/:25:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. GUI设计原则 一致性：同一类型的元素应保持一致的外观和行为，以便用户更好地理解和使用界面。 简洁性：避免不必要的复杂性，界面应简洁明了，使用户能快速找到所需功能。 反馈机制：用户的每个操作应有相应的反馈，如按钮点击后变化，确保用户知道程序正在响应。 可访问性：确保界面对所有用户（包括不同能力的人）友好。在颜色、字体和布局上考虑可访问性。 直观性：界面元素的位置应符合用户的期望，使用户能够自然地进行操作。 ","date":"2024-12-27","objectID":"/text45/:25:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 常见的GUI框架和工具 不同编程语言有不同的库和框架用于创建GUI应用程序。以下是一些流行的选择： Java Swing：Java的原生GUI工具包，提供丰富的组件和自定义功能。 JavaFX：一个现代的GUI工具包，支持图形、媒体和现代用户界面设计。 ","date":"2024-12-27","objectID":"/text45/:25:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"4. GUI应用示例 以下是使用Java Swing创建简单GUI的示例： import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JPanel; public class SimpleGui { public static void main(String[] args) { // 创建主窗口 JFrame frame = new JFrame(\"Simple GUI\"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(300, 200); // 创建面板 JPanel panel = new JPanel(); // 添加按钮 JButton button = new JButton(\"Click Me!\"); button.addActionListener(e -\u003e System.out.println(\"Button Clicked\")); panel.add(button); frame.add(panel); frame.setVisible(true); } } ","date":"2024-12-27","objectID":"/text45/:25:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"事件监听机制 事件监听机制是图形用户界面（GUI）编程中的一项基本功能，它允许程序响应用户的操作（事件），如点击按钮、移动鼠标、键入文本等。通过事件监听机制，程序能够以动态的方式与用户交互，提升用户体验。 以下是关于事件监听机制的关键概念、工作原理以及一些编程语言中的实现示例。 ","date":"2024-12-27","objectID":"/text45/:26:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 事件和事件源 事件：用户与界面元素进行交互时的操作，常见的事件类型包括： 鼠标事件（如点击、移动、进入、离开等） 键盘事件（如按下、释放等） 窗口事件（如打开、关闭、移动等） 事件源：触发事件的对象或组件，例如按钮、文本框和窗口等。每当用户与事件源进行交互时，就会生成相应的事件。 ","date":"2024-12-27","objectID":"/text45/:26:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 事件监听器 事件监听器是一个实现特定接口的对象，它用来接收并处理事件。每种事件类型通常有一个对应的事件监听器接口，例如： ActionListener：处理按钮点击等动作事件。 MouseListener：处理鼠标事件（如点击、进入、离开等）。 KeyListener：处理键盘事件（如按键和释放等）。 ","date":"2024-12-27","objectID":"/text45/:26:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 事件的工作原理 注册：开发者将事件监听器注册到特定的事件源，以便在事件发生时接收通知。 触发：当用户在事件源上执行特定操作（如点击按钮）时，事件被触发。 通知：事件源通知所有注册的监听器，相关事件被传递给这些监听器。 处理：监听器接收到事件后，调用相应的事件处理方法来处理事件。 ","date":"2024-12-27","objectID":"/text45/:26:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"4. 示例：Java中的事件监听机制 以下是一个使用Java Swing创建简单按钮和事件监听器的示例： import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JPanel; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class EventListenerExample { public static void main(String[] args) { // 创建主窗口 JFrame frame = new JFrame(\"Event Listener Example\"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(300, 200); // 创建面板 JPanel panel = new JPanel(); // 创建按钮 JButton button = new JButton(\"Click Me!\"); // 注册事件监听器 button.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.out.println(\"Button Clicked!\"); } }); // 将按钮添加到面板 panel.add(button); frame.add(panel); // 设置窗口可见 frame.setVisible(true); } } ","date":"2024-12-27","objectID":"/text45/:26:4","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"5.示例：JavaScript (DOM)事件监听机制 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eEvent Listener Example\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton id=\"myButton\"\u003eClick Me!\u003c/button\u003e \u003cscript\u003e document.getElementById(\"myButton\").addEventListener(\"click\", function() { console.log(\"Button clicked!\"); }); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-12-27","objectID":"/text45/:26:5","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"我们常说的翻墙 “翻墙”是一个中文术语，通常指绕过互联网审查或访问受限制网站和内容的行为。在一些国家或地区，特别是对于网络访问进行严格限制的地方（如中国），用户常常会用“翻墙”来描述使用各种技术手段访问被屏蔽的网站或服务。 ","date":"2024-12-27","objectID":"/text45/:27:0","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"1. 翻墙的目的 访问被屏蔽的内容：如社交媒体（Facebook、Twitter）、新闻网站（BBC、纽约时报）或其他外部网站。 保护个人隐私：通过加密流量和隐藏真实IP地址，用户希望保护自己的网络活动不被监控。 获取更自由的信息流：在限制互联网自由的环境中，“翻墙”帮助用户接触全球范围的信息和观点。 ","date":"2024-12-27","objectID":"/text45/:27:1","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"2. 常见的翻墙技术 VPN (虚拟专用网络)：通过加密的通道连接到互联网，用户的真实IP地址被替换为VPN服务器的IP地址，从而绕过地理限制和网络审查。 代理服务器：用户通过代理服务器发送请求，代理会代表用户访问目标网站，用户只需访问代理服务器即可。 Shadowsocks：一种被广泛使用的加密代理工具，特别在中国非常流行，提供更轻量级的翻墙解决方案。 Tor 网络：通过全球多个中继节点传递用户的网络请求，为用户提供匿名浏览，通常用于访问暗网和其他被屏蔽的网站。 ","date":"2024-12-27","objectID":"/text45/:27:2","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"3. 翻墙的法律和道德问题 在某些国家，使用翻墙工具可能违反当地法律和互联网使用政策，因此在选择翻墙工具时，用户需要了解相关的法律和风险。此外，翻墙工具的使用可能会引发道德上的讨论，涉及信息自由、隐私权、国家安全等议题。 ","date":"2024-12-27","objectID":"/text45/:27:3","tags":["Java"],"title":"【Java】Java语言进阶（三）","uri":"/text45/"},{"categories":["Java"],"content":"API概述 在Java中，API（应用程序编程接口）指的是一些预定义的类和接口，这些类和接口可以被开发人员用来构建应用程序。Java的API为程序员提供了丰富的库和工具，使得开发变得更加高效和简单。以下是Java API的一些关键点： ","date":"2024-12-27","objectID":"/text42/:1:0","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"1. Java标准库 Java的标准API涵盖了多个包，最重要的几个包括： java.lang：自动导入的核心类库，例如基本数据类型、字符串处理和线程等。 java.util：包含集合框架、日期和时间处理、随机数生成等。 java.io：用于输入和输出的类，包括文件读取和写入。 java.nio：提供更高效的I/O操作，尤其是面向字节和字符的处理。 ","date":"2024-12-27","objectID":"/text42/:1:1","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"2. Java API文档 Java API通常通过官方文档进行描述，开发者可以通过在线文档了解类、接口及其方法的使用说明。例如，Java SE的文档可以通过Oracle的官方网站访问。 ","date":"2024-12-27","objectID":"/text42/:1:2","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"3. 第三方API 除了Java标准API外，开发者还可以使用各种开源和商业的第三方库和API，例如： Apache Commons：提供了复用的功能库。 Spring Framework：一个流行的企业级应用开发框架。 Hibernate：用于对象关系映射（ORM）的框架。 ","date":"2024-12-27","objectID":"/text42/:1:3","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"4. 使用API的好处 提高生产力：通过复用现有的代码和库，减少重复开发。 可靠性：经过测试的API通常更为稳定，并能降低错误发生的概率。 文档和支持：大多数API都有良好的文档和社区支持，帮助开发者快速上手。 ","date":"2024-12-27","objectID":"/text42/:1:4","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"Object类 在Java中，Object类是所有类的根类，意味着所有Java类都是直接或间接继承自Object类。它提供了一组基本的方法，这些方法可以被所有Java对象使用。了解Object类是理解Java面向对象编程的关键，因为它定义了一些通用行为。 ","date":"2024-12-27","objectID":"/text42/:2:0","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"Object类的重要特性 所有类的基类： 任何类都可以被视为是Object类的子类，除非显式地继承自其他类（在这种情况下，Object类仍然是隐式的父类）。 常用方法： equals(Object obj)：比较两个对象的值是否相等。默认实现比较的是对象的引用，但可以被重写以基于内容比较。 hashCode()：返回对象的哈希码，通常与equals方法一起使用。这个方法也可以重写。 toString()：返回对象的字符串表示形式，默认返回类名加对象的哈希码。可以重写以提供更有意义的信息。 getClass()：返回对象的运行时类。 clone()：创建并返回当前对象的一个副本。需要实现Cloneable接口才能使用。 finalize()：在垃圾回收前被调用，可以用于清理资源，但不应该依赖于它。 ","date":"2024-12-27","objectID":"/text42/:2:1","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"示例代码 以下是一个简单的示例，演示如何重写toString()和equals()方法： class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } //返回该对象的字符串表示，结果为一个\"简单的文字信息表达式\" @Override public String toString() { return \"Person{name='\" + name + \"', age=\" + age + \"}\"; } //指示其他某个对象是否与此对象\"相等\"，和==比较相同。当数据类型不同时，用equals @Override public boolean equals(Object obj) { if (this == obj) return true; // 引用相等 if (obj == null || getClass() != obj.getClass()) return false; // 类型检查 Person person = (Person) obj; // 强制类型转换 return age == person.age \u0026\u0026 name.equals(person.name); // 字段比较 } //根据不同对象的内部地址值[实际地址值]转化成一个整数[哈希码值] @Override public int hashCode() { return Objects.hash(name, age); // 哈希码生成 } } public class Main { public static void main(String[] args) { Person person1 = new Person(\"Alice\", 30); Person person2 = new Person(\"Alice\", 30); System.out.println(person1.toString()); // 输出：Person{name='Alice', age=30} System.out.println(person1.equals(person2)); // 输出：true } } ","date":"2024-12-27","objectID":"/text42/:2:2","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"垃圾回收器 在Java中，垃圾回收器（Garbage Collector，GC）是自动管理内存的机制，主要用于自动识别和回收不再使用的对象，以防止内存泄漏并优化应用程序的性能。Java的垃圾回收机制帮助开发者无需手动释放内存，从而降低了错误的风险，提高了开发效率。 ","date":"2024-12-27","objectID":"/text42/:3:0","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"垃圾回收器的工作原理 对象的创建与分配： 当Java程序创建一个对象时，内存从堆中分配给这个对象。开发人员不需要明确释放这个内存，GC会在适当的时候自动进行。 对象的可达性分析： 垃圾回收器通过可达性分析来判断对象是否仍被引用。根对象（如栈中的局部变量、静态变量等）是起始点，GC会追踪这些根对象，判断哪些对象是可达的（即仍在使用中的）和不可达的（即可以被回收的）。 回收策略： 通过标记-清除、复制算法或其他策略，GC会清理那些不可达的对象，回收它们占用的内存空间。 ","date":"2024-12-27","objectID":"/text42/:3:1","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"垃圾回收的主要算法 标记-清除（Mark-and-Sweep）： 首先标记所有可达对象。 然后清理未标记的对象，释放它们的内存。 复制（Copying）： 将存活的对象复制到一个新空间，清除旧空间。 避免了内存碎片。 分代收集（Generational GC）： 大多数Java垃圾回收器采用分代策略，将对象分为年轻代（Young Generation）和老年代（Old Generation）。 年轻代中的对象通常短命，而老年代中的对象更长寿，GC可频繁回收年轻代，减少老年代的回收频率。 ","date":"2024-12-27","objectID":"/text42/:3:2","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"Java中的垃圾回收器 Java提供了多种垃圾回收器，以下是几种常见的： 串行垃圾回收器（Serial GC）： 简单易用，适合单线程环境，在老年代的处理上较慢。 并行垃圾回收器（Parallel GC）： 针对多核处理器，使用多线程并行处理，适用于需要最高吞吐量的应用。 并发标记清除（Concurrent Mark-Sweep, CMS）： 旨在减少垃圾回收的停顿时间，通过并发执行标记和清除过程来保持应用的响应性。 G1垃圾回收器（Garbage-First, G1 GC）： 综合了多个算法，目前是默认的高性能垃圾回收器，适合大堆内存和多CPU系统。G1 GC使用分区（Region）处理内存，使得大对象可以有效地被收集。 ","date":"2024-12-27","objectID":"/text42/:3:3","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"如何调整垃圾回收 Java允许开发者通过JVM参数来调整垃圾回收的行为。例如： -XX:+UseG1GC：启用G1垃圾回收器。 -Xmx512m：设置最大堆内存为512MB。 -Xms256m：设置初始堆内存为256MB。 ","date":"2024-12-27","objectID":"/text42/:3:4","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"Scanner类 在Java中，Scanner类是一个非常有用的工具，主要用于获取用户输入和读取数据。它属于java.util包，可以从多种输入源读取文本，包括控制台输入、文件、字符串等。通过Scanner类，开发者可以以简单的方式处理用户输入。 ","date":"2024-12-27","objectID":"/text42/:4:0","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"Scanner类的特点 多种输入来源： Scanner可以从控制台、文件、字符串、输入流等读取数据。 简易的数据解析： 提供了一系列方法，可以方便地解析基本数据类型（如int、double、String等）。 支持正则表达式： 可以使用正则表达式来定义分隔符，对输入进行更加灵活的处理。 ","date":"2024-12-27","objectID":"/text42/:4:1","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"常用构造方法 Scanner scanner = new Scanner(System.in); // 从控制台读取输入 ","date":"2024-12-27","objectID":"/text42/:4:2","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"常用方法 next(): 读取下一个完整的单词（以空格为分隔符）。 nextLine(): 读取当前行的所有输入，包括空格。 nextInt(): 读取下一个整数。 nextDouble(): 读取下一个双精度浮点数。 hasNext(): 返回一个布尔值，指示是否还有输入。 close(): 关闭Scanner，释放相关资源。 ","date":"2024-12-27","objectID":"/text42/:4:3","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"示例代码 以下是一个简单的示例，演示如何使用Scanner类从控制台读取用户输入： import java.util.Scanner; public class ScannerExample { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(\"请输入您的名字：\"); String name = scanner.nextLine(); // 读取整行输入 System.out.print(\"请输入您的年龄：\"); int age = scanner.nextInt(); // 读取整数 System.out.println(\"你好，\" + name + \"！您今年 \" + age + \" 岁。\"); scanner.close(); // 关闭scanner避免资源浪费 } } ","date":"2024-12-27","objectID":"/text42/:4:4","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"注意事项 资源管理： 使用完Scanner后应调用close()方法关闭，以释放相关资源。特别是在读取文件时，更应注意这一点。 输入异常处理： 读取整数或浮点数时，如果输入不符合预期，Scanner会抛出InputMismatchException。建议在读取输入时进行异常处理，以避免程序崩溃。 获取字符串包含空格的输入： 使用nextLine()而不是next()，因为next()读取到第一个空格就会停止。 ","date":"2024-12-27","objectID":"/text42/:4:5","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"String类 在Java中，String类是用于表示字符串的主要类，属于java.lang包。String在Java中是一个不可变（immutable）对象，这意味着一旦创建，字符串的内容就不能被改变。由于其广泛应用和重要性，理解String类的特性和方法对于Java开发者至关重要。 String的s，大写为类，小写为数据类型。 ","date":"2024-12-27","objectID":"/text42/:5:0","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"1. 字符串的创建 Java中可以通过以下几种方式创建String对象： 字面量方式： String str1 = \"Hello, World!\"; 使用构造函数： String str2 = new String(\"Hello, World!\"); 尽管可以用构造函数创建字符串，推荐使用字面量方式，因为Java会在字符串池中重用相同内容的字符串，以节省内存。 ","date":"2024-12-27","objectID":"/text42/:5:1","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"2. 不可变性 String对象一旦创建，就无法更改其内容。如果对字符串进行修改，例如连接或替换，会生成一个新的字符串对象。例如： String str = \"Hello\"; str = str + \" World\"; // 创建一个新字符串对象 HelloWorld //字符串直接赋值的方式是先到字符串常量池里去找，如果有就直接返回，如果没有就创建并返回 字符串变量相加，例：s1+s2 ，先开空间，再相加 字符串常量相加，例：\"Hello\" + \"World\" ，先相加，再常量池找，有就返回，无就创建返回 ","date":"2024-12-27","objectID":"/text42/:5:2","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"3. 常用方法 String类提供了丰富的方法，以下是一些常用的方法： length()：返回字符串的长度。 charAt(int index)：返回指定位置的字符。 substring(int beginIndex, int endIndex)：返回字符串的子串（不包含endIndex的字符）。 indexOf(String str)：返回指定子字符串第一次出现的位置。 toUpperCase()：将字符串转换为大写。 toLowerCase()：将字符串转换为小写。 trim()：去除字符串两端的空格。 equals(Object obj)：比较两个字符串的内容是否相等。 equalsIgnoreCase(String anotherString)：忽略大小写比较字符串。 replace(char oldChar, char newChar)：替换字符串中的字符。 split(String regex)：根据给定的正则表达式分割字符串。 contains(String str)：判断大写字符串中是否包含小字符串。 srartsWith(String str)：判断字符串是否以某个指定的字符串开头。 endsWith(String str)：判断字符串是否以某个指定的字符串结尾。 isEmpty()：判断字符串是否为空。 字符串内容为空（对象存在，内容为空）String s = \" \" 字符串对象为空（对象不存在，空引用）String s = null ","date":"2024-12-27","objectID":"/text42/:5:3","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"4. 示例代码 以下是一个简单的示例，演示了String类的常用方法： public class StringExample { public static void main(String[] args) { String str = \" Hello, World! \"; // 字符串长度 System.out.println(\"长度: \" + str.length()); // 提取子串 String subStr = str.substring(2, 7); System.out.println(\"子串: \" + subStr); // 字符替换 String replacedStr = str.replace(\"World\", \"Java\"); System.out.println(\"替换后的字符串: \" + replacedStr); // 字符串分割 String[] parts = str.trim().split(\", \"); System.out.println(\"分割后的部分:\"); for (String part : parts) { System.out.println(part); } // Comparing strings String str2 = \" hello, world! \"; boolean isEqual = str.trim().equalsIgnoreCase(str2.trim()); System.out.println(\"忽略大小写比较: \" + isEqual); } } ","date":"2024-12-27","objectID":"/text42/:5:4","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"5. 字符串连接 频繁的字符串连接可能会导致性能问题，因为每次连接都会创建新的字符串对象。为了解决这个问题，可以使用StringBuilder或StringBuffer，如： StringBuilder sb = new StringBuilder(); sb.append(\"Hello\"); sb.append(\" World\"); String result = sb.toString(); // 转换为String 1.java中的StringBuffer类 在Java中，StringBuffer是一个可变的字符序列类，属于java.lang包。与String类不同，StringBuffer对象的内容可以在创建后进行修改，而不需要创建新的对象。这使得StringBuffer非常适合用于需要频繁修改字符串内容的情况，例如在拼接、插入或删除字符时。 2. StringBuffer的特点 可变性：StringBuffer对象的内容可以更改，因此通过修改一个StringBuffer对象不会创建新的对象。 线程安全：StringBuffer的方法是同步的，意味着它是线程安全的，适合在多线程环境中使用。 性能较好：在进行大量的字符串操作（如拼接）时，StringBuffer通常比String更高效，因为它避免了字符串的重复创建。 3. 常用构造方法 默认构造方法：创建一个长度为16的空StringBuffer。 StringBuffer sb = new StringBuffer(); 指定初始容量：创建一个空的StringBuffer，并指定初始容量。 StringBuffer sb = new StringBuffer(50); // 初始容量为50 使用字符串初始化：用指定字符串的内容初始化StringBuffer。 StringBuffer sb = new StringBuffer(\"Hello\"); 4. 常用方法 StringBuffer类提供了很多方法来操作字符序列，以下是一些常用的方法： append(String str)：在此StringBuffer的末尾添加字符串。 insert(int offset, String str)：在指定位置插入字符串。 delete(int start, int end)：删除从start到end的字符。 replace(int start, int end, String str)：替换从start到end的字符为给定字符串。 reverse()：反转字符序列。 toString()：将StringBuffer转换为String。 capacity()：返回当前容量。 length()：返回字符序列的长度。 5. 示例代码 以下是一个使用StringBuffer的简单示例，展示其基本操作： public class StringBufferExample { public static void main(String[] args) { StringBuffer sb = new StringBuffer(\"Hello\"); // 追加字符串 sb.append(\" World\"); System.out.println(\"追加后的字符串: \" + sb); // 输出: Hello World // 插入字符串 sb.insert(5, \",\"); System.out.println(\"插入后的字符串: \" + sb); // 输出: Hello, World // 删除字符 sb.delete(5, 6); System.out.println(\"删除后的字符串: \" + sb); // 输出: Hello World // 替换字符 sb.replace(6, 11, \"Java\"); System.out.println(\"替换后的字符串: \" + sb); // 输出: Hello Java // 反转字符串 sb.reverse(); System.out.println(\"反转后的字符串: \" + sb); // 输出: avaJ olleH // 转换为String String result = sb.toString(); System.out.println(\"转为String: \" + result); // 输出: avaJ olleH } } 5. 线程安全 尽管StringBuffer是线程安全的，但在某些情况下，使用StringBuilder（不安全但性能更高）会更合适，尤其是在单线程环境中。StringBuilder的使用方法和StringBuffer类似，但其方法没有同步，因此在多线程情况下使用时需要小心。 ","date":"2024-12-27","objectID":"/text42/:5:5","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"6.字符串获取 int length()：获取字符串的长度 char charAt(int index)：获取指定索引的位置上的字符 int indexOf(int ch)：返回指定字符在此字符串中第一次出现出的索引【可以给char类型的实参】 int indexOf(String str)：字符串（返回索引） int indexOf(int ch,int fromIndex)：从指定位置（字符，返回索引） int indexOf(String str,int fromIndex)：从指定位置（字符，返回索引） String subString(int start)：从指定位置截取字符串（包括start位置的字符） String subString(int start,int end)：从指定位置到指定位置（包左不包右） ","date":"2024-12-27","objectID":"/text42/:5:6","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"7.字符串转换 byte[] getBytes()：把字符串转换为字节数组 char[] toCharArray()：把字符串转换为字符数组 static String valueOf(char[] chs)：把字符数组[或任意类型数据]换为字符串 static String valueOf(int i)：把int类型的数据转成字符串 String toLowerCase()：把字符串转成小写（原字符串不发生改变，转换时生成新的） String toUpperCase()：把字符串转成大写 String concat(String str)：把字符串拼接 ","date":"2024-12-27","objectID":"/text42/:5:7","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"8.字符串替换 String replace(char old,char new) String replace(String old,String new) String trim()：去除字符串两端的空格 ","date":"2024-12-27","objectID":"/text42/:5:8","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"9.字符串判断 String s1 = new String(\"Hello\"); String s2 = \"Hello\"; s1 == s2 //false s1.equals(s2) //true == 比较的是引用类型的地址值是否相同。equals 默认比较的也是引用类型的地址值。 String类重写了equals()方法，以便比较字符串的内容而非其引用。 1. String类的equals()方法实现 在Java中，String类重写了equals()方法，以便比较字符串的内容而非其引用。这意味着两个字符串对象，如果它们的字符序列相同，使用equals()方法比较时会返回true。下面是String类中equals()方法的实现逻辑以及一些常见的使用示例。 String类的equals()方法源码的核心逻辑如下： 首先，检查两个引用是否指向同一个对象（如果是，则返回true）。 然后，检查传递的对象是否为null，或者它是否与当前对象的类型不同。 如果上述检查都通过，最后会逐个比较字符串中的字符，确保内容相同。 以下是String类重写equals()方法的简化示例： @Override public boolean equals(Object obj) { if (this == obj) return true; // 引用相等 if (obj == null || getClass() != obj.getClass()) return false; // 类型检查 String other = (String) obj; // 强制类型转换 return this.value.equals(other.value); // 比较内容 } 2. 使用String类的equals()方法示例 public class StringEqualsExample { public static void main(String[] args) { String str1 = new String(\"Hello\"); String str2 = new String(\"Hello\"); String str3 = \"Hello\"; // 字符串常量池 String str4 = \"Hello\"; // 使用equals()比较内容 System.out.println(str1.equals(str2)); // 输出：true (内容相同) System.out.println(str1.equals(str3)); // 输出：true (内容相同) System.out.println(str3.equals(str4)); // 输出：true (内容相同) // 使用==比较引用 System.out.println(str1 == str2); // 输出：false (不同对象) System.out.println(str3 == str4); // 输出：true (相同对象，需要注意字符串池) } } 3. 注意事项 反身性：任何非空引用调用equals应该返回true。 对称性：如果x.equals(y)返回true，那么y.equals(x)也应该返回true。 传递性：如果x.equals(y)和y.equals(z)都返回true，则x.equals(z)也应返回true。 一致性：如果没有改变对象的内容，连续多次调用equals应该始终返回相同的结果。 对于任何非空引用x，x.equals(null)应该返回false。 ","date":"2024-12-27","objectID":"/text42/:5:9","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"equals与== 在Java中，equals方法用于比较两个对象的内容是否相同，而不是它们的地址值（引用）。这意味着，如果你使用equals方法比较两个不同的对象，但它们的内容相同，则返回值为true。这与==运算符不同，后者比较的是对象的引用，即它们在内存中的地址。 ","date":"2024-12-27","objectID":"/text42/:6:0","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"1. equals方法的作用 默认实现：Object类提供了equals方法的默认实现，该实现使用==运算符来比较对象的地址。因此，除非重写，否则equals方法将比较引用。 重写equals方法：通常，开发者会在其自定义类中重写equals方法，以便根据类的字段比较对象的实际内容。 ","date":"2024-12-27","objectID":"/text42/:6:1","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"2. 示例 下面是一个简单的例子，展示了equals和==的区别： class Person { String name; int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public boolean equals(Object obj) { if (this == obj) return true; // 引用相等 if (obj == null || getClass() != obj.getClass()) return false; // 类型检查 Person person = (Person) obj; // 强制类型转换 return age == person.age \u0026\u0026 name.equals(person.name); // 内容比较 } @Override public int hashCode() { return Objects.hash(name, age); // 生成哈希码 } } public class EqualsExample { public static void main(String[] args) { Person person1 = new Person(\"Alice\", 30); Person person2 = new Person(\"Alice\", 30); // 使用==比较引用 System.out.println(person1 == person2); // 输出：false // 使用equals比较内容 System.out.println(person1.equals(person2)); // 输出：true } } ","date":"2024-12-27","objectID":"/text42/:6:2","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"3. 关键点总结 ==运算符：用于检查两个对象引用是否指向同一块内存（即地址值）。 equals方法：用于检查两个对象的值是否相等，具体比较的内容取决于类中如何重写equals方法。 重写equals时的注意事项： 确保反身性：对于任意非空引用x，x.equals(x)应该返回true。 对称性：如果x.equals(y)返回true，那么y.equals(x)也应该返回true。 传递性：如果x.equals(y)和y.equals(z)都返回true，则x.equals(z)也应该返回true。 一致性：多次调用x.equals(y)应该始终返回相同的结果，前提是对象未修改。 对任何非空引用x，x.equals(null)应该返回false。 ","date":"2024-12-27","objectID":"/text42/:6:3","tags":["Java"],"title":"【Java】Java语言进阶（一）","uri":"/text42/"},{"categories":["Java"],"content":"一、基础部分 ","date":"2024-12-14","objectID":"/text40/:1:0","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"1. 关键字keyword 全是小写，能被虚拟机识别。goto 和 const 是保留字（现在保留，可能会成为关键字）。 ","date":"2024-12-14","objectID":"/text40/:1:1","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"2.标识符 作用：起名字。 组成：$ _ 数字 英文大小写 （不能以数字开头） 常见的命名规则： 见名知意 包：其实就是文件夹，用于把相同的类名进行区分 单级包（全部小写）：wangty 多级包（用.隔开）：cn.wangty –指cn包下的wangty包 类/接口 一个单词组成，首字母大写：Student、Dog 多个单词组成，大驼峰：HelloWorld 方法/变量 一个单词，首字母小写：main方法、name变量 多个单词，小驼峰：studentAge 常量 一个单词，全部大写：PI 圆周率 多个单词，全部大写，以_ 隔开：STUDENT_MAX_AGE This is a tip\r类：为java基本底层，一切以其为开始，{ }中可以写：结构定义语句、功能执行语句\r","date":"2024-12-14","objectID":"/text40/:1:2","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"3.注释 用于解释说明程序，调试排错 单行注释：// 多行注释：/* */ （不能嵌套使用） 文档注释：/** */ （被javadoc工具解析，生成一个说明书，面向对象部分讲解） ","date":"2024-12-14","objectID":"/text40/:1:3","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"4.常量 执行过程中，其值不可发生改变。 使用final关键字申明（前端一般使用const申明），只能进行一次赋值 字面值常量 字符串常量：双引号括起来的内容，例： \"Hello\" 整数常量：所有整数，例：100 小数常量：所有小数，例：0.11111 字符常量：单引号括起来的内容，例：'A' 布尔常量：真/假，例：true false 空常量：null 自定义常量 ​ ","date":"2024-12-14","objectID":"/text40/:1:4","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"5.进制 1) 定义 表示进位的方式。（X进制：逢x进一） 计算机的电子原件状态：开/关 ，用数字1/0 表示 表达数据的时候，国际化标准组织规定，用8个这样的信号来表示一个数据，单位为字节 ob开头：2进制 o开头：8进制 ox开头：16进制 ​ 2) 进制转换 X → 10 进制的转换：（任意进制 → 十进制） 系数：每一个位上的数值本身，成为系数 基数：X进制，基数为X 权：从右开始，以0开始编号，即为该位上权值 示例：2进制 转 10进制 示例：8进制 转 10进制 示例：16进制 转 10进制 8421码 8421码：用于2进制与10进制的快速转换 2 1 1 1 1 1 1 1 1 10 128 64 32 16 8 4 2 1 示例：2进制 转 10进制 将不同权位上为1的，对应位置上的数值相加 示例：10进制 转 2进制 左添0，从高位寻起，有则为1；相减，无则为0。去掉左0，添ob标识 10 100 100 36 4 4 4 0 0 10 128 64 32 16 8 4 2 1 2 0 1 1 0 0 1 0 0 10 → X 进制的转换：（十进制 → 任意进制） 商为0时结束，倒写余数。除基取余，直到商为0，余数反转。 示例：10进制 转 2进制 示例：10进制 转 8进制 示例：10进制 转 16进制 X → Y 任意进制之间转换：（X → Y） 以10进制做桥梁，X → 10，10 → Y ​ ","date":"2024-12-14","objectID":"/text40/:1:5","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"6.有符号数据表示法 在计算机内，有符号数有3中表示法：原码、补码、反码 在计算机操作的时候，都是采用数据对应的二进制补码来计算的。 原码：二进制定点表示法，最高位为符号位，\"0\"表示正，\"1\"表示负，其余表数值的大小 示例：±7。首先得到7的二进制为111 原码 符号位 数值位 +7 0 0000111 总共8为，不为1的补0 -7 1 0000111 总共8为，不为1的补0 反码：正数的反码与其原码相同。负数的反码，对其原码逐为取反，但符号位除外。 反码 符号位 数值位 +7 0 0000111 -7 1 1111000 对应取反 补码：正数的补码与其原码相同。负数的补码，是在反码的基础上加1 反码 符号位 数值位 +7 0 0000111 -7 1 1111001 加在尾部，若要进位则进 2个练习加深印象： 已知X的原码10110100B，求补/反码 第一个符号位，为1，该数为负数 原码B表示二进制 反码：0 1001011 补码：0 1001100 （注意进位） 已知X补码11101110B，求原码 补码减1，注意借位，不够往前借 补码：1 1101110 反码：1 1101101 原码：1 0010010 ","date":"2024-12-14","objectID":"/text40/:1:6","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"7.变量 内存中的一小块区域。 //强制转换 byte c = (byte)(a+b) 变量相加：先提升数据，再计算运行 常量相加：先计算结果（调试、编译），再赋值。再检测数据类型范围，超出则报错 //示例： byte b1 = 3; byte b2 = 4; byte b; //byte的范围 -128 ~ 127 b = b1 + b2 //报错,数据提升。（先提升成int 3，int4，才会进行相加赋值 7是int） b = 3 + 4 //b = 7 （7是byte） //'a' = 97 //'A' = 65 //'o' = 48 字符串相加：其+表示为连接符。结果为：字符串 数值相加：其+表示为运算符。结果为：计算结果 //示例 'a' + 1 + 'hello' //98hello 'hello' + 'a' + '1' //helloa1 定义Long类型变量，1L。 定义Float类型变量，1f。 整数默认为int，浮点默认为Double byte、short在定义时，他们接受的其实是一个int类型的值。（做了一个数据检测，如果不再它们的范围内，就报错） byte值的问题 //byte的范围 -128 ~ 127 byte b1 = 127; byte b2 = (byte) 128; //-128 byte b3 = (byte) 129; //-127 byte b4 = (byte) 130; //-126 //128:10000000 //-128: 10000000 这里1既是符号位，也是数值位，这里的0为负0 ","date":"2024-12-14","objectID":"/text40/:1:7","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"8.默认类型转换 char(2)、byte(1)、short(2) → int(4) → long(8) → float(4) → double 为什么 ‘8字节’ 可以转换为 ‘4字节’？ long：8字节，整数存储 float：4字节，浮点型存储 它们底层的存储类型不同，float类型在计算机中只使用4个字节存储，遵循IEEE-754格式标准。一个浮点数有两个部分构成： 底数m：以二进制数表示词浮点数的实际值，占24bit，高位始终为1。 指数e：占用8bit的二进制数，范围0-255。有±，减127才是真正的指数 例如： 17.625存储 二进制：10001.101 整数部分：除以2，商为0，余数反转。（10001.101） 小数部分：乘以2，乘位为0，进位顺序取（1.0001101高位恒为1） 右移至小数点前只有1位，2→3，需移动4位，指数加127 = 4 + 127=131 131二进制：10000011 结果为：0 1000001 10001101 00000000 00000000 符号位 指数 底数 0 10000011 0001101 0…0 float表示的数据范围比long大 证明： char能存一个中文字符，一个字符2个字节。java语言采用Unicode编码。 ​ ","date":"2024-12-14","objectID":"/text40/:1:8","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"9.运算符 1) 算术运算符（Operator） +、-、×、÷、%、++、-- 例一：a = 10； b = 10 ；c = 10； a = b++; //a = 10； b = 11 ；c = 10 c = --a; //a = 9； b = 11 ；c = 9 b = ++a; //a = 10； b = 10 ；c = 9 c = c--; //a = 9； b = 10 ；c = 8 //在前，先++/--，再赋值 //在后，先赋值，再++/-- 例二：x = 4 y = (x++) + (++x) + (x*10); //x = 6;y = 70 // 4 6 60 // x = 5 x = 6 ​ 2）赋值运算符 =、+=、-=、*=、/=、%= 例一：short s = 1； s = s + 1; //short 参加运算，提升为int，可能损失精度 s += 1; //s为short //拓展的赋值运算符其实隐含了一个强制类型转换 /* s += 1; \u003c≠\u003e s = s + 1; \u003c=\u003e s =(short) s + 1; */ ​ 3）比较运算符（关系运算符） \u003c、\u003e、\u003c=、\u003e=、!=、==、instanceof 结果都是boolean类型，只要有一个满足条件就可以 ​ 4）逻辑运算符 \u0026 与 ：同真为真 | 或 ：同假为假 ^ 异或：同名为假，异名为真 ! 非 ：取反 \u0026\u0026 短路与 ：左假右不管 || 短路或 ：左真右不算 左右必须都是布尔型表达式。 ​ 5）位运算符（2进制） \u003c\u003c 扩大，正数补0，负数补1 \u003e\u003e 缩小，正数补0，负数补1 \u0026、|、^ 当两边为数据做的是“位运算”，两边为表达式做的是“逻辑运算” ~、 \u003e\u003e\u003e 无符号右移，全补0 例一：某一个数据对另一个数据位异或两次，数据不变 //可以用来加密 a^b^b = a a^b^a = b 例二：将两个变量所携带的整数进行交换。a换成b，b换成a //方法一： a = a^b; b = a^b; //b = a^b^b = a; a = a^b; //a = a^b^a = b; //方法二： a = a+b; //a =30; b = a-b; //b = 10, b = (a+b)-b = a; a = a-b; //a = 20, a = (a+b)-a = b; //方法三： c = a; a = b; b = c; //方法四： b = (a+b)-(a=b) //等价于 a = b; b = (a+b)-b = a; ","date":"2024-12-14","objectID":"/text40/:1:9","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"10.键盘录入数据（Scanner） 导包 import java.util.Scanner; 创建键盘录入对象 Scanner sc = new Scanner(System.in); 通过对象获取数据 int x = sc.nextInt(); //键盘录入 整数值 String s = sc.nextLine(); //键盘录入 字符串 例一： import java.util.Scanner; public class ScannerDemo { public static void main(String[] args) { Scanner sc = new Scanner(System.in); System.out.println(\"请输入：\"); int x = sc.nextInt(); System.out.println(\"你输入的是：\"+x); } } ​ ","date":"2024-12-14","objectID":"/text40/:1:10","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"11.流程控制语句 1）顺序结构 // 顺序结构示例 System.out.println(\"程序开始\"); // 变量赋值 int a = 10; int b = 20; // 计算和 int sum = a + b; // 输出结果 System.out.println(\"a 和 b 的和是: \" + sum); System.out.println(\"程序结束\"); 2）选择结构（if/switch） if(比较表达式){ 语句体 }else{ 语句体 } switch(表达式){ case 值1 :语句体1; break; default :语句体n+1; break; } /* 1、case后面，只能是常量，不能是变量，且多个case后的值不能相同 2、default可以省略，不建议 3、break可以省略吗？可以（最后一个） 4、default一定要在最后面吗？可以在任意位置 */ if/switch的区分： Boolean用if 1000上万数据用if 小数范围用if 针对几个常量值情况用switch 3）循环结构（for/do-while） for循环语句 for(初始化语句;判断条件语句;变量变化){ 循环语句体 } 例一：输出1~10 for(int x=1;x\u003c=10;x++){ System.out.println(x); } 例二：求1~10的数据和 int sum = 0; for(int x=1;x\u003c=10;x++){ sum += x; } System.out.println(sum); 例三：求1~100之间的偶数和 /** 思路：1~100之和为5050 1~100奇/偶对半各50 偶比奇大1，总共多50 （5050-50）÷ 2 +50 = 偶数和 */ //方法一： int sum = 0; for(int x=1;x\u003c=100;x++){ if(x%2 == 0){ sum += x; } } System.out.println(sum); //方法二： //从0开始，自增2位 int sum = 0; for(int x=0;x\u003c=100;x+=2){ sum += x; } System.out.println(sum); 例四：求5的阶乘 //阶乘：n! = n*(n-1)! = n*(n-1)*(n-2)*...*1 int sum = 1; for(int x=1;x\u003c=5;x++){ sum *= x; } System.out.println(sum); 例五：水仙花数（求所有水仙花数） //水仙花数：一个三位数，即各位数字的立方和等于该数本身。 //例如：153 = 1^3+5^3+3^3 = 153 for(int x=100;x\u003c1000;x++){ int ge = x%10; //获取个位数 int shi = x/10%10; //获取十位数 int bai = x/10/10%10; //获取百位数 if(x == (ge*ge*ge + shi*shi*shi +bai*bai*bai)){ System.out.println(x); } } while循环语句 可以与for循环等价转换 while(判断条件语句){ 循环体语句 } 例一：按照for语句，交换各项位置 for(int x=0;x\u003c10;x++){ System.out.println(\"hello\"); } //等价于 int x = 0; while(x\u003c10){ System.out.println(\"hello\"); x++; } /* while的初始化在外面，x为全局变量 for的x为局部变量 当循环，有范围时，用for；无明确范围时，用while */ do-while循环语句 do{ 循环语句 }while(判断条件句) //对应上方for循环 int x = 0; do{ System.out.println(\"hello\"); x++; }while(x\u003c10) This is a tip\r三种循环的区别： do-while至少执行一次循环体 while、for必须判断条件再循环（只有这一个区别） 死循环： ctrl+c 强制停止循环。一定注意造成死循环是因为没有写条件控制 ​ ","date":"2024-12-14","objectID":"/text40/:1:11","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"12.跳转控制语句 1）break中断 break使用场景（离开下面两个场景，无意义） switch语句中 循环语句中 //嵌套for中，只跳出一层 //使用“标签名：语句” - 跳出目标层 wc:for(...){ nc:for(...){ if(){break wc;} //中断外+内层 if(){break nc;} //中断内层 } } 2）continue继续 使用场景，for循环中。（离开此场景无意义） 跳出本次循环，进入下一循环体 （0,1,2,跳出，4,5,6…） ​ 3）return返回 使用场景，结束一个方法，跳转到上层调的方法 方法的注意事项： 方法不调用不执行 方法与方法是平级关系，不能嵌套定义 方法定义的时候参数之间用逗号隔开 方法调用时不用在传递数据类型 如有明确返回值，一定要return ​ ","date":"2024-12-14","objectID":"/text40/:1:12","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"二、核心部分 ","date":"2024-12-14","objectID":"/text40/:2:0","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"1.方法（函数） 方法定义在一个类中，完成特定功能的代码块。 修饰符 返回类型 方法名(参数类型 参数名){ 函数体; return 返回值; } /* 写一个方法（两个明确） 1、返回值类型：结果的数据类型 2、参数列表：传递几个、每个的数据类型 */ 参数： 实参：实际参与运算的 形参：形式上定义的，用来接受实际参数的 return：结束方法 返回值：就是功能的结果，由return带回给调用者 例一：求2个数的和 //方法不调用不会自动运行 public static int Sum(int a,int b) { int c = a+b; return c; } 特例：main方法，在Java虚拟机处调用，所以不用认为调用，依然可以运行 public static void main(String[] args) {....} 方法的调用方式： //单独调用 Sum(a,b); //输出调用 System.out.println(Sum(a,b)); //赋值调用 int result = Sum(a,b); void方法调用：只适用于第一种\"单独调用\" ​ ","date":"2024-12-14","objectID":"/text40/:2:1","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"2.重载 方法的功能相同，参数列表不同，java允许它们起相同的名字。 参数列表不同： 参数个数不同 参数数据类型不同 通过参数个数识别，不同的方法。JVM会根据不同的参数，去调用不同的方法。 //原方法 public static int Sum(int a,int b) {} //重载入参个数 public static int Sum(int a,int b,int c) {} //重载入参类型 public static float Sum(float a,float b) {} ​ ","date":"2024-12-14","objectID":"/text40/:2:2","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"3.数组 1）定义 数组是用于存储多个变量(元素)的容器，这多个元素的数据类型相同。 数据类型[] 数组名 //常用 数据类型 数组名[] 数组定义后，没有值，需要初始化 int[] arr = new int[3]; //int[] arr：看成一个变量，变量需要初始化才能使用 //new：为数组分配内存空间。之后看见的所有的new都是分配内存空间的 //int[3]：数组长度，动态初始化 2）初始化 初始化：开辟内存空间，并赋值 静态初始化：给定元素数值，长度系统定 动态初始化：给定系统长度，由系统分配初始值（默认为0） //动态初始化格式 数据类型[] 数组名 = new 数据类型[数组长度] //静态初始化格式 数据类型[] 数组名 = new 数据类型[元素1,元素2,...] 注意：不要同时使用动/静态初始化。 使用System.out.println(arr) 输出数组arr，显示数组的地址值 用数组名和索引相结合，可以获取数组中指定编号的元素。格式：数组名[索引值]。 3）栈和堆的区别 This is a tip\rJava中的内存分配以及栈和堆的区别： 为了提高运算效率，对内存空间进行了不同区域的划分 栈：存\"基本类型变量\"和\"引用变量\" 不同区域：有特定的“处理数据方式\"和\"内存管理方式\" 5个内存空间： 栈（存储局部变量：方法定义上、方法申明上） 堆（存储new出来的东西 + 数组） 方法区 本地方法区（和系统有关） 寄存器（给CPU使用） 堆内存的特点： 每一个new出来的东西都有地址值 每个变量都有默认值 byte、short、int、long → 0 float、double → 0.0 char → ‘\\u0000’ （空字符） boolean → false 引用类型 → null 使用完毕后，就变成垃圾，但是并没有立即收回，在垃圾回收器空间的时候回收。 栈内存的特点： 用完即释放（数据脱离其作用域） 图解： 4）报错问题 数组操作（越界/空指针）问题： ArrayIndexOutOfBoundsException 数组索引越界异常：原因你访问了不存在的索引。 NullPointerException 空指针异常：原因数组已经不指向堆内存了，但你使用数组名访问了元素。 图解： 数组操作（遍历）： 依次输出数组中每一个元素。 //每个元素只有索引值不同 //遍历：用循环改变索引即可 for(int x=0;x\u003c10;x++){ System.out.println(arr[x]); } 5）数组长度length 数组元素不可数时，用属性length，专门获取数组的长度。 数组名.length; 6）遍历多个数组 写一个通用方法：返回值void，参数列表int []arr。 依次以数组作为入参 public static void printArray(int []arr){ for(int x=0;x\u003carr.length;x++){ System.out.println(arr[x]); } } //多个数组依次调用该通用方法 public static void main(String[] args) { int []arr1 = .....; int []arr2 = .....; printArray(arr1); printArray(arr2); } 7）数组操作（最值） 最值获取 - 最大值获取 int []arr = {1,2,3,4,5} /* 分析： 1、从数组中，任意找一个元素作为参考（一般取第一个，先默认其最大） 2、遍历其他元素，依次取来与之比较，大于则留下，小的就忽略 3、遍历完成，最后剩下的即是最大值 */ int max = arr[0]; for(int i=1;i\u003carr.length;i++){ if(arr[i]\u003emax){ max = arr[i]; } } System.out.println(max); 写成通用方法： public static int getArrayMax(int []arr){ int max = arr[0]; for(int i=1;i\u003carr.length;i++){ if(arr[i]\u003emax){ max = arr[i]; } } return max; } //调用该通用方法 public static void main(String[] args) { int []arr1 = .....; int MAX = getArrayMax(arr1); } 8）数组操作（逆序） /* 分析： 1、把0索引与arr.length-1交换 2、把1索引与arr.length-2交换 ... 3、奇一半、偶中间，做到一半arr.length/2时，完成了所有交换 */ //方法一： public static void reverse(int []arr){ for(int x=0;x\u003carr.length/2;x++){ int temp = arr[x]; arr[x] = arr[arr.length-1-x]; arr[arr.length-1-x] = temp; } } //方法二： public static void reverse(int []arr){ for(int start=0,end=arr.length-1;start\u003c=end;start++,end--){ int temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; } } 9）数组操作（查找） /* 按照索引，查找对应元素 分析： 1、遍历数组 2、和已知数相等 3、返回索引值 */ //方法一： public static int getIndex(int []arr,int value){ for(int i=0;i\u003carr.length;i++){ if(value == arr[i]){ return i; } } return -1; //找不到返回-1 } /* 分析： 1、定义索引 2、遍历数组 3、查到第一个相同，修改索引值 */ //方法二： public static int getIndex(int []arr,int value){ int index = -1; for(int i=0;i\u003carr.length;i++){ if(value == arr[i]){ index = i; //找到即修改 System.out.println(index); break; //找到则不再继续 } } } ","date":"2024-12-14","objectID":"/text40/:2:3","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"4.二维数组 1）定义 “一个元素为一维数组\"的数组 数据类型 [][]数组名 = new 数据类型[m][n] 数据类型 数组名[][] = new 数据类型[m][n] 数据类型[] 数组名[] = new 数据类型[m][n] //m：表示多少个“一维数组” //n：表示“一维数组”中有多少个元素 //arr[m][n]：表示获取第m+1个一维数组的第n+1个元素。 //int x,y：定义两个变量 //int []x,y[]：定义一维数组x，二维数组y 内存存储方式图例： 二维数组元素分布图例： 2）二维数组遍历 /* 分析： 1、arr[0]为第1个数组 2、依次循环改进 3、arr.length在二维数组中，表示一维数组个数 */ public static void getArrays(int [][]arr){ for(int x=0;x\u003carr.length;x++){ for(int y=0;y\u003carr[x].length;y++){ System.out.println(arr[x][y]); } } } 3）二维数组求和 //遍历，累加所有元素，改上的输出为计算sum+=arr[x][y] public static void arraysAdd(int [][]arr){ for(int x=0;x\u003carr.length;x++){ for(int y=0;y\u003carr[x].length;y++){ sum+=arr[x][y] } } } 4）输出杨辉三角形 /* 分析： 杨辉三角形格式： 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 行数可以手动改输入 任何一行的第一列和最后一列都是1 从第三行开始，每一个数据是它上一行的前一列与本列之和 */ import java.util.Scanner; public class YangHuiTriangle { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(\"请输入杨辉三角形的行数: \"); int numRows = scanner.nextInt(); int[][] triangle = new int[numRows][]; for (int i = 0; i \u003c numRows; i++) { triangle[i] = new int[i + 1]; // 每行的元素数量 // 第一个和最后一个元素为1 triangle[i][0] = 1; triangle[i][i] = 1; // 计算中间的元素 for (int j = 1; j \u003c i; j++) { triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j]; } } // 打印杨辉三角形 for (int i = 0; i \u003c numRows; i++) { for (int j = 0; j \u003c= i; j++) { System.out.print(triangle[i][j] + \" \"); } System.out.println(); } scanner.close(); } } ","date":"2024-12-14","objectID":"/text40/:2:4","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"5.面向对象 面向过程：强调每一个功能的步骤 面向对象：强调对象方法功能 创建对象 使用对象 指挥对象做事情 管理维护对象之间的关系 特征（继承、封装、多态） 把构成问题的事物，分成多个独立的对象； 通过调用对象的方法，来解决问题 UML统一建模语言 This is a tip\r错误提示：Invalid character 无效字符：【原因】英文符号打成中文符号\rJava中参数传递值（传值）及引用（传地址）在内存中的分布图例： ","date":"2024-12-14","objectID":"/text40/:2:5","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"6.类及对象 类：是一组相关的属性和行为的集合，是一个抽象的概念。 对象：是该事物的具体表现形式，是具体存在的 现实中对事物的描述： 学生： 属性：该事物的描述信息 =\u003e姓名、年龄、性别 行为：该事物能够做什么 =\u003e学习、吃饭、睡觉 编程模拟现实事物，以Java最基本单位\"类\"体现出来。 1）定义 成员变量：定义同前，(位置)类中方法外 成员方法：没有static、暂时不写 格式 class 类名{ //定义变量 数据类型 变量名 初始化 //定义方法 修饰符 返回值 方法名(){ 方法体 } } 2）使用 在一个java文件中，写两个类：一个基本类、一个测试类 创建对象使用，类名 对象名 = new 类名(); 使用： 成员变量：对象名.变量名 成员方法：对象名.方法名 3)一个对象的内存图 java中没有索引，只有引用，且不对引用进行操作 （两）三个对象的内存图，大体一致，注意不同对象的变量的空间方法调用 4）成员变量 \u0026 局部变量（区别） 所处位置不同 类中方法外 方法内或者方法声明上 内存中位置不同 堆内存 栈内存 生命周期不同 随着对象的存在而存在 随着方法的调用而存在，随着方法的调用完毕而消失 初始化值不同 有默认初始值 没有初始值，需要定义，被赋值才可使用 同一方法中，局部变量 可以与 成员变量同名，且默认访问的是局部变量。要想访问成员变量，使用this关键字。格式：this.成员变量名 C++中，面向过程的程序设计： 分解出解决问题所需要的步骤 用函数将这些步骤实现 使用时依次调用就可以了 5）匿名对象（没有名字的对象） new Student(); //匿名对象 //调用方式 - 只能调用一次 匿名对象.方法名 //举例 //一个学生对象 public class Student{ //查看学生信息方法 public void Show(){...} } //实名对象调用 Student s = new Student(); s.Show(); s.Show(); //同一个对象两次调用Show方法 //匿名对象调用 new Student().Show(); new Student().Show();//重新创建了一个新的对象，调用完毕，匿名对象为垃圾 //回收垃圾 java.lang.System.gc(); 6）形式参数（2种类型） 基本类型：形参的改变，不影响实际参数 引用类型：形参的改变，直接影响实际参数 【注】：方法的形式参数是类名（引用类型）的时候如何调用？ //一个学生对象 public class Student{ //查看学生信息方法 public void Show(){...} } //一个新的对象 public class StudentDemo{ //以学生对象为形式参数的方法 public void method(Student s){ s.Show(); } } //调用引用类型为参数的类方法，需要传实参对象的地址值 Student s = new Student(); StudentDemo ss = new StudentDemo(); ss.method(s); 7）创建对象详解 创建对象做了哪些事情？Student s = new Student(); 把Student.class文件加载到内存 在栈内存给s变量开辟一个空间 在堆内存为学生对象申请一个空间 给成员变量进行默认初始化（null/0） 给成员变量进行显示初始化 通过构造方法给成员变量进行初始化 把堆内存地址赋值给s内存变量 ","date":"2024-12-14","objectID":"/text40/:2:6","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"7.封装 Java中的封装（Encapsulation）是一种面向对象编程的核心概念，它指的是将**对象的状态（数据）和对状态的操作（方法）**封装在一起，从而保护对象的内部状态不被外部代码直接访问和修改。这种机制提高了数据的安全性，使得对象的行为更加可靠。 封装通过以下几个方面实现： 访问修饰符：Java提供了四种主要的访问修饰符（public、protected、default、private），用来控制类、方法和变量的可见性。 private：仅在本类中可访问。 default（没有修饰符）：在同一包内可访问 protected：在同一包内以及子类中可访问。 public：在任何地方可访问。 范围：从上到下，依次变大 有public的源文件，文件名必须与public修饰的类名相同（必须） Getter和Setter：通过公共的方法来获取和设置私有变量的值。这种方式使得可以在设置或获取值时添加额外的逻辑，例如验证输入值。 public class Person { private String name; // 私有变量 // Getter方法 public String getName() { return name; } // Setter方法 public void setName(String name) { this.name = name; } } this随对象存在，哪个对象调用方法，则this指向内存中的该对象堆 改变内部实现而不影响外部：封装允许我们改变类的内部实现，只要保持接口不变，外部代码就不需要做任何修改。这提高了代码的灵活性和可维护性。 数据保护：通过限制对对象内部状态的直接访问，封装能防止对象进入不一致的状态。例如，可以在Setter方法中添加条件检查，从而确保只有有效的数据才能赋值。 ","date":"2024-12-14","objectID":"/text40/:2:7","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"8.构造方法 在Java中，构造方法（Constructor）是一种特殊的方法，用于在创建对象时初始化该对象的状态。构造方法的特点包括： 与类同名：构造方法的名称必须与类名完全相同。 没有返回类型：构造方法不返回任何类型，连void也没有。 可以重载：一个类可以有多个构造方法，称为构造方法重载。通过不同的参数列表来区分。 自动调用：构造方法在对象创建时自动调用。 1）构造方法的基本示例 以下是一个简单的示例，展示了构造方法的用法： public class Car { private String model; private int year; // 默认构造方法 public Car() { model = \"Unknown\"; year = 2020; } // 带参数的构造方法 public Car(String model, int year) { this.model = model; this.year = year; } public void displayInfo() { System.out.println(\"Model: \" + model + \", Year: \" + year); } public static void main(String[] args) { // 使用默认构造方法 Car car1 = new Car(); car1.displayInfo(); // 输出: Model: Unknown, Year: 2020 // 使用带参数的构造方法 Car car2 = new Car(\"Toyota\", 2021); car2.displayInfo(); // 输出: Model: Toyota, Year: 2021 } } 2）构造方法的类型 默认构造方法：如果类没有定义任何构造方法，Java会自动提供一个无参的默认构造方法。它会初始化对象的字段为默认值（如数值为0，布尔为false，引用对象为null）。 参数化构造方法：用户可以定义构造方法，接受参数以初始化对象的状态。 注意事项 如果我们给了构造方法，不管是否有参，系统都不再提供 构造方法被私有以后，外界就不能创建对象 构造方法不能被static修饰，也不能被final或abstract修饰。 在一个构造方法中，可以使用this关键字来调用同一类中的其他构造方法，实现构造方法重载。例子参考下面。 3）关键字 this 在构造方法中，常常使用this关键字来区分实例变量和参数变量。例如： public Car(String model, int year) { this.model = model; // this.model指的是类的实例变量 this.year = year; // model和year是构造方法的参数 } //这个示例展示了如何使用构造方法来正确初始化对象的属性。 ","date":"2024-12-14","objectID":"/text40/:2:8","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"9.static关键字的引入 1）定义及特点 针对多个对象有共同的这样的成员变量值的时候，Java提供static关键字来修饰。 随着类的加载而加载【可以修饰成员变量和方法】 优先于对象存在 对象共享【如果某个成员变量被所有对象所共享时，用静态修饰】 可以通过类名调用【特殊的：main方法。被类名.main虚拟机调用。其实它本身也可以通过对象名调用，静态修饰的内容一般我们称其为：与类相关的类成员】 被static修饰的，内存位置全部移动； 在静态方法中没有this关键字：静态是随着类的加载而加载，this是随着对象的创建而存在。静态优先于内存中比对象先存在。 静态方法只能访问静态的成员方法/变量。 2）特点示例 在Java中，static关键字用于声明类的静态成员（字段和方法）。静态成员属于类本身，而不是类的实例（对象）。这意味着你可以在没有类实例（对象）的情况下访问静态成员。以下是static关键字的几个主要用法和特性： 静态变量（字段）： 静态变量是属于类的共享变量，而不是某个特定对象的实例变量。所有对象共享同一个静态变量。 例子： class MyClass { static int staticCount = 0; // 静态变量 MyClass() { staticCount++; } } 静态方法： 静态方法可以直接通过类名调用，而无需创建类的实例。静态方法只能访问静态变量，无法直接访问实例变量（非静态变量）。 例子： class MyClass { static void staticMethod() { System.out.println(\"This is a static method.\"); } } // 调用静态方法 MyClass.staticMethod(); 静态块： 静态初始化块用于初始化静态变量或执行某些一次性操作。它在类被加载时执行。 例子： class MyClass { static int staticVar; static { staticVar = 42; // 静态块 } } 静态内部类： 静态内部类属于外部类，可以直接访问外部类的静态成员，但不能访问非静态成员。 例子： class Outer { static int outerStaticVar = 5; static class Inner { void display() { System.out.println(\"Outer static var: \" + outerStaticVar); } } } 静态导入： Java允许通过静态导入语句直接使用类中的静态成员，简化代码。 例子： import static java.lang.Math.*; double result = sqrt(25); // 直接使用sqrt()方法 static关键字在Java中提供了一种方便的方式来管理类级别的属性和行为，使得代码更加简洁和高效。 3）main方法详解 4）静态变量/成员变量区别 静态变量 成员变量 所属 类（类变量） 对象（对象变量） 内存位置 方法区中的静态区 堆 出现时间 类加载时出现 类消失时释放 对象产生出现 对象消失释放 调用 类.xx 对象.xx 对象.xx ","date":"2024-12-14","objectID":"/text40/:2:9","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"10.递归 递归是指在一个方法内部，直接或间接调用自身的过程。它通常用于解决可以被分解成相似子问题的问题，适合处理那些具有重叠子问题和最优子结构特性的场景。递归的关键概念包括基准情况和递归情况。 1）递归基本结构 基准情况：这是递归的终止条件，防止无限调用自身。 递归调用：在基准情况未满足时，方法会调用自身来解决更小的子问题。 2）递归的例子 最常见的递归示例是计算阶乘（Factorial）和斐波那契数列（Fibonacci sequence）。 1. 计算阶乘 阶乘是一个非负整数的乘积，表示为 n!，可以定义为： 0! = 1 n! = n * (n - 1)! Java实现： public class Factorial { public static int factorial(int n) { // 基准情况 if (n == 0) { return 1; } // 递归情况 return n * factorial(n - 1); } public static void main(String[] args) { int number = 5; System.out.println(\"Factorial of \" + number + \" is: \" + factorial(number)); } } 2. 斐波那契数列 斐波那契数列定义为： F(0) = 0 F(1) = 1 F(n) = F(n - 1) + F(n - 2)（n ≥ 2） Java实现： public class Fibonacci { public static int fibonacci(int n) { // 基准情况 if (n == 0) { return 0; } else if (n == 1) { return 1; } // 递归情况 return fibonacci(n - 1) + fibonacci(n - 2); } public static void main(String[] args) { int number = 6; System.out.println(\"Fibonacci of \" + number + \" is: \" + fibonacci(number)); } } 3）递归的优缺点 优点： 简洁：递归可以显著简化一些复杂问题的代码。 自然表达：能更自然地表达一些问题的解决方案，如树结构的遍历。 缺点： 效率：递归方法可能效率较低，尤其是在调用深度较大或存在重叠子问题时，可能导致大量重复计算（例如斐波那契数列的简单递归）。 栈溢出：递归深度过大可能导致栈溢出错误（StackOverflowError）。 ","date":"2024-12-14","objectID":"/text40/:2:10","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"11.继承 在Java中，继承是面向对象编程的一个重要概念，它允许一个类（子类）继承另一个类（父类）的属性（字段）和方法（行为）。通过继承，子类能够重用父类的代码，同时还可以扩展或修改父类的功能。继承有助于代码重用和组织，便于维护和扩展。 1）继承的基本概念 父类（超级类）和子类： 父类（或基类）是被继承的类。 子类（或派生类）是继承父类的类。 extends 关键字：用于表明一个类是从另一个类继承的，例如： class Parent { // 父类属性和方法 } class Child extends Parent { // 子类中的属性和方法 } 单继承：Java不支持多重继承，即一个类只能有一个直接父类。子类可以实现多个接口，但只能继承一个类。 2）继承的特点 属性和方法的继承：子类可以直接访问父类的公共属性和方法，也可以通过protected修饰符访问。在子类中，无法直接访问父类的私有属性和方法。 方法重写：子类可以重写父类的方法，以提供特定的实现。重写的方法必须具有相同的名称、返回类型和参数列表。 class Parent { void display() { System.out.println(\"This is the Parent class.\"); } } class Child extends Parent { @Override void display() { // 方法重写 System.out.println(\"This is the Child class.\"); } } 构造器：子类构造器默认调用父类的无参构造器。如果父类没有无参构造器，则必须在子类构造器中显式调用父类的其他构造器。 super关键字：用于引用父类的属性和方法。可以在子类构造器中使用super()调用父类构造器。 class Parent { Parent() { System.out.println(\"Parent constructor\"); } } class Child extends Parent { Child() { super(); // 调用父类构造器 System.out.println(\"Child constructor\"); } } 3）示例代码 下面是一个简单的继承示例，包含父类和子类的定义以及方法的重写： class Animal { void sound() { System.out.println(\"Animal makes a sound\"); } } class Dog extends Animal { @Override void sound() { // 方法重写 System.out.println(\"Dog barks\"); } void fetch() { System.out.println(\"Dog fetches a ball\"); } } public class Main { public static void main(String[] args) { Dog dog = new Dog(); dog.sound(); // 调用重写的方法 dog.fetch(); // 调用子类特有的方法 } } 4）继承的优点和缺点 优点： 代码重用：通过继承，子类可以重用父类的代码，减少重复代码。 结构化设计：可以通过继承建立类之间的层次结构，便于理解和维护代码。 缺点： 紧耦合性：子类与父类之间的关系可能导致代码的紧耦合，父类的改动会影响所有子类。 继承的复杂性：过多的继承层次会导致系统的复杂性增加，影响可读性和可维护性。 ","date":"2024-12-14","objectID":"/text40/:2:11","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"12.重写/重载 在Java中，重写（Overriding）和重载（Overloading）都是重要的多态性概念，但它们之间有着明显的区别。以下是对这两个概念的详细解释： 1. 重载（Overloading） 重载是指在同一个类中，可以定义多个同名的方法，这些方法在参数列表上必须不同（可以是参数类型、参数个数或参数顺序不同）。重载主要用于增强代码的可读性和灵活性。 特点： 方法名相同：重载的方法必须有相同的方法名。 参数不同：重载的方法必须至少有一个参数的类型或数量不同。 返回类型：返回类型可以不同，但返回类型的不同不能作为重载的唯一条件。 示例： class MathUtils { // 重载的方法 public int add(int a, int b) { return a + b; } public double add(double a, double b) { return a + b; } public int add(int a, int b, int c) { return a + b + c; } } public class Main { public static void main(String[] args) { MathUtils mathUtils = new MathUtils(); System.out.println(mathUtils.add(2, 3)); // int System.out.println(mathUtils.add(2.5, 3.5)); // double System.out.println(mathUtils.add(1, 2, 3)); // int } } 2. 重写（Overriding） 重写是指在子类中重新定义父类中已经存在的方法。重写允许子类提供特定的实现，以替代父类中的实现，增加了灵活性和可扩展性。重写的主要目的是实现运行时多态性。 特点： 方法名相同：重写的方法名与被重写的方法名相同。 参数相同：重写方法的参数列表必须与父类中的方法完全相同。 返回类型：允许返回类型是被重写方法返回类型的子类（协变返回类型）。 访问修饰符：重写方法的访问修饰符不能比父类中的方法更加严格。（私有父类方法不可重写，子类权限不小于父类，父类静态方法，子类必须以静态方法重写） 示例： class Animal { void sound() { System.out.println(\"Animal makes a sound\"); } } class Dog extends Animal { @Override // 注解，表明该方法是重写父类的方法 void sound() { System.out.println(\"Dog barks\"); } } public class Main { public static void main(String[] args) { Animal myDog = new Dog(); myDog.sound(); // 输出: Dog barks } } 对比总结 特征 重载（Overloading） 重写（Overriding） 定义 同一类中，方法名相同，参数不同 子类中，方法名和参数相同 方法数量 可以有多个重载方法 一种方法只能有一个重写 返回类型 可以不同 必须相同或协变返回类型 使用场景 提高代码可读性，支持多种输入类型 实现运行时多态性，提供特定实现 访问修饰符 无特殊限制 访问修饰符不能更严格 ","date":"2024-12-14","objectID":"/text40/:2:12","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"13.多态 在Java中，多态（Polymorphism）是面向对象编程的重要特性之一。多态性允许对象以多种形式出现，它主要分为编译时多态（也称为方法重载）和运行时多态（也称为方法重写）。 1. 编译时多态（方法重载） 编译时多态是通过方法重载实现的。在同一个类中，可以定义多个同名的方法，这些方法具有不同的参数列表。编译器根据传入参数的数量和类型来决定调用哪个方法。示例参考上面。 2. 运行时多态（方法重写） 运行时多态是通过方法重写实现的。子类可以重写（Override）父类的方法，以提供特定的实现。示例参考上面。 ","date":"2024-12-14","objectID":"/text40/:2:13","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"14.final关键字 在Java中，final 关键字用于定义一些不应被修改的内容。它可以用来修饰类、方法和变量，具有不同的含义。以下是对 final 关键字的详细解释： 1. final 修饰变量 当一个变量被声明为 final 时，它的值在初始化后不能再被修改。这意味着你只能给它赋一次值。final 变量可以是基本数据类型（如 int、double）或引用类型（如对象）。 示例： final int MAX_VALUE = 100; // MAX_VALUE = 200; // 这将导致编译错误，无法改变 final 变量的值 final List\u003cString\u003e myList = new ArrayList\u003c\u003e(); myList.add(\"Hello\"); // 可以修改对象的内容 // myList = new ArrayList\u003c\u003e(); // 这将导致编译错误，无法重新赋值 2. final 修饰方法 当一个方法被声明为 final 时，该方法不能在子类中被重写。这可以保护父类的实现，确保子类不会改变方法的行为。 示例： class Parent { final void display() { System.out.println(\"This is a final method.\"); } } class Child extends Parent { // void display() { // 这将导致编译错误，不能重写 final 方法 // System.out.println(\"Trying to override.\"); // } } 3. final 修饰类 当一个类被声明为 final 时，该类不能被继承。这意味着不能创建一个子类来扩展该类。这通常用于创建安全的、不应被修改的类。 示例： final class FinalClass { // 类的内容 } // class SubClass extends FinalClass { // 这将导致编译错误，FinalClass 不能被继承 // } 4. 使用 final 的目的 常量定义：使用 final 来定义常量，确保值不被修改。 安全性：防止实现被修改，维护代码的安全性和稳定性。 性能优化：某些情况下，JVM 可以对 final 方法或类进行优化，从而提高性能。 ","date":"2024-12-14","objectID":"/text40/:2:14","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"15.抽象类 在Java中，抽象类是面向对象编程的一部分，用于提供一个不完全的类定义，可以由子类进行扩展。抽象类允许您定义不需要完全实现的类，为子类提供基本的结构。以下是对抽象类的详细解释以及它们的用途、特性和示例。 1. 抽象类的定义 抽象类是使用 abstract 关键字声明的类。它可以包含抽象方法（没有具体实现的方法）和具体方法（有实现的方法）。抽象类无法实例化，您不能直接创建一个抽象类的对象。 示例定义： abstract class Animal { // 抽象方法，没有实现 abstract void sound(); //不能写成sound(){}，因为{}是空方法体。抽象方法不能有主体。 // 具体方法 void eat() { System.out.println(\"Animal is eating\"); } } 2. 抽象类的特性 不能实例化：您无法创建抽象类的实例，只能通过子类来使用。 可以包含抽象方法和具体方法：抽象类可以包含零个或多个抽象方法，也可以包含具有实现的具体方法。 子类必须实现抽象方法：所有继承抽象类的子类必须实现所有抽象方法，除非子类也是抽象类。 3. 抽象类的用途 提供模板：抽象类可以作为其他类的模板，强制子类实现特定的方法。 代码复用：可以在抽象类中实现共享的方法，子类可以直接使用或重写这些方法。 实现多态：可以通过抽象类来实现多态性，使用父类引用指向子类对象进行方法调用。 4. 示例 下面的示例展示了如何定义一个抽象类，并使其子类实现抽象方法： // 定义抽象类 abstract class Animal { // 抽象方法 abstract void sound(); // 具体方法 void eat() { System.out.println(\"Animal is eating\"); } } // 继承抽象类并实现抽象方法 class Dog extends Animal { @Override void sound() { System.out.println(\"Dog barks\"); } } class Cat extends Animal { @Override void sound() { System.out.println(\"Cat meows\"); } } // 主类 public class Main { public static void main(String[] args) { Animal myDog = new Dog(); // 父类引用指向子类对象 Animal myCat = new Cat(); myDog.sound(); // 输出: Dog barks myDog.eat(); // 输出: Animal is eating myCat.sound(); // 输出: Cat meows myCat.eat(); // 输出: Animal is eating } } 5. 不能与抽象类共存的关键字 private：无法重写 final：无法重写 static：无方法体，调用无意义 6.抽象类与接口的比较 特性 抽象类 接口 修饰符 可以有 public、protected、private 修饰符 默认是 public，方法默认是抽象的 变量 可以包含实例变量和静态变量 只能包含常量（static final） 方法 可以有抽象方法和具体方法 只能有抽象方法（从 Java 8 开始支持默认方法） 继承 支持单继承 支持多重继承（可以实现多个接口） 适用场景 用于提供类的一部分实现 用于定义一组功能 ","date":"2024-12-14","objectID":"/text40/:2:15","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"16.接口 体现事物的扩展性，不是实际意义上的类，只做功能的扩展，无法实现 在Java中，接口（Interface）是一种特殊的参考类型，它定义了一组方法的签名，但不提供具体的实现。接口用于实现抽象，允许不同类之间实现一致的行为。以下是关于接口的一些重要点： 1. 定义接口 接口使用interface关键字定义，示例如下： public interface Animal { void eat(); void sleep(); } 2. 实现接口 一个类可以通过implements关键字实现一个或多个接口。类需要提供接口中声明的所有方法的具体实现： //接口的子类，重写所有抽象方法（具体类） public class Dog implements Animal { @Override public void eat() { System.out.println(\"Dog is eating.\"); } @Override public void sleep() { System.out.println(\"Dog is sleeping.\"); } } 3. 多重继承 Java不支持类的多重继承，但一个类可以实现多个接口，从而允许多重行为的实现： public interface Pet { void play(); } public class Cat implements Animal, Pet { @Override public void eat() { System.out.println(\"Cat is eating.\"); } @Override public void sleep() { System.out.println(\"Cat is sleeping.\"); } @Override public void play() { System.out.println(\"Cat is playing.\"); } } 4. 默认方法和静态方法 从Java 8开始，接口可以包含默认方法和静态方法： public interface Vehicle { void drive(); default void honk() { System.out.println(\"Honking!\"); } static void fuel() { System.out.println(\"Filling fuel.\"); } } 5. 常量 接口可以包含常量，定义时需要使用public static final（默认为这样）： public interface Constants { int MAX_SPEED = 120; } 6. 接口与抽象类的比较 实现方式：接口只定义方法的签名，抽象类可以有实现的方法。 构造函数：接口不能有构造函数，抽象类可以有。 多继承：一个类可以实现多个接口，但只能继承一个抽象类。 7.接口的成员访问特点 成员变量：接口中的变量，默认为常量、且为静态的。有默认修饰符public static final 构造方法：没有，所有类都默认继承自Object类 成员方法：没有方法体，默认public abstract 8.多态的几种类型 具体类多态（几乎没有） 抽象类多态（常用） 接口多态（最常用） ","date":"2024-12-14","objectID":"/text40/:2:16","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"17.包 在Java中，包（Package）是一种组织类和接口的机制，可以帮助开发者更好地管理和结构化代码。包提供了命名空间，避免类名冲突，并且可以控制访问权限。以下是关于Java包的一些重要概念： 1. 定义包 使用package关键字定义包。例如，将类放入名为com.example的包中： package com.example; public class MyClass { // 类内容 } 2. 包的命名规则 包名通常采用小写字母，避免与类名冲突。 通常使用反向域名来命名包，例如com.companyname.project。 包名中可以包含字母、数字和下划线，但应避免使用特殊字符和空格。 3. 导入包 在Java中，可以使用import关键字导入其他包中的类。可以导入单个类或整个包： import com.example.MyClass; // 导入单个类 import com.example.*; // 导入包中的所有类 4. 访问控制 包还与访问控制相关联。Java提供了四种访问修饰符，用于控制类、方法和变量的可见性： public：公共的，可以被任何类访问。 protected：受保护的，在同一包内或子类中可访问。 默认（无修饰符）：在同一包内可访问。 private：私有的，仅在同一类中可访问。 5. 使用自定义包 可以创建自己的包并在项目中使用。通常，组织方式为： src └── com └── example ├── MyClass.java └── AnotherClass.java 这些类可以通过相同的包名来组织，方便管理。 6. Java标准库中包 Java标准库中有许多使用广泛的包，例如： java.lang：包含核心类，自动导入。 java.util：包含集合框架、日期时间等。 java.io：提供输入输出功能。 java.net：包含网络相关的类。 7. 包的好处 避免命名冲突：不同包中的类可以使用相同的名称。 组织代码：将相关的类和接口组织成一个层次结构，使代码更清晰。 访问控制：通过包的可见性控制，增强安全性和模块性。 示例 定义一个简单的包并在主类中使用： // 在 com/example 目录下创建 MyClass.java package com.example; public class MyClass { public void display() { System.out.println(\"Hello from MyClass!\"); } } // 在其他文件中使用 import com.example.MyClass; public class Main { public static void main(String[] args) { MyClass myClass = new MyClass(); myClass.display(); } } 通过上述示例，可以看到package语句必须是程序的第一条可执行的代码；package语句在一个java文件中只能有一个；如果没有package，默认表示无包名。 ","date":"2024-12-14","objectID":"/text40/:2:17","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"18.内部类 在Java中，内部类（Inner Class）是一种在另一个类内部定义的类。使用内部类可以让你更好地组织代码、提高封装性并简化某些任务。下面是关于内部类的几个重要方面： 1. 内部类的类型 Java主要有四种类型的内部类： 1.1 成员内部类 直接定义在外部类的类中。可以访问外部类的所有成员（包括私有成员）。 public class OuterClass { private int outerField = 10; class InnerClass { void display() { System.out.println(\"Outer field value: \" + outerField); } } } 1.2 静态内部类 使用static关键字定义，不能访问外部类的非静态成员。静态内部类的实例可以直接通过外部类名来创建。 public class OuterClass { static int outerField = 10; static class StaticInnerClass { void display() { System.out.println(\"Outer static field value: \" + outerField); } } } 1.3 局部内部类 定义在外部类的方法内部，其作用域仅限于方法内部。可以访问外部类的所有成员，包括私有的。 public class OuterClass { void outerMethod() { class LocalInnerClass { void display() { System.out.println(\"Inside local inner class.\"); } } LocalInnerClass localInner = new LocalInnerClass(); localInner.display(); } } 1.4 匿名内部类 没有名字的类，用来实现接口或扩展类，通常在声明上直接创建实例。常用于事件处理和回调。 public class OuterClass { void createAnonymous() { Runnable runnable = new Runnable() { @Override public void run() { System.out.println(\"Running in anonymous inner class.\"); } }; new Thread(runnable).start(); } } 2. 内部类的用途 封装性：内部类可以封装不需要对外公开的类，因为它们只在外部类的上下文中使用。 易读性：使得代码逻辑更清晰，内聚性更强。 直接访问外部类成员：内部类可以直接访问外部类的成员，减少了参数传递的麻烦。 3. 使用示例 以下是一个使用内部类的完整示例，演示了成员内部类和静态内部类的用法： public class Outer { private String outerField = \"Outer field\"; // 成员内部类 class Inner { void display() { System.out.println(\"Accessing: \" + outerField); } } // 静态内部类 static class StaticInner { static void print() { System.out.println(\"Static inner class method.\"); } } public static void main(String[] args) { // 创建内部类的实例 Outer outer = new Outer(); Inner inner = outer.new Inner(); inner.display(); // 创建静态内部类的实例 StaticInner.print(); } } 4. 注意事项 内部类的实例不能存在于其外部类的实例之前。 使用static修饰的内部类不能直接访问外部类的非静态成员。 内部类与外部类的关系表明了封装性和依赖性，有助于减少耦合性。 ","date":"2024-12-14","objectID":"/text40/:2:18","tags":["Java"],"title":"【Java】Java语言基础（二）","uri":"/text40/"},{"categories":["Java"],"content":"基础概念入门 ","date":"2024-12-11","objectID":"/text39/:1:0","tags":["Java"],"title":"【Java】Java语言基础（一）","uri":"/text39/"},{"categories":["Java"],"content":"一、计算机 裸机：没有安装任何软件的计算机 科学计算 —— 数值计算 数据处理 自动控制 计算机辅助设计 人工智能 多媒体应用 计算机网络 计算机硬件：电工、机械、光电元件（各种物理装置的总称） CPU、主板、内存、电源、主机箱、硬盘、显卡、键盘、鼠标、显示器 计算机软件：一系列指令（由程序 + 相关文档 组成，用于执行特定任务/功能） 系统软件：DOS（Disk Operating System）、Windows、ios、Android、Mac、Linux 应用软件：Office、QQ、微信 软件开发：特定顺序 + 数据 + 指令 的集合 人机交互：图形化界面 + 命令行方式 （例如：控制台） Dos窗口命令： d: 切换至d盘 [盘符切换] dir: 列出当前目录下的文件 （ls Nginx中使用这个） md 创建目录 rd 删除目录（删文件夹） 带内容的文件夹删除 一个一个的删 rd + /s rd + /s + /q cd 进入指定目录 cd.. 退出当前目录 （单级退出） del 删除 （只能删除*.txt类文件） cls 清屏 exit 退出 edit 编辑 notepad 打开记事本 mspaint 打开画图 ctrl + alt + L 代码对齐 键盘prtSc 屏幕截图 确保系统上已正确安装 Java 开发工具包（JDK），Dos窗格中可以： javac HelloWorld.java 编译 java HelloWorld.class 运行 Java语言平台版本 J2SE 桌面 J2ME 手机 J2EE 电脑 Java的垮平台性：指Java程序能够在不同操作系统和硬件平台上运行，而无需修改源代码。 Java虚拟机（JVM）： Java源代码在编译后生成的是字节码（.class文件），而不是直接生成特定操作系统的机器代码。字节码可以在任何安装了Java虚拟机（JVM）的设备上运行。各个操作系统都有各自的JVM实现，这使得相同的Java字节码可以在Windows、Linux、Mac OS等平台上无缝运行。 一次编写，到处运行（WORA）： Java的设计理念是“一次编写，随处运行”。开发者只需将Java程序编写一次，并编译成字节码，之后就可以在任何支持JVM的系统上运行，而无需进行任何修改。 高度的抽象性： Java提供了大量的标准库和API，这些库和API被设计为与平台无关。开发者在编写应用时主要使用这些标准的功能，而不需要考虑底层操作系统的差异。 图例： （大）JDK：Java开发工具包（开发环境） Javac.exe 编译工具 jar.exe 打包工具 ….. （中）JRE：Java运行环境 （小）JVM：Java虚拟机 （小）Java核心库：一组重要类和接口，它们提供了Java程序开发所需的基本功能 java.lang：包含基本的类，如 String、Math、Object 等，所有Java程序默认导入这个包。 java.util：提供了许多实用的工具类，如集合框架（List、Set、Map）、日期/时间类等。 java.io：包含输入/输出类，允许程序与数据源（如文件、网络）进行数据交换。 java.net：提供网络编程的支持，包括URL、Socket等类。 java.awt 和 javax.swing：用于创建图形用户界面（GUI）的类。 java.sql：提供与数据库连接和操作相关的类。 ​ ","date":"2024-12-11","objectID":"/text39/:1:1","tags":["Java"],"title":"【Java】Java语言基础（一）","uri":"/text39/"},{"categories":["Java"],"content":"二、path环境配置 PATH 是一个环境变量，用于告诉操作系统在命令行中寻找可执行程序的位置。正确配置 PATH 变量，使你能够在任何位置通过命令调用相关的可执行文件，而不需要输入其完整的路径。这在使用 Java、Git 等开发工具时特别重要。 目的：需要在任意的目录下均可运行（可执行性文件.exe） Windows 中配置 打开系统属性： 右键点击“此电脑”或“计算机”，选择“属性”。 点击“高级系统设置”。 在“系统属性”窗口中，点击“环境变量”按钮。 编辑 PATH 变量： 在“系统变量”或“用户变量”区域，查找PATH变量： 如果不存在，点击“新建”，输入变量名 Path。 如果已存在，选择它并点击“编辑”。 添加新的路径： 在编辑窗口中，点击“新建”，然后添加你想要包含的目录路径（例如，Java 的 bin 目录）。 示例路径： C:\\Program Files\\Java\\jdk-11\\bin 你也可以直接在已有的路径中添加（用分号 ; 分隔每个路径）。 保存并关闭： 点击“确定”以保存更改，然后关闭所有相关窗口。 macOS 和 Linux 中配置 打开终端。 编辑配置文件： 根据你使用的 shell，编辑相应的配置文件（例如 .bashrc、.bash_profile 或 .zshrc）。 使用文本编辑器打开文件。例如： nano ~/.bashrc # 对于 bash 对于其他 shell，如 zsh，你可能需要编辑 .zshrc 文件。 添加路径到 PATH： 在文件的末尾添加以下行： export PATH=\"/path/to/directory:$PATH\" 例如，如果你希望添加 Java 的bin目录： export PATH=\"/usr/local/java/jdk-11/bin:$PATH\" 保存并退出（对于 nano，使用 CTRL + X，然后按 Y 保存）。 使改动生效： 运行以下命令： source ~/.bashrc # 或者 source ~/.zshrc 这会使新的 PATH 设置在当前终端会话中生效。也可以重新打开终端来应用更改。 ​ 验证 PATH 配置 你可以通过在命令行中输入以下命令来验证 PATH 是否配置正确： 在 Windows： echo %PATH% 在 macOS/Linux： echo $PATH 执行该命令后，你应该能看到你添加的路径。如果没有，可能需要检查是否正确保存了文件并重新加载配置。 ","date":"2024-12-11","objectID":"/text39/:1:2","tags":["Java"],"title":"【Java】Java语言基础（一）","uri":"/text39/"},{"categories":["Java"],"content":"三、classpath环境配置 在Java中，CLASSPATH 是一个环境变量，用于告诉**Java虚拟机（JVM）**和 **Java编译器（javac）**在哪些目录下寻找类文件（.class文件）和库文件（.jar文件）。 设置 CLASSPATH 的作用 查找类：CLASSPATH 告诉JVM和编译器从哪里加载所需的类和资源。 项目依赖：在一个应用程序中，可能会需要多个外部库，CLASSPATH 有助于管理这些依赖。 CLASSPATH 配置方法 在不同操作系统上，配置 CLASSPATH 的方法略有不同： Windows 打开系统属性： 右键点击“此电脑”或“计算机”，选择“属性”。 点击“高级系统设置”。 在“系统属性”窗口中，点击“环境变量”。 创建或编辑 CLASSPATH： 在“系统变量”或“用户变量”区域，查找CLASSPATH变量： 如果不存在，点击“新建”，输入变量名 CLASSPATH。 如果已存在，选择它并点击“编辑”。 添加路径： 在变量值中添加目录路径或jar文件的路径，用分号（;）分隔。例如： C:\\myproject\\classes;C:\\myproject\\lib\\mylibrary.jar 保存和关闭： 点击“确定”保存，并关闭所有窗口。 macOS 和 Linux 打开终端。 编辑配置文件： 根据使用的shell，编辑相应的配置文件（例如，~/.bashrc、~/.bash_profile 或 ~/.zshrc）。 使用文本编辑器打开文件，例如： nano ~/.bashrc 添加 CLASSPATH： 在文件末尾添加以下行： export CLASSPATH=/path/to/classes:/path/to/libs/mylibrary.jar:$CLASSPATH : 用于分隔多个路径。 保存并退出（对于 nano，使用 CTRL + X，然后按 Y 保存）。 使改动生效： source ~/.bashrc 或重新打开终端。 ","date":"2024-12-11","objectID":"/text39/:1:3","tags":["Java"],"title":"【Java】Java语言基础（一）","uri":"/text39/"},{"categories":["前端"],"content":"Vue3快速上手 ","date":"2024-11-14","objectID":"/vue3/:1:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.Vue3简介 2020年9月18日，Vue.js发布3.0版本，代号:One Piece(海贼王) 耗时2年多、2600+次提交、30+个RFC（请求修改意见稿）、600+次PR、99位贡献者 github上的tags（各个开源版本）地址:https://github.com/vuejs/vue-next/releases/tag/v3.0.0 ","date":"2024-11-14","objectID":"/vue3/:1:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.Vue3带来了什么 ","date":"2024-11-14","objectID":"/vue3/:1:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"一、创建Vue3.0工程 ","date":"2024-11-14","objectID":"/vue3/:2:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.使用 vue-cli 创建 官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create ## 查看@vue/c1i版本，确保@vue/cli版本在4.5.0以上 ,vue -V查看本机@vue/c1i版本 vue --version ## 安装或者升级你的@vue/cli --不满足版本要求就自行这一步重新安装 npm install -g @vue/cli ## 创建 vue create vue_test ## 启动 cd vue_test npm run serve ​ ","date":"2024-11-14","objectID":"/vue3/:2:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.使用 vite 创建 官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite vite官网：https://vitejs.cn 什么是vite? —— 新一代前端构建工具（作用对比webpack）。 优势如下： 开发环境中，无需打包操作，可快速的冷启动。 轻量快速的热重载(HMR) 真正的按需编译，不再等待整个应用编译完成。 传统构建 与 vite构建对比图（这两张图来自于vite官网位置） npm run serve这种的webpack传统工作模式：先是从一个entry，先看路由，再看模块，再进行打包，最后告知8080服务器启动好了。【主要等待时间在Bundle打包的位置】 vite构建工作模式：先告知8080服务器启动准备完成，根据你发起的请求，找到对应的entry并且解析该模块对应的路由和组件信息展示。 ## 创建工程 npm init vite-app \u003cproject-name\u003e ##进入工程目录 cd \u003cproject-name\u003e ##安装依赖 npm insta1l ## 运行 npm run dev 我们将两种构建模式放一起同时运行，很明显vite方式的要比传统方式快很多。 期间，传统方式等待的这段时间，就是在打包。 注意\r传统运行命令是npm run serve，vite运行命令式npm run dev。现在vite模式还没有大规模应用，所以我们此文档后面的演示还是使用基于传统模式的运行方式。\r","date":"2024-11-14","objectID":"/vue3/:2:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"3.分析工程结构 This is a tip\r分析工程结构，需要：使用Vue3搭建好后最原始的初始化工程 关闭框架自动的校验提示，同样使用Vue2中根目录下的vue.config.js文件。拷贝放入根目录即可。 入口文件main.js 首先分析入口文件，文件路径为工程项目包/src/main.js //引入的不再是Vue构造函数了，引入的是一个名为createApp的工厂函数 //Vue构造函数：需要使用new关键字进行引用 //工厂函数：不需要使用new关键字，可以直接调用，如：createApp() import {createApp } from 'vue' import App from './App.vue‘ createApp(App).mount('#app') 我们对这一句代码createApp(App).mount('#app')，进行拆解分析： //创建应用实例对象，类似于vm，但app比vm更\"轻\"，没有那么多的属性和方法 const app = createApp(App) app.mount('#app') //挂载mount。 //对应挂载mount，有unmount卸载. //使用定时器，1秒钟后卸载app组件，整体页面消失 setTimeout(()=\u003e{ app.unmount('#app') },1000) 对比vue2中写法，可以发现结构其实是相似的： import {Vue } from 'vue' const vm = new Vue({ render:h=\u003eh(App) }) vm.$mount('#app') 特别注意\r在Vue3的项目入口文件中使用Vue2中的写法是不可以的。我们可以清晰的看见报错信息： 翻译过来为：不存在的对象，不能进行实例化。 我们打印Vue实例对象，我们发现并没有成功引入进来。 所以使用new实例化对象的Vue2写法在Vue3项目中并不可行。 领头组件App.vue \u003ctemplate\u003e \u003c!--Vue3组件中的模板结构，可以不使用div根标签包裹，如果写，也不会报错--\u003e \u003cimg alt=\"Vue logo\" src=\"./assets/logo.png\"\u003e \u003cHelloWorld msg=\"Welcome to Your Vue.js App\"/\u003e \u003c/template\u003e \u003cscript\u003e \u003c!--正常引入组件--\u003e import HelloWorld from './components/HelloWorld.vue' export default { name: 'App', components:{HelloWorld} } \u003c/script\u003e \u003c!--组件样式--\u003e \u003cstyle\u003e ..... \u003c/style\u003e ","date":"2024-11-14","objectID":"/vue3/:2:3","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"4.安装开发者工具 Vue2篇幅中，安装在浏览器里的Vue开发者工具是不支持Vue3的。 由此，我们需要安装Vue3专用的开发者工具。 同样，也有两种安装方式： **在线安装：**直接在chrome网上应用商店，搜索vue，选择图标带脚标的，进行添加安装 **离线安装：**Vue开发者工具安装包，拖入拓展程序页面，点击添加，添加后启用。 如果扩展程序同时添加了Vue2以及Vue3的开发者工具，则需要禁用一个，启用一个。 ","date":"2024-11-14","objectID":"/vue3/:2:4","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"二、常用 Composition API Composition API 我们也称组合式API 官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html ","date":"2024-11-14","objectID":"/vue3/:3:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.setup配置项 理解：Vue3.0中一个新的配置项，值为一个函数。 setup(){ //数据 //方法 //计算属性，监视属性 //生命周期等钩子函数 } 组件中所用到的：数据、方法等等，均要配置在setup中。 setup函数的两种返回值: 1.若返回一个对象，则对象中的属性、方法,在模板中均可以直接使用。 2.若返回一个渲染函数：则可以自定义渲染内容。 简单示例： \u003ctemplate\u003e \u003ch1\u003eHello Vue3\u003c/h1\u003e \u003c!--直接使用setup的返回中暴露的数据和方法--\u003e \u003ch2\u003e姓名：{{name}}\u003c/h2\u003e \u003ch2\u003e年龄：{{age}}\u003c/h2\u003e \u003cbutton @click=\"sayHello\"\u003e说你好\u003c/button\u003e \u003c/template\u003e \u003c!--返回一个对象--\u003e \u003cscript\u003e export default { name:'App', //此处简单示例只用于测试setup工作，暂不考虑处理响应式 setup(){ //数据 let name = '张三' //不用const说明，以后这些数据有可能发生变化 let age = 18 //方法 function sayHello(){ alert(`我叫${name},我${age}岁了，你好！`) //使用``模版字符串 } //setup返回一个对象，将所有数据和方法暴露出去 return { name, //当key-value形式，写为 name:name时，可以触发简写形式name age, sayHello } } } \u003c/script\u003e \u003ctemplate\u003e \u003c!--不论此模版处写什么，都不进行编译，只读取返回的渲染函数中的内容--\u003e \u003ch1\u003eHello Vue3\u003c/h1\u003e \u003c/template\u003e \u003c!--返回一个渲染函数--\u003e \u003cscript\u003e //手动引用h函数 import {h} from 'vue' export default { name:'App', setup(){ //数据 let name = '张三' let age = 18 //方法 function sayHello(){ alert(`我叫${name},我${age}岁了，你好！`) } //setup返回一个渲染函数【这种写法不常用，但可做了解】 //在Vue2中，有个render配置项 //只要写render，Vue就帮你传入一个h，并调用，这个h就是渲染函数 //Vue3中，需要手动引入这个h函数，才能调用 //调用方式和Vue2中一样，传入两个参数:h('想要放入页面的元素','该元素对应的文字') //例如：h('h1','你好') //将h函数的调用返回值暴露返回给setup的return。return h('h1','你好') //即整体写做 return ()=\u003e{return h('h1','你好')} //简写为 return ()=\u003e h('h1','你好') return ()=\u003e h('h1','你好') } } \u003c/script\u003e Vue3是可以向下兼容Vue2写法的，他们可以同时存在和使用，例如： \u003ctemplate\u003e \u003c!--Vue3所配置的数据及方法--\u003e \u003ch2\u003e姓名：{{name}}\u003c/h2\u003e \u003cbutton @click=\"sayHello\"\u003e说你好\u003c/button\u003e \u003c!--Vue2所配置的数据及方法--\u003e \u003ch2\u003e姓名：{{age}}\u003c/h2\u003e \u003cbutton @click=\"sayAge\"\u003e说你好\u003c/button\u003e \u003c/template\u003e \u003c!--返回一个对象--\u003e \u003cscript\u003e export default { name:'App', //-----------Vue2语法------------ data(){ return {sex:'男'} }, methods：{ sayAge(){ alert(`22222222`) } }, //-----------Vue3语法------------ setup(){ let name = '张三' function sayHello(){ alert(`11111111`) } return { name,sayHello } } } \u003c/script\u003e 注意点: 尽量不要与Vue2.x配置混用 Vue2.x配置(data、methos、computed..)中可以访问到setup中的属性、方法。 \u003c!--Vue2中访问Vue3的setup配置中的数据、方法：均能访问成功--\u003e \u003cscript\u003e export default { name:'App', data(){ return {sex:'男'} }, methods：{ test(){ console.log(this.sex) //男 console.log(this.name) //张三 console.log(this.sayHello) //function(..) } }, //-----------Vue3语法------------ setup(){ let name = '张三' function sayHello(){ alert(`11111111`) } return { name,sayHello } } } \u003c/script\u003e 但在setup中不能访问到Vue2.x配置(data、methos、computed…)。 \u003c!--Vue3的setup配置中访问Vue2的数据、方法：均不能访问成功--\u003e \u003cscript\u003e export default { name:'App', data(){ return {sex:'男'} }, methods：{ sayAge(){ alert(`22222222`) } }, setup(){ let name = '张三' function sayHello(){ alert(`11111111`) } function test(){ console.log(this.sex) //undefined console.log(this.sayAge) //undefined console.log(name) //张三 console.log(sayHello) //function(..) } return { name,sayHello,test } } } \u003c/script\u003e 如果有重名，setup优先。 \u003ctemplate\u003e \u003ch2\u003e{{a}}\u003c/h2\u003e\u003c!--编译a的值，显示为：200--\u003e \u003c/template\u003e \u003cscript\u003e export default { name:'App', //-----------Vue2语法------------ data(){ return {a:100} }, //-----------Vue3语法------------ setup(){ let a = 200 return { a } } } \u003c/script\u003e setup不能是一个async函数（不可写做async setup(){}）。 凡是async修饰的函数，返回值不再是return的对象，而是promise包裹了一层的对象，会导致Vue模板看不到return对象中的属性。 在写function为同异步调用的时候特别注意！！这里不能使用！！会导致模版编译不可用！！ ","date":"2024-11-14","objectID":"/vue3/:3:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.ref函数 作用：定义一个响应式的数据 接收的数据可以是：基本类型、也可以是对象类型。 基本类型的数据：响应式依然是靠 0bject.defineProperty()的 get 与 set 完成的。 对象类型的数据：响应式内部“求助”了Vue3.0中的一个新函数-reactive函数【后面阐述】 Vue2中ref是一个标签属性，写做\u003cinput ref=\"qwq' ...\u003e，用于标识组件或者标签。 Vue3中ref也可以作为标签属性，但他还有一个用法，就是作为ref函数： 看一个现象： 正常声明数据变量，并在方法中修改，变量被修改成功，但页面并不渲染。 \u003ctemplate\u003e \u003ch1\u003e一个人的信息\u003c/h1\u003e \u003ch2\u003e姓名:{{name}}\u003c/h2\u003e \u003ch2\u003e年龄:{{age}}\u003c/h2\u003e \u003cbutton @click=\"changeInfo\"\u003e修改人的信息\u003c/button\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'App', setup(){ let name = '张三' let age = 18 //方法 function changeInfo(){ name ='李四' age = 48 console.log(name,age) } return { name, age, changeInfo } } \u003c/script\u003e ref函数-基本类型数据申明 我们用ref函数包裹申明，并且打印申明的数据： import {ref} from 'vue' .... setup(){ let name = ref('张三') let age = ref(18) //方法 function changeInfo(){ console.log(name) console.log(18) } .... 根据打印结果，很明显的，所有的数据都申明成了一个RefImpl对象。 数据内容都是对RefImpl的实例化。 我们拆分RefImpl单词，分别为reference引用， implement实现。所以对其申明的对象（{}中的内容），我们称之为：引用实现对象。 全称：引用实现的实例对象。 也简称：引用对象。 对于基本数据类型，如果在Vue3中想要实现响应式，则需要将数据丢给ref函数进行处理，形成引用对象。 在Vue3中，基本数据类型通过ref实现响应式，和Vue2中一样，也是通过0bject.defineProperty()实现getter、setter的方式。 且getter、setter其不在实例对象本体RefImpl上，而在原型对象__proto__上。找不到默认往原型上找，可以成功找到。使用数据的时候，可以通过.value的方式进行访问，修改时，也可以通过setter进行页面的重新渲染，且保证了实例对象的属性精简。 上述例子，修改数据的完整写法： \u003ctemplate\u003e \u003ch1\u003e一个人的信息\u003c/h1\u003e \u003ch2\u003e姓名:{{name}}\u003c/h2\u003e \u003ch2\u003e年龄:{{age}}\u003c/h2\u003e \u003cbutton @click=\"changeInfo\"\u003e修改人的信息\u003c/button\u003e \u003c/template\u003e \u003cscript\u003e import {ref} from 'vue' export default { name: 'App', setup(){ let name = ref('张三') let age = ref(18) //方法 function changeInfo(){ name.value ='李四' age.value = 48 console.log(name,age) } return { name, age, changeInfo } } \u003c/script\u003e 这里注意：\r只有在setup访问中，遵循ES6语法时，访问数据才使用.value的形式。 在模版解析的时候：不能写成name.value。 \u003c!--模版中，正常使用插值语法--\u003e \u003ctemplate\u003e \u003ch2\u003e姓名:{{name}}\u003c/h2\u003e \u003ch2\u003e年龄:{{age}}\u003c/h2\u003e \u003c/template\u003e 在Vue3中，解析模版时，当其发现引用数据为RefImpl的实例对象，则会自动帮我们访问数据对象的.value属性。 如果再手动加.value，就会识别成name.value.value导致也能渲染失败 ref函数-对象类型数据申明 注意申明结构： let person = ref({ name : '张三', age : 18 }) 打印person.value结果 这里能看到，对象类型的数据实现响应式，不再同Vue2一样。而是使用的Proxy对象。【后面会详细阐述】 访问每个属性则使用：person.value.type 修改对象类型数据的完整写法： \u003ctemplate\u003e \u003ch1\u003e一个人的信息\u003c/h1\u003e \u003ch2\u003e姓名:{{person.type}}\u003c/h2\u003e \u003ch2\u003e年龄:{{person.salary}}\u003c/h2\u003e \u003cbutton @click=\"changeInfo\"\u003e修改人的信息\u003c/button\u003e \u003c/template\u003e \u003cscript\u003e import {ref} from 'vue' export default { name: 'App', setup(){ let person = ref({ type : '前端工程师', salary : 30k }) //方法 function changeInfo(){ person.value.type = 'UI设计师' person.value.salary = '40k' } return { person, changeInfo } } \u003c/script\u003e ","date":"2024-11-14","objectID":"/vue3/:3:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"3.reactive函数 作用：定义一个对象类型的响应式数据 与ref基本和对象类型的都可以申明不同，reactive只能申明对象类型的。用reactive申明基本数据类型let number = reactive(666)，控制台报错： 申明对象类型的，则控制台打印： 语法：const 代理对象 = reactive(源对象) 接收一个对象(或数组)，返回一个代理对象(proxy的实例对象，简称proxy对象) //申明对象 let job = reactive({ d:111, a:{ b:{ c: 666 } } }) reactive定义的响应式数据是“深层次的”。 //修改对象 job.a.b.c = 999 //申明数组 let hobby = reactive(['111','222','333']) //修改数组 hobby[0] = '000' 内部基于 ES6 的 Proxy 实现，通过 代理对象 操作 源对象 内部数据进行操作。 ​ ","date":"2024-11-14","objectID":"/vue3/:3:3","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"4.Vue3.0中的响应式原理 vue2.x的响应式 实现原理: 对象类型:通过 Object.defineProperty()对对象的的读取、修改进行拦截(数据劫持)。 数组类型:通过重写更新数组的一系列方法来实现拦截。(对数组的变更方法进行了包裹) Object.defineProperty(data,'count',{ get(){}， set(){} }) 存在问题： 新增属性、删除属性，界面不会更新。（原因是：defineProperty只检测查改，检测不到增删。检测查改利用的get和set，没有检测增删的手段和方法） \u003ctemplate\u003e \u003cdiv\u003e \u003c!--person身上追加一个性别属性，删除原有的name属性--\u003e \u003ch1 v-show=\"person.name\"\u003e姓名：{{person.name}}\u003c/h1\u003e \u003ch1\u003e年龄：{{person.age}}\u003c/h1\u003e \u003ch1 v-show=\"person.sex\"\u003e性别：{{person.sex}}\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'App', data(){ return { person:{ name:'张三'， age: 18 } } }, methods:{ addSex(){ this.person.sex = '女' //person中数据改了，但是页面不更新 //解决办法 this.$set(this.person,'sex','女') //或者 import Vue from 'vue' Vue.set(this.person,'sex','女') }, deleteName(){ delete this.person.name //person中数据改了，但是页面不更新 //解决办法 this.$delete(this.person,'name') //或者 import Vue from 'vue' Vue.delete(this.person,'name') } } } \u003c/script\u003e 直接通过下标修改数组,界面不会自动更新。 \u003ctemplate\u003e \u003cdiv\u003e \u003c!-- --\u003e \u003ch1\u003e爱好：{{person.hobby}}\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'App', data(){ return { person:{ hobby:['学习','吃饭','睡觉'] } } }, methods:{ updateHobby(){ this.person.hobby[0] = '逛街' //person中数据改了，但是页面不更新 //解决办法 this.$set(this.person.hobby,0,'逛街') //或者 this.person.hobby.splice(0,1,'逛街') } } } \u003c/script\u003e ​ vue3.0的响应式 vue2.x的响应式模拟 新建一个.html文件，我们在其中模拟vue2.x实现响应式原理的关键代码 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e //源数据 let person = { name:'张三'， age:18 } //模拟Vue2中实现响应式 let p = {} //新建一个代理对象 Object.defineProperty(p,'name',{ //(操作对象,'对象中要操作的属性',{get\\set方法}) configurable:true,//允许删除 get(){ //有人读取person中的name时调用 return person.name }, set(value){ //有人修改person中name时调用 console.log('有人修改了name属性，我发现了，我要去更新界面！') person.name = value } }) //age同理---------------- Object.defineProperty(p,'age',{ get(){ //有人读取person中的age时调用 return person.age }, set(value){ //有人修改person中age时调用 console.log('有人修改了age属性，我发现了，我要去更新界面！') person.age = value } }) //.... //有多少个属性就要写多少个Object.defineProperty()---------------- \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 测试一下响应式的效果 ​ vue3.0的响应式模拟 想研究Vue3中的响应式，需要认识window上的window.Proxy这个函数。 他是window身上的一个内置的构造函数（不用下载安装，不用引入，直接就可以通过window使用） 这个Proxy我们在之前配置脚手架的代理的时候也用过，当时用作解决ajax跨域的问题。其实，不管在哪里，他都是代理的意思。 他的作用，就是使用p去映射对person的操作。和defineProperty弄出来一个p去匹配get、set；一操作p，就使person发生变化，并且能检测到，是一个道理。 下面是他的使用语法： 同样是新建一个.html文件，我们在其中模拟vue3.0实现响应式原理的关键代码 \u003c!--只是模拟关键代码，阐述原理，vue3底层并不是真正的这样去直接操作源数据--\u003e \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e //源数据 let person = { name:'张三'， age:18 } //模拟Vue3中实现响应式 //(要代理的对象，{代理使用的CRUD方法}) //const p = new Proxy(person,{}) //{}里可以空着，但是{}必须写 const p = new Proxy(person,{ get(target, propName){ console.log('有人读取了p身上的${propName}属性，我发现了，我要去更新界面！') return target[propName] }, set(target, propName, value){ console.log('有人修改了p身上的${propName}属性，我发现了，我要去更新界面！') target[propName] = value }， // 拦截删除属性 deleteProperty(target,propName){ console.log('有人删除了p身上的${propName}属性，我发现了，我要去更新界面！') return delete target[propName] } }) //不管多少个属性，写一个Proxy就可以了---------------- \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 测试一下响应式的效果 vue3.0的响应式真实原理 Vue3中响应式的实现原理\rnew Proxy(data,{ // 拦截读取属性值 get(target, propName){ return Reflect.get(target,propName) }, // 拦截设置属性值或添加新属性 set(target, propName, value){ return Reflect.set(target,propName,value) }， // 拦截删除属性 deleteProperty(target,propName){ return Reflect.deleteProperty(target,propName) } }) 实现原理: 通过Proxy(代理)：拦截对象中任意属性的变化，包括:属性值的读写、属性的添加、属性的删除等。 通过Reflect(反射)：对被代理对象的属性进行操作。 MDN文档中描述的Proxy与Reflect： Proxy: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy Reflect: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect let obj = {a:1,b:2} 读取一个对象obj身上的属性： //方式一 obj.a //1 //方式二 //window.Reflect 反射 Reflect.get(obj,'a') //1 控制台效果： 修改一个对象obj身上的属性： //方式一 obj.a = 100 //a=100 //方式二 Reflect.set(obj,'a',666) //a=666 控制台效果： 删除一个对象obj身上的属性： Reflect.deleteProperty(obj,'a') //true ","date":"2024-11-14","objectID":"/vue3/:3:4","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"5.reactive对比ref 从定义数据角度对比： ref用来定义：基本类型数据。 reactive用来定义：对象(或数组)类型数据 备注：ref也可以用来定义对象(或数组)类型数据，它内部会自动通过 reactive 转为代理对象。 从原理角度对比： ref通过 Object.defineProperty()的get 与 set 来实现响应式**(数据劫持)**。 reactive通过使用Proxy来实现响应式(数据劫持),并通过Reflect操作源对象内部的数据。 从使用角度对比： ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。 reactive定义的数据：操作数据与读取数据：均不需要.value。 ​ ","date":"2024-11-14","objectID":"/vue3/:3:5","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"6.setup的两个注意点 setup执行的时机 在beforeCreate之前执行一次，this是undefined。 setup的参数 props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。 context：上下文对象 attrs：值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性，相当于this.$attrs slots: 收到的插槽内容，相当于this.$slots emit: 分发自定义事件的函数，相当于this.$emit 。 Vue2中父子组件传值方式\rprops接受传参 \u003cDemo msg='111' school='222'\u003e \u003c!--父组件中传值--\u003e \u003cscript\u003e...,props:['msg','school'] //子组件中接受 \u003c/script\u003e \u003ch3\u003e{{msg}}\u003c/h3\u003e \u003c!--子组件中使用--\u003e \u003ch3\u003e{{school}}\u003c/h3\u003e \u003c!--子组件中使用--\u003e $attrs存储传参 \u003cDemo msg='111' school='222'\u003e \u003c!--父组件中传值--\u003e \u003cscript\u003e...,props:[] //子组件中不接受 \u003c/script\u003e \u003ch3\u003e{{$attrs.msg}}\u003c/h3\u003e \u003c!--子组件中使用--\u003e \u003ch3\u003e{{$attrs.school}}\u003c/h3\u003e \u003c!--子组件中使用--\u003e 这里注意一个现象： 同样的，$slots中也能够存储插槽的虚拟节点信息。如： \u003cDemo\u003e \u003cspan\u003e1111\u003c/span\u003e \u003cspan\u003e2222\u003c/span\u003e \u003c/Demo\u003e \u003c!--父组件中传值--\u003e \u003cdiv class=\"demo\"\u003e \u003ch3\u003e我是Demo组件\u003c/h3\u003e \u003cslot\u003e\u003c/slot\u003e\u003c!--子组件中不管使不使用，$slots中均有内容--\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/div\u003e Vue3中父子组件传值方式\rsetup在beforeCreate之前执行，且setup内的this是undefined。 \u003cscript\u003e export default { name: 'Demo', beforeCreate(){ console.log('---beforeCreate---') }， setup(){ console.log('---setup---',this) } } \u003c/script\u003e 控制台效果： setup中的props参数接受传参 \u003cDemo msg='111' school='222'\u003e \u003c!--父组件中传值--\u003e \u003cscript\u003e\u003c!--子组件中接收--\u003e export default { name: 'Demo', setup(props){ console.log('---setup---',props) } } \u003c/script\u003e 控制台效果： ​ 说明Vue3中不能只申明不接收就在setup中使用！ \u003cscript\u003e\u003c!--子组件中接收--\u003e export default { name: 'Demo', props:['msg','school'],//*******所有传入参数，必须全部申明********* setup(props){ console.log('---setup---',props) } } \u003c/script\u003e setup中的context参数 \u003cscript\u003e\u003c!--子组件中接收--\u003e export default { name: 'Demo', setup(context){ console.log('---setup---',context) } } \u003c/script\u003e 控制台效果： 这个里面配置项的效果，与Vue2中对应的配置项，的效果一致。 注意！emits要用的时候，必须都先申明： \u003cscript\u003e\u003c!--子组件中接收--\u003e export default { name: 'Demo', props:['msg','school'],//*******申明props********* emits:['hello'],//*******申明emits********* setup(props,context){ console.log('---setup---',context.attrs)//相当于Vue2中的$attrs console.log('---setup---',context.emit)//触发自定义事件 console.log('---setup---',context.slots)//插槽 } } \u003c/script\u003e 注意：Vue3中有API兼容的问题，推荐使用插槽的时候使用v-slot:名字的方式 \u003c!--父组件中传值--\u003e \u003ctemplate v-slot:qwe\u003e \u003cspan\u003e11111\u003c/span\u003e \u003c/template\u003e ","date":"2024-11-14","objectID":"/vue3/:3:6","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"7.计算属性与监视 1.computed函数 与Vue2.x中computed配置功能一致 写法 import {computed} from 'vue' setup(){ ... //计算属性一简写 let fullName = computed(()=\u003e{ return person.firstName + '-' + person.lastName }) //计算属性-完整 let fullName = computed({ get(){ return person.firstName +'-'+ person.lastName }, set(value){ const nameArr =value.split('_') person.firstName =nameArr[0] person.lastName =nameArr[1] } }) } 2.watch函数 与Vue2.x中watch配置功能一致 两个小\"坑\"： 监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视(deep配置失效)。 监视reactive定义的响应式数据中某个属性时：deep配置有效。 //情况一:监视ref定义的响应式数据 watch(sum,(newValue,oldValue)=\u003e{ console.log('sum变化了',newValue,oldValue) },{immediate:true}) //情况二:监视多个ref定义的响应式数据 watch([sum,msg],(newValue,oldValue)=\u003e{ console.log('sum或msg变化了',newValue,oldValue) }) /*情况三:监视reactive定义的响应式数据 若watch监视的是reactive定义的响应式数据，则无法正确获得oldvalue!! 若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */ watch(person,(newValue,oldValue)=\u003e{ console.log('person变化了',newValue,oldValue) },{immediate:true,deep:false})//此处的deep配置不再奏效 //情况四:监视reactive定义的响应式数据中的某个属性 watch(()=\u003eperson.job,(newValue,oldValue)=\u003e{ console.log('person的job变化了',newValue,oldValue) },{immediate:true,deep:true}) //情况五:监视reactive所定义的一个响应式数据中的某些属性 watch([()=\u003eperson.name,()=\u003eperson.age],(newValue,oldValue)=\u003e{ console.log('person的name或age变化了',newValue,oldValue) }) //特殊情况 watch(()=\u003eperson.job,(newValue,oldValue)=\u003e{ console.log('person的job变化了',newValue,oldValue) },{deep:true})//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效 3.watchEffect函数 watch的套路是：既要指明监视的属性，也要指明监视的回调。 watchEfect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。 watchEffect有点像computed： 但computed注重的计算出来的值(回调函数的返回值)，所以必须要写返回值 而watchEffect更注重的是过程(回调函数的函数体)，所以不用写返回值。 //watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。 watchEffect(()=\u003e{ const x1= sum.value const x2=person.age console.log('watchEffect配置的回调执行了') }) ","date":"2024-11-14","objectID":"/vue3/:3:7","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"8.生命周期 待完善 ","date":"2024-11-14","objectID":"/vue3/:3:8","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"9.自定义hook函数 什么是hook?——本质是一个函数，把setup函数中使用的Composition API进行了封装。 类似于vue2.x中的mixin。 自定义hook的优势：复用代码，让setup中的逻辑更清楚易懂。 ","date":"2024-11-14","objectID":"/vue3/:3:9","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"10.toRefs 作用：创建一个 ref对象，其value值指向另一个对象中的某个属性值。 语法：const name =toRef(person,'name') 应用：要将响应式对象中的某个属性单独提供给外部使用时。 扩展：toRefs与toRef功能一致，但可以批量创建多个ref 对象，语法：toRefs(person) ","date":"2024-11-14","objectID":"/vue3/:3:10","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"三、其它 Composition API ","date":"2024-11-14","objectID":"/vue3/:4:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.shallowReactive 与 shallowRef shallowReactive：只处理对象最外层属性的响应式(浅响应式)。 shallowRef：只处理基本数据类型的响应式，不进行对象的响应式处理。 什么时候使用? 如果有一个对象数据，结构比较深，但变化时只是外层属性变化 ===\u003e shallowReactive。 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===\u003e shallowRef。 ","date":"2024-11-14","objectID":"/vue3/:4:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.readonly 与 shallowReadonly readonly：让一个响应式数据变为只读的(深只读)。 shallowReadonly：让一个响应式数据变为只读的(浅只读)。 应用场景：不希望数据被修改时。 ","date":"2024-11-14","objectID":"/vue3/:4:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"3.toRaw 与 markRaw toRaw： 作用：将一个由reactive 生成的响应式对象转为普通对象。 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。 markRaw： 作用：标记一个对象，使其永远不会再成为响应式对象。 应用场景： 有些值不应被设置为响应式的，例如复杂的第三方类库等。 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。 ","date":"2024-11-14","objectID":"/vue3/:4:3","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"4.customRef 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。 实现防抖效果： \u003ctemplate\u003e \u003cinput type=\"text\" v-model=\"keyword\"\u003e \u003ch3\u003e{{keyword}}\u003c/h3\u003e \u003c/template\u003e \u003cscript\u003e import {ref,customRef} from 'vue' export default{ name:'Demo', setup(){\\ //let keyword = ref('hello') //使用Vue准备好的内置ref //自定义一个myRef function myRef(value,delay){ let timer //通过customRef去实现自定义 return customRef((track,trigger)=\u003e{ return{ get(){ track()//告诉Vue这个value值是需要被“追踪”的 return value }, set(newValue){ clearTimeout(timer) timer = setTimeout(()=\u003e{ value = newValue trigger()//告诉Vue去更新界面 },delay) } } }) } // let keyWord =ref('hello') //使用Vue提供的ref let keyWord = myRef('hello',500)//使用程序员自定义的ref return {keyWord} } \u003c/script\u003e ","date":"2024-11-14","objectID":"/vue3/:4:4","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"5.provide 与 inject 作用：实现祖孙组件间通信 套路：父组件有一个 provide 选项来提供数据，子组件有一个 inject 选项来开始使用这些数据 具体写法： 祖组件中: setup(){ ... let car =reactive({name:'奔驰',price:'40万'}) provide('car',car) ... } 孙组件中: setup(props,context){ ... const car=inject('car') return {car} ... } ","date":"2024-11-14","objectID":"/vue3/:4:5","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"6.响应式数据的判断 isRef：检查一个值是否为一个 ref 对象 isReactive：检查一个对象是否是由 reactive 创建的响应式代理 isReadonly：检査一个对象是否是由 readonly 创建的只读代理 isProxy：检査一个对象是否是由 reactive 或者 readonly 方法创建的代理 ","date":"2024-11-14","objectID":"/vue3/:4:6","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"四、Composition API 的优势 ","date":"2024-11-14","objectID":"/vue3/:5:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.Options API 存在的问题 使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改。 ","date":"2024-11-14","objectID":"/vue3/:5:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.Composition APl 的优势 我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。 ","date":"2024-11-14","objectID":"/vue3/:5:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"五、新的组件 ","date":"2024-11-14","objectID":"/vue3/:6:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.Fragment 在Vue2中：组件必须有一个根标签 在Vue3中：组件可以没有根标签，内部会将多个标签包含在一个Fragment虚拟元素中 好处：减少标签层级，减小内存占用 ","date":"2024-11-14","objectID":"/vue3/:6:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.Teleport 什么是Teleport? —— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。 \u003cteleport to=\"移动位置\"\u003e \u003cdiv v-if=\"isShow\" class=\"mask\"\u003e \u003cdiv class=\"dialog\"\u003e \u003ch3\u003e我是一个弹窗\u003c/h3\u003e \u003cbutton @click=\"isShow = false\"\u003e关闭弹窗\u003c/button\u003e \u003c/div\u003e \u003c/div\u003e \u003c/teleport\u003e ","date":"2024-11-14","objectID":"/vue3/:6:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"3.Suspense 等待异步组件时渲染一些额外内容，让应用有更好的用户体验 使用步骤： 异步引入组件 import {defineAsyncComponent} from 'vue' const Child = defineAsyncComponent(()=\u003eimport('./components/Child.vue')) 使用 Suspense包裹组件，并配置好 default 与 fallback \u003ctemplate\u003e \u003cdiv class=\"app\"\u003e \u003ch3\u003e我是App组件\u003c/h3\u003e \u003cSuspense\u003e \u003ctemplate v-slot:default\u003e \u003cChild/\u003e \u003c/template\u003e \u003ctemplate v-slot:fallback\u003e \u003ch3\u003e加载中.....\u003c/h3\u003e \u003c/template\u003e \u003c/Suspense\u003e \u003c/div\u003e \u003c/template\u003e ","date":"2024-11-14","objectID":"/vue3/:6:3","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"六、其他 ","date":"2024-11-14","objectID":"/vue3/:7:0","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"1.全局API的转移 Vue 2.x有许多全局 API和配置。 例如：注册全局组件、注册全局指令等 //注册全局组件 Vue.component('MyButton',{ data:()=\u003e({ count:0 }), template:'\u003cbutton @click=\"count++\"\u003eClicked {{ count }} times.\u003c/button\u003e' //注册全局指令 Vue.directive('focus',{ inserted:el =\u003eel.focus() } Vue3.0中对这些API做出了调整： 将全局的API，即:Vue.xxx调整到应用实例(app)上 ","date":"2024-11-14","objectID":"/vue3/:7:1","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["前端"],"content":"2.其他改变 data选项应始终被声明为一个函数。 过度类名的更改: Vue2.x写法 .enter, .v-leave-to{ opacity:0; } .v-leave, .v-enter-to{ opacity: 1; } Vue3.x写法 .v-enter-from, .v-leave-to{ opacity: 0; } .v-leave-from, .v-enter-to{ opacity: 1; } 移除 keyCode作为 v-on 的修饰符，同时也不再支持 config.keyCodes 移除 v-on.native 修饰符 父组件中绑定事件 \u003cmy-component v-on:close=\"handleComponentEvent\" v-on:click=\"handleNativeclickEvent\" /\u003e 子组件中声明自定义事件 \u003cscript\u003e export default { emits:['close'] } \u003c/script\u003e 移除过滤器(filter) 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是“只是 JavaScript\" 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。 ","date":"2024-11-14","objectID":"/vue3/:7:2","tags":["vue"],"title":"【Vue前端框架】Vue3.0全套教程","uri":"/vue3/"},{"categories":["Office基本操作"],"content":"带路径的文件名称 待提取的文件夹下新建txt文件，拷贝下面这段代码 @echo off dir /s/b *.* \u003e文件名.txt exit 保存这个txt文件，然后将txt文件的后缀修改为bat。 双击这个bat文件，此时文件夹中会多出来一个txt文件，此txt文件就是提取的文件夹路径和文件名称了。 ","date":"2024-11-11","objectID":"/text36/:1:0","tags":["bat","excel"],"title":"【bat批处理】提取多文件夹下的文件名称","uri":"/text36/"},{"categories":["Office基本操作"],"content":"带结构的文件名称 待提取的文件夹下新建txt文件，拷贝下面这段代码 @ECHO OFF tree /F \u003e 文件名列表.txt 保存这个txt文件，然后将txt文件的后缀修改为bat。 双击这个bat文件，此时文件夹中会多出来一个txt文件，此txt文件就是提取的文件夹路径和文件名称了。 ","date":"2024-11-11","objectID":"/text36/:2:0","tags":["bat","excel"],"title":"【bat批处理】提取多文件夹下的文件名称","uri":"/text36/"},{"categories":["Office基本操作"],"content":"excel处理文件名称 选择文件路径内容所在列，选择导航栏：数据 - 分列 默认选择[分隔符]号，点击下一步。 选择其他并输入符号“\\”，点击下一步。 点击完成。 ","date":"2024-11-11","objectID":"/text36/:3:0","tags":["bat","excel"],"title":"【bat批处理】提取多文件夹下的文件名称","uri":"/text36/"},{"categories":["Idea"],"content":"idea连接svn配置选项设置如下： ","date":"2024-11-11","objectID":"/text38/:0:0","tags":["idea"],"title":"【idea】IDEA现有项目连接SVN","uri":"/text38/"},{"categories":["前端"],"content":"闭包的概念 如果一个函数访问了此函数的父级及父级以上的作用域变量，那么这个函数就是一个闭包。 本质上，JS中的每个函数都是一个闭包，因为每个函数都可以访问[全局变量]。 ","date":"2024-11-11","objectID":"/text37/:0:1","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["前端"],"content":"闭包的用途 访问函数内部的变量 让变量始终保持在内存中 ","date":"2024-11-11","objectID":"/text37/:0:2","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["前端"],"content":"闭包的优点 可以减少全局变量的定义，避免全局变量的污染 能够读取函数内部的变量 在内存中维护一个变量，可以用做缓存 ","date":"2024-11-11","objectID":"/text37/:0:3","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["前端"],"content":"闭包的2种形成方式 1、函数作为参数被传递 // 将函数作为实参传递给另一个函数调用 function showDelay(msg,time){ //setTimeout 的第一个参数function是函数，符合闭包的规则 setTimeout(function(){ alert(msg) },time) } showDelay('张三',2000) 2、函数作为返回值被返回 function a() { var i = '初始值'; i = i + \"—_执行a\" // 此处的函数b访问了父级函数a中的局部变量i,成为了一个闭包 function b() { i = i + \"_执行b\" console.log(i) } return b; } var c = a(); // 此时 i 的值为 ：初始值—_执行a c() // 此时 i 的值为 ：初始值—_执行a_执行b c() // 此时 i 的值为 ：初始值—_执行a_执行b_执行b 将函数a赋值给全局变量c时，a会执行一次，局部变量 i 的值变为初始值—_执行a，最终返回函数b，此时全局变量c的值为闭包函数b的引用。 此时函数a虽然已执行完，但因为内部包含闭包函数b，所以函数 a 的执行期上下文会继续保留在内存中，不会被销毁，所以局部变量 i 仍是初始值—_执行a This is a tip\r执行期上下文：当函数执行时，会创建一个执行期上下文的内部对象。每调用一次函数，就会创建一个新的上下文对象，他们之间是相互独立的。当函数执行完毕，它所产生的执行期上下文会被销毁\r第一次执行 c() 时，闭包函数b第一次执行，局部变量 i 的值变为初始值—_执行a_执行b 第二次执行 c() 时，闭包函数b第二次执行，局部变量 i 的值变为初始值—_执行a_执行b_执行b ","date":"2024-11-11","objectID":"/text37/:0:4","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["前端"],"content":"闭包的特点 被闭包函数访问的父级及以上的函数的局部变量（如范例中的局部变量 i ）会一直存在于内存中，不会被JS的垃圾回收机制回收。 闭包函数实现了对其他函数内部变量的访问。（函数内部的变量对外是无法访问的，闭包通过这种变通的方法，实现了访问。） This is a tip\rJavascript的垃圾回收机制： 如果一个对象不再被引用，那么这个对象就会被GC回收。 如果两个对象互相引用，而不再被第三者所引用，那么这两个对象都会被回收。 ","date":"2024-11-11","objectID":"/text37/:0:5","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["前端"],"content":"闭包的应用场景 模拟两人对话、使setTimeout支持传参、封装私有变量、模拟块作用域、实现迭代器 ","date":"2024-11-11","objectID":"/text37/:0:6","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["前端"],"content":"闭包的缺点 造成内存泄露 闭包会使函数中的变量一直保存在内存中，内存消耗很大，所以不能滥用闭包。 【内存泄露：无用的变量一直在内存中，无法被释放】 解决方法：使用完变量后，手动将它赋值为null； This is a tip\r闭包是内存泄漏吗? 闭包只是让变量在内存常驻，本身不是内存泄漏， 滥用闭包才会导致内存泄漏 闭包可能在父函数外部，改变父函数内部变量的值。 造成性能损失 由于闭包涉及跨作用域的访问，所以会导致性能损失。 解决方法：通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响 免责申明\r———————————————— 转载摘录，原文链接：https://blog.csdn.net/weixin_41192489/article/details/124312822 本文仅用于记录学习，不做商用，版权归属原作者，如涉侵权，请联系删除 ","date":"2024-11-11","objectID":"/text37/:0:7","tags":["JavaScript"],"title":"【JS】闭包","uri":"/text37/"},{"categories":["虚拟机"],"content":"新建一个虚拟机 1、打开虚拟机主页面，点击“创建新的虚拟机” 2、该页面建议选择”自定义“，并点击”下一步“ 3、这里选最大16.2.x，并点击“下一步” 4、选择“稍后安装操作系统”，并点击“下一步” 5、没有win11的名称，就选择win10 x64版本，并点击“下一步” 6、根据自己具体的情况，选择虚拟机存放的位置 7、修改虚拟机的名称，用于区别自己创建的其他虚拟机。并点击“下一步” 8、该页面，点击“下一步” 9、根据情况和需求，配置处理器数量。并点击“下一步” 10、根据情况和需求，配置内存大小。并点击“下一步” 11、选择“使用桥接网络”，并点击“下一步” 12、点击“下一步” 13、点击“下一步” 14、点击“下一步” 15、根据情况和需求，配置磁盘大小。并点击“下一步” 16、根据自己具体的情况，选择虚拟机存放的位置，并点击“下一步” 17、在浏览器使用搜索引擎（这里使用的是：百度搜索引擎），搜索Windows11。选择微软官网。 18、在官网找到“win11磁盘映像” 19、选择ISO版本，语言“简体中文”，点击64-bit Download 20、找到下载完成后保存的位置 21、继续回到虚拟机安装导向，点击自定义硬件 22、选择新CD/DVD，选择使用ISO映像文件，配置刚刚下载的文件的位置，点击“关闭”。 23、点击“完成” 24、点击“编辑虚拟机设置”，选择“选项”卡，选择“访问控制”，点击“加密” 25、根据自己的情况，设置加密密码，两次密码保持一致。并点击“加密” --随机生成密码 spoHLT2b 26、选择“硬件选项卡”，点击“添加，”选择“可信平台模块”，并点击完成 27、点击“开启此虚拟机”。 28、进入时，如卡住，按enter回车键，继续。ctrl+alt可以实现鼠标光标在虚拟机内外来回切换 29、出现“安装系统界面”，点击\"下一步\" 30、点击\"下一步\" 31、选择\"我没有产品密钥\" 32、选择\"win11专业版\"，并点击\"下一步\" 33、勾选\"我接受\"，并点击\"下一步\" 34、新建磁盘空间，点击\"新建\"，大小为1024的倍数。例如50G就是50*1024即可。点击\"应用\" 35、其余自动的硬盘分区，也应用，并点击\"下一步\" 39、点击\"安装\" 40、等待安装进度条 41、可以等待他自动重启，也可以点击\"立即重启\" 42、等待重启 43、安装准备界面，根据提示和导向，一路点\"是\" --pin 1437059026@qq.com 48、等待桌面加载 49、进入到win11系统桌面界面 ","date":"2024-11-06","objectID":"/text35/:0:1","tags":["VMware"],"title":"【VMware】VMware虚拟机安装Windows11系统教程","uri":"/text35/"},{"categories":["虚拟机"],"content":"设置虚拟机屏幕全屏 1、选择\"虚拟机\"，选择\"安装VMware Tools\" 2、右下角弹出窗，表示安装完成 3、进入资源管理器，选择\"此电脑\"，双击打开\"DVD驱动器\" 4、选择\"是\"，等待安装 5、弹出\"安装向导\"，点击\"下一步\" 6、继续点击\"下一步\" 7、点击\"安装\" 8、等待安装进度 9、安装完成后就自动适配了全屏，点击\"完成\" 10、弹出窗，选择\"是\" ","date":"2024-11-06","objectID":"/text35/:0:2","tags":["VMware"],"title":"【VMware】VMware虚拟机安装Windows11系统教程","uri":"/text35/"},{"categories":["虚拟机"],"content":"虚拟机内win11系统激活 打开个性化有下面这个标识，标识win11系统未激活 1、激活脚本拷贝进虚拟机 https://www.123pan.com/s/g520Vv-rgRid 2、连接上网络，双击激活脚本，选择\"是\" 3、根据该网址激活教程操作 https://massgrave.dev/ irm https://get.activated.win | iex ​ 到此，关闭所有黑窗口 6、桌面空白处，右键，选择\"个性化\"。若激活提示消失，说明激活成功。 ","date":"2024-11-06","objectID":"/text35/:0:3","tags":["VMware"],"title":"【VMware】VMware虚拟机安装Windows11系统教程","uri":"/text35/"},{"categories":["虚拟机"],"content":"操作习惯设置 1、个性化 - 主题 - 桌面图标设置 2、勾选\"计算机\"、“回收站”、“控制面板”，点击\"应用\" 3、系统 - 显示 - 缩放 ， 大小改为\"125%\" 4、虚拟机这个图标可以全屏，全屏后顶部同样点这个图标可以退出全屏 开机密码-- 1437059026 ","date":"2024-11-06","objectID":"/text35/:0:4","tags":["VMware"],"title":"【VMware】VMware虚拟机安装Windows11系统教程","uri":"/text35/"},{"categories":["虚拟机"],"content":"虚拟机下载资源 虚拟机安装包：https://www.123pan.com/s/g520Vv-Dg2id 最新系统镜像文件：https://www.123pan.com/s/g520Vv-KIWid 最新Win10Win11系统激活工具：https://www.123pan.com/s/g520Vv-rgRid 虚拟机安装 win11系统选择VMware-workstation-full-16.2.3-19376536.exe 1、双击安装程序 2、在该界面等待准备完成 3、准备完成出现安装导向，点击”下一步“ 4、点“接受”，继续“下一步” 5、安装位置，根据自己的情况来选择，并点击“下一步” 6、取消勾选这两个选项，并点击“下一步” 7、快捷方式根据自己情况勾选，并点击“下一步” 8、点击安装，等待安装 9、安装结束界面，点击“许可证” 10、把激活密钥，复制粘贴到许可证的位置 11、点击“输入” 12、最后点击“完成” 13、桌面上双击虚拟机图标进入虚拟机，检查是否安装成功 ","date":"2024-11-06","objectID":"/text34/:0:0","tags":["VMware"],"title":"【VMware】VMware虚拟机下载安装激活教程","uri":"/text34/"},{"categories":["Idea"],"content":"1. idea可以显示侧边文件的最后修改时间以及文件大小 具体如下图 ","date":"2024-11-04","objectID":"/text32/:0:1","tags":["Java"],"title":"【idea】IDEA显示侧边文件的最后修改时间以及文件大小","uri":"/text32/"},{"categories":["Idea"],"content":"2. 关闭或开启 在低版本的idea中 可以使用快捷键 Shift + alt + \\ 来进行开启或者关闭 在idea高版本中取消了快捷键，可以在setting中手动设置快捷键 或者在view - Appearance - Details in Tree View 通过勾选或者取消勾选来进行开启或关闭 ","date":"2024-11-04","objectID":"/text32/:0:2","tags":["Java"],"title":"【idea】IDEA显示侧边文件的最后修改时间以及文件大小","uri":"/text32/"},{"categories":["Java"],"content":"Java中正则的使用 ","date":"2024-11-04","objectID":"/regex/:0:0","tags":["JavaSE"],"title":"【Java】Java中正则的使用","uri":"/regex/"},{"categories":["Java"],"content":"正则简介 非常常见的问题： 如何判断字符串是否是有效的电话号码？例如：010-1234567，123ABC456，13510001000等 如何判断字符串是否是有效的电子邮件地址？例如：test@example.com，test#example等 如何判断字符串是否是有效的时间？例如：12:34，09:60，99:99等 如何通过程序判断，这种方法需要为每种用例创建规则，然后用代码实现，太过复杂；因此出现了正则表达式 正则表达式就是一个描述规则的字符串，所以，只需要编写正确的规则，我们就可以让正则表达式引擎去判断目标字符串是否符合规则； 正则适用于任何语言 正则表达式是用字符串描述的一个匹配规则，使用正则表达式可以快速判断给定的字符串是否符合匹配规则。Java标准库Java.util.regex内建了正则表达式引擎 ","date":"2024-11-04","objectID":"/regex/:1:0","tags":["JavaSE"],"title":"【Java】Java中正则的使用","uri":"/regex/"},{"categories":["Java"],"content":"匹配规则 基本的规则 .：匹配任意字符 \\d：匹配数字；\\D表示匹配非数字 \\w：匹配一个字母、数字或下划线，w的意思是word；\\W表示匹配非字母 \\s：匹配空格、tab键；S表示匹配非空格 [ABC]：匹配方括号中任意字符 [axA-F1-9]：匹配 a、x、A-F、1-9中的任意字符 AB|CD|EF：匹配 AB或CD或EF [\\u4e00-\\u9fa5]：匹配中文 [^A-F]：匹配不包含 A-F 的字符，^ 放在 [] 中表示不匹配 ^：匹配开头，放在 [] 中表示不匹配 $：匹配结尾 ^[0-9]\\*$：^ 表示以什么开头，$ 表示以什么结尾，这里正则代表匹配数字 匹配次数 {n}：匹配 n 次 {n,m}：匹配 n-m 次 {n,}：匹配最少n次，最大无上限 *：匹配任意次 +：匹配至少一次以上 注意：Java中字符的转义和正则表达式中的转义 //简单的正则匹配，注意转义字符的使用 boolean b1 = \"abc\".matches(\"abc\"); //true boolean b2=\"19882445846\".matches(\"1\\\\d{10}\"); //true boolean b3=\"lei@sdadsa.com\".matches(\"\\\\w{1,4}@\\\\w{5,6}\\\\.\\\\w{2,3}\"); //true boolean b4=\"A19a\".matches(\"[A19]{4}\"); //false，因为[]中没有字符 a boolean b5=\"045875641\".matches(\"[1-9]*\"); //false boolean b6=\"145875641\".matches(\"[1-9]*\"); //true ","date":"2024-11-04","objectID":"/regex/:2:0","tags":["JavaSE"],"title":"【Java】Java中正则的使用","uri":"/regex/"},{"categories":["Java"],"content":"分组匹配 使用(...)进行分组匹配 姓名：电话这个规则，匹配字符串后，分别取出姓名和电话，方便后续操作 分组匹配单次 /* * 注意： * m.matches() 判断的是匹配的整个字符串，匹配成功返回 true，失败返回 false * */ Pattern p = Pattern.compile(\"([\\\\u4e00-\\\\u9fa5]{2,3})-(1\\\\d{10})\"); Matcher m = p.matcher(\"张三-15196116945\"); int start=0; if (m.matches()){ m.group(0); //张三-15196116945 m.group(1); //张三 m.group(2) //15196116945 } 分组匹配多次 /* * 注意: * m.matches() 在这里会返回 false，因为 正则规则此时不能完全匹配字符串 * m.find(i) 带参数时，表示从字符串索引 i 后开始寻找匹配，不带参数表示从头开始 * m.end() 返回当前匹配字符串最后位置索引 * m.group() 表示当前已经匹配上的字符串，参数0 表示当前匹配的字符串全部，参数1 表示当前匹配的分组规则1的字符换 ...... * */ Pattern p = Pattern.compile(\"([\\\\u4e00-\\\\u9fa5]{2,3})-(1\\\\d{10})\"); Matcher m = p.matcher(\"张三-15196111945李四-19882415846\"); int start=0; while (m.find(start)){ System.out.println(m.group(0)+m.group(1)+\":\"+m.group(2)); m.group(1); m.group(2); start=m.end(); } 例子：获取2021-09-11 23:01:59的年月日和时分秒 Pattern pattern = Pattern.compile(\"(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\\\\s(\\\\d{2}):(\\\\d{2}):(\\\\d{2})\"); Matcher matcher = pattern.matcher(\"2021-09-11 23:01:59\"); if (matcher.matches()) { System.out.println(matcher.group(1)+\"年\"+matcher.group(2)+\"月\"+matcher.group(3)+\"日\"); System.out.println(matcher.group(4)+\"时\"+matcher.group(5)+\"分\"+matcher.group(6)+\"秒\"); } ","date":"2024-11-04","objectID":"/regex/:3:0","tags":["JavaSE"],"title":"【Java】Java中正则的使用","uri":"/regex/"},{"categories":["Java"],"content":"非贪婪匹配 正则匹配默认为贪婪匹配，既尽可能多的进行匹配 给定一个字符串表示的数字，现判断结尾0的个数 157000：三个0 9560：一个零 595：0个0 思路：使用分组匹配，正则表达式为：(\\d+)(0*)，代码如下 Pattern pattern = Pattern.compile(\"(\\\\d+)(0*)\"); Matcher matcher = pattern.matcher(\"157000\"); if (matcher.matches()) { matcher.group(1); // \"157000\" matcher.group(2); // \"\" } 可以看到：(\\d+)将整个数字字符串都进行匹配了，因为默认为贪婪匹配，会尽可能多的匹配满足条件的字符 使用?修改为非贪婪匹配，(\\d+?) 此时只要匹配上就不继续进行匹配了，代码如下 Pattern pattern = Pattern.compile(\"(\\\\d+?)(0*)\"); Matcher matcher = pattern.matcher(\"1230000\"); if (matcher.matches()) { System.out.println(\"group1=\" + matcher.group(1)); // \"123\" System.out.println(\"group2=\" + matcher.group(2)); // \"0000\" } 注意：matcher.matches() 方法，会尽可能地去完成匹配，结合下面 matcher.find() 例子理解 // matcher.find() 带参数时，从字符串首位开始进行匹配 // 这里(\\d+?)表示非贪婪匹配，只要匹配到则返回；(0*)匹配 0个或多个0 // 因此这里会匹配到三次，循环输出三次，前两次group(1)都只是匹配到了一个数字结束，最后一次匹配到3000 Pattern pattern = Pattern.compile(\"(\\\\d+?)(0*)\"); Matcher matcher = pattern.matcher(\"1230000\"); int start=0; while (matcher.find(start)){ System.out.println(matcher.group(1)+\":\"+matcher.group(2)); start=matcher.end(); } //输出结果如下： // 1: // 2: // 3:0000 ","date":"2024-11-04","objectID":"/regex/:4:0","tags":["JavaSE"],"title":"【Java】Java中正则的使用","uri":"/regex/"},{"categories":["Java"],"content":"搜索和替换 分割字符串 使用正则表达式分割字符串可以实现更加灵活的功能。String.split()方法传入的正是正则表达式。我们来看下面的代码： \"a b c\".split(\"\\\\s\"); // { \"a\", \"b\", \"c\" } \"a b c\".split(\"\\\\s\"); // { \"a\", \"b\", \"\", \"c\" } \"a, b ;; c\".split(\"[\\\\,\\\\;\\\\s]+\"); // { \"a\", \"b\", \"c\" } 如果我们想让用户输入一组标签，然后把标签提取出来，因为用户的输入往往是不规范的，这时，使用合适的正则表达式，就可以消除多个空格、混合,和;这些不规范的输入，直接提取出规范的字符串。 搜索字符串 使用正则表达式还可以搜索字符串，我们来看例子： String s = \"the quick brown fox jumps over the lazy dog.\"; Pattern p = Pattern.compile(\"\\\\wo\\\\w\"); Matcher m = p.matcher(s); while (m.find()) { String sub = s.substring(m.start(), m.end()); System.out.println(sub); } 我们获取到Matcher对象后，不需要调用matches()方法（因为匹配整个串肯定返回false），而是反复调用find()方法，在整个串中搜索能匹配上\\\\wo\\\\w规则的子串，并打印出来。这种方式比String.indexOf()要灵活得多，因为我们搜索的规则是3个字符：中间必须是o，前后两个必须是字符[A-Za-z0-9_]。 替换字符串 使用正则表达式替换字符串可以直接调用String.replaceAll()，它的第一个参数是正则表达式，第二个参数是待替换的字符串 String s = \"The quick\\t\\t brown fox jumps over the lazy dog.\"; String r = s.replaceAll(\"\\\\s+\", \" \"); System.out.println(r); // \"The quick brown fox jumps over the lazy dog.\" 反向引用 如果我们要把搜索到的指定字符串按规则替换，比如前后各加一个\u003cb\u003exxxx\u003c/b\u003e，这个时候，使用replaceAll()的时候，我们传入的第二个参数可以使用$1、$2来反向引用匹配到的子串。例如： String s = \"the quick brown fox jumps over the lazy dog.\"; String r = s.replaceAll(\"\\\\s([a-z]{4})\\\\s\", \" \u003cb\u003e$1\u003c/b\u003e \"); System.out.println(r); //the quick brown fox jumps \u003cb\u003eover\u003c/b\u003e the \u003cb\u003elazy\u003c/b\u003e dog. 它实际上把任何4字符单词的前后用\u003cb\u003exxxx\u003c/b\u003e括起来。实现替换的关键就在于\" \u003cb\u003e$1\u003c/b\u003e \"，它用匹配的分组子串([a-z]{4})替换了$1 例子：将2021-09-11 23:01:59替换显示为2021年09月11日 23时01分59秒 String time=\"2021-09-11 23:01:59\"; String formatTime=time.replaceAll(\"(\\\\d{4})-(\\\\d{2})-(\\\\d{2})\\\\s(\\\\d{2}):(\\\\d{2}):(\\\\d{2})\",\"$1年$2月$3日 $4时$5分$6秒\"); System.out.println(s); //2021年09月11日 23时01分59秒 ","date":"2024-11-04","objectID":"/regex/:5:0","tags":["JavaSE"],"title":"【Java】Java中正则的使用","uri":"/regex/"},{"categories":["Java"],"content":"一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。 Apple apple = new Apple(); //直接初始化，「正射」 apple.setPrice(4); 上面这样子进行类对象的初始化，我们可以理解为「正」。 ","date":"2024-11-04","objectID":"/text31/:0:0","tags":["Java"],"title":"【Java】反射的基本使用及API","uri":"/text31/"},{"categories":["Java"],"content":"反射 不知道初始化的对象是什么，无法使用new关键字 这时候，我们使用 JDK 提供的反射 API 进行反射调用： Class clz = Class.forName(\"com.chenshuyi.reflect.Apple\"); Method method = clz.getMethod(\"setPrice\", int.class); Constructor constructor = clz.getConstructor(); Object object = constructor.newInstance(); method.invoke(object, 4); 在运行时通过字符串值才得知要运行的类（com.chenshuyi.reflect.Apple） 反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法 ","date":"2024-11-04","objectID":"/text31/:1:0","tags":["Java"],"title":"【Java】反射的基本使用及API","uri":"/text31/"},{"categories":["Java"],"content":"一个简单例子 public class Apple { private int price; public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } public static void main(String[] args) throws Exception{ //正常的调用 Apple apple = new Apple(); apple.setPrice(5); System.out.println(\"Apple Price:\" + apple.getPrice()); //使用反射调用 Class clz = Class.forName(\"com.chenshuyi.api.Apple\"); Method setPriceMethod = clz.getMethod(\"setPrice\", int.class); Constructor appleConstructor = clz.getConstructor(); Object appleObj = appleConstructor.newInstance(); setPriceMethod.invoke(appleObj, 14); Method getPriceMethod = clz.getMethod(\"getPrice\"); System.out.println(\"Apple Price:\" + getPriceMethod.invoke(appleObj)); } } 输出结果： Apple Price:5 Apple Price:14 从这个简单的例子可以看出，一般情况下我们使用反射获取一个对象的步骤： 获取类的 Class 对象实例 Class clz = Class.forName(\"com.zhenai.api.Apple\"); 根据 Class 对象实例获取 Constructor 对象 Constructor appleConstructor = clz.getConstructor(); 使用 Constructor 对象的 newInstance 方法获取反射类对象 Object appleObj = appleConstructor.newInstance(); 而如果要调用某一个方法，则需要经过下面的步骤： 获取方法的 Method 对象 Method setPriceMethod = clz.getMethod(\"setPrice\", int.class); 利用 invoke 方法调用方法 setPriceMethod.invoke(appleObj, 14); 到这里，我们已经能够掌握反射的基本使用。但如果要进一步掌握反射，还需要对反射的常用 API 有更深入的理解。 在 JDK 中，反射相关的 API 可以分为下面几个方面： 获取反射的 Class 对象、 通过反射创建类对象、 通过反射获取类属性方法及构造器。 ","date":"2024-11-04","objectID":"/text31/:1:1","tags":["Java"],"title":"【Java】反射的基本使用及API","uri":"/text31/"},{"categories":["Java"],"content":"反射常用API 1、获取反射中的Class对象 在 Java API 中，获取 Class 类对象有三种方法： **第一种，使用 Class.forName 静态方法。**当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。 Class clz = Class.forName(\"java.lang.String\"); 第二种，使用 .class 方法。 这种方法只适合在编译前就知道操作的 Class。 Class clz = String.class; 第三种，使用类对象的getClass()方法。 String str = new String(\"Hello\"); Class clz = str.getClass(); 2、通过反射获取类属性、方法、构造器 我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。 Class clz = Apple.class; Field[] fields = clz.getFields(); for (Field field : fields) { System.out.println(field.getName()); } 输出结果是： price 而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性： Class clz = Apple.class; Field[] fields = clz.getDeclaredFields(); for (Field field : fields) { System.out.println(field.getName()); } 输出结果是： name price 与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。 ","date":"2024-11-04","objectID":"/text31/:1:2","tags":["Java"],"title":"【Java】反射的基本使用及API","uri":"/text31/"},{"categories":["Office基本操作"],"content":"办法1：ctrl+p 在edge浏览器中，使用ctrl+p快捷键可以快速调出打印。 打印页面选择，另存为pdf ","date":"2024-11-04","objectID":"/text33/:0:1","tags":["pdf"],"title":"【PDF文档】将网页转换为pdf文件并下载","uri":"/text33/"},{"categories":["Office基本操作"],"content":"办法2：Open in new tab 打开网页右上方的三个点，找到更多工具，打开开发者工具； 找到Network，找到Fetch/XHR，CTRL+R刷新界面，滑到最下面的fetch文件； 右击最下面的fetch文件，选择Open in new tab； 自动跳转到文件下载页，点击下载按钮。 ","date":"2024-11-04","objectID":"/text33/:0:2","tags":["pdf"],"title":"【PDF文档】将网页转换为pdf文件并下载","uri":"/text33/"},{"categories":["Office基本操作"],"content":"办法3：window.open Open in new tab打不开的页面 打开控制台Console，输入下面代码，并按回车键 window.open(URL,'_blank') 这里的URL复制Network处的路径 在跳转到的文件下载页，点击下载按钮。 ","date":"2024-11-04","objectID":"/text33/:0:3","tags":["pdf"],"title":"【PDF文档】将网页转换为pdf文件并下载","uri":"/text33/"},{"categories":["Hugo系列"],"content":"image画廊 一个 image 示例: {{\u003c image src=\"./images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"./images/lighthouse-small.jpg\" src_l=\"./images/lighthouse-large.jpg\" \u003e}} 呈现的输出效果如下: Lighthouse (image)\rimage shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. ","date":"2024-11-01","objectID":"/text29/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（五）","uri":"/text29/"},{"categories":["Hugo系列"],"content":"typeit打字动画 typeit shortcode 基于 TypeIt 库提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2024-11-01","objectID":"/text29/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（五）","uri":"/text29/"},{"categories":["Hugo系列"],"content":"1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2024-11-01","objectID":"/text29/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（五）","uri":"/text29/"},{"categories":["Hugo系列"],"content":"2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2024-11-01","objectID":"/text29/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（五）","uri":"/text29/"},{"categories":["Hugo系列"],"content":"禁止解析代码块 使用/*...*/包裹禁止解析的代码，Hugo官方文档- 代码高亮. ","date":"2024-11-01","objectID":"/text29/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（五）","uri":"/text29/"},{"categories":["后端"],"content":"报错信息： A component required a bean of type ‘com...Mapper‘ that could not be found. Consider defining a bean of type ‘com.yinhai.msg.localResource.msgtpl.mapper 检查配置： pom文件（项目总） \u003cmodules\u003e ..... \u003cmodule\u003emsg-center\u003c/module\u003e ..... \u003c/modules\u003e pom文件（项目启动类） \u003cdependencies\u003e .... \u003cdependency\u003e \u003cgroupId\u003ecom.yinhai\u003c/groupId\u003e \u003cartifactId\u003emsg-center\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e .... \u003c/dependencies\u003e pom文件（所在包） \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cparent\u003e \u003cgroupId\u003ecom.yinhai\u003c/groupId\u003e \u003cartifactId\u003eyhch-base-backend\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cartifactId\u003emsg-center\u003c/artifactId\u003e \u003cproperties\u003e \u003cmaven.compiler.source\u003e8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e8\u003c/maven.compiler.target\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.yinhai\u003c/groupId\u003e \u003cartifactId\u003ecommon\u003c/artifactId\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e application-datasource.yml （启动类配置文件） ta404: datasource: datasource-list: * type: * druid: ta404ds: datasource: url: jdbc:oracle:* username: * password: * # 初始化连接数 initial-size: 5 # 连接池最大连接数量 max-active: 20 # 获取链接超时时间 （毫秒） max-wait: 60000 mybatis: mapper-locations: # mapper映射文件路径 - classpath*:mapper/msg-center/**.xml base-packages: # 包路径 - com.yinhai.msg.**.mapper mybatis-plus: db-type: oracle ","date":"2024-10-11","objectID":"/text28/:0:0","tags":["Spring-boot"],"title":"【Spring-boot】启动报错注入bean失败Mapper找不到","uri":"/text28/"},{"categories":["office基本操作"],"content":"\rThis is a tip\rword 页码不连续可通过以下步骤解决：1. 检查并删除分节符；2. 更改页码格式为连续编号；3. 更新整篇文档页码；4. 检查页眉或页脚中的页码设置，确保与正文一致；5. 取消页眉或页脚之间的链接。\r1. 检查分节符： 分节符可以将文档分成不同的部分，每个部分可以有自己的页码。 将光标放在页码中断处，然后转到“布局”选项卡 \u003e “分隔符”组。 如果有分节符插入，请删除它。 2. 更改页码格式： 转到“插入”选项卡 \u003e “页码”组。 选择“页码格式”选项，然后选择连续页码选项。 确保“页码起始编号”设置为 1。 3. 更新页码： 更新页码后，需要更新整个文档的页码。 转到“插入”选项卡 \u003e “页码”组，然后单击“更新页码”。 选择“更新整篇文档”选项。 4. 检查页眉或页脚： 有时，页眉或页脚中的页码设置可能与文档正文不匹配。 双击页眉或页脚区域进行编辑。 检查页码设置是否正确，并将其与文档正文中的页码保持一致。 5. 取消链接页眉或页脚： 如果页眉或页脚之间存在链接，可能会导致页码不连续。 双击要更改页眉或页脚的页面。 转到“设计”选项卡 \u003e “页眉和页脚”组，然后取消选中“链接到前一节”复选框。 ","date":"2024-10-08","objectID":"/text27/:0:0","tags":["office"],"title":"【word文档】word页脚页码不连续解决办法","uri":"/text27/"},{"categories":["Hugo系列"],"content":"hugo访问统计功能 由于静态网站静态的属性，所以一些动态的内容，如评论、计数等模块就需要借助外来平台。而不蒜子就是这么一个访问统计模块，但与百度统计谷歌分析不同的是，它可直接将访问次数显示在在网页上。因此我们可以通过不蒜子快速便捷地添加访问统计功能。 当然除了不蒜子，valine 评论系统也附带了单页的阅读人数统计。但是由于不蒜子除了单页的阅读人数统计还可以提供全站的访问统计，外加我用的不是 valine 评论系统，所以不蒜子是更加普适且好用的访问统计模块。 在下文中，由于不涉及主题的参数，所以有可能很多的 Hugo 主题都适用，但本文仍以 LoveIt 主题为例。 ","date":"2024-09-13","objectID":"/text24/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加 Html 模板 在your_site\\layouts\\partials\\plugin\\路径下添加文件busuanzi.html，并将下面的配置输入至该文件 在配置文件中添加参数 找到your_site\\config.toml配置文件，在最后面添加不蒜子的参数如下： # 添加不蒜子计数 [params.busuanzi] enable = true # 是否开启全站独立访客数 site_uv = true # 全站独立访客数前的图标或提示语 site_uv_pre = '\u003ci class=\"fa fa-user\"\u003e\u003c/i\u003e' # 全站独立访客数后的图标或提示语 site_uv_post = '' # 是否开启全站浏览量 site_pv = true # 全站浏览量前的图标或提示语 site_pv_pre = '\u003ci class=\"fa fa-eye\"\u003e\u003c/i\u003e' # 全站浏览量后的图标或提示语 site_pv_post = '' # 是否开启单页浏览量 page_pv = true # 单页浏览量前的图标或提示语 page_pv_pre = '\u003ci class=\"far fa-eye fa-fw\"\u003e\u003c/i\u003e' # 单页浏览量后的图标或提示语 page_pv_post = '' ","date":"2024-09-13","objectID":"/text24/:1:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"在对应处引入不蒜子 开启页脚的全站统计 把your_site\\themes\\LoveIt\\layouts\\partials\\footer.html复制粘贴到路径your_site\\layouts\\partials\\下。 再修改文件your_site\\layouts\\partials\\footer.html，在最后三行 \u003c/div\u003e \u003c/footer\u003e {{- end -}} 的前面添加 {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.busuanzi \"bsz_type\" \"footer\") -}} 添加后代码如下图： 最后的呈现结果如下图： This is a tip\r如果只想简单地开启全站统计，我们可以忽略## 添加 Html 模板和## 在配置文件中添加参数，直接从开启页脚的全站统计开始，但需把要添加的 {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.busuanzi \"bsz_type\" \"footer\") -}} 换为 \u003cscript async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"\u003e\u003c/script\u003e \u003cspan id=\"busuanzi_container_site_pv\"\u003e \u003ci class=\"fa fa-eye\"\u003e\u003c/i\u003e \u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e 次 \u003c/span\u003e | \u003cspan id=\"busuanzi_container_site_uv\"\u003e \u003ci class=\"fa fa-user\"\u003e\u003c/i\u003e \u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e 位 \u003c/span\u003e 但这种方法不好添加单页阅读 开启单页的阅读统计 把your_site\\themes\\LoveIt\\layouts\\posts\\single.html复制粘贴到路径your_site\\layouts\\posts\\下。再在your_site\\layouts\\posts\\single.html中找到第二个\u003cdiv class=\"post-meta-line\"\u003e标签，并在该标签下添加下面的代码 {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.busuanzi \"bsz_type\" \"page-reading\") -}} 添加后代码如下： 最后的呈现结果如下图： This is a tip\r参考文章：不蒜子官方\r","date":"2024-09-13","objectID":"/text24/:1:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"Permalinks 参数修改 修改这个参数，可以使我们之后修改网站文章的 url 更便捷，不需再采用hugo new posts/your_post.md新建文章的方式来修改，我们甚至还可以做到文章文件名与其 url 不一致。 This is a tip\r文章文件名就是指你使用hugo new posts/your_post.md后生成的文章的文件名，本例子中是your_post；而网站文章 url，是指这篇文章在你的 blog 网站中的 url，在本例中如果按照 LovIt 主题默认的方式，那么网站文章 url 为 https://stilig.me/your_post/\r","date":"2024-09-13","objectID":"/text24/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 Permalink 配置 找到博客根目录下的配置文件your_site/config.toml，找到参数Permalinks，按照下面的代码块修改： # Permalinks 配置 [Permalinks] # 原来是 posts = \":filename\"，其意为以文件名为 url posts = \"/posts/:slug\" # 如果你不想改变原来的 url（比如说文章已被搜索网站收录）,可以去掉/posts/，那么其将变为 posts= \":slug\" ","date":"2024-09-13","objectID":"/text24/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"将 slug 参数添加至.md文件的模版 在你博客的根目录下找到your_site\\archetypes\\default.md并打开，把 slug 参数 添加到 title 参数下，如下代码块： --- title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" slug: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" \u003c!-- 注意：这里 \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" 表示参数取文章的文件名，这只是为了防止参数为空而设定的默认值 --\u003e ... ... --- 这样我们新建的文章中就都会有 slug 参数了，然后我们只需要修改slug=\"\" 的\"\"中的值，就可以改变文章 url 了。 而对于之前那些文章，我们也只需要在文章头中添加参数 slug 就可以了，如下图： ","date":"2024-09-13","objectID":"/text24/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加自定义404页面 在博客根目录的your_site\\layouts\\文件夹下，放入你想放的404.html文件，这样它就会覆盖掉原主题的your_blog\\themes\\LoveIt\\layouts\\404.html文件。 This is a tip\r生成 public 文件时，Hugo 会优先读取根目录的文件，然后再读取主题里文件（也就是your_blog\\themes\\LoveIt\\layouts\\里的文件）。 我们当然也可以直接修改主题里的文件，但是如果这样做，那么在更新主题后我们之前的修改也会一并地消失。因此在本文的后面，我们宁愿把主题里的文件复制到根目录对应位置后再修改，也不直接修改。 ","date":"2024-09-13","objectID":"/text24/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加文章数量统计 其实就是利用 hugo 提供的变量来获取文章数量，再通过 html 里的sup标签，把文章数量在上标中显示出来，如下图： ","date":"2024-09-13","objectID":"/text24/:4:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 list.html 文件 复制your_site\\themes\\LoveIt\\layouts\\taxonomy\\list.html到your_site\\layouts\\taxonomy\\路径下。 然后打开your_site\\layouts\\taxonomy\\list.html，找到下面的内容： {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else if eq $taxonomy \"tag\" -}} \u003ci class=\"fas fa-tag fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else -}} 将其改为： {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }}\u003csup\u003e{{ len .Pages }}\u003c/sup\u003e {{- else if eq $taxonomy \"tag\" -}} \u003ci class=\"fas fa-tag fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }}\u003csup\u003e{{ len .Pages }}\u003c/sup\u003e {{- else -}} 继续找到： {{- range $pages.PageGroups -}} \u003ch3 class=\"group-title\"\u003e{{ .Key }}\u003c/h3\u003e 将其改为： {{- range $pages.PageGroups -}} \u003ch3 class=\"group-title\"\u003e{{ .Key }} \u003csup\u003e{{ len .Pages }}\u003c/sup\u003e\u003c/h3\u003e 因为 LoveIt 博客是以年份来分组的，但是我的博文没有那么多，以月份来分组更加有记录感，所以可以把下面内容： {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \"2006\" -}} 改为： {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \"2006-01\" -}} 从而达到以月份分组。 ","date":"2024-09-13","objectID":"/text24/:4:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 terms.html 文件 复制your_site\\themes\\LoveIt\\layouts\\taxonomy\\terms.html到your_site\\layouts\\taxonomy\\路径下。 然后打开your_site\\layouts\\taxonomy\\terms.html，找到下面的内容： \u003cdiv class=\"page archive\"\u003e {{- /* Title */ -}} \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- .Params.Title | default (T $taxonomies) | default $taxonomies | dict \"Some\" | T \"allSome\" -}} \u003c/h2\u003e 改成： \u003cdiv class=\"page archive\"\u003e {{- /* Title */ -}} \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- .Params.Title | default (T $taxonomies) | default $taxonomies | dict \"Some\" | T \"allSome\" -}}\u003csup\u003e{{ len .Pages }}\u003c/sup\u003e \u003c/h2\u003e 继续找到： \u003ch3 class=\"card-item-title\"\u003e \u003ca href=\"{{ .RelPermalink }}\"\u003e \u003ci class=\"far fa-folder fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Page.Title }} \u003c/a\u003e \u003c/h3\u003e 然后改成： \u003ch3 class=\"card-item-title\"\u003e \u003ca href=\"{{ .RelPermalink }}\"\u003e \u003ci class=\"far fa-folder fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Page.Title }} \u003csup\u003e{{ len .Pages }}\u003c/sup\u003e \u003c/a\u003e \u003c/h3\u003e ","date":"2024-09-13","objectID":"/text24/:4:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 section.html 文件 复制your_site\\themes\\LoveIt\\layouts\\_default\\section.html到your_site\\layouts\\_default\\路径下。 然后打开your_site\\layouts\\_default\\section.html，找到下面的内容： \u003cdiv class=\"page archive\"\u003e {{- /* Title */ -}} \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- .Params.Title | default (T .Section) | default .Section | dict \"Some\" | T \"allSome\" -}} \u003c/h2\u003e 改成： \u003cdiv class=\"page archive\"\u003e {{- /* Title */ -}} \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- .Params.Title | default (T .Section) | default .Section | dict \"Some\" | T \"allSome\" -}}\u003csup\u003e{{ len .Pages }}\u003c/sup\u003e \u003c/h2\u003e 继续找到： {{- range $pages.PageGroups -}} \u003ch3 class=\"group-title\"\u003e{{ .Key }}\u003c/h3\u003e 然后改成： {{- range $pages.PageGroups -}} \u003ch3 class=\"group-title\"\u003e{{ .Key }} \u003csup\u003e{{ len .Pages }}\u003c/sup\u003e\u003c/h3\u003e 同样，这里是以年份分组的，若要改为以月份分组，则要把下面代码： {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \"2006\" -}} 改为： {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \"2006-01\" -}} 这样操作后，以我的网站为例，归档、分类和标签页面就都能加上文章数量统计了。 ","date":"2024-09-13","objectID":"/text24/:4:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加文章密码 有时候我们并不想把一部分网页展示给所有人，那么我们可以加密我们的网页，使其要通过密码访问，如下图: ","date":"2024-09-13","objectID":"/text24/:5:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"修改 single.html 将your_site\\themes\\LoveIt\\layouts\\posts\\single.html复制粘贴到your_site\\layouts\\posts\\路径下。打开your_site\\layouts\\posts\\single.html文件，在{{- $params := .Scratch.Get \"params\" -}}下添加下面内容： {{- $password := $params.password | default \"\" -}} {{- if ne $password \"\" -}} \u003cscript\u003e (function(){ if({{ $password }}){ if (prompt('请输入文章密码') != {{ $password }}){ alert('密码错误！'); if (history.length === 1) { window.opener = null; window.open('', '_self'); window.close(); } else { history.back(); } } } })(); \u003c/script\u003e {{- end -}} ","date":"2024-09-13","objectID":"/text24/:5:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"将 password 参数添加至.md文件的模版 之后我们只要将 password 参数添加到文章头即可。 但为了方便起见，我这里直接把它加到了模板文件中，即在博客的根目录下找到your_site\\archetypes\\default.md并打开，把 password 参数添加进去，如下代码块： --- title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" slug: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" ... ... password: \"\" ... ... --- This is a tip\rpassword= \"\"的\"\"中的字符即为密码，若无字符，则文章不加密无需密码登录。\r","date":"2024-09-13","objectID":"/text24/:5:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（二）","uri":"/text24/"},{"categories":["Hugo系列"],"content":"添加_custom.scss以自定义 css Hugo 会优先读取博客根目录下的同名目录和文件，所以我们在博客根目录下添加文件your_site\\assets\\css\\_custom.scss This is a tip\r我们要使用hugo_extended版本的 Hugo 才可使_custom.scss文件生效\r","date":"2024-09-13","objectID":"/text25/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"添加custom.js以自定义 JavaScript 我们要创建一个.js文件来自定义 JavaScript，但是由于 LoveIt 主题本身并没有提供这样的一个文件，所以除了创建文件，我们还要修改一下 LoveIt 主题的模版。 ","date":"2024-09-13","objectID":"/text25/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"创建custom.js文件 在博客根目录添加文件your_site\\static\\js\\custom.js，之后我们自定义 JavaScript 的修改就都是在这个文件中进行的。 ","date":"2024-09-13","objectID":"/text25/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"修改 LoveIt 模版 把your_site\\themes\\LoveIt\\layouts\\partials\\assets.html文件复制到your_site\\layouts\\partials\\路径下。 在your_site\\layouts\\partials\\assets.html文件内容的最尾部找到{{- partial \"plugin/analytics.html\" . -}}，并在其上一行中添加如下内容： {{- /* 自定义 js 文件 */ -}} \u003cscript type=\"text/javascript\" src=\"/js/custom.js\"\u003e\u003c/script\u003e 由于本系列文章的部分功能会用到 jQuery（如网站运行时间和背景图片），因此强烈建议与自定义的 js 文件一起引入，即在刚才添加的内容的上一行再添加如下的内容： \u003cscript type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js\"\u003e\u003c/script\u003e ","date":"2024-09-13","objectID":"/text25/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"添加网站运行时间 把your_site\\themes\\LoveIt\\layouts\\partials\\footer.html复制到your_site\\layouts\\partials\\路径下。 打开文件your_site\\layouts\\partials\\footer.html，在其中找到\u003cdiv class=\"footer-container\"\u003e，并在其下方添加如下内容： \u003cdiv class=\"footer-line\"\u003e \u003cspan id=\"run-time\"\u003e\u003c/span\u003e \u003c/div\u003e 之后，在我们刚刚新建的your_site\\static\\js\\custom.js文件中添加如下内容： /* 站点运行时间 */ function runtime() { window.setTimeout(\"runtime()\", 1000); /* 请修把这里的建站时间换为你自己的 */ let startTime = new Date('05/23/2023 08:00:00'); let endTime = new Date(); let usedTime = endTime - startTime; let days = Math.floor(usedTime / (24 * 3600 * 1000)); let leavel = usedTime % (24 * 3600 * 1000); let hours = Math.floor(leavel / (3600 * 1000)); let leavel2 = leavel % (3600 * 1000); let minutes = Math.floor(leavel2 / (60 * 1000)); let leavel3 = leavel2 % (60 * 1000); let seconds = Math.floor(leavel3 / (1000)); let runbox = document.getElementById('run-time'); runbox.innerHTML = '本站已运行\u003ci class=\"far fa-clock fa-fw\"\u003e\u003c/i\u003e ' + ((days \u003c 10) ? '0' : '') + days + ' 天 ' + ((hours \u003c 10) ? '0' : '') + hours + ' 时 ' + ((minutes \u003c 10) ? '0' : '') + minutes + ' 分 ' + ((seconds \u003c 10) ? '0' : '') + seconds + ' 秒 '; } runtime(); ","date":"2024-09-13","objectID":"/text25/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"lightgallery 图片相册功能的改进 lightgallery 是 LoveIt 支持的图片相册功能（就是点击图片能放大观察的功能）。如果要开启，则先要在your_site/config.toml配置文件中，令参数lightgallery为 true。 但是若要真正的启用这个功能，那么我们要对每个图片起一个标题（引入图片的形式为![图片说明](https://picture.com\"图片标题\")），但是懒惰的我一般不会给图片起标题（因为要打两个双引号），所以要是图片说明能当图片标题就好了。 为了达到上面的效果，我们只需要创建your_site/layouts/_default/_markup/render-image.html文件，并在该文件中添加如下内容： {{ $figcap := or .Title .Text }} {{ $caption := or .Text \" \" }} {{- if eq $figcap $caption -}} {{ $caption = \" \" }} {{- end -}} {{- if $figcap -}} \u003cfigure\u003e {{- dict \"Src\" .Destination \"Title\" $figcap \"Caption\" $caption \"Linked\" true \"Resources\" .Page.Resources | partial \"plugin/image.html\" -}} \u003cfigcaption class=\"image-caption\"\u003e {{- $figcap | safeHTML -}} \u003c/figcaption\u003e \u003c/figure\u003e {{- else -}} {{- dict \"Src\" .Destination \"Title\" (path.Base .Destination) \"Resources\" .Page.Resources | partial \"plugin/image.html\" -}} {{- end -}} 但是如果你真的不需要标题，而且嫌标题很丑的话，那么可以在your_site\\assets\\css\\_custom.scss文件中添加如下内容： /* 图片 */ figcaption { display: none !important; } 然后标题就可以消失了。 ","date":"2024-09-13","objectID":"/text25/:4:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"文章过期提醒 像这种科技博文，一般都有时效性，所以添加一个文章过期提醒就显得很有必要了。 ","date":"2024-09-13","objectID":"/text25/:5:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"修改配置及模版文件 在your_site/config.toml配置文件中，添加如下内容： # Display a message at the beginning of an article to warn the readers that it's content may be outdated. # 在文章末尾显示提示信息，提醒读者文章内容可能过时。 [params.outdatedInfoWarning] enable = true hint = 90 # Display hint if the last modified time is more than these days ago. # 如果文章最后更新于这天数之前，显示提醒 warn = 180 # Display warning if the last modified time is more than these days ago. # 如果文章最后更新于这天数之前，显示警告 但是我们总不可能每一篇都是这种有时效性的科技博客，所以我们要添加一个参数来控制其是否开启。为了方便起见，这里我选择直接在模版文件your_site\\archetypes\\default.md里添加变量： outdatedInfoWarning: true This is a tip\r这里默认文章过期提醒开启，若想修改默认，直接将 true 改为 false 即可。之前创建的文章直接在文章头添加该参数即可。\r","date":"2024-09-13","objectID":"/text25/:5:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"修改国际化文件 把your_site\\themes\\LoveIt\\i18n\\zh-CN.toml复制到your_site\\i18n\\路径下，打开your_site\\i18n\\zh-CN.toml文件，添加如下内容： [outdatedInfoWarningBefore] other = \"本文最后更新于 \" [outdatedInfoWarningAfter] other = \"，文中内容可能已过时，请谨慎使用。\" ","date":"2024-09-13","objectID":"/text25/:5:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"添加outdated-info-warning.html文件 在your_site/layouts/partials/single/路径下添加outdated-info-warning.html文件，内容如下： {{- if or .Params.outdatedInfoWarning (and .Site.Params.outdatedInfoWarning.enable (ne .Params.outdatedInfoWarning false)) }} {{- $daysAgo := div (sub now.Unix .Lastmod.Unix) 86400 }} {{- $hintThreshold := .Site.Params.outdatedInfoWarning.hint | default 30 }} {{- $warnThreshold := .Site.Params.outdatedInfoWarning.warn | default 180 }} {{- $updateTime := .Lastmod }} {{- if .GitInfo }} {{- if lt .GitInfo.AuthorDate.Unix .Lastmod.Unix }} {{- $updateTime := .GitInfo.AuthorDate }} {{- end }} {{- end -}} {{- if gt $daysAgo $hintThreshold }} {{- $iconDetails := \"fas fa-angle-right fa-fw\" -}} {{- if gt $daysAgo $warnThreshold }} {{- $type := \"warning\" -}} {{- $icon := \"fas fa-exclamation-triangle fa-fw\" -}} \u003cdiv class=\"details admonition {{ $type }} open\"\u003e \u003cdiv class=\"details-summary admonition-title\"\u003e \u003ci class=\"icon {{ $icon }}{{ $type }}\"\u003e\u003c/i\u003e{{ T $type }}\u003ci class=\"details-icon {{ $iconDetails }}\"\u003e\u003c/i\u003e {{- else }} {{- $type := \"question\" -}} {{- $icon := \"fas fa-exclamation-triangle fa-fw\" -}} \u003cdiv class=\"details admonition {{ $type }} open\"\u003e \u003cdiv class=\"details-summary admonition-title\"\u003e \u003ci class=\"icon {{ $icon }}{{ $type }}\"\u003e\u003c/i\u003e{{ T $type }}\u003ci class=\"details-icon {{ $iconDetails }}\"\u003e\u003c/i\u003e {{- end }} \u003c/div\u003e \u003cdiv class=\"details-content\"\u003e \u003cdiv class=\"admonition-content\"\u003e {{ T \"outdatedInfoWarningBefore\" -}} \u003cspan class=\"timeago\" datetime=\"{{ dateFormat \"2006-01-02T15:04:05\" $updateTime }}\" title=\"{{ dateFormat \"January 2, 2006\" $updateTime }}\"\u003e {{- dateFormat \"January 2, 2006\" $updateTime -}} \u003c/span\u003e{{ T \"outdatedInfoWarningAfter\" -}} \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e {{- end -}} {{- end -}} ","date":"2024-09-13","objectID":"/text25/:5:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"修改single.html文件 把your_site/themes/LoveIt/layouts/posts/single.html复制到your_site/layouts/posts/路径下，然后打开your_site/layouts/posts/single.html找到下面内容： {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e 修改为： \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} {{- /* Outdated Info Warning */ -}} {{- partial \"single/outdated-info-warning.html\" . -}} \u003c/div\u003e ","date":"2024-09-13","objectID":"/text25/:5:4","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"双击生成颜表情 在your_site\\static\\js\\custom.js文件中，添加如下内容： /* 返回随机颜色 */ function randomColor() { return \"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"; } /* 点击生成字符特效 */ var a_idx = 0; var a_click = 1; /* 生成的字符内容 */ var a = new Array(\"乀(ˉεˉ乀)\",\"𓂃𓂃𓂃𓊝𓄹𓄺𓂃𓂃𓂃\",\"˘ᗜ˘\",\"(╥╯^╰╥)\",\"╰(*´︶`*)╯\",\"✧(◍˃̶ᗜ˂̶◍)✩\",\"｡◕‿◕｡\", \"(๑ت๑)\",\"(๑❛ᴗ❛๑)\",\"w(ﾟДﾟ)w\",\"Σ( ° △ °|||)︴\",\"(⊙ˍ⊙)\",\"(๑ˉ∀ˉ๑)\",\"\u003c(￣︶￣)\u003e\",\"╰(*°▽°*)╯\",\"✿\", \"(,,•́ . •̀,,)\",\"վ'ᴗ' ի\",\"(◔◡◔)\",\"⚝\",\"₍ᐢ. ֑ .ᐢ₎\"); jQuery(document).ready(function($) { $(\"body\").click(function(e) { /* 点击频率，点击几次就换文字 */ var frequency = 2; if (a_click % frequency === 0) { var $i = $(\"\u003cspan/\u003e\").text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css({ \"z-index\": 9999, \"top\": y - 20, \"left\": x, \"position\": \"absolute\", \"font-weight\": \"bold\", \"color\": randomColor(), \"-webkit-user-select\": \"none\", \"-moz-user-select\": \"none\", \"-ms-user-select\": \"none\", \"user-select\": \"none\" }); $(\"body\").append($i); $i.animate({ \"top\": y - 180, \"opacity\": 0 }, 1500, function() { $i.remove(); }); } a_click ++; }); }); ","date":"2024-09-13","objectID":"/text25/:6:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"离开进入网站的标题变化 可以发现，若离开我的网站去其他页面，那么我的网站的标题和图标会发生变化。若再次回到我的网站，则标题和图标会再次发生变化。想要达到这个效果，只需在your_site\\static\\js\\custom.js文件中添加如下内容： /* 离开当前页面时修改网页标题，回到当前页面时恢复原来标题 */ window.onload = function() { var OriginTitile = document.title; var titleTime; document.addEventListener('visibilitychange', function() { if(document.hidden) { $('[rel=\"icon\"]').attr('href', \"/failure.ico\"); $('[rel=\"shortcut icon\"]').attr('href', \"/failure.ico\"); document.title = '哦~该回码头了'; clearTimeout(titleTime); } else { $('[rel=\"icon\"]').attr('href', \"/favicon.ico\"); $('[rel=\"shortcut icon\"]').attr('href', \"/favicon.ico\"); document.title = '哈~又整到薯条了'; titleTime = setTimeout(function() { document.title = OriginTitile; }, 2000); } }); } 其中文字部分改为自己喜欢的就可以了，而至于网站图标文件favicon.ico和failure.ico如果不清楚，具体可见我之前的文章 Hugo的Lovelt主题美化（一）。 这里只简单的说一下：一般而言，我们会把网站图标放到your_site\\static\\路径下，而在当前的目的下，我们可以只调用48*48的.ico文件作为显示图标。此外，favicon.ico一般是我们原来的网站图标，所以我们只需要在创建一个failure.ico作为离开页面时显示的图标即可。 ","date":"2024-09-13","objectID":"/text25/:7:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（三）","uri":"/text25/"},{"categories":["Hugo系列"],"content":"二级标题样式 为了使文章的可读性更强，在这里最好修改一下 LoveIt 主题的文章样式。 ","date":"2024-09-13","objectID":"/text26/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"二级标题的修改 原主题的二级标题我不好评价，它跟下一级的标题几乎区分不开，这导致文章看起来没有条理。因此在这里我们将修改二级标题的样式以做区分。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 标题 */ .page.single h2 { box-shadow: rgb(95, 90, 75) 0px 0px 0px 1px, rgba(10, 10, 0, 0.5) 1px 1px 6px 1px; color: rgb(255, 255, 255); font-family: 微软雅黑, 宋体, 黑体, Arial; font-weight: bold; line-height: 1.3; text-shadow: rgb(34, 34, 34) 2px 2px 3px; background: rgb(43, 102, 149); border-radius: 6px; border-width: initial; border-style: none; border-color: initial; border-image: initial; padding: 7px; margin: 18px 0px 18px -5px !important; } ","date":"2024-09-13","objectID":"/text26/:1:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"行内代码 原主题的行内代码能用，但只能用一点点，实在是与正文区分不开，所以在这修改一下它的样式。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 行内代码块 */ code { margin: 0 .2rem; font-size: .9em; border: 1px solid #d6d6d6; border-radius: .2rem; } /* 预格式代码块(用tab键插入的代码块) */ pre code { margin: 0; border: none; font-size: .875rem; } /* 标题里的代码块样式 */ .page.single .content\u003eh2 code { color: #f7ab01; background: transparent !important; border: none; } ","date":"2024-09-13","objectID":"/text26/:1:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"分割线 在原主题中分割线几乎看不到，这里修改一下。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 分隔线 */ hr { border: none; border-bottom: 2px dashed #7a7a7a !important; } ","date":"2024-09-13","objectID":"/text26/:1:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"页脚分割线 页脚内容与其他内容连在一起有点杂乱，因此添加一个页脚的分割线还是很有必要的。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 页脚分割线 */ .footer { display: block; border-top-width: 3px; border-top-style: solid; border-top-color: #96c1db; position: relative; z-index: -1; max-width: 800px; width: 60%; margin: .5rem auto 0 auto; padding-left: 0rem; padding-right: 0rem; } @media only screen and (max-width: 1440px) { .footer { width:54.5% } } @media only screen and (max-width: 1200px) { .footer { width:50.5% } } @media only screen and (max-width: 960px) { .footer { width: 77% } } @media only screen and (max-width: 680px) { .footer { width: 95% } } ","date":"2024-09-13","objectID":"/text26/:1:4","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"首页头像旋转 这是一个没什么用的功能，但是好玩。 找到your_site\\assets\\css\\_custom.scss文件，在里面添加如下内容： /* 头像旋转 */ .home .home-profile .home-avatar img { width: 5rem; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ease-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; \u0026:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } } ","date":"2024-09-13","objectID":"/text26/:1:5","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"更新时间设置 原主题是有最近更新时间参数的，只不过藏的比较深，一般不显示。但实际上，更新时间是要比发布时间更好用的（毕竟老文章改改也就成新文章了）。 ","date":"2024-09-13","objectID":"/text26/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"首页显示最近更新时间 虽然我们有最近更新时间，但首页并不显示，这好吗？这不好！所以我劝年轻人们都把它加上。 把your_site/themes/LoveIt/layouts/_default/summary.html复制到your_site/layouts/_default/路径下，然后打开your_site/layouts/_default/summary.html文件，找到如下内容： {{- with .Site.Params.dateFormat | default \"2006-01-02\" | .PublishDate.Format -}} \u0026nbsp;\u003cspan class=\"post-publish\"\u003e {{- printf `\u003ctime datetime=\"%v\"\u003e%v\u003c/time\u003e` . . | dict \"Date\" | T \"publishedOnDate\" | safeHTML -}} \u003c/span\u003e {{- end -}} 把它修改为下面的内容： {{- with .Site.Params.dateFormat | default \"2006-01-02\" | .PublishDate.Format -}} \u0026nbsp;\u003cspan class=\"post-publish\"\u003e {{- printf `\u003ctime datetime=\"%v\"\u003e%v\u003c/time\u003e` . . | dict \"Date\" | T \"publishedOnDate\" | safeHTML -}}, \u003c/span\u003e {{- end -}} {{- with .Site.Params.dateFormat | default \"2006-01-02\" | .Lastmod.Format -}} \u0026nbsp;\u003cspan class=\"post-publish\"\u003e {{- printf `\u003ctime datetime=\"%v\"\u003e%v\u003c/time\u003e` . . | dict \"Date\" | T \"updatedOnDate\" | safeHTML -}}, \u003c/span\u003e {{- end -}} ","date":"2024-09-13","objectID":"/text26/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"显示最近更新的十篇文章 一般来说，归档页面只有按发布时间排序的列表，但是我们最新的动态往往会涉及到修改以前的文章，所以我们最好加一栏用来显示最近更新的文章。 首先，在your_site/config.toml配置文件中添加新参数： [params.section] # 显示最近更新文章的数量 lastUpdatedSize = 10 然后，把your_site/themes/LoveIt/layouts/_default/section.html复制到your_site/layouts/_default/路径下，然后打开your_site/layouts/_default/section.html文件，找到如下内容： {{- /* Paginate */ -}} 在它的上面添加如下内容： {{- /* Last Modified */ -}} {{- $lastUpdatedSize := .Site.Params.section.lastUpdatedSize -}} {{- if $lastUpdatedSize -}} {{- if .Pages -}} {{- $pages := .Pages.ByLastmod.Reverse -}} \u003ch3 class=\"group-title\"\u003e{{ T \"RecentUpdate\" -}} \u003csup\u003e{{- $lastUpdatedSize -}}\u003c/sup\u003e\u003c/h3\u003e {{- range first $lastUpdatedSize $pages -}} \u003carticle class=\"archive-item\"\u003e \u003ca href=\"{{ .RelPermalink }}\" class=\"archive-item-link\"\u003e {{- .Title -}} \u003c/a\u003e \u003cspan class=\"archive-item-date2\"\u003e {{- \"2006-01-02\" | .Lastmod.Format -}} \u003c/span\u003e \u003c/article\u003e {{- end -}} {{- end -}} {{- end -}} 接着来修改国际化文件，把your_site\\themes\\LoveIt\\i18n\\zh-CN.toml复制到your_site\\i18n\\路径下，打开your_site\\i18n\\zh-CN.toml文件，添加如下内容： [RecentUpdate] other = \"最近更新\" 如果还设置了其他语言，那么我们只需将这个参量添加到对应的文件，再把 other 的内容改掉即可。 然后在your_site/assets/css/_custom.scss中添加如下内容： .archive-item-date2 { color: #7c7c88; } 最后，为了区分开发布时间和最近更新时间，我们要在每篇文章中添加最近更新时间的 meta。把your_site/themes/LoveIt/layouts/posts/single.html复制到your_site/layouts/posts/路径下，然后打开your_site/layouts/posts/single.html文件，找到如下内容： {{- with .Site.Params.dateformat | default \"2006-01-02\" | .PublishDate.Format -}} \u003ci class=\"far fa-calendar-alt fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;\u003ctime datetime=\"{{ . }}\"\u003e{{ . }}\u003c/time\u003e\u0026nbsp; {{- end -}} 将其改为： {{- with .Site.Params.dateformat | default \"2006-01-02\" | .PublishDate.Format -}} \u003ci class=\"far fa-calendar fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;\u003ctime datetime=\"{{ . }}\"\u003e{{ . }}\u003c/time\u003e\u0026nbsp; {{- end -}} {{- with .Site.Params.dateformat | default \"2006-01-02\" | .Lastmod.Format -}} \u003ci class=\"far fa-calendar-plus fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;\u003ctime datetime=\"{{ . }}\"\u003e{{ . }}\u003c/time\u003e\u0026nbsp; {{- end -}} ","date":"2024-09-13","objectID":"/text26/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"添加友链卡片 为了我们的友链显得更加的好看，这里我们引入友链卡片。 ","date":"2024-09-13","objectID":"/text26/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"添加friend.html文件 在your_site\\layouts\\shortcodes\\路径下，新创建文件friend.html，并且在里面添加如下内容： {{ if .IsNamedParams }} {{- $src := .Get \"logo\" -}} {{- $small := .Get \"logo_small\" | default $src -}} {{- $large := .Get \"logo_large\" | default $src -}} \u003cdiv class=\"friend-div\"\u003e \u003ca target=\"_blank\" href={{ .Get \"url\" | safeURL }} title={{ .Get \"name\" }} \u003e \u003cimg class=\"lazyload\" src=\"/svg/loading.min.svg\" data-src={{ $src | safeURL }} alt={{ .Get \"name\" }} data-sizes=\"auto\" data-srcset=\"{{ $small | safeURL }}, {{ $src | safeURL }} 1.5x, {{ $large | safeURL }} 2x\" /\u003e \u003cspan class=\"friend-name\"\u003e{{ .Get \"name\" }}\u003c/span\u003e \u003cspan class=\"friend-info\"\u003e{{ .Get \"word\" }}\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e {{ end }} ","date":"2024-09-13","objectID":"/text26/:3:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"添加_friend.scss文件 在your_site\\assets\\css\\_partial\\_single\\路径下（如果没有就自己创建），新建文件_friend.scss，并在里面添加如下内容： #article-container { word-wrap: break-word; overflow-wrap: break-word } #article-container a { color: #49b1f5 } #article-container a:hover { text-decoration: underline } #article-container img { margin: 0 auto .8rem } .flink#article-container .friend-list-div \u003e .friend-div a .friend-info, .flink#article-container .friend-list-div \u003e .friend-div a .friend-name { overflow: hidden; -o-text-overflow: ellipsis; text-overflow: ellipsis; white-space: nowrap } .flink#article-container .friend-list-div { overflow: auto; padding: 10px 10px 0; text-align: center; } .flink#article-container .friend-list-div \u003e .friend-div { position: relative; float: left; overflow: hidden; margin: 15px 7px; width: calc(100% / 3 - 15px); height: 90px; border-radius: 8px; line-height: 17px; -webkit-transform: translateZ(0) } @media screen and (max-width: 1100px) { .flink#article-container .friend-list-div \u003e .friend-div { width: calc(50% - 15px) !important } @media screen and (max-width: 600px) { .flink#article-container .friend-list-div \u003e .friend-div { width: calc(100% - 15px) !important } } } .flink#article-container .friend-list-div \u003e .friend-div:hover { background: rgba(87, 142, 224, 0.15); } .flink#article-container .friend-list-div \u003e .friend-div:hover img { -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -o-transform: rotate(360deg); -ms-transform: rotate(360deg); transform: rotate(360deg) } .flink#article-container .friend-list-div \u003e .friend-div:before { position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: -1; background: var(--text-bg-hover); content: ''; -webkit-transition: -webkit-transform .3s ease-out; -moz-transition: -moz-transform .3s ease-out; -o-transition: -o-transform .3s ease-out; -ms-transition: -ms-transform .3s ease-out; transition: transform .3s ease-out; -webkit-transform: scale(0); -moz-transform: scale(0); -o-transform: scale(0); -ms-transform: scale(0); transform: scale(0) } .flink#article-container .friend-list-div \u003e .friend-div:hover:before, .flink#article-container .friend-list-div \u003e .friend-div:focus:before, .flink#article-container .friend-list-div \u003e .friend-div:active:before { -webkit-transform: scale(1); -moz-transform: scale(1); -o-transform: scale(1); -ms-transform: scale(1); transform: scale(1) } .flink#article-container .friend-list-div \u003e .friend-div a { color: var(--font-color); text-decoration: none } .flink#article-container .friend-list-div \u003e .friend-div a img{ float: left; margin: 15px 10px; width: 60px; height: 60px; border-radius: 35px; -webkit-transition: all .3s; -moz-transition: all .3s; -o-transition: all .3s; -ms-transition: all .3s; transition: all .3s } .flink#article-container .friend-list-div \u003e .friend-div a .friend-name { display: block; padding: 16px 10px 0 0; height: 40px; font-weight: 700; font-size: 20px } .flink#article-container .friend-list-div \u003e .friend-div a .friend-info { display: block; padding: 1px 10px 1px 0; height: 50px; font-size: 13px } ","date":"2024-09-13","objectID":"/text26/:3:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"在_single.scss中引入代码 把your_site\\themes\\LoveIt\\assets\\css\\_page\\_single.scss复制粘贴到路径your_site\\assets\\css\\_page\\下。 再在文件your_site\\assets\\css\\_page\\_single.scss里添加如下内容： @import \"../_partial/_single/friend\"; ","date":"2024-09-13","objectID":"/text26/:3:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"调用友链卡片 至此，我们便可以使用如下的shortcodes在我们文章.md的任意地方调用友链卡片了： \u003cdiv class=\"flink\" id=\"article-container\"\u003e \u003cdiv class=\"friend-list-div\" \u003e {{ \u003c friend name=\"友链名称1\" url=\"友链地址1\" logo=\"友链图片链接1\" word=\"友链描述1\" \u003e }} {{ \u003c friend name=\"友链名称2\" url=\"友链地址2\" logo=\"友链图片链接2\" word=\"友链描述2\" \u003e }} \u003c/div\u003e \u003c/div\u003e This is a tip\r不能省略这两个div\r","date":"2024-09-13","objectID":"/text26/:3:4","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"创建友链页面 有了友链卡片，我们最好还要有一个页面来专门放置友链。之前我讲过如何添加关于页面，而其实这次与添加关于页面差不多。 ","date":"2024-09-13","objectID":"/text26/:4:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"创建friend/index.md文件 于终端中来到博客的根目录，我们来创建一个.md文件作为友链页面， 本站友链 friend name=\"Ty Note\" url=\"https://Wangty654.github.io\" logo=\"https://Wangty654.github.io/apple-touch-icon.png\" word=\"一个简单的私人博客网站 (˘◡˘)\" ","date":"2024-09-13","objectID":"/text26/:4:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（四）","uri":"/text26/"},{"categories":["Hugo系列"],"content":"自定义网站图标 ","date":"2024-09-13","objectID":"/text23/:1:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"1. 主页头像 在 blog 根目录下找到文件夹assets，打开该文件夹并新建文件夹images，把我们的主页头像图片avatar.png放到文件夹images中。 在 blog 根目录下找到配置文件config.toml ,在配置文件中找到# 主页配置 -\u003e # 主页显示头像的 URL的参数avatarURL = \"\"。在\"\"中填入主页头像图片在assets下的路径（这里填图片的URL亦可），最后则为avatarURL = \"images/avatar.png\"。 然后我们的 blog 主页就有头像了，如下图： ","date":"2024-09-13","objectID":"/text23/:1:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"2. 网站名前的logo 同前面一样，先将 logo 图标logo.png放到assets/images下。 在配置文件config.toml中找到# 页面头部导航栏配置 -\u003e # LOGO 的 URL的参数logo = \"\"。填入路径后将变为logo = \"images/logo_ico.png\"（当然图片URL亦可）。 This is a tip\r这里我发现，如果使用.png的图片，图片大小控制不好的话,会导致图与文字排列奇怪。图标会将标题顶开一定的位置。 但是如果我们使用.ico的图片，那么这种情况就不会出现。然而logo这个参数本身并不支持.ico图片。因此我们需要把作为 logo 的.ico图片的后缀名改为.png，这样logo才能读取图片文件。 而如果你的 logo 图一开始是.png图片，那么可以通过这个网站在线修改为.ico图片。 然后我们的 blog 就有了显示正常的 logo 了，如下图： ","date":"2024-09-13","objectID":"/text23/:1:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"3. 网站图标 注意与上面不同的是，我们要先将网站图标放到 blog 根目录的static文件夹下，而对于要放什么类型的图标我们有两种选择： 使用.svg后缀的伸缩矢量图形： 如果你的图标是.png文件（其他的类似），则可以通过这个网站，在线地把.png转换为.svg文件。然后把这个.svg文件放到static文件夹即可。 然后在配置文件config.toml中找到# 应用图标配置的参数svgFavicon = \"\"，不妨认为我们的.svg图标名为safari-pinned-tab.svg，那么我们只需修改参数为svgFavicon = \"/safari-pinned-tab.svg\"即可。 使用多尺寸的图标： 我们可以找到 LoveIt 主题文件里的配置文件config.toml（路径为your_blog\\themes\\LoveIt\\config.toml），可以发现svgFavicon参数为空，但是它的官网却也有网站图标。我们观察一下主题自带的exampleSite文件里的static（路径为your_blog\\themes\\LoveIt\\exampleSite\\static），可以发现里面有大小各异的网站图标，如下图： 因此我们可以依葫芦画瓢，在我们 blog 根目录的static文件夹里，放入我们各种大小的网站图标，如下图：（采用此方法，svgFavicon参数一定要为空，且各种大小的图标命名要和官方一致）在这里可以传入你想要的图片，很容易的生成这些文件。 然后我们的 blog 就有网站图标了，如下图： ","date":"2024-09-13","objectID":"/text23/:1:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"文章头的参数 我们在根目录archetypes文件夹下修改的default.md。这个default.md实际是我们每篇文章头（如下图）的模板。 ","date":"2024-09-13","objectID":"/text23/:2:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"tags 此参数意为文章的标签，可以有多个，若要添加多个标签，只需按照如下形式即可（即用\"\"引住标签内容，而,作为标签内容间的分隔）： tags: [\"博客\",\"LoveIt 美化\"] ","date":"2024-09-13","objectID":"/text23/:2:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"categories 此参数意为文章的分类，一篇文章可以同时存在于多个分类下（与 tags 参数类似），若要文章处于多个分类下，只需按照如下形式即可（即用\"\"引住分类名称，而,作为分类名称间的分隔）： categories: [\"Hugo 博客\",\"Markdown\"] ","date":"2024-09-13","objectID":"/text23/:2:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"share 此参数意为是否开启文章底部的分享功能。 ","date":"2024-09-13","objectID":"/text23/:2:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"comment 此参数意为是否开启文章底部的评论功能。 ","date":"2024-09-13","objectID":"/text23/:2:4","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"hiddenFromHomePage 此参数意为是否在主页隐藏本文章。 ","date":"2024-09-13","objectID":"/text23/:2:5","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"hiddenFromSearch 此参数意为是否在搜索时隐藏本文章。 ","date":"2024-09-13","objectID":"/text23/:2:6","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"summary 在主页中显示的对文章的描述性语言，如下图： 但如果不加，如下图： 那么hugo会自动将文章内容前半部分取过来，显示在描述这里，文章描述会很杂乱。 ","date":"2024-09-13","objectID":"/text23/:2:7","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"featuredImagePreview 这个参数为在主页显示的文章配图：我们可以对该参数添加图片URL，那么主页对应文章标题上方便会出现被裁剪后的配图，如下图： 但如果我们不加配图，如下图： 那么主页文章间的分割不明显，且不够花里胡哨。 ","date":"2024-09-13","objectID":"/text23/:2:8","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"featuredImage 这个参数与上个参数类似，但它在为主页添加配图的同时，也将图片（未裁剪的）添加至文章内容的开头，如下图： This is a tip\r加到 featuredImagePreview 中的图片的宽高比尽量为 10:3 ，不然会自动裁剪为 10:3 ，这样有可能损失内容。同时为了使网页背景与图片可区分，我们不要让图片以纯白或深灰为底。我一般选# f6f6f6 或# f6f6ff代替纯白。\r","date":"2024-09-13","objectID":"/text23/:2:9","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"链接和提示框 ","date":"2024-09-13","objectID":"/text23/:3:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"link 如果我们在 Markdown 文件中输入{{ \u003c link \"https://Wangty654.github.io\" \u003e }}，则在网页上会显示为https://Wangty654.github.io。 ","date":"2024-09-13","objectID":"/text23/:3:1","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"admonition 横幅 我们若在任意一个 Mardown 中输入： 则会出现如下效果： This is a tip\r一个 技巧 横幅\r其中参数 admonition type 为横幅的类型，一共有12种，分别为 note，abstract，info，tip，success，question，warning，failure，danger，bug，example，quote（其中默认值为note）。 参数 title 顾名思义是横幅的标题 参数 open 为横幅是否自动打开，默认是 true 打开。 ","date":"2024-09-13","objectID":"/text23/:3:2","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"其他的拓展 Shortcode 具体可见这里，而一些 Hugo 内置的 Shortcode 可见这里 This is a note\r一个 技巧 横幅\rThis is a abstract\r一个 技巧 横幅\rThis is a info\r一个 技巧 横幅\rThis is a tip\r一个 技巧 横幅\rThis is a success\r一个 技巧 横幅\rThis is a question\r一个 技巧 横幅\rThis is a warning\r一个 技巧 横幅\rThis is a failure\r一个 技巧 横幅\rThis is a danger\r一个 技巧 横幅\rThis is a bug\r一个 技巧 横幅\rThis is a example\r一个 技巧 横幅\rThis is a quote\r一个 技巧 横幅\r","date":"2024-09-13","objectID":"/text23/:3:3","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["Hugo系列"],"content":"关于页面 我们的 blog 往往会有一个\"关于\"页面来介绍自己，但我们一开始所给的配置参数并不包含这个页面，因此我们可以来添加该页面。 首先我们要在终端中来到 blog 的根目录，执行下面命令，在content文件夹下创建一个about文件夹，并使其有文件index.md。一般读取都是读取路径包下的index.md文件，若没有多个文件，也可以建成单独的about.md 这个index.md或者about.md就是我们的\"关于\"页面。 然后我们还要在菜单栏配置中添加\"关于\"这一栏。在 blog 根目录下找到 config.toml,再在该配置下找到# 菜单配置，在这一项下添加： [[menu.main]] name = \"关于\" # weight 参数可以看做菜单栏上各项的排序，越大的排在电脑网页的越右边 weight = 4 identifier = \"about\" url = \"/about/\" title = \"About\" 这样，“关于\"页面就创建好了。 ","date":"2024-09-13","objectID":"/text23/:4:0","tags":["hugo"],"title":"【HUGO】Hugo的LoveIt主题美化（一）","uri":"/text23/"},{"categories":["前端"],"content":"第1章：Vue核心 ","date":"2024-08-21","objectID":"/vue2/:0:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"1.vue简介： vue是一套用于构建用户界面的渐进式javaScript框架 This is a tip\rvue可以自底向上逐层的应用 简单应用：只需要一个轻量小巧的核心库 复杂应用：可以引入各式各样的vue插件 This is a warning\rvue2.0发布于2016年10月1日，vue3.0发布于2020年9月18日\r","date":"2024-08-21","objectID":"/vue2/:1:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"vue的特点： 组件化 采用组件化模式，提高代码复用率、且让代码更好维护 声明式 声明式编码，让编码人员无需直接操作DOM，提高开发效率 说明： 当有一个需求如下，需要将数据persons，放入容器list中： //数据persons [ {id:'001',name:'张三',age:18}, {id:'002',name:'李四',age:19}, {id:'003',name:'王五',age:20} ] //list \u003cul id=\"list\" \u003e\u003c/ul\u003e 效果为： 命令式编码实现方式： 原生javaScript写法 //准备html字符串 let htmlStr = '' //遍历数据拼接html字符串 persons.forEach( p =\u003e{ htmlStr += `\u003cli\u003e${p.id} - ${p.name} - ${p.age}\u003c/li\u003e` }); //获取list元素 let list = document.getElementById('list') //修改内容(亲自操作Dom) list.innerHTML = htmlStr 声明式编码实现方式： \u003cul id=\"list\" \u003e \u003cli v-for=\"p in persons \"\u003e {{p.id}} - {{p.name}} - {{p.age}} \u003c/li\u003e \u003c/ul\u003e 虚拟dom 3.使用虚拟DOM+优秀的Diff算法，尽量复用DOM节点 This is a tip\rdiff算法： 新生成的虚拟dom会和之前生成的虚拟dom比较，这个比较算法称为diff算法。 当新的虚拟dom中，存在与旧dom中相同的属性和内容值时， vue就直接将旧的真实dom直接拿到页面渲染出来，再处理不同的部分 ​ 原生js 4.学习vue之前需要掌握的javaScript基础知识 ES6语法规范：结构赋值、模板字符串、箭头函数等。ES6基础-久远银海内部链接 ES6模块化：默认暴露、分别暴露、统一暴露、import、isport等 包管理器：npm、yram、cnpm 原型、原型链： 数组常用方法：过滤一个数组、加工一个数组、筛选最值 axios： promise：异步请求 ​ ","date":"2024-08-21","objectID":"/vue2/:1:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"2. vue官网使用指南 地址：vue官网操作手册 ​ ","date":"2024-08-21","objectID":"/vue2/:2:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"3.搭建vue开发环境 在没有脚手架的情况下，最原始的使用vue框架，就是在.html 文件中，引入vue.js包 \u003c!-- 开发环境版本，包含了有帮助的命令行警告 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js\"\u003e\u003c/script\u003e 或者 \u003c!-- 生产环境版本，优化了尺寸和速度 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2\"\u003e\u003c/script\u003e 在vue2的官方文档中，解释了两种引入vue的方式 ","date":"2024-08-21","objectID":"/vue2/:3:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"script直接引入 首先先看第一种安装vue的方式： CDN：阿里云CND操作文档 我们在写script的时候，里面有一个属性，叫src，可以指定资源的位置 如果把src写成：\"./xxx\"的形式，为引入一个本地文件。如果写成\"https\"的形式，一般为了加速，会在其中加入一个CDN的标识 This is a tip\rCDN 内容分发网络（Content Delivery Network，CDN）是建立并覆盖在承载网上，由不同区域的服务器组成的分布式网络。将源站资源缓存到全国各地的边缘服务器，供用户就近获取，降低源站压力。 官网两个vue版本，点击后均会进行下载，但下载的文件有些不同 为方便演示，将两个版本均下载在桌面，并新建一个文件夹取名为vue_basic，并用vscode打开 将引入写入html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e初识Vue\u003c/title\u003e \u003c!-- 引入vue --\u003e \u003cscript type=\"text/javascript\" src=\"../js/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-08-21","objectID":"/vue2/:3:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"控制台提示 直接引入产生的控制台提示 打开写好的html页面，在控制台会出现两个小提示 提示解析： Download the Vue Devtools extension for a better development experinence: //表示：请你下载vue的开发者工具，到达一个更好的开发体验 You are running Vue in development mode. //表示：你正在运行一个开发者模版的vue. Make sure to turn on production mode when deploying for production. //请确认你的项目不在生产时使用 [此句话意思表明，你引入的是vue.js其中带有很多提示和警告，包比较大，不适合上线项目使用] 开发者工具 解决 下载vue开发者工具 的问题 国外网络可以正常访问谷歌商城： 正常能打开gitHub，点击官网的下载链接过去，选择谷歌浏览器选项 进入谷歌网上应用商店，点击添加，完成 国内无法正常访问谷歌商城： Vue开发者工具扩展链接： 【下载开发者工具】： https://pan.baidu.com/s/1MtYvMPew4lb14piIrs9x6w 提取码：6666 【安装开发者工具】： 一、Chrome浏览器安装方式： ①：点击右上角三个点 ②：点击更多工具 ③：点击扩展程序 ④：点击右上角的开发者模式，将他启用 ⑤：将下载的Vue.crx文件直接拖动到浏览器窗口即可 ⑥：点到扩展的详细信息界面，再开启【允许访问文件URL】选项再试试看 二：Edge浏览器安装方式 ①：点击浏览器右上角的三个点 ②：点击扩展 ③：点击左下角的开发人员模式，将他启用 ④：将Vue.crx文件拖动到浏览器即可 解决 vue.js不建议在上线项目中使用的提示 Vue.config 是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列 property(属性) 首先验证，Vue.config 是否存在： 这里的属性，是对vue的全局配置。一次修改，到处都可以使用。 此处的：productionTip: true 小提示默认为true，是默认开启状态 代码的body中键入下方代码，可以对提示进行关闭： \u003cbody\u003e \u003c!--关闭生产提示--\u003e \u003cscript type=\"text/javascript\"\u003eVue.config.productionTip = false\u003c/script\u003e \u003c/body\u003e 【注意：上方代码如果失效，则进入vue.js文件，直接对productionTip属性进行修改为false】 开端开发编辑工具vscode下载地址：开端开发编辑工具vscode下载地址 ​ ","date":"2024-08-21","objectID":"/vue2/:3:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"4. Hello小案例 ","date":"2024-08-21","objectID":"/vue2/:4:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"html的基础写法 hello代码示例 【注意：此段代码是html的基础写法，并没有用到vue】 \u003cbody\u003e \u003c!-- 准备一个容器 --\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003c/div\u003e \u003c/body\u003e ","date":"2024-08-21","objectID":"/vue2/:4:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Live Server 插件运行 右键打开页面，控制台错误如下： favicon.ico - 指网站的页签图标 打开控制台的Network选项卡，强制刷新一下[ 按住shift 点击刷新]，可以看见请求了本地5500服务器访问该图标 关于本地5500服务器的解释说明： 在vscode中，右键，使用Live Server 插件打开的页面：Live Server会自动先帮你打开当前选择的这个页面，并在你的电脑的5500的端口上开了一台小型的内置服务器，并且进行了“把你所有工程的文件和文件夹，作为这个服务器的根资源去使用”的一个操作。 验证内置5500端口服务器，可以地址栏直接访问127.0.0.1:5500。显示的一定是当前工程下的所有文件夹。 解决图标访问404的问题，只需要在根目录中放置一个叫favicon.ico的图片文件，页面刷新即可 This is a tip\rlive server 插件是一个具有实时加载功能的小型服务器，它的作用： 模拟服务器的方式打开页面 代码改动后,会自动刷新页面 vsCode中装Live Server插件。 ","date":"2024-08-21","objectID":"/vue2/:4:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"vue的写法演示 使用vue进行hello的显示 理解：引入的vue相当于外部引入的一个函数。要使用vue函数，需要new Vue \u003c!-- 准备一个容器 --\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e //创建Vue实例 /* * 注意Vue()中只传一个参数，这个参数是一个配置对象{} * 配置对象中，都以 key : value 的形式书写 * 配置对象中，key的名称不得更改，value的值必须符合key的数据类型 */ const x = new Vue({ //vue的第一个key是el，el是element元素的简写。 //键值对象类似于css中的id选择器 //el用于指定当前Vue实例为哪个容器，值通常为css选择器字符串。 el:'#root' //还有一种写法，一般不用，但是可以这样写 //指 人为找到这个元素，再给他配置到el里去 el:document.getElementById('root') }) \u003c/script\u003e \u003c!-- 如果用class不用id --\u003e \u003cdiv class=\"root\"\u003e \u003ch1\u003eHello\u003c/h1\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const x = new Vue({ //el就写成css中类选择器的写法 el:'.root' }) \u003c/script\u003e 利用插值语法 \u003c!-- 如果用class不用id --\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello,{{name}}\u003c/h1\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const x = new Vue({ el:'#root', data:{ //data中用于存储数据，数据供el所指定的容器去使用 name:'wangty' } }) \u003c/script\u003e 注意：data中的数据需要在指定的容器中使用，没在容器中使用data内数据并不会生效 This is a tip\r三个注意事项： 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；目前这里为：el、data root容器里的代码依然符合html规范，只不过混入一些特殊的Vue语法； root容器里的代码被称为【Vue模版】 对于vue模版的解释： 我们写的为一个Vue模板，经过解析，形成一个全新的正常的html片段块，然后替换掉模板的位置，显示在页面上 容器的作用： 1、为Vue提供模板 2、把Vue解析后的html片段，指定位置放置 ​ ","date":"2024-08-21","objectID":"/vue2/:4:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"5. 分析Hello案例 ","date":"2024-08-21","objectID":"/vue2/:5:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"一对一关系 演示说明：容器和实例是一对一，一一对应关系 有两个同名的容器的情况： 首先，能运行成功，且控制台不报错 说明，一个Vue实例不能同时接管两个容器 有两个Vue实例指向同一个容器的情况： 首先，第一个Vue内容显示正常，第二个内容不显示，且控制台报错 说明，一个容器只能被一个Vue实例接管和解析 ","date":"2024-08-21","objectID":"/vue2/:5:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"{{ }} 中为js表达式 This is a tip\r注意：{{ }} 中可以写的内容，不一定是Vue实例中声明过的。只要是js里的表达式，Vue都是可以解析的\r注意区分:js表达式 和js代码(语句) ​ 1.表达式: 一个表达式会生成一个值，可以放在任何一个需要值的地方: ​ (1).a ​ (2).a+b ​ (3).demo(1) ​ (4).x === y ? ‘a’ : ‘b’ ​ 2.js代码(语句) ​ (1).if( ){ } ​ (2).for( ){ } ","date":"2024-08-21","objectID":"/vue2/:5:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue的开发者工具 打开控制台右侧Vue选项卡 Root这里代表唯一的那一个Vue实例，点击这里的Root，能看的data里的所有数据 点击配置对象旁边的编辑按钮，可以对其值进行修改 \u003c!-- 前端小写内容全部转换为大写的方法使用 .toUpperCase() --\u003e \u003ch1\u003e{{name.toUpperCase()}} \u003c/h1\u003e //name:'wangty' // WANGTY ","date":"2024-08-21","objectID":"/vue2/:5:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生产包和开发包 关于 vue.js 和vue.min.js 在new Vue实例对象时候的区别 当不写new的时候，vue.js： 当不写new的时候，vue.min.js并不报这个warning ","date":"2024-08-21","objectID":"/vue2/:5:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"6. 模板语法 ","date":"2024-08-21","objectID":"/vue2/:6:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"6.1 插值语法 把指定的值，放到指定的位置，使用方法，见上述hello案例 【注意：插值语法多用于指定标签体内容。即，两标签之间的内容。不可以用于标签属性和属性值】 ","date":"2024-08-21","objectID":"/vue2/:6:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"6.2 指令语法（内置语法） 【注：指令语法小结示例里包含了很多后面的东西，建议先跳过看完后面再看这一节比较好理解】 普通html，点击跳转地址写法 \u003ca href=\"https://www.baidu.com\"\u003e点我去百度\u003c/a\u003e v-bind vue写法 \u003cdiv id=\"root\"\u003e \u003ch1\u003e指令语法\u003c/h1\u003e \u003ca :href=\"url\"\u003e点我去百度\u003c/a\u003e \u003c!--等价于\u003ca v-bind:href=\"url\"\u003e点我去百度\u003c/a\u003e --\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root' , data:{ url:'https://www.baidu.com' //注意，这里如果写两个一模一样的属性名，控制台不会报错 //Vue会默认读取第二个属性名的内容，这里就会默认跳转淘宝 //url:'https://www.taobao.com' } }) \u003c/script\u003e 注意：这里的 “:href\"中的冒号，是v-bind的简写。我们把类似于v-bind这样的语法称为，指令语法。 This is a tip\r在html标签中，如果标签中的属性没有使用指定语法，则就是普通的属性和属性值 如果使用了指定语法，Vue就会把属性值引号内的东西，取出来当做表达式进行执行 Class 与 Style 绑定 操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是 attribute，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 绑定样式: 1.class样式 ​ 写法:class=“xxx”xxx可以是字符串、对象、数组。 ​ 字符串写法适用于: 类名不确定，要动态获取。 ​ 对象写法适用于: 要绑定多个样式，个数不确定，名字也不确定。 ​ 数组写法适用于:要绑定多个样式，个数确定，名字也确定，但不确定用不用。 ​ 2.style样式 ​ :style=\"{fontSize:xxx}“其中xxx是动态值。 ​ :style=\"[a,b]“其中a、b是洋式对象 绑定class样式 \u003c!--正常的样式正常写，绑定的样式传值，字符串写法--\u003e \u003cdiv class=\"basic\" :class=\"normal\"\u003e\u003c/div\u003e .... data(){ normal:'red' } .... \u003c!--html解析后显示为 class=\"basic red\"--\u003e \u003c!----------------------------或者--------------------------------\u003e \u003c!--正常的样式正常写，绑定的样式传值，数值写法--\u003e \u003cdiv class=\"basic\" :class=\"arr\"\u003e\u003c/div\u003e .... data(){ arr:['red'，'yellow'，'buld'] } .... \u003c!--html解析后显示为 class=\"basic red yellow buld\"--\u003e \u003c!--按钮事件动态操作arr数组可以实现样式的改变--\u003e \u003c!----------------------------或者--------------------------------\u003e \u003c!--正常的样式正常写，绑定的样式传值，对象写法--\u003e \u003cdiv class=\"basic\" :class=\"Obj\"\u003e\u003c/div\u003e .... data(){ Obj:{ red:false, yellow:false } } .... \u003c!--按钮事件动态操作Obj对象可以实现样式的改变--\u003e 绑定style样式 v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名： \u003cdiv v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"\u003e\u003c/div\u003e data: { activeColor: 'red', fontSize: 30 } 直接绑定到一个样式对象通常更好，这会让模板更清晰： \u003cdiv v-bind:style=\"styleObject\"\u003e\u003c/div\u003e data: { styleObject: { color: 'red', fontSize: '13px' } } 同class一样，也可以写成数组，v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上： \u003cdiv v-bind:style=\"[baseStyles, overridingStyles]\"\u003e\u003c/div\u003e v-model 数据绑定 \u003cdiv id=\"root\"\u003e 单项数据绑定：\u003cinput type=\"text\" v-bind:value=\"name\"\u003e \u003cbr/\u003e 双向数据绑定：\u003cinput type=\"text\" v-model:value=\"name2\" \u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root' , data:{ name:'wangty', name2:'wangty', } }) \u003c/script\u003e 页面效果： Vue中有2种数据绑定的方式: 1.单向绑定(v-bind):数据只能从data流向页面, 2.双向绑定(v-model):数据不仅能从data流向页面，还可以从页面流向data。 只适用于表单元素 注意：不是任意的所有的地方都能使用v-model来进行双向绑定 例： \u003cdiv id=\"root\"\u003e \u003ch3 v-bind:x=\"name\"\u003ewangty\u003c/h3\u003e \u003ch3 v-model:x=\"name\"\u003ewangty\u003c/h3\u003e \u003c!-- 该行代码是有问题的 --\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root' , data:{ name:'wangty', } }) \u003c/script\u003e 上面的几行代码，首先在页面查看效果如下： 说明：v-model只能应用在表单元素上（输入类元素，有value值的元素）。 简写形式 和v-bind一样，v-model有他的简写形式 \u003c!-- v-bind简写 --\u003e \u003cinput type=\"text\" v-bind:value=\"name\"\u003e 等价于 =====\u003e \u003cinput type=\"text\" :value=\"name\"\u003e ---------------------------------------------------------------------- \u003c!-- v-model简写 --\u003e \u003cinput type=\"text\" v-model:value=\"name2\" \u003e 等价于 =====\u003e \u003cinput type=\"text\" v-model=\"name2\" \u003e v-on 事件处理 事件的基本使用: 1.使用v-on:xxx或@xxx定事件，其中xxx是事件名; ​ 2.事件的回调需要配置在methods对象中，最终会在vm上; ​ 3.methods中配置的的数，不要用箭头函数。否则this就不是vm了; ​ 4.methods中配置的的数，都是被Vue所管理的函数，this的指向是vm或组件实例对象 ​ 5.@click=“demo\"和 @click=“demo($event)”效果一致，但后者可以传参; \u003cdiv id=\"root\"\u003e \u003ch1\u003eHello,{{name}} \u003c/h1\u003e \u003c!-- 简写形式 v-on:click =====\u003e 等价于 @click --\u003e \u003cbutton v-on:click=\"showInfo\"\u003e点击实现提示信息\u003c/button\u003e \u003cbutton @click=\"showInfo\"\u003e点击实现提示信息\u003c/button\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e //创建Vue实例 new Vue({ el:'#root', data(){ return{} }, //注意showInfo需要放在methods里。 //这儿有个问题：可不可以放进data里呢？ 是可以的。 //能够正常运行，且控制台不报错。但是会被Vue执行数据代理，加重Vue的负荷。 methods:{ //注意这里的showInfo方法也会存储在vm身上，打印vm时可以看见 showInfo(a,b,c,d){ //alert(\"提示\"); console.log(a,b,c,d); } } }) \u003c/script\u003e 方法写在data里的情况，会使得vm对此方法进行数据代理。详解请看【数据代理】小结。 所以我们一般写点击事件只传一个参数，格式写为 showInfo(event){ console.log(event); //获取点击时间的触发目标，一般指按钮对象 //使用event.target console.log(event.target.innerText); //按钮名称 //这里的this也是Vue实例 //这里showInfo如果写成箭头","date":"2024-08-21","objectID":"/vue2/:6:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"7. el与data的两种写法 我们知道，Vue实例和容器之间是通过el属性进行关联的，如果不写el，则标签引用的Vue数据不会被解析，如下面这段代码： \u003c!-- 如果不写el,则Vue不工作，name不被解析 --\u003e \u003cdiv id=\"root\"\u003e \u003ch3\u003e{{name}}\u003c/h3\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ //el:'#root' ,将该行代码注释，页面不解析name，且控制台不报错 data:{ name:'wangty', } }) \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:7:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"v.$mount(’’) 那么有没有什么办法能替代el，使得Vue工作呢 \u003cdiv id=\"root\"\u003e \u003ch3\u003e{{name}}\u003c/h3\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const v = new Vue({ //我们使用一个恒定不变的对象来承接整个Vue实例，取名叫v data:{ name:'wangty', } }) console.log(v); //打印这个v，我们能够看到整个Vue的实例对象 v.$mount('#root') //使用Vue实例的$mount方法，指向root容器，以实现解析和挂载 \u003c/script\u003e 在控制台，这是我们第一个看见Vue的整个实例对象 通过这种写法，我们可以很容易的控制Vue解析页面的时间 //让Vue等一秒钟，再进行页面的解析 setTimeout(()=\u003e{ v.$mount('#root') },1000) 图解 ","date":"2024-08-21","objectID":"/vue2/:7:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"data函数式写法 在Vue实例中，我们把data: { }，这种写法形式称为对象式写法，花括号{}里包含的是对象属性。 除此之外，data在Vue实例里还能写成函数的形式： new Vue({ //data的第一种写法：对象式 data:{ name:'wangty', } //data的第二种写法：函数式 data:function(){ return{ name:'wangty' } } }) ","date":"2024-08-21","objectID":"/vue2/:7:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"关于this 注意：这里的data函数不是我们手动调用的，是Vue帮我们调用的 在这里我们打印输入一下，data方法中的this new Vue({ data:function(){ console.log(\"this\",this); return{ name:'wangty' } } }) 这里this指向的是整个Vue实例对象 注意，如果把data写成箭头函数，例： new Vue({ data:()=\u003e{ console.log(\"this\",this); return{ name:'wangty' } } }) 这里的this指向就会有问题，就会指向全局的window。（箭头函数是没有自己的this的，他默认就会向外去找指向，就会找到外层全局的window，当做他的this去使用） ","date":"2024-08-21","objectID":"/vue2/:7:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"简写形式 我们通常写普通的函数时，一般用（）来代替:function()，所以写成： new Vue({ //data:function() =====\u003e 等价于 =====\u003e data() data(){ console.log(\"this\",this); return{ name:'wangty' } } }) This is a tip\r注意：由Vue所管理的函数，一定不能写成箭头函数，例：data()，watch()，computer()等\r","date":"2024-08-21","objectID":"/vue2/:7:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"8. 理解MVVM Vue在最初的设计的时候，很大程度上参考了MVVM模型官网解释地址 1.M：模型（Model) :对应 data 中的数据 2.V：视图(View):模板 3.VM：视图模型(ViewModel)：Vue 实例对象 这块注意有个现象：写在data里的属性，会同步出现在Vue实例对象的属性里面，原理我们在数据代理时会进行阐述。 同时{{ }}中，Vue实体内中能够看到的所有属性，也能够使用 【Vue实体内的所有属性，Vue模板都可以使用】 例如： \u003ch1\u003e{{$options}}\u003c/h1\u003e \u003ch1\u003e{{$emit}}\u003c/h1\u003e \u003ch1\u003e{{_c}}\u003c/h1\u003e ","date":"2024-08-21","objectID":"/vue2/:8:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"9. Object.defineProperty 数据劫持、数据代理、计算属性，的底层均用到了Object.defineProperty这个方法 作用：给一个方法或者一个对象定义属性 用法：Object.defineProperties(操作的对象名,‘添加的属性名’,{配置项键值对}) \u003cscript type=\"text/javascript\"\u003e let person = { name:'wangty', address:'chengdu' } //给person对象添加一个属性，叫age，值为18 Object.defineProperty(person,'age',{ value:18 }) console.log(person); \u003c/script\u003e 注意这块添加进去的age属性，在控制台的呈现样子 这个颜色的区别，表示这个age不可以被枚举，及age这个属性不参与遍历 ","date":"2024-08-21","objectID":"/vue2/:9:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"enumerable配置项 //我们通过Object的keys方法对其进行验证 // Object.keys()传入一个对象，将对该对象的属性名进行提取，并拼合成一个数组 console.log(Object.keys(person)); 这里可以明显看到，没有age属性 如果想让age属性能够正常被遍历和枚举，我们引入defineProperty中的另一个配置项enumerable //enumerable可枚举的，默认为false Object.defineProperty(person,'age',{ value:18, enumerable:true }) ","date":"2024-08-21","objectID":"/vue2/:9:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"writable配置项 我们在控制台分别操作一下name属性和age属性，再次打印，我们发现age并不能操作成功 这说明defineProperty设置的属性的属性值是不能被修改的 若要使其同正常属性一样能够修改其属性值，则需要使用另一个配置项writable //writable 能否被修改，默认为false Object.defineProperty(person,'age',{ value:18, writable:true }) console.log(person); ","date":"2024-08-21","objectID":"/vue2/:9:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"configurable配置项 我们对属性进行删除操作，这里同样操作name和age： 这说明defineProperty设置的属性的属性值是不能被删除的 若要使其同正常属性一样能够删除，则需要使用另一个配置项configurable //configurable能否被删除，默认为false Object.defineProperty(person,'age',{ value:18, configurable:true, }) console.log(person); ","date":"2024-08-21","objectID":"/vue2/:9:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"getter get函数 当我有一个从变量number中获取年龄的age需求时，希望：当变量发生变化时，年龄属性也同步发生变化。 \u003cscript type=\"text/javascript\"\u003e let number = 18 let person = { name:'wangty', address:'chengdu' } Object.defineProperty(person,'age',{ //注意简写： //get:function() ========\u003e 等价于 get() get:function(){ //当有人读取person的age属性时，get函数就会被调用,且返回值就是age的值 return 'hello' //设置成变量 //return number } }) console.log(person); \u003c/script\u003e 控制台效果为： 注意：每一次使用或者涉及读取age这个属性的时候，都会现调用getter ","date":"2024-08-21","objectID":"/vue2/:9:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"setter 和getter相同的，有一个控制写入的配置项函数，set函数 //当有人修改person的age属性时，set函数就会被调用,且入参是修改的age值 set(value){ console.log(\"有人修改age,且修改值为：\"+value); number = value } ","date":"2024-08-21","objectID":"/vue2/:9:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"10.数据代理 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写） 例： \u003cscript type=\"text/javascript\"\u003e let obj={x:100} let obj2 ={y:200} 0bject.defineProperty(obj2,'x',{ get(){ return obj.x }， set(value){ obj.x = value }) \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:10:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue中的数据代理 1.Vue中的数据代理: 通过vm对象来代理data对象中属性的操作(读/号) 2.Vue中数据代理的好处: 更加方便的操作data中的数据 3.基本原理: 通过object.defineProperty()把data对象中所有属性添加到vm上。 为每一个添加到vm上的属性，都指定一个getter/setter。 在getter/setter内部去操作(读/号)data中对应的属性 这个时候我们来看MVVM小结里的Vue实例中的现象，就很好理解： 首先，Vue在设置data方法的时候，将data内的数据复制了一份，放进了Vue实例对象的_data里 此时使用设置的name，可以用_data.name。 此时还没有进行数据代理。 然后，Vue对所有的data内属性和值使用数据代理，在Vue实体中添加name等属性，自动为其设置getter、setter方法，使得： vm._data.name = vm.name 此时：vm._data = options.data = data 【注意后面这个=成立需要将data要放到整个全局】 关于_data 注意：这块展开_data能够看到和vm中一样的结构，但他并不是数据代理，他主要用来监听data内容变化，用于影响页面解析显示 Vue中的数据劫持主要是通过ES6的Object.defineProperty()方法来实现。Vue会遍历data选项中的属性，并使用Object.defineProperty()将它们转为带有getter和setter的属性，这样Vue就能监控和响应数据的变化。 数据劫持：我们把原始的data内容，复制后增加了getter和setter方法用于数据监测的这种改写和加工操作，称为数据劫持。 ","date":"2024-08-21","objectID":"/vue2/:10:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"11.Computed ","date":"2024-08-21","objectID":"/vue2/:11:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"姓名案例 \u003c!-- 写一个姓名案例：实现输入框输入姓名的时候，自动拼成全名 --\u003e \u003cdiv id=\"root\"\u003e 姓：\u003cinput type=\"text\" v-model=\"xing\"\u003e 名：\u003cinput type=\"text\" v-model=\"ming\"\u003e \u003c!-- 插值语法的正常写法 --\u003e 全名：\u003cspan\u003e{{xing}} - {{ming}}\u003c/span\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e new Vue({ el:'#root', data(){ return{ xing:'wang', ming:'ty' } }, }) \u003c/script\u003e 页面效果为 这个时候，当input内无限输入姓名的长度，却只取前4位时，插值的写法 \u003c!-- 当需求越复杂，插值语法中的内容就越多 --\u003e \u003c!-- 这种写法不报错，但是不推荐 --\u003e 全名：\u003cspan\u003e{{xing.slice(0,3)}} - {{ming}}\u003c/span\u003e 在Vue官方文档中，风格指南中明确表示，组件模板中应当只包含简单表达式： methods的写法： \u003c!-- fullName不加()返回的是整个函数体 --\u003e \u003c!-- fullName加()返回的是return里的东西 --\u003e 全名：\u003cspan\u003e{{fullName()}}\u003c/span\u003e methods:{ fullName(){ //return 'wangty' return this.xing +'-'+this.ming } } ","date":"2024-08-21","objectID":"/vue2/:11:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"计算属性 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e computed:{ fullName:{ \u003c!-- get原理和defineProperty一样 --\u003e get(){ return 'wangty' } } } 计算属性加载后依旧会放在vm中 在Vue开发者工具的结构中也能够很清晰的区分普通属性和计算属性 Vue对计算属性的缓存处理： \u003c!-- 写一个姓名案例：实现输入框输入姓名的时候，自动拼成全名 --\u003e \u003cdiv id=\"root\"\u003e 姓：\u003cinput type=\"text\" v-model=\"xing\"\u003e 名：\u003cinput type=\"text\" v-model=\"ming\"\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第一次调用 --\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第二次调用 --\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第三次调用 --\u003e 全名：\u003cspan\u003e{{fullName}}\u003c/span\u003e\u003c!-- 第四次调用 --\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ el:'#root', data(){ return{ xing:'wang', ming:'ty' } }, computed:{ fullName:{ //有人读取fullname时，被调用 get(){ console.log(\"get被调用\"); return this.xing + '-' + this.ming } } } }) \u003c/script\u003e 注意控制台，这个地方对get的调用只调了一次！ 实际上，在第一次调用fullName属性的时候，Vue向计算属性要了返回结果，并进行了缓存处理。在后面再次请求fullName属性的时候，直接使用了缓存中的值。 那么这个缓存在数据变化时是否会对显示造成影响呢？是不会的。 计算属性中的get有两个被调用时机： ​ 1、初次读取fullName属性时 ​ 2、当依赖的数据发生变化时 此处就可以区分methods写法和computed写法之间的优劣了。对的，methods会反复调用！！ \u003cscript type=\"text/javascript\"\u003e ..... ,computed:{ fullName:{ //有人读取fullname时，被调用 get(){ console.log(\"get被调用\"); return this.xing + '-' + this.ming }, //有人修改fullname时，被调用 //传入value为‘李-四’ set(value){ console.log(\"set被调用,被修改的值：\",value); const arr = value.split('-') this.xing = arr[0]; this.ming = arr[1]; } } }, ....... \u003c/script\u003e 计算属性总结： 1.定义：要用的属性不存在，要通过已有属性计算得来。 2.原理：底层借助了objcet.defineproperty方法提供的getter和setter。 3.get函效什么时候执行？ （1）.初次读取时会执行一次。 （2）.当依赖的数据发生改变时会被再次调用。 4.优势：与methods实现相比。内部有缓存机制（复用），效奉更高，调试方便。 5.备注： 1.计算属性最终会出现在vm上，直接读取使用即可。 2.如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生 ","date":"2024-08-21","objectID":"/vue2/:11:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"计算属性 简写 通常情况下，我们多使用计算属性的读取，不怎么使用修改。当确定计算属性只读不改时： 我们简化计算属性的写法： 1、删除掉set方法； 2、将fullName由对象写法改成函数写法： ​ fullName:{ } ===\u003e fullName:function( ){ } ===\u003e fullName(){ } ​ 并将这个函数，当作get函数使用 \u003cscript type=\"text/javascript\"\u003e ..... ,computed:{ fullName(){ return this.xing + '-' + this.ming }, }, ....... \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:11:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"12.watch ","date":"2024-08-21","objectID":"/vue2/:12:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"天气案例 \u003c!-- 写一个按钮点击后，实现页面天气的切换，并且输出切换前的天气和切换后的天气 --\u003e \u003cdiv id=\"root\"\u003e \u003ch3\u003e今天天气很{{info}}\u003c/h3\u003e \u003cbutton @click=\"isHost = !isHost\"\u003e点击切换天气\u003c/button\u003e \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ el:'#root', data(){ return{ isHost:true, } }, methods:{ }, computed:{ info(){ return this.isHost? '炎热':'凉爽' } } }) \u003c/script\u003e 效果是，点击按钮，天气能在炎热凉爽之间来回切换 注意：这样的写法，在Vue开发者工具上会有个bug \u003cdiv id=\"root\"\u003e \u003c!-- 当我将下面这行代码 --\u003e \u003ch3\u003e今天天气很{{info}}\u003c/h3\u003e \u003c!-- 改为 --\u003e \u003ch3\u003e今天天气很一般\u003c/h3\u003e ..... \u003c/div\u003e \u003cscript type=\"text/javascript\"\u003e .... ,computed:{ info(){ return this.isHost? '炎热':'凉爽' } }, .... \u003c/script\u003e 此处，computed中info的属性依旧随着isHost值的变化，而计算了 但是在Vue开发者工具中却并不能提现。但是我们可以通过vm验证，计算属性是变化了的。 即，当页面没有使用计算属性和基本属性的时候，Vue开发者工具，就不更新data中被修改的基本属性的值了。但是实际上vm中的data属性值和计算属性值都是被更改了的。 此处属于Vue开发者工具的一个小坑，后续可能Vue开发者工具会进行维护。 ","date":"2024-08-21","objectID":"/vue2/:12:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"监视属性 \u003cscript type=\"text/javascript\"\u003e new Vue({ ..... ,watch:{ //isHost：监视谁，这儿就写谁的名字，这里指监视isHost的变化 isHost:{ //handler函数什么时候调用？在isHost被修改的时候。 handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //初始化时是否执行handler,默认为false immediate:true } }, }) \u003c/script\u003e 控制台效果 第二种写法，可以通过Vue实例对象，实现效果都是一样的 \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ ........ }) //注意这里监视对象要加''引号。里面的配置项内容和watch里的写法一样 vm.$watch('isHost',{ handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //immediate:true }) \u003c/script\u003e 监视属性watch 1.当被监视的属性变化时，回调函数自动调用，进行相关操作 2.监视的属性必须存在，才能进行监视！！ 没有不会报错，但是监视前后数据都是undefined 3.监视的两种写法： （1）. new Vue时传入watch配置 ​ （2）. 通过vm.$watch监视 ","date":"2024-08-21","objectID":"/vue2/:12:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"深度监视 深度监视： （1）Vue中的watch默认不监测对象内部值的改变（一层）。 （2）配置deep:true可以监测对象内部值改变（多层）。 备注： （1）Vue自身可以监测对象内部值的改变，但vue提供的watch默认不可以！ （2）使用watch时根据数据的具体结构，决定是否采用深度监视。 \u003cscript type=\"text/javascript\"\u003e const vm = new Vue({ el:'#root', data(){ return{ number:{ a:1, b:1 } } }, watch:{ //监视多级结构中，某个属性的变化 'number.a':{ handler(){ console.log('a被修改了'); }, } }, }) \u003c/script\u003e 注意：这块儿监视的number是指number：{ }对象所在的地址值 如果写成watch：{ number：{ } } 地址永远不会变化，则永远不会触发监听。 如果想要监视到number中任意一个值变化，那么需要加上监视穿透deep \u003cscript type=\"text/javascript\"\u003e ........., watch:{ number:{ deep:true, handler(){ console.log('a被修改了'); }, } }, ....... \u003c/script\u003e 注意：这块两个概念，Vue实例是可以监测到多层级数据中属性的变化的，这个可以在控制台通过打印vm验证。只是Vue提供给开发者的watch属性中，无法直接监测到多层级数据的变化，需要设置默认检测层级或者使用deep。 ","date":"2024-08-21","objectID":"/vue2/:12:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"监视的简写形式 如果监视的对象不适用其他配置项，例如deep，immediate等，只使用handler，可简写成： \u003cscript type=\"text/javascript\"\u003e ........., watch:{ //正常写法 isHost:{ handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //简写，isHost对象式写成函数式，当handler用 isHost(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, }, ....... \u003c/script\u003e 或者 \u003cscript type=\"text/javascript\"\u003e ........., //正常写法 vm.$watch('isHost',{ handler(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }, //deep:true //immediate:true }) //简写 vm.$watch('isHost',function(newValue,oldValue){ console.log('isHost被修改了',newValue,oldValue); }) ....... \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:12:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"13.watch对比computed 计算属性 vs 侦听属性 Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子： \u003cdiv id=\"demo\"\u003e{{ fullName }}\u003c/div\u003e var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' }, watch: { firstName: function (val) { this.fullName = val + ' ' + this.lastName }, lastName: function (val) { this.fullName = this.firstName + ' ' + val } } }) 上面代码是命令式且重复的。将它与计算属性的版本进行比较： var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar' }, computed: { fullName: function () { return this.firstName + ' ' + this.lastName } } }) 好得多了，不是吗？ 我们发现，好多功能在使用watch和computed属性都可以完成： 不过呢。。。computed完全依赖return的内容。 但是，目前还没有办法可以让computed等待一段时间再进行return返回。 说明，计算属性中，是不能够开启异步任务去处理数据的。 那这个时候就需要依赖watch watch不依赖return，watch中的数据修改，依赖于数据处理语句，例如：a = b ，给a的赋值语句 所以当有：想要某值改变，但是延迟一秒操作的时候。使用watch进行处理 这里注意一个小细节哦： //这里的setTimeout很自然的使用了箭头函数 //之前我们说过，尽量不适用箭头函数以免改变了方法体中this的指向 //这里： //isHost是Vue管理下的函数。 //但是setTimeout定时器所指定的回调，是不受Vue控制的。浏览器定时器管理模块控制的。最后到时间了，也是js引擎帮我们调的函数 //------------------------------------------------------ //所以这儿，必须写成箭头函数 //如果这儿写成普通函数，js引擎会认为this是它引擎控制的整个window //------------------------------------------------------ //原理： //当这儿写成箭头函数的时候，由于箭头函数没有this，就会默认往外层找 //这儿setTimeout的外层是isHost函数 //而isHost函数的this就是Vue //由此使得this的指向正常 watch:{ isHost(val){ setTimeout(()=\u003e{ this.isHost = val },1000); } 小结： computed利watch之间的区别： 1.computed能完成的功能，watch都可以完成。 2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。 两个重要的小原则： 1.所被vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。 2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数、Promise的回调函数等，只要是没引入Vue都可以调用的函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象 ","date":"2024-08-21","objectID":"/vue2/:13:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"14.列表过滤 两种实现方式，先用watch写一遍再用computed写一遍 watch写法： \u003cbody\u003e \u003cdiv\u003e \u003ch3\u003e列表过滤\u003c/h1\u003e \u003c/div\u003e \u003cdiv id=\"root\"\u003e \u003cinput type=\"text\" v-model=\"keyWord\"\u003e \u003cul\u003e \u003cli v-for=\"(p,index) of filPersons\" :key=\"p.id\"\u003e {{p.name}}-{{p.age}}-{{p.sex}} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#root', computed:{ }, watch:{ keyWord:{ immediate:true, handler(val){ //这块注意，filter要返回满足条件的新数组 this.filPersons = this.persons.filter((p)=\u003e{ //indexOf对于包含的内容返回索引，不包含的内容返回-1 //这里注意，都包含空字符串：任何字符串.indexOf('')都返回0 return p.name.indexOf(val) !== -1 }) }, } }, data:{ keyWord:'', persons:[ {id:'001',name:'马冬梅',age:18,sex:'女'}, {id:'002',name:'周冬雨',age:19,sex:'女'}, {id:'003',name:'周杰伦',age:20,sex:'男'}, {id:'004',name:'温兆伦',age:21,sex:'男'}, ], filPersons:[] }, }) \u003c/script\u003e \u003c/body\u003e computed写法： \u003cbody\u003e \u003cdiv\u003e \u003ch3\u003e列表过滤\u003c/h1\u003e \u003c/div\u003e \u003cdiv id=\"root\"\u003e \u003cinput type=\"text\" v-model=\"keyWord\"\u003e \u003cul\u003e \u003cli v-for=\"(p,index) of filPersons\" :key=\"p.id\"\u003e {{p.name}}-{{p.age}}-{{p.sex}} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#root', computed:{ filPersons(){ return this.persons.filter((p)=\u003e{ return p.name.indexOf(this.keyWord) !== -1 }) } }, data:{ keyWord:'', persons:[ {id:'001',name:'马冬梅',age:18,sex:'女'}, {id:'002',name:'周冬雨',age:19,sex:'女'}, {id:'003',name:'周杰伦',age:20,sex:'男'}, {id:'004',name:'温兆伦',age:21,sex:'男'}, ], }, }) \u003c/script\u003e \u003c/body\u003e ","date":"2024-08-21","objectID":"/vue2/:14:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"15.列表排序 排序和搜索都能同时控制使用 computed写法： \u003cbody\u003e \u003cdiv\u003e \u003ch3\u003e列表排序\u003c/h1\u003e \u003c/div\u003e \u003cdiv id=\"root\"\u003e \u003cinput type=\"text\" v-model=\"keyWord\"\u003e \u003cbutton @click = \"sortType = 2\"\u003e年龄升序\u003c/button\u003e \u003cbutton @click = \"sortType = 1\"\u003e年龄降序\u003c/button\u003e \u003cbutton @click = \"sortType = 0\"\u003e原顺序\u003c/button\u003e \u003cul\u003e \u003cli v-for=\"(p,index) of filPersons\" :key=\"p.id\"\u003e {{p.name}}-{{p.age}}-{{p.sex}} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#root', computed:{ filPersons(){ const arr = this.persons.filter((p)=\u003e{ return p.name.indexOf(this.keyWord) !== -1 }) //为0时不进该判断 if(this.sortType){ //升降序方法.sort(a,b)两个入参。升序-前减后，降序-后减前 arr.sort((p1,p2)=\u003e{ return this.sortType === 1? p2.age - p1.age : p1.age - p2.age }) } return arr; } }, data:{ keyWord:'', sortType:0, // 0原顺序 1降序 2升序 persons:[ {id:'001',name:'马冬梅',age:18,sex:'女'}, {id:'002',name:'周冬雨',age:19,sex:'女'}, {id:'003',name:'周杰伦',age:20,sex:'男'}, {id:'004',name:'温兆伦',age:21,sex:'男'}, ], }, methods:{ } }) \u003c/script\u003e \u003c/body\u003e ","date":"2024-08-21","objectID":"/vue2/:15:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"16.Vue监测数据改变的原理 这里注意，修改更新data中的数据时存在这样一个问题： \u003cbody\u003e \u003cdiv\u003e \u003ch3\u003e人员列表\u003c/h1\u003e \u003c/div\u003e \u003cdiv id=\"root\"\u003e \u003cbutton @click=\"updataMei\"\u003e点击更改马冬梅的数据\u003c/button\u003e \u003cul\u003e \u003cli v-for=\"(p,index) of persons\" :key=\"p.id\"\u003e {{p.name}}-{{p.age}}-{{p.sex}} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003cscript\u003e const vm = new Vue({ el:'#root', computed:{ }, data:{ persons:[ {id:'001',name:'马冬梅',age:18,sex:'女'}, {id:'002',name:'周冬雨',age:19,sex:'女'}, {id:'003',name:'周杰伦',age:20,sex:'男'}, {id:'004',name:'温兆伦',age:21,sex:'男'}, ], }, methods:{ updataMei(){ //这里挨个修改data中的第一行数据 this.persons[0].name = '马老师'; this.persons[0].age = '50'; this.persons[0].sex = '男'; //这里整体修改data中的第一行数据 【会发现此种写法它不生效】 this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'} } } }) \u003c/script\u003e \u003c/body\u003e 运行结果： 可以看出，逐条修改数据，可以成功修改Vue中的数据，并且更新页面上的显示；但是整体修改，Vue中的数据确实被修改了，这里通过vm可以看出，页面上却不更新显示。 由此我们在这里探讨：Vue监测数据改变的原理。（Vue是如何监测数据改变的） ","date":"2024-08-21","objectID":"/vue2/:16:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"响应式解析过程 data中数据的解析过程： ​ 在数据代理小节：我们知道，Vue将data中的数据复制一份,形成了_data。Vue通过_data进行数据代理生成页面上的data。 ​ 但是，这儿能看出我们写的data和vm中的_data，_data结构上比我们写的多了些东西。这里说明Vue不是单纯的复制了我们写的data，它对data进行了加工。 ​ 它对data进行加工的作用，使得我们在修改data中的数据的时候，它通过setter方法重新解析模板。这就是响应式。 ​ 整个响应式流程：data中name修改，形成新的_data.name，调用setter方法、重新解析模版，生成虚拟dom，新旧dom对比算法，复用旧dom/生成新dom。 ","date":"2024-08-21","objectID":"/vue2/:16:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"模拟数据监测 这里我们不使用Vue，单独写一个对象的数据监测： \u003c!--Vue的数据检测类似 --\u003e \u003cscript text=\"text/javascript\"\u003e let data = { name: 'username', age:'12' } //这里创建一个监视的实力对象，用于监视数据data中的数据变化 const obs = new Observer(data); console.log(obs); //这里的obs打印输出来和data一致 //Observer函数：入参为需要监视的数据对象 function Observer(obs){ //取对象中所有的属性形成一个数组 ，这里是[name,age] const keys = Object.keys(obs) //遍历 keys.forEach((k)=\u003e{ //k为每一个属性,this为整个obs实例对象 //Object.defineProperty(对象,'属性',{}) Object.defineProperty(this,k,{ //读：就把改属性的值返回去 get(){ console.log(\"被读\"); return obs[k] }, //改：就把收到的值替换到对应属性 set(val){ console.log(\"被改\"); obs[k] = val } }) }) } \u003c/script\u003e 注意不能直接对data使用defineProperty，防止死循环 //死循环代码 //这种监视会反复调用读取，导致卡死 Object.defineProperty(data,'name',{ get(){ return data.name } }) ","date":"2024-08-21","objectID":"/vue2/:16:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue里的对象监测原理 ​ Vue底层的对象监测类似于此，依赖于Vue.set() ","date":"2024-08-21","objectID":"/vue2/:16:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue.set() 注意，Vue里模版中使用一个对象中不存在的属性，则值默认为undefined。如果Vue在页面中遇到undefined，则默认成什么都不展示，且控制台无报错。 当Vue里模版中使用vm身上不存在的属性，控制台就会报错告诉你未定义。 所以这里，我们设置一个属性时，将其定义在对象中。保证我们的演示效果，写法如上图左侧 我们需要对student.sex实时追加属性值，使得页面上同时进行实时更新。 这里使用Vue.set() 官网API地址 //Vue提供函数 target改动对象，key操作的属性，val修改的值 Vue.set(target,key,val) //vm._data取对象 Vue.set(vm._data.student,'sex','男') //或者vm.data取对象，数据代理原理 Vue.set(vm.student,'sex','男') 或者使用vm.$set() vm.$set(target,key,val) //vm._data取对象 vm.$set(vm._data.student,'sex','男') //或者vm.data取对象，数据代理原理 vm.$set(vm.student,'sex','男') 注意：对象不能是 Vue 实例，或者 Vue 实例的根数据对象。Vue.set()不是万能的，其设定了禁止直接对vm进行操作。即，只能操作data里的对象，不能操作data对象，例如： //使用Vue.set()直接在vm中加入sex属性 //此操作会报错，告诉你禁止直接操作vm下的data对象。 //下面是两种错误写法 Vue.set(vm._data.sex,'sex','男') Vue.set(vm.sex,'sex','男') ","date":"2024-08-21","objectID":"/vue2/:16:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue里的数组监测原理 Vue如何检测数组里的数据改变 我们将data中设置一组对象数据，和一组数组数据，我们在页面控制台输出的data中可以看到两个数据的差别 Vue在加工的时候，给对象都创建了getter和setter方法。但是数组却没有。 当我们修改数组的时候 this.school[0] = '大学' //页面不生效 原因这儿就找到了！页面模版的重新解析，依赖了数据中的setter方法，而数组没有setter。所以当我们修改数组时，vm的data中确实数据发生了更改，而页面却没有任何变化。这就也解释了为什么人员列表的时候，persons数组列表中直接修改第一行的数据，vm被改动，但页面不生效的现象了。 在Vue 的设计者认为中，数组应使用修改数组的一些方法对其进行修改。只有当使用数组的通用修改方法时，Vue才承认数组被改变了，才能够监测到数组数据的改变。 修改数组的一些常用方法： ​ push：在数组尾部添加一个元素 ​ pop：删除最后一个元素 ​ shift：删除第一个元素 ​ unshift：在数组头部添加一个元素 ​ splice：在某索引处进行删除、修改、添加 ​ sort：数组排序 ​ reverse：数组翻转 当使用上面这些方法时，Vue则可以成功监测到数据改变，同步更新页面。例如： vm._data.school.push('大学') 当然，提供的Vue.set() 依旧对数组有效 Vue.set(vm._data.school,0,'大学') 不过需要注意的是，这里vm使用的push及其以上方法，并是不原生态的Array数组使用的push方法。Vue对其进行了包装。官网API地址 //控制台验证 vm._data.school.push === Array.prototype.push //false ","date":"2024-08-21","objectID":"/vue2/:16:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"17.表单数据收集 表单数据收集时： ajax前台往后台传参数的时候，把一组数据转成JSON格式的 JSON.statiy()数据转换成JSON格式 收集表单数据：可以用this._data，但是一般不推荐直接使用 建议整个表单数据，前面包一个对象，通过 对象收集 this.queryInfo v-model的修饰符： v-model.trim =\u003e 不收集输入的空格（所有的空格都不收集） v-model.number =\u003e 收集的数据自动转成数值类型 v-model.lazy =\u003e 收集时，需要失去焦点后再记录 小结： 如果input框的type类型是text，v-model收集的是value，用户输入的也是value 如果类型是radio，需要给标签配置value值 如果类型是checkbox， 没有设置value，收集的是是否被选中，true/false 配置了value，初始值是数组，收集的是选中的数组。是非数组，收集的是布尔值 ","date":"2024-08-21","objectID":"/vue2/:17:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"18.过滤器 小案例：当前时间戳的转换。【日期第三方库 moment.js 、 dayjs】 我们用三种实现方式：计算属性、methods、过滤器 分别实现 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e过滤器\u003c/title\u003e \u003cscript src=\"js/vue.js\"\u003e\u003c/script\u003e \u003c!-- 日期转换方法第三方库引入 --\u003e \u003c!-- 有互联网也可以引在线的 --\u003e \u003c!-- https://www.bootcdn.cn/ 搜索dayjs 复制链接 另存为 --\u003e \u003cscript src=\"js/dayjs.min.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e \u003ch1\u003e过滤器 时间戳切换\u003c/h1\u003e \u003ch3\u003e当前时间：{{time}}\u003c/h3\u003e \u003c!-- 计算属性 实现 --\u003e \u003ch3\u003e当前时间：{{timeComputed}}\u003c/h3\u003e \u003c!-- methods 实现 --\u003e \u003ch3\u003e当前时间：{{getNowTime()}}\u003c/h3\u003e \u003c!-- filter 实现 --\u003e \u003c!-- | 管道符前面的为入参 后面的为过滤器函数 --\u003e \u003c!-- 后面的函数return的内容 整个替换掉插值位置的所有内容 显示 --\u003e \u003ch3\u003e当前时间：{{time | timeFormater}}\u003c/h3\u003e \u003c!-- filter传参 --\u003e \u003c!-- 默认第一位参数为 | 前参数，第二位参数为小括号内参数 --\u003e \u003ch3\u003e当前时间：{{time | timeFormater(\"YYYY年MM月DD日\")}}\u003c/h3\u003e \u003c!-- filter串联 --\u003e \u003c!-- 串联不影响传参 --\u003e \u003c!-- mySlice只接受timeFormater返回地方值进行计算 挨着串联 只处理该函数 | 前的返回值为入参--\u003e \u003ch3\u003e当前年份：{{time | timeFormater(\"YYYY年MM月DD日\") | mySlice}}\u003c/h3\u003e \u003c/div\u003e \u003cscript\u003e //定义全局过滤器 //一次只能定义一个 //Vue.filter('注册全局过滤器名称',function(入参){方法体} Vue.filter('mySlice',function(val){ return val.slice(0,4) }) new Vue({ el:'#root', data:{ time:Date.now(), }, computed:{ timeComputed(){ return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss') } }, methods:{ getNowTime(){ return dayjs(this.time).format('YYYY-MM-DD HH:mm:ss') } }, //注意：new Vue中的filters 可以写多个。里面的每一个filter都属于局部过滤器。当这个Vue是组件时，A组件和B组件的filter不能相互使用。 filters:{ //timeFormater(val){ 没有第二入参的写法 timeFormater(val,str = 'YYYY-MM-DD HH:mm:ss'){ //有第二入参用入参，没有用默认的 = 后的这个 //return 'hello' 返回啥页面就是啥，完全依赖此处return return dayjs(val).format('YYYY-MM-DD HH:mm:ss') }, mySlice(val){ return val.slice(0,4) } } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ⚠️注意：new Vue中的filters 可以写多个。里面的每一个filter都属于局部过滤器。当这个Vue是组件时，A组件和B组件的filter不能相互使用。 \u003c!-- 过滤器使用方式 --\u003e \u003c!-- 插值语法 --\u003e \u003ch3\u003e当前时间：{{time | timeFormater}}\u003c/h3\u003e \u003c!-- 单向属性绑定（双向用不了，这种形式也用的比较少） --\u003e \u003ch3 :x=\"time | timeFormater\"\u003e\u003c/h3\u003e 🏷小结：一般用于 对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理） ","date":"2024-08-21","objectID":"/vue2/:18:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"19.生命周期 定义\r生命周期: 1.又名: 生命周期回调函数、生命周期函数、生命周期钩子。（只需要准备好函数，在特定的时间，将函数钩出来使用。） 2.是什么: Vue在关键时刻帮我们调用的一些特殊名称的函数。 3.生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的 4.生命周期函数中的this指向是vm或组件实例对象。 实现一个幻灯片渐隐渐现的效果 \u003c!-- 定时器写在外部(不推荐) --\u003e \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003c!-- 此处为 :style=\"{opacity:opacity}\" 因为style中为js函数体，函数体同名可以省略，由此写成下面的这种形式--\u003e \u003ch2 :style=\"{opacity}\"\u003e一个渐隐渐现的效果\u003c/h2\u003e \u003c/div\u003e \u003cscript\u003e const vm = new Vue({ el:'#el', data:{ opacity:1 //初始化：默认透明度为1 }, }) //再Vue外面写一个定时器，循环操作vm setInterval(()=\u003e{ //每次透明度减小0.01 vm.opacity -= 0.01 //注意此处写成 \u003c=0 ,而不是写成 ==0 ，因为在js中 0.1 +0.1 不一定等于0.2 ，所以在-0.01的时候不一定会刚好减到0，有可能直接奔负数就去了 //一旦发现透明度减完了，就使其恢复到1 if(vm.opacity \u003c= 0) vm.opacity =1 },16) //每隔16毫秒就减一次透明度 \u003c/script\u003e \u003c/body\u003e 使用声明周期函数，使得定时器能够自然的存在于Vue的内部 原理：Vue在解析完模板，由虚拟DOM生成真实DOM之后，会默认调用的几个函数，帮我们完成在元素加载后，自动调用需要调用的函数 【在Vue整个干活过程中，特殊的时间点，去调用的函数，统称为生命周期函数】 \u003c!-- mounted()生命周期函数 写法--\u003e \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003ch2 :style=\"{opacity}\"\u003e一个渐隐渐现的效果\u003c/h2\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#el', data:{ opacity:1 //初始化：默认透明度为1 }, //Vue完成模版的解析并把真实的DOM元素放入页面后（挂载完成）调用mounted //只在真DOM放入时调用一次，后面解析模板不会再被调用 mounted(){ setInterval(()=\u003e{ this.opacity -= 0.01 if(this.opacity \u003c= 0) this.opacity =1 },16) } }) \u003c/script\u003e \u003c/body\u003e 官方操作手册中给出了非常完整的Vue生命周期图示：如这里 ， 同时也给了详细的解释。这里我们仅仅将图拿过来，进行简单的备注和阐述。 阅读此图注意： 实色填充图形均为 生命周期 流程 红色圆角矩形框 均为 生命周期 函数 绿色填充和黄色填充圆角矩形框和菱形框 均为 生命周期 某环节 ","date":"2024-08-21","objectID":"/vue2/:19:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生命周期_挂载流程 beforeCreate() 第一个生命周期函数： 数据创建前 首先打印函数名称，确定函数执行；其次验证vm上并没有data的数据代理 \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003ch2\u003e当前的n值是：{{n}}\u003c/h2\u003e \u003cbutton @click = \"add\"\u003e点我n+1\u003c/button\u003e \u003c/div\u003e \u003cscript\u003e new Vue({ el:'#el', data:{ n:1 }, methods:{ add(){ n++} }, beforeCreate(){ console.log('beforeCreate'); console.log(this); debugger; } }) \u003c/script\u003e \u003c/body\u003e 控制台表现 created() 第二个生命周期函数： 数据创建完毕 首先打印函数名称，确定函数执行；其次验证vm上完成了data的数据代理 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); console.log(this); } }) \u003c/script\u003e \u003c/body\u003e 控制台表现 beforeMount() 第三个生命周期函数 数据挂载前 首先打印函数名称，确定函数执行；其次验证vm中有值，但此时并没有将解析结果（值）放入页面 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); }, beforeMount(){ console.log('beforeMount'); console.log(this); debugger; }, }) \u003c/script\u003e \u003c/body\u003e 控制台表现 验证此处对DOM的所有操作，最终都不会有效 mounted() 第四个生命周期函数 数据挂载完毕 首先打印函数名称，确定函数执行；其次，确定页面上所有的元素都被解析完成，且挂载完毕 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); }, beforeMount(){ console.log('beforeMount'); }, mounted(){ console.log('mounted'); console.log(this); debugger; }, }) \u003c/script\u003e \u003c/body\u003e 控制台效果 到此，整个挂载流程结束。 挂载流程 - 图解： 注意\r在使用template模版对象时，有多个节点只能用\u003cdiv\u003e标签进行包裹，不能使用\u003ctemplate\u003e标签。 \u003cscript\u003e ..... //只能使用div template:` \u003cdiv\u003e \u003ch2\u003e当前的n值是：{{n}}\u003c/h2\u003e \u003cbutton @click = \"add\"\u003e点我n+1\u003c/button\u003e \u003c/div\u003e `, ...... //不能使用template template:` \u003ctemplate\u003e \u003ch2\u003e当前的n值是：{{n}}\u003c/h2\u003e \u003cbutton @click = \"add\"\u003e点我n+1\u003c/button\u003e \u003c/template\u003e `, \u003c/script\u003e 我们知道\u003ctemplate\u003e标签，在页面解析的时候，会自动隐藏掉最外的一层，只显示\u003ctemplate\u003e标签里面的内容。所以，容易产生\u003ctemplate\u003e标签里面多根节点的问题。导致template模版对象编译失败报错 ","date":"2024-08-21","objectID":"/vue2/:19:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生命周期_更新流程 beforeUpdate() 第五个生命周期函数 在页面数据更新完成前 首先打印函数名称，确定函数执行；其次，验证此环节：数据已经更改，但页面并未更新 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); }, beforeMount(){ console.log('beforeMount'); }, mounted(){ console.log('mounted'); }, beforeUpdate(){ console.log('beforeUpdate'); console.log(this.n); debugger; }, }) \u003c/script\u003e \u003c/body\u003e 控制台效果 updated() 第六个生命周期函数 在页面数据更新完毕 首先打印函数名称，确定函数执行；其次，验证此环节：数据已经更改，页面完成更新 \u003cbody\u003e .... \u003cscript\u003e new Vue({ ..... beforeCreate(){ console.log('beforeCreate'); }, created(){ console.log('created'); }, beforeMount(){ console.log('beforeMount'); }, mounted(){ console.log('mounted'); }, beforeUpdate(){ console.log('beforeUpdate'); }, updated(){ console.log('updated'); console.log(this.n); debugger; }, }) \u003c/script\u003e \u003c/body\u003e 控制台效果 到此，整个更新流程结束。 更新流程 - 图解： ","date":"2024-08-21","objectID":"/vue2/:19:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生命周期_销毁流程 This is a tips\rvm被销毁： 使得该vm不再工作（数据变化时，不再继续解析了） 但是原来工作的成果还在（即，已经被解析挂载的页面不会有变化）。 官方解释：https://cn.vuejs.org/v2/api/#vm-destroy beforeDestroy() 第七个生命周期函数 将要销毁前 这里是可以访问所有的vm中的所有数据和方法的，但是此时所有对数据的修改都不会再返过去触发更新流程了。即，这里所有的数据修改操作，页面都不会有任何效果。（值可以随便用，方法可以随便调，页面不会有变化） \u003cscript\u003e new Vue({ ..... beforeDestroy(){ console.log('beforeDestroy'); console.log(this.n); //能正常拿到 this.n = 99 //改行操作无用 }, }) \u003c/script\u003e destroyed() 第八个生命周期函数 销毁完毕 \u003cscript\u003e new Vue({ ..... beforeDestroy(){ console.log('beforeDestroy'); }, destroyed(){ console.log('destroyed'); } }) \u003c/script\u003e 到此，整个销毁流程结束。 销毁流程 - 图解： ","date":"2024-08-21","objectID":"/vue2/:19:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"生命周期_总结 整个生命周期 - 图解： 4对生命周期钩子： vm的一生(vm的生命周期): 将要创建========\u003e调用beforeCreate函数。 创建完毕========\u003e调用created函数。 将要挂载========\u003e调用beforeMount。 (重要)挂载完毕==\u003e调用mounted函数========\u003e【重要的钩子】 将要更新========\u003e调用beforeUpdate数。 更新完毕========\u003e调用updated函数。 (重要)将要销毁==\u003e调用beforeDestroy函数。========\u003e【重要的钩子】 销毁完毕========\u003e调用destroyed函数。 这块流程中：主要阐述8个钩子。还有3个常用的钩子，需要在特殊的场景才能被调用，我们会在路由小节中进行详细描述。 第2章：Vue组件化编程 ","date":"2024-08-21","objectID":"/vue2/:19:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"20.组件 Vue组件化编程 传统方式编写应用，存在2个问题： 1、依赖关系混乱不好维护（一堆html引用一堆js和css）； 2、代码复用率不高。 组件的定义： 实现应用中局部功能代码(html、js、css)和资源(mp3、gif)的集合 模块化： 当用js来写的，并且将一个大的js按照模块分成多个不同的js来编写应用，就称为一个模块化应用 组件化： 当用组件来写，并且应用中的功能都是多个组件来编写的，就称为一个组件化的应用。 组件复用不需要复制粘贴，只需要引用即可。非常方便。 ","date":"2024-08-21","objectID":"/vue2/:20:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"非单文件组件 一个文件中包含有n个组件。例如：a.html中有4个组件 ","date":"2024-08-21","objectID":"/vue2/:20:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"单文件组件 一个文件中只包含有1个组件。例如：a.vue中有且只有唯一一个组件 ","date":"2024-08-21","objectID":"/vue2/:20:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue中使用组件的三步 1、创建组件 \u003cscript\u003e //创建school组件 const school = Vue.extend({ //组件定义时，一定不要写el配置项 //因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器 //el:'#el', //data这里必须写成函数形式 data(){ //在return中返回你要设置的data内容 //这个问题在el于data的写法小节有铺垫过 //原因就是：data对象式直接使用了同一个对象，导致多方调用时，相互影响。 //而data函数形式，每一次调用都是return创建的一个新的对象，解决了多方调用被相互影响的问题。 return{ name:'某学校', address:'某地址' } }, template:` \u003cdiv\u003e \u003ch2\u003e学校名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学校地址：{{address}}\u003c/h2\u003e \u003c/div\u003e ` }) //创建student组件 const student = Vue.extend({ data(){ return{ name:'张三', age:'18' } }, template:` \u003cdiv\u003e \u003ch2\u003e学生名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学生年龄：{{age}}\u003c/h2\u003e \u003c/div\u003e ` }) new Vue({ el:'#el', }) \u003c/script\u003e 2、注册组件 This is a tip\r全局注册 Vue.component('school',school) \u003cscript\u003e new Vue({ el:'#el', //全新配置项 //注册组件（局部注册） components:{ school:school, student:student } }) \u003c/script\u003e 3、编写组件标签，使用组件 \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003c!-- 编写组件标签 --\u003e \u003cschool\u003e\u003c/school\u003e \u003cstudent\u003e\u003c/student\u003e \u003c/div\u003e \u003c/body\u003e 实现效果以及Vue开发者工具节点体现如图： ","date":"2024-08-21","objectID":"/vue2/:20:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"细节点注意 1.关于组件名: 一个单词组成: 第一种写法(首字母小写):school 第二种写法(首字母大写):School 多个单词组成: 第一种写法(kebab-case命名):my-school \u003cmy-school\u003e\u003c/my-school\u003e components:{ 'my-school':school, } 第二种写法(CamelCase命名):MySchool(需要Vue脚手架支持) \u003c!-- 不在Vue脚手架里会报错 --\u003e \u003cMySchool\u003e\u003c/MySchool\u003e components:{ MySchool:school, } 备注: (1).组件名尽可能回避HTML中已有的元素名称，例如:h2、H2都不行。 (2).可以使用name配置项指定组件在开发者工具中呈现的名字。 \u003cscript\u003e const student = Vue.extend({ //自定义组件名字 - 没有这个就取注册时候的key:value的key值 name:'student' data(){ return{ .... } }, template:.... }) \u003c/script\u003e 2.关于组件标签: 第一种写法:\u003cschool\u003e\u003c/school\u003e 第二种写法:\u003cschoo1/\u003e 备注:不用使用脚手架时，\u003cschool/\u003e会导致后续组件不能渲染 \u003c!-- 两种写法：页面均可正常渲染school组件 --\u003e \u003cmyshool\u003e\u003c/myshool\u003e \u003cmyshool/\u003e \u003c!-- 页面渲染三个school组件 --\u003e \u003cmyshool\u003e\u003c/myshool\u003e \u003cmyshool\u003e\u003c/myshool\u003e \u003cmyshool\u003e\u003c/myshool\u003e \u003c!-- 页面只渲染一个school组件，后面的不再渲染 --\u003e \u003cmyshool/\u003e \u003cmyshool/\u003e \u003cmyshool/\u003e 3.一个简写方式: const school =Vue.extend(options)可简写为:const school = options \u003cscript\u003e //主动调用组件扩展方法extend const student = Vue.extend({ data(){ return{ ... } }, template:.... }) //简写 const student = { data(){ return{ ... } }, template:.... } new Vue({ el:'#el', //注册组件时判断：有写extend直接使用组件，没有则帮忙调用extend之后使用组件 components:{ school:school, } }) \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:20:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"组件的嵌套 下方是三个组件的嵌套。 所有的组件都嵌在app组件中，app组件中有同级school组件、hello组件，school组件中含有student组件、 代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cscript src=\"../js/vue.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003capp\u003e\u003c/app\u003e \u003c/div\u003e \u003cscript\u003e //创建student组件 const student = Vue.extend({ data(){ return{ name:'张三', age:'18' } }, template:` \u003cdiv\u003e \u003ch2\u003e学生名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学生年龄：{{age}}\u003c/h2\u003e \u003c/div\u003e ` }) //创建school组件 const school = Vue.extend({ data(){ return{ name:'某学校', address:'某地址' } }, template:` \u003cdiv\u003e \u003ch2\u003e学校名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学校地址：{{address}}\u003c/h2\u003e \u003c!-- 2在哪里注册的，在哪个模版中写 --\u003e \u003cstudent\u003e\u003c/student\u003e \u003c/div\u003e `, //注册组件 components:{ //1定义组件的代码，要写在注册组件之前（比如这里的14~27行代码，必须在49行代码之前） //简写 student } }) const hello = Vue.extend({ template:`\u003ch1\u003e你好鸭！欢迎来进行学习~\u003c/h1\u003e` }) const app = Vue.extend({ template:` \u003cdiv\u003e \u003chello\u003e\u003c/hello\u003e \u003cschool\u003e\u003c/school\u003e \u003c/div\u003e `, components:{ hello, school } }) new Vue({ el:'#el', //注册组件 components:{ //简写 app } }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 页面及控制台运行效果： This is a tip\r1 定义组件的代码，要写在注册组件之前 2 子组件只能写在，注册的父组件的模版template中 ","date":"2024-08-21","objectID":"/vue2/:20:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"VueComponent结构函数 关于VueComponent： 1.school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的 const school = Vue.extend({}) //定义组件后，打印组件 console.log(\"@\",school); 控制台输出为： 这里可以看出，其是一个函数。严谨上来讲，我们称其为构造函数，其调用方式应该为new VueComponent() 我们打开Vue.js查找VueComponent函数，打印一段文字。我们会发现，当我们使用组件时候，使用一次就调一次该函数。即，有一个\u003cschool\u003e\u003c/school\u003e调一次new，有三个，就调3次。 2.我们只需要写\u003cschool/\u003e或\u003cschool\u003e\u003c/school\u003e，Vue解析时会帮我们创建school组件的实例对象，即Vue帮我们执行的：new VueComponent(options)。 3.特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！ const school = Vue.extend({}) const student = Vue.extend({}) //定义组件后，打印组件 console.log(\"@\",school); console.log(\"@\",student); //打印出来的东西，看起来都是长一样的，都是VueComponent //但是是两个全新的，各自独立的，功能长相都一样的 VueComponent //-----------------验证----------------- console.log(school === student); //false school.a = 99 console.log(school.a); //99 console.log(student.a); //undefind 4.关于this指向： (1).组件配置中： data函数、methods中的函数、watch中的函数、computed中的函数它们的this均是【VueComponent实例对象】 (2).new Vue()配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】 5.VueComponent的实例对象，以后简称vc(也可称之为:组件实例对象)。 Vue的实例对象，以后简称vm。 控制台输出vm，结构里面能通过$children很清晰的看见各个组件的 结构关系，和上下管理层级关系。 ","date":"2024-08-21","objectID":"/vue2/:20:6","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"Vue实例 \u0026 组件实例 vm和vc从结构上来看基本上一致，但并不是完全一致，并不是完全相等的两个东西。 首先，vm是Vue创建实例的时候，生成的实例对象；vc是VueComponent创建实例的时候，生成的实例对象。 Vue生成实例对象和VueComponent生成实例对象的缔造过程并不是一模一样的！所以他们两并不是完全一样的 其次，vm中是可以使用el配置项的，用于指定服务于哪个容器；vc中是不能使用el的 再有，vm中的data可以写成data:{}，也可以写成data(){}；但是vc中data只能写成data(){return }函数形式 ","date":"2024-08-21","objectID":"/vue2/:20:7","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"内置关系 首先复习一个js上的属性概念：.prototype \u0026 .__proto__ \u003cscript type=\"text/javascript\"\u003e //定义一个构造函数 function Demo(){ this.a = 1 this.b = 2 } //创建一个Demo的实例对象 const d = new Demo() //显式原型属性 //只有function函数才有这个属性，实例对象是没有的 //一般通过该条:程序员追加值 console.log(Demo.prototype); //打印输出为 原型对象{} //隐式原型属性 //实例对象默认都带有这个属性 //一般通过该条程序自动访问值 console.log(d.__proto__);//也打印输出为 原型对象{} ,且与上面的长得一样 //通过 显式原型属性 操作原型对象，追加一个x属性 Demo.prototype.x = 99 //手动通过这种方式访问值 //发现是同步更新到值的 console.log(d.__proto__.x); //99 //验证两个原型对象是否是完全相同的 console.log(Demo.prototype === d.__proto__); //true //通过Demo的实例对象访问 console.log(d); //Demo{a=1,b=2} 这里，Demo表示后面的{}里的对象内容，是由Demo缔造出来的 console.log(d.x); //99 //为什么输出的d带着Demo //表示这个{}对象是谁构造出来的 //例如 function school(){} function student(){} const s = new school() const ss = new student() console.log(s); //school{} console.log(ss);//student{} //这里如果没有前面的这个名字，则分不清对象来自于哪里 \u003c/script\u003e 由此引入一个重要的内置关系： VueComponent.prototype.__proto__ === Vue.prototype 这个关系的作用： 让组件实例对象vc可以访问到Vue原型上的属性、方法 这是Vue独有的：增加了，vc原型对象的原型对象指向vm的原型对象。 \u003c!-- 因为有这个内置关系：使得组件里this.x打印输出为99 得以实现 --\u003e \u003cbody\u003e \u003cdiv id = \"el\"\u003e \u003cschool\u003e\u003c/school\u003e \u003c/div\u003e \u003cscript\u003e Vue.prototype.x = 99 //创建school组件 const school = Vue.extend({ data(){ return{ name:'某学校', address:'某地址' } }, template:` \u003cdiv\u003e \u003ch2\u003e学校名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学校地址：{{address}}\u003c/h2\u003e \u003cbutton @click=\"onChange\"\u003e点击获取x的值\u003c/button\u003e \u003c/div\u003e `, methods:{ onchange(){ alert(\"当前x的值是\"+this.x) } } }) new Vue({ el:'#el', components:{ school } }) \u003c/script\u003e \u003c/body\u003e ","date":"2024-08-21","objectID":"/vue2/:20:8","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"单文件组件 单文件组件，均是以xxxx.vue的文件 命名规范： 一个单词的文件命名为：school.vue，School.vue 多个单词的文件命名为：my-school.vue，MySchool.vue 一般我们都使用大写字母开头进行命名，主要是为了和开发者工具那边的根节点结构展示的名字一样【这边写成小写开头，那边也会默认显示为大写】。 1新建一个单文件组件School.vue \u003c!-- .vue文件中主要是：页面资源的合集，即html、css、js 为了迎合常见的前端三种资源显示的写法，vue提供了三个标签 分别是： 1、组件的结构标签\u003ctemplate\u003e 2、组件的交互标签\u003cscript\u003e 3、组件的样式标签\u003cstyle\u003e --\u003e \u003c!-- 这里就能看出“非单文件”的一个弊端： 组件的样式是不能单独写的，是公共写公共引用的 “单文件”的样式，一个文件一个，是独立的 --\u003e \u003c!-- 组件的结构标签 --\u003e \u003ctemplate\u003e \u003cdiv class=\"demo\"\u003e \u003ch2\u003e学校名称：{{name}}\u003c/h2\u003e \u003ch2\u003e学校地址：{{address}}\u003c/h2\u003e \u003cbutton @click=\"onChange\"\u003e点击获取x的值\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003c!-- 组件的交互标签 --\u003e \u003cscript\u003e //组件需要被引用，外部使用import //这儿有三种暴露方式： // export const school = Vue.extend({})//1分别暴露 // export{school}//2统一暴露 // export default school //3默认暴露 //我们一般使用默认暴露，因为引用时比较简单，只需要import 起名 from vue文件的位置； //export default Vue.extend({}) //由于Vue.extend不写vue也会自动帮我们调用，所以这里可以简写 export default{ name:'School',//和文件名保持一致，开发者工具呈现的是这儿的名字 data(){ return{ name:'某学校', address:'某地址', x:1 } }, methods:{ onchange(){ alert(\"当前x的值是\"+this.x) } } } \u003c/script\u003e \u003c!-- 组件的样式标签 --\u003e \u003cstyle\u003e .demo{ background-color: aqua; } \u003c/style\u003e 2新建一个总体管理的顶级父组件App.vue \u003ctemplate\u003e \u003c!-- 这儿的div必须有，保证根节点 --\u003e \u003cdiv\u003e \u003cSchool\u003e\u003c/School\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e //引入组件 import School from './School.vue'; import School from './School.vue'; export default{ name:'App', //注册 components:{ School } } \u003c/script\u003e 3新建一个入口文件main.js //vue脚手架选择了main.js用来调用new Vue()创建vm实例对象 //引入App import App from \"./App.vue\"; new Vue({ el:\"#root\", componements:{App} }) 4新建一个根容器文件index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 指定容器 --\u003e \u003cdiv id=\"root\"\u003e \u003c!-- 引用App --\u003e \u003cApp\u003e\u003c/App\u003e \u003c/div\u003e \u003c!-- 在模块加载完毕后引入 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/vue.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"./main.js\"\u003e\u003c/script\u003e \u003c!-- main.js入口文件 --\u003e \u003c/body\u003e \u003c/html\u003e 整个单文件组件引用流程和书写规范就结束了，主要的文件如图： xxxx.vue文件运行，借助： 1、自己单独使用webpack 搭建工作流，借助一些第三方插件和node将.vue文件转换 成 .html 文件使得浏览器能够运行 2、Vue脚手架【vue官方团队，也是通过webpack经过一些node借助一些第三方插件打造的一个工作流，是一个搭建好的一个编译环境，可以直接使用】 ———————-所以，我们这里阐述vue脚手架的内容———————– 第3章：使用Vue脚手架 ","date":"2024-08-21","objectID":"/vue2/:20:9","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"21.Vue脚手架 ","date":"2024-08-21","objectID":"/vue2/:21:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"创建Vue脚手架 1说明 Vue脚手架是Vue官方提供的标准化开发工具（开发平台） 最新的版本是4.x 官方文档：https://cli.vuejs.org/zh/。 CLI的全称是 command line interface 直译过来是：命令行接口工具 2具体步骤 第一步（仅第一次执行）：全局安装@vue/cli npm install -g @vue/cli 第二步：切换到你要创建项目的目录，然后使用命令创建项目 vue create xxxx 提示选择用哪个版本的Vue创建项目，这里移动光标，选择Vue2，回车 babel：ES6转ES5需要用到的语法编译器 eslint：语法检查器 等待创建 创建完成 第三步：启动项目 npm run serve 按步骤执行 启动成功 打开页面 停止程序 crtl+c 连续两次即可 This is a tip\r备注： 1、如果出现下载缓慢请配置npm淘宝镜像： //该镜像已经过期 npm config set registry https://registry.npm.taobao.org //请使用下面的最新的镜像 npm config set registry https://registry.npmmirror.com 2、Vue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，请执行 vue inspect \u003e output.js 3、执行完install命令，退出命令窗口，重新cmd打开，再输入vue测试是否安装成功。 //退回到上一层目录 cd //清空上面所有记录 cls //新建一个文件夹 mkdir 4、vue create xxxx命令创建的项目中，包含 vue脚手架 官方给你写好的HelloWord例子 ","date":"2024-08-21","objectID":"/vue2/:21:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"分析脚手架结构 将项目用vscode打开，同样用终端启动。分析项目中对应文件的作用。 .gitignore 哪些文件或者文件夹不想接受git管理，在.gitignore这个文件中配置 babel.config.js demo的控制文件。配置一些ES6转ES5的规则。【不需要我们去修改】 package.json 包的说明书。你的包叫什么名字，什么版本，使用的一些依赖，引入的一些库，一些短命令。 package-lock.json 包管理器。包版本控制文件。 README.md 对整个工程进行一个说明或者一个描述 src 下面的4个四个文件： assets - 一般放前端的静态资源：例如图片 components App.vue - 顶级父组件 main.js - 入口文件 public 下面两个文件： favicon.ico - 网站图标 index.html - 主页面 ","date":"2024-08-21","objectID":"/vue2/:21:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"22.render函数 new Vue({ render: h =\u003e h(App), }).$mount('#app') 替换成 new Vue({ render(createElement){ return createElement('h1','你好啊') } }).$mount('#app') 发现页面正常显示： 由此可以知道，render：是vue帮我们调用的，且利用入参createElement函数帮我们编译模板。 上面的代码： render(createElement){ return createElement('h1','你好啊') } 简化可以写成： //函数写成箭头函数 //render:(createElement) =\u003e{return createElement('h1','你好啊')} //一个入参，可以去掉括号 //render:createElement =\u003e{return createElement('h1','你好啊')} //一个唯一返参，可以去掉return render:createElement =\u003ecreateElement('h1','你好啊') //这便是main.js中写入模版精简的形式 render: h =\u003e h(App) 讨论main.js中的render函数的作用 我们之前独自写过main.js，格式是这样的： import App from \"./App.vue\"; new Vue({ el:\"#root\", template:`\u003cApp\u003e\u003c/App\u003e`, componements:{App} }) 那为什么vue创建的main.js不这么写呢。 我们将上面这段代码copy后，放入脚手架中，编译项目，可以看见控制台报错： 我们去调查，为什么vue不完整 在Es6引入第三方库的时候，我们一般写到某个路径下具体某个文件xxx.js 在vue引入第三方库的时候，我们一般只写到它的名字。 那么它具体引入的是哪个js，按住ctrl键，点击： 点击引用的vue文件，可以看到来到了node_moudles中 这儿能看见整个vue包含的文件。其实，main.js中import Vue from 'vue'只写到了这个vue包文件夹，具体指向的哪个js文件，需要依赖配置项： package.json中的module的配置js。 这里可以看到是dist/vue.runtime.esm.js。这个js是个精简版的vuejs，它将模版解析器精简掉了，所以他没办法解析template配置项，产生报错。 打开dist文件夹，我们可以看见他下方有很多个vuejs，但是只有Vue.js是完整版的，其余的都是在它的基础上精简或者稍加改变的。 那么问题找到了，我们将main.js包中的引入换成完整版的： import Vue from 'vue' 替换为： import Vue from 'vue/dist/vue' 重新编译后，页面和控制台： 模版编译成功，控制台无报错。 为什么不使用这个完整版的vue呢。 vue.runtime.esm.js体积小，打包以后体积还能更小一点。且模版编译器最终，不应该出现在我们最终打包好的文件内。 This is a tip\r注意： 组件中也有template标签，但是不用render函数去编译解析。 在package.json中专门引入了依赖包，去解析组件中的模版标签。 只有vm中的模版标签它解析不了，需要使用render函数 脚手架中一般只有一个vm，render也只会在vm中出现一次 ","date":"2024-08-21","objectID":"/vue2/:22:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"23.修改默认配置 脚手架的默认配置 为了安全Vue将配置的文件隐藏起来，使用下面的这个命令可以将隐藏的文件形成一个.js文件显示在项目的根目录： Vue inspect \u003e output.js 虽然output.js是可以看见默认配置的，但是对这个文件的修改是无效果的。 如果要自定义配置，可以在项目的根目录下，新建一个文件vue.config.js 修改脚手架默认配置 官方文档解释位置：https://cli.vuejs.org/zh 例如，我们把main入口文件的名字改成自定义 原理： Vue底层基于webpack，webpack基于node 使用文件vue.config.js中的这块，重写webpack中修改的这一部分 使得核心部分能有修改入口，且不会对基本核心内部进行破坏造成影响 ","date":"2024-08-21","objectID":"/vue2/:23:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"24.ref属性 This is a tip\rref属性 1.被用来给元素或子组件注册引用信息(id的替代者) 2.应用在htmi标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象(vc) 3.使用方式: 打标识:\u003ch1 ref=\"xxx\"\u003e.....\u003c/h1\u003e或\u003cSchool ref=\"xxx\"\u003e\u003c/School\u003e获取:this.$refs.xxx 获取Dom元素，原始写法： document.getElementById(\"text\") 用ref写法 \u003cdiv\u003e \u003ch1 ref=\"text\" id=\"text\"\u003etext\u003c/h1\u003e \u003cSchool ref=\"sch\" id=\"sch\"/\u003e \u003c/div\u003e \u003cscript\u003e .... methods:{ showDOM(){ //组件里的this都是vc //输出的是h1的整个DOM元素 - 基本标签ref可以当id用 console.log(this.$refs.text) console.log(document.getElementById(\"text\"))//结果同上 //输出的是组件school的vc实例对象 console.log(this.$refs.sch) //输出的是组件模版解析后的真实DOM console.log(document.getElementById(\"sch\")) } } \u003c/script\u003e 看一下输出ref： 看一下输出id： ","date":"2024-08-21","objectID":"/vue2/:24:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"25._props配置 props的作用：让组件接收外部传过来的数据 组件外属性传值： \u003cstudent name=\"张三\" sex=\"男\" age=\"18\"\u003e 组件内接受，三种写法： //简单接受 props:['name','age','sex'] //接受的同时对数据进行类型限制 props:{ name:String, sex:String, age:Number } //接受时限制是否必传、默认值以及类型 props:{ name:{ type:String, //限制name类型为String required:true //且为必传 }, sex:{ type:Number, default:99 //不必传，没传时默认99 }, age:{ type:String, required:true }, } This is a tip\r备注:props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。 例如： this.age = 19; //页面有效果，控制台有警告 Vue不建议在组件内部，修改外部传入的属性的属性值。 一般做法： //使用一个中间变量 data(){ return{ changeAge:this.age } } //修改中间变量，并使用中间变量 this.changeAge = 19 ","date":"2024-08-21","objectID":"/vue2/:25:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"26.mixin混入 两个组件共享一个配置 ，实现复用方法的效果 //新建一个共有.js文件 《hunhe.js》 //该文件中暴露共用配置方法 //export const为分别暴露，引入的时候需要带{} export const hunhe ={ methods:{ ...... } } //需要的组件中引入.js文件 import {hunhe} from '../hunhe.js' //组件中使用mixins配置项 mixins:[hunhe] This is a tip\r混合中data中的数据以及methods冲突，以组件为主，例如： //《hunhe.js》中 export const hunhe ={ data(){ return{ a:1 } } } //《组件student中》 data(){ return{ a:99 } },mixins:[hunhe] console.log(this.a) //输出为99，以组件为准 但是！！！ 生命周期冲突，不以任何为主，都会执行 //《hunhe.js》中 export const hunhe ={ ..., mounted(){ console.log(\"11\") } } //《组件student中》 ..., mounted(){ console.log(\"22\") },mixins:[hunhe] //启动后控制台输出： //11 //22 ","date":"2024-08-21","objectID":"/vue2/:26:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"27.插件 插件实际上是一个{ }对象 自定义插件必须有有个install函数 //新建《plugins.js》 export default{ install(Vue){ ... //install的入参是Vue。 //此函数中可以设定所有全局Vue能够设定的方法，并且让组件均能使用 } } //main.js中引入插件 import pligins from './pligins.js' //main.js中使用插件 Vue.use(pligins) //这句话或默认帮我们调用《plugins.js》中的install方法 This is a tip\r插件功能:用于增强Vue 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。\r","date":"2024-08-21","objectID":"/vue2/:27:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"28.scoped样式 scoped作用：让样式在局部生效，防止冲突 先看一个冲突 解决这个问题 在style标签里加上scoped属性 \u003cstyle scoped\u003e .... \u003c/style\u003e 原理：scoped原本就有作用域的意思，它在每个负责的标签样式后面都随机生成一个属性，配合样式选择器完成每个组件中引用同名样式的区分 ","date":"2024-08-21","objectID":"/vue2/:28:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"29.浏览器本地存储 在浏览器打开某网页，未登录情况下搜索某关键字，发现能够有对应的历史记录。 此历史记录是浏览器将信息存在了本机的硬盘上，也叫浏览器本地存储 浏览器本地存储统称webStorage 1、存储内容大小一般支持5MB左右(不同浏览器可能还不一样) 2、浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。 localStorage sessionStorage ","date":"2024-08-21","objectID":"/vue2/:29:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"localStorage.setItem 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。 浏览器本地存储不是Vue独有的，是js就有的，用.html文件就可以实现编译。 保存本地存储 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003elocalStorage\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch2\u003elocalStorage\u003c/h2\u003e \u003cbutton onclick=\"s()\"\u003e点击保存一个数据\u003c/button\u003e \u003cscript type=\"text/javascript\"\u003e function s(){ //第一个API叫setItem，两个入参必须为字符串 //重复添加同名的，会覆盖之前的值 localStorage.setItem('msg','hello!') //msg hello! localStorage.setItem('msg2',666) //msg2 666 localStorage.setItem('msg3',{'id':'001'})//不是字符串的会自动调toString，对象会存成[Object object] localStorage.setItem('msg4',JOSN.stringify(对象)) } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2024-08-21","objectID":"/vue2/:29:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"localStorage.getItem 该方法接受一个键名作为参数，返回键名对应的值 读取本地存储 \u003cscript type=\"text/javascript\"\u003e function s(){ //第二个API叫getItem,会给一个字符串的返回值 localStorage.getItem('msg') console.log(localStorage.getItem('msg')); //hello! console.log(JSON.parse(对象字符串));//对象的需要手动转换一下 } \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:29:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"localStorage.removeItem 该方法接受一个键名作为参数，并把该键名从存储中删除 删除本地存储 \u003cscript type=\"text/javascript\"\u003e function s(){ //第三个API叫removeItem localStorage.removeItem('msg') } \u003c/script\u003e ","date":"2024-08-21","objectID":"/vue2/:29:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"localStorage.clear 该方法会清空存储中的所有数据。 清空本地存储 \u003cscript type=\"text/javascript\"\u003e function s(){ //第四个API叫clear localStorage.clear() } \u003c/script\u003e This is a tip\r关闭浏览器，并不会自动清空浏览器本地存储。 但是！！！清除缓存，会清空浏览器本地存储。 ","date":"2024-08-21","objectID":"/vue2/:29:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"sessionStorage sessionStorage的4个API和localStorage使用和功能效果是一样的。 控制台位置，在localStorage下面 This is a tip\r备注: 1、SessionStorage存储的内容会随着浏览器窗口关闭而消失。 2、LocalStorage存储的内容，需要手动清除才会消失。 3、xxxxxstorage.getItem(xxx)如果xxx对应的value获取不到，那么getltem的返回值是null. 4、JSON.parse(null)的结果依然是null。\r","date":"2024-08-21","objectID":"/vue2/:29:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"30.组件自定义事件 ","date":"2024-08-21","objectID":"/vue2/:30:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"绑定【子传父】 子组件给父组件传值，三个写法： function \u003c!--父组件App.vue--\u003e \u003cSchool :getSchoolName=\"getSchoolName\"/\u003e props:['getSchoolName'], methods:{ getSchoolName(name){ console.log(\"学校名：\"+name) } } \u003c!--子组件School.vue--\u003e this.getSchoolName(this.name) $emit （自定义事件） \u003c!--父组件App.vue--\u003e \u003cStudent v-on:student=\"getStudentName\"/\u003e \u003cStudent @student=\"getStudentName\"/\u003e\u003c!--简写--\u003e methods:{ getStudentName(name){ console.log(\"学生名：\"+name) } } \u003c!--子组件Student.vue--\u003e this.$emit('student',this.name) ref （自定义事件） \u003c!--父组件App.vue--\u003e \u003cStudent ref=\"student\"/\u003e methods:{ getStudentName(name){ console.log(\"学生名：\"+name) } }, mounted:{ this.$refs.student.$on('studentTest',this.getStudentName) } \u003c!--子组件Student.vue--\u003e this.$emit('studentTest',this.name) This is a tip\r如果子传父的参数很多，三个办法： 挨个写入参 this.$emit('demo',x,y,z,p...) this.$refs.组件名.$on('demo',x,y,z,p...) 写成一个对象 this.$emit('demo',{params}) this.$refs.组件名.$on('demo',{params}) ES6写法，…a this.$emit('demo',this.name,...params) this.$refs.组件名.$on('demo',this.name,...params) ","date":"2024-08-21","objectID":"/vue2/:30:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"解绑 解绑一个自定义事件 $off \u003c!--父组件App.vue--\u003e \u003cStudent @student=\"getStudentName\"/\u003e \u003c!--子组件Student.vue--\u003e this.$off('student') 解绑多个自定义事件 $off([事件名]) \u003c!--父组件App.vue--\u003e \u003cStudent @student=\"getStudentName\" @demo=\"getDemo\"/\u003e \u003c!--子组件Student.vue--\u003e this.$off(['student','demo']) 解绑所有的自定义事件 $off() \u003c!--父组件App.vue--\u003e \u003cStudent @student=\"getStudentName\" @demo=\"getDemo\"/\u003e \u003c!--子组件Student.vue--\u003e this.$off() This is a tip\r组件上也可以绑定原生DOM事件，需要使用native修饰符. 不使用native修饰符.会默认@click为自定义事件 \u003cStudent @student=\"getStudentName\" @click.native=\"getDemo\"/\u003e this.$refs.组件名.$on('事件名',回调函数)里的回调函数需要写成箭头函数，或者直接定义在当前组件的methods中。否则this指向会有问题 this.$refs.组件名.$on('事件名',()=\u003e{}) //或者 methods:{ demo(){} } this.$refs.组件名.$on('事件名',this.demo) ","date":"2024-08-21","objectID":"/vue2/:30:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"31.全局事件总线 ","date":"2024-08-21","objectID":"/vue2/:31:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"GlobalEventBus 一种组件间通讯的方式，适用于任意组件间的通讯 安装全局事件总线 //《main.js》 new Vue({ .... beforeCreate(){ Vue.prototype.$bus = this //定义全局事件总线 }, ...... }) 使用事件总线： 1、接受数据 //《School.vue》 this.$bus.$on(\"事件名\",回调函数) 2、提供数据 //《Student.vue》 this.$bus.$emit(\"事件名\",传递入参数据) 3、关闭总线中不用的自定义事件 //《School.vue》 beforeDestroy(){ this.$bus.$off('demo') } ","date":"2024-08-21","objectID":"/vue2/:31:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"32.消息订阅与发布 ","date":"2024-08-21","objectID":"/vue2/:32:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"_pubsub pubsub.js是一个第三方库，引用这个库可以在任意框架实现消息的订阅和发布。 npm i pubsub-js pubsub是publish发布和subscribe订阅的组合简写 在组件中引入 import pubsub from 'pubsub-js' 订阅消息 pubsub.subscribe('事件名'，回调函数(事件名，收到的数据){}) 发布消息 pubsub.publish('事件名'，事件名，传递入参数据) 销毁消息（ 取消订阅） //在订阅的组件内,通过id取消订阅 this.pubId = pubsub.subscribe('事件名'，回调函数(事件名，收到的数据){}) beforeDestroy(){ pubsub.unsubscribe(this.pubId) } ","date":"2024-08-21","objectID":"/vue2/:32:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"33.$nextTick 语法this.$nextTick(回调函数) 作用：在下一次DOM更新结束后执行其指定的回调 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在$nextTick所指定的回调函数中执行 This is a tip\r不写$nextTick，用定时器也是可以解决，等待DOM更新结束后执行的操作。 setTimeout(( )=\u003e{ 基于更新后的新DOM进行某些操作 },2000) 只是官方推荐使用$nextTick ","date":"2024-08-21","objectID":"/vue2/:33:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"34.动画效果 实现一块元素从左边缓缓进入再离开的动画效果 原始css3的写法： \u003c!-- 合适时候换成go --\u003e \u003ch1 class=\"come\"\u003e\u003c/h1\u003e \u003cstyle scoped\u003e h1{ background-color: burlywood; } .come{ /* 播放这个动画 持续1s钟 */ animation: demo 1s; } .go{ /* 反转播放这个动画 持续1s钟 */ animation: demo 1s reverse; } /* 动画：定义一个关键帧 起名叫demo */ @keyframes demo { /* 左右来回变换 */ from{ /* 从左边 */ transform: translateX(-100%); } to{ transform: translateX(0px); } } \u003c/style\u003e Vue的实现写法 \u003c!--transition标签包裹的就是过度动画 --\u003e \u003ctransition\u003e \u003ch1\u003e\u003c/h1\u003e \u003c/transition\u003e \u003cstyle scoped\u003e h1{ background-color: burlywood; } /* 进入时激活：来 */ .v-enter-active{ /* 播放这个动画 持续1s钟 */ animation: demo 1s; } /* 离开时激活：离开 */ .v-leave-active{ /* 反转播放这个动画 持续1s钟 */ animation: demo 1s reverse; } /* 动画：定义一个关键帧 起名叫demo */ @keyframes demo { /* 左右来回变换 */ from{ /* 从左边 */ transform: translateX(-100%); } to{ transform: translateX(0px); } } \u003c/style\u003e This is a tip\r如果\u003ctransition\u003e有名字，则.v-enter-active开头需要将v替换成取的名字 \u003ctransition name=\"aaa\"\u003e\u003c/transition\u003e \u003cstyle scoped\u003e .aaa-enter-active{ } .aaa-leave-active{ } \u003c/style\u003e 如果要第一次页面就显示动画，需要加上appear属性 \u003ctransition name=\"aaa\" :appear=\"true\"\u003e\u003c/transition\u003e Vue的实现第二种写法 \u003ctransition\u003e \u003ch1\u003e\u003c/h1\u003e \u003c/transition\u003e \u003cstyle scoped\u003e h1{ background-color: burlywood; } .v-enter-active,.v-leave-active{ transition: 0.5s linear; /* 动画持续0.5s 匀速 */ } /* 进入起点，离开终点 */ .v-enter,.v-leave-to{ transform: translateX(-100%); } /* 进入终点，离开起点 */ .v-leave,.v-enter-to{ transform: translateX(-100%); } \u003c/style\u003e 多个元素过度 \u003c!-- 多个元素使用transition-group --\u003e \u003ctransition-group\u003e \u003c!-- 且每个元素必须有key值 --\u003e \u003ch1 key=\"1\"\u003e\u003c/h1\u003e \u003ch1 key=\"2\"\u003e\u003c/h1\u003e \u003c/transition-group\u003e 集成第三方动画 有时候我们也集成一些好用的第三方库来帮我们完成好看的动画效果，npm网站：https://npmjs.com 上有这么这一个库，叫animate.css 这是一个成型的动画库，只需要引入，就能直接使用这个链接里的动画 用一个简单的例子： 安装这个库 npm install animate.css --save 组件里引入这个库 import 'animate.css' 使用这个库 先选一个样式动画，复制 \u003ctransition-group apper name=\"animate__animated animate__bounce\" enter-active-class=\"animate__swing\" \u003e \u003c/transition-group\u003e ","date":"2024-08-21","objectID":"/vue2/:34:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"35.插槽 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 ====\u003e子组件 分类：默认插槽、具名插槽、作用域插槽 使用方式： 默认插槽 父组件中: \u003cCategory\u003e \u003cdiv\u003ehtml结构1\u003c/div\u003e \u003c/Category\u003e 子组件中: \u003ctemplate\u003e \u003cdiv\u003e \u003c!--定义插槽 --\u003e \u003cslot\u003e插槽默认内容...\u003c/slot\u003e \u003c/div\u003e \u003c/template\u003e 具名插槽 父组件中: \u003cCategory\u003e \u003c!-- 基本写法 --\u003e \u003cdiv slot=\"center\"\u003e \u003cdiv\u003ehtml结构1\u003c/div\u003e \u003c/div\u003e \u003c!-- 只有template可以这样写 --\u003e \u003ctemplate v-slot:footer\u003e \u003cdiv\u003ehtm1结构2\u003c/div\u003e \u003c/template\u003e \u003c/Category\u003e 子组件中: \u003ctemplate\u003e \u003cdiv\u003e \u003c!--定义插槽 --\u003e \u003cslot name=\"center\"\u003e插槽默认内容...\u003c/slot\u003e \u003cslot name=\"footer\"\u003e插槽默认内容...\u003c/slot\u003e \u003c/div\u003e \u003c/template\u003e 作用域插槽 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。 具体编码： 父组件中: \u003cCategory\u003e \u003c!-- scope没有d，注意和style那块区分--\u003e \u003c!-- scope收到传来的整个插槽对象的数据 --\u003e \u003c!-- scope里面入参scopeData包含有多个属性的值，如solt :a=\"11\" :b=\"11\" --\u003e \u003c!-- 引用则写成scopeData.a 或者scopeData.b --\u003e \u003ctemplate scope=\"scopeData\"\u003e \u003c!-- 生成的是u1列表--\u003e \u003cu1\u003e \u003cli v-for=\"g in scopeData.games\" :key=\"g\"\u003e{{g}}\u003c/li\u003e \u003c/u1\u003e \u003c/template\u003e \u003c/Category\u003e \u003cCategory\u003e \u003ctemplate slot-scope=\"scopeData\"\u003e \u003c!--生成的是h4标题 --\u003e \u003ch4 v-for=\"g in scopeData.games\" :key=\"g\"\u003e{{g}}\u003c/h4\u003e \u003c/template\u003e \u003c/Category\u003e 子组件中: \u003ctemplate\u003e \u003cdiv\u003e \u003cslot :games=\"games\"\u003e\u003c/slot\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e .... data(){ return{ games:['1','2','3'] } } \u003c/script\u003e 最新写法 \u003c!-- 旧的写法，现在还能用 --\u003e \u003c!-- scope里面入参有多个，如solt :a=\"11\" :b=\"11\" --\u003e \u003ctemplate scope=\"{dataList}\"\u003e \u003c!-- 最新写成 --\u003e \u003ctemplate solt-scope=\"{dataList}\"\u003e 第四章：Vue拓展 ","date":"2024-08-21","objectID":"/vue2/:35:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"36.Vue中的ajax请求 ","date":"2024-08-21","objectID":"/vue2/:36:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"跨域配置代理 在开发的过程中，如何借助Vue脚手架，去解决ajax跨域的问题。 发送一个ajax的方法： xhr new XMLHttpRequest() ： xhr.open() 和 xhr.send() jQuery 对xhr进行封装 $.get 和 $.post 【因为jQuery中80%内容都是用于对DOM操作的封装，Vue避免对DOM进行操作，所以它不常用在Vue中】 axios 【Vue推荐使用】 fetch 我们这里选择使用axios 安装axios库 npm i axios 引入axios库 import axios from 'axios' 使用 methods:{ demo(){ //服务器地址 axios.get('http://localhost:5000/demo').then( //成功回调 response =\u003e{ console.log(response.data)}, //失败回调 error =\u003e{ console.log(error.message)} ) } } 跨域报错警告\rAccess to XMLHttpRequest at 'http://localhost:5000/demo' from origin 'http://localhost:8080' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 访问规定：协议名，主机名，端口号 。三个一致，允许访问。 不一致，会请求，会查到数据，但是返回给请求方的时候报跨域错误。 解决跨域： 服务器位置：通过配置cors，允许某部分请求头能够访问，解决跨域的问题。 jsonp ：借助script标签里的src属性，在引入外部资源的时候，不受同源策略限制的特点实现的。【只能解决get请求，post解决不了】 配置代理服务器 1. 配置代理 方式一 请求方 \u003c======\u003e 代理服务器 \u003c=======\u003e 目标服务器 niginx 反向代理服务器 vue-cli 借助vue脚手架帮我们开启一个服务器 官方文档位置：https://cli.vuejs.org/zh/config/#devserver-proxy 写法： 在vue.config.js里添加下面的代码： //开启代理服务器 devServer:{ proxy:'http://localhost:5000' //指向目标服务器 } 调用 这里只能找代理服务器发请求，代理服务器端口是8080 methods:{ demo(){ //服务器地址 axios.get('http://localhost:8080/demo').then( //成功回调 response =\u003e{ console.log(response.data)}, //失败回调 error =\u003e{ console.log(error.message)} ) } } 注意！！！\r这样的代理配置有两个缺点： 只能配置一个目标服务器 如果public根文件夹下有静态资源，则直接返回了静态资源，不会请求代理服务器，如： http://localhost:8080/demo会直接请求demo.txt文件，没有才请求代理服务器，有就直接返回demo.txt的信息。 2. 配置代理 方式二 写法： 在vue.config.js里添加下面的代码： devServer: { proxy: { '/api': { target: '\u003curl\u003e', ws: true, changeOrigin: true }, '/foo': { target: '\u003cother_url\u003e' } } } 先看第一部分 devServer: { proxy: { '/api': { //请求前缀，如果是以这个名字为前缀的，代理就转发 target: 'http://localhost:5000', //请求的目标服务器 ws: true, //支持：websocket客户端与服务器间的一种通讯方式 changeOrigin: true,//用于控制请求头重host的值。请求来源 返回成和目标服务器一致 pathRewrite:{'^/api':''} //重写路径，正则匹配以api开头的路径，全部替换成空。不然，访问目标服务器时也会带着请求前缀，导致接口404 }, } //前缀写在端口号后，方法名称前 axios.get('http://localhost:8080/api/demo').then() 3. vue-resource vue-resource也是一个发送ajax请求的库，也是对xhr进行封装的，vue1.0使用广泛，现在官方已不再维护。 安装vue-resource npm i vue-resource main.js中引入插件 import vueResource from 'vue-resource' Vue.use(vueResource) 使用同axios this.$http.get('http://localhost:8080/demo').then( //成功回调 response =\u003e{ console.log(response.data)}, //失败回调 error =\u003e{ console.log(error.message)} ) ","date":"2024-08-21","objectID":"/vue2/:36:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"37.Vuex插件 Vuex简介 概念：专门在 Vue 中实现集中式状态(数据)管理的一个 Vue 插件，对 vue 应用中 多个组件的共享状态进行集中式的管理(读/写)，也是一种组件间通信的方式，且适用于任意组件间通信。 Github 地址: https://github.com/vuejs/vuex This is a tip\r**集中式：**将所有接受方集中起来，发送一次，都能接受。 **分布式：**分成多个相同的，同时发送，都能接受。 Vuex工作原理图 搭建Vuex环境 安装插件：npm i vuex 使用插件：Vue.use(Vuex) 注意哦\r在2022年2月7日，vue3成为了默认版本。也就是说，我们现在去执行npm i vue安装的就直接是vue3了。 vue3成为默认版本的同时，vuex也更新到了4版本。也就是说，我们现在去执行npm i vuex安装的是vuex4了。 而vuex的4版本，只能在vue3中使用。如果在vue2版本中使用vuex的4版本，就会出现报错。 vue2中，只能用vuex的3版本 vue3中，只能用vuex的4版本 我们现在用的vue2的框架环境，所以我们这里要引入3版本的vuex，命令为npm i vuex@3 vuex安装后，存在一个store配置项，所有组件均能看见store：vc ==\u003e store 创建文件：src/store/index.js，store文件夹与App.vue同级 //该文件用于创建Vuex中最为核心的store //引入Vue核心库 import Vue from 'vue' //引入Vuex import Vuex from 'vuex' Vue.use(Vuex) //准备actions-用于响应组件中的动作 const actions={} //准备mutations-用于操作修改数据(state) const mutations ={} //准备state-用于保存存储数据 const state ={} //创建并暴露store export default new Vuex.Store({ actions, mutations, state, }) 在main.js中创建vm时引入store配置项 ..... //引入store import store from './store' ..... //创建vm const vm = new Vue({ el:'#app', render:h=\u003eh(App), store, //配置store直接简写 }) 基本使用 初始化数据、配置 actions、配置mutations、操作文件store.js .... //准备actions-用于响应组件中的动作 const actions={ jia(context,value){ // console.1og('actions中的jia被调用了',ministore,value) context.commit('JIA',value) } } //准备mutations-用于操作修改数据(state) const mutations ={ //执行加 JIA(state,value){ // console.log('mutations中的JIA被调用了'state,value) state.sum += value } } //准备state-用于保存存储数据 const state ={ sum:0 } .... 组件中读取vuex中的数据：$store.state.sum 组件中修改vuex中的数据：$store.dispatch('action中的方法名',数据)或$store.commit('mutation中的方法名',数据) 备注\r若没有网络请求或其他业务逻辑，组件中也可以越过actions，即，不写dispatch，直接编写commit\rvuex开发者工具的使用 getters的使用 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。 在store.js中追加getters配置 ..... const getters = { bigSum(state){ return state.sum = 10 } } //创建并暴露store export default new Vuex.Stroe({ ...... getters }) 组件中读取数据：$store.getters.bigSum 四个map方法的使用 **mapState方法：**用于帮助我们映射state中的数据为计算属性 import {mapState} from 'vuex' computed:{ //借助mapState生成计算属性:sum、schoo1、subject(对象写法) ...mapState({sum:'sum',school:'school',subjeCT:'subject')), //借助mapstate生成计算属性:sum、schoO1、subject(数组写法) ...mapState([ 'sum','school','subjact']), }, **mapGetters方法：**用于帮助我们映射getters中的数据为计算属性 import {mapGetters} from 'vuex' computed:{ //借助mapGetters生成计算属性:bigsum(对象写法) ...mapGetters({bigSum:'bigSum'}), //借助mapGetters生成计算属性:bigSum(数组写法) ...mapGetters(['bigSum']) }, **mapActions方法：**用于帮助我们生成与actions对话的方法，即:包含 $store.dispatch(xxx)的函数 import {mapActions} from 'vuex' methods: { //靠mapActions生成:incrementOdd、incrementwait(对象形式) ...mapActions({incrementOdd:'jia0dd',incrementWait:'jiaWait'}) //靠mapActions生成:incrementOdd、incrementWait(数组形式) ...mapActions(['jiaodd','jiawait']) }, **mapMutations方法：**用于帮助我们生成与mutations对话的方法，即:包含$store.commit(xxx)的函数 import {mapMutations} from 'vuex' methods:{ //靠mapMutations生成:increment、decrement(对象形式) ...mapMutations({increment:'JIA',decrement:'JIAN'}), //靠mapMutations生成:JIA、JIAN(数组形式) ...mapMutations(['JIA','JIAN']), }, 备注\rmapActions与mapMutaions使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。\r一个前端随机生成唯一id的方法 import {nanoid} from 'nanoid' Const id = nanoid(); ajax调用接口 import axios from 'axios' axios.get('接口').then( response =\u003e{}, error =\u003e { alert(error.message) } ) 模块化\u0026命名空间 store包下，index.js //求和相关的配置,开启命名空间 const countOptions={actions:{},mutations:{},state:{},getters:{},namespaced:true} //人员管理相关的配置,开启命名空间 const personOptions={actions:{},mutations:{},state:{},getters:{},namespaced:true} //创建并暴露store export default new Vuex.Store({ modules:{ a:countOptions, b:personOptions } }) 模块化则分别将index.js中的两个部分，分成count.js person.js两个js，并精简index.js中的代码 .... import countOptions from './count' import personOptions from './person' ... export default new Vuex.Store({ modules:{ countAbout:countOptions, personAbout:personOptions } }) xxx.vue组件中 computed:{ //借助mapState生成计算属性，从state中取数据。(数组写法) ...mapState('countAbout',['sum','school','subject']), ...mapState('personAbout',['personList']), //借助mapGetters生成计算属性，从getters中读取数据。(数组写法) ...mapGetters('countAbout","date":"2024-08-21","objectID":"/vue2/:37:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"38.路由 ","date":"2024-08-21","objectID":"/vue2/:38:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"路由的简介 路由就是一组key-value的对应关系 =\u003eroute 多个路由，需要经过路由器的管理 =\u003erouter 编码中的路由，为了实现SPA应用(single page web application)，也称单页面应用 单页面应用，指：只有一个.html文件的应用。如下图： 多页面应用，指：有很多个.html文件的来回跳转切换的应用。 路由使用原理： 点击左边侧边栏某菜单 改变 地址栏 端口号后面的路径 路由器router寻找配置的路由route规则 根据对应的 路径=\u003e组件 的配置规则 更新显示页面，致绿色的内容模块中 如下图： 小tips\r生活中：路由器的作用，是：为了实现多台电脑上网 代码中：路由器的作用，是：为了实现单页面应用的页面跳转 vue-router： vue的一个插件库，专门用来实现SAP应用。 SPA 应用： 单页Web应用(single page web application，SPA) 整个应用只有一个完整的页面。 点击页面中的导航链接不会刷新页面，只会做页面的局部更新。 数据需要通过 ajax 请求获取 路由的理解： 什么是路由? 一个路由就是一组映射关系(key-value) key为路径,value 可能是 function 或componente 路由分类： 后端路由： 理解：value 是 function,用于处理客户端提交的请求。 工作过程：服务器接收到一个请求时，根据请求路径找到匹配的函数来处理请求，返回响应数据。 前端路由: 理解：value 是 component，用于展示页面内容。 工作过程：当浏览器的路径改变时，对应的组件就会显示。 方便记忆\r路由：根据你的路径，由我决定展示对应的组件\r​ ","date":"2024-08-21","objectID":"/vue2/:38:1","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"路由基本使用 在vue项目中使用路由，引入vue-router插件 npm i vue-router 注意\r2022年2月7日以后，vue-router的默认版本，为4版本 vue-router4，只能用在vue3中 vue-router3，才能用在vue2中 我们现在使用的是vue2，所以需要指定引入版本 npm i vue-router@3 安装完成后，在main.js中引入，并应用 //引入插件 import VueRouter from 'vue-router' //应用插件 Vue.use(VueRouter) 此时，在vm中，可以使用一个全新的配置项router new Vue(){ ... router:'' //router中的内容格式被严格控制，不允许随意写入字符串 ... } main.js同级位置，新建文件夹router文件夹。在该文件夹下，新增文件index.js。 index.js中拷入下方代码，用于创建整个应用的路由器。 //该文件专门用于创建整个应用的路由器 import VueRouter from 'vue-router' //引入组件 import About from'../components/About import Home from'../components/Home //创建并暴露一个路由器 export default new VueRouter({ routes:[ //一组组key-value对儿 { path:'/about', component:About }, { path:'/home' component:Home }, ] }) 此时在main.js中赋值router配置项为刚创建的服务器 //引入路由器 import router from./router //创建vm new Vue({ .... router:router //赋值配置项 }) 保存所有文件，此时路由器已经配置完成，并开始工作。 地址导航栏能够看见/#/的符号。 路由器以及路由规则配置完成。 现在需要处理两个组件，能够触发路由跳转： \u003c!--原始htm1中我们使用a标签实现页面的跳转--\u003e \u003ca href=\"./about.htm\"\u003eAbout\u003c/a\u003e \u003ca href=\"./home.html\"\u003eHome\u003c/a\u003e 在路由中，我们使用vue-router库中，提供给我们开发者的一个标签\u003crouter-link\u003e，触发跳转 \u003c!--to指想把路径后面改成什么样子--\u003e \u003c!--active-class指想点击了哪一个菜单，哪个就高亮显示。直接修改地址栏，也可以对应触发高亮--\u003e \u003crouter-link to=\"/about\" active-class=\"active\"\u003eAbout\u003c/router-link\u003e \u003crouter-link to=\"/home\" active-class=\"active\"\u003eHome\u003c/router-link\u003e \u003crouter-view\u003e设置页面内容展示的位置 \u003cdiv class=\"panel\"\u003e \u003cdiv class=\"panel-body\"\u003e \u003c!--指定组件的呈现位置--\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/div\u003e \u003c/div\u003e 几个注意点\r一般组件 \u0026 路由组件 正常写的，如\u003cBanner/\u003e为一般组件，在项目中我们通常放在components包下，进行管理 通过\u003crouter-link to=\"/ \"\u003e写的为路由组件，在项目中我们通常放在pages包下，进行管理 路由组件的显示与隐藏 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。 ​ 在菜单间切换的时候，路由组件是被频繁的挂载和销毁的。 ​ 一个路由组件内容，在点击另一个菜单的时候，切换为另一个路由组件内容，该路由组件则被销毁 ​ 每个路由组件中的this，多了两个属性$route，$router ​ 每个组件都有自己的 $route属性，里面存储着自己的路由信息。整个应用只有一个router，可以通过组件的 $router 属性获取到。 ​ 这里注意： ​ 哪个组件的this，打印出来的$route就是哪个组件的path，如下图 ​ 但是每个组件的this中，打印出来的$router是同一个 ​ ","date":"2024-08-21","objectID":"/vue2/:38:2","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"嵌套路由 嵌套路由的实现效果： ​ 点击左侧的菜单，其右下的内容中有新的菜单，点击新的菜单，更改下方的内容。 如下图： ​ 嵌套路由，有时候我们也叫它多级路由，路径上体现为多级路径：xxx/xxx 嵌套路由的配置，使用children配置项： { path:'/home', component:Home, children:[ { path:'new', //子路由路径前方不写斜杠'/',底层路由处理中会对子路径自动加上'/' component:New, } ] } 组件中的配置，to路径注意写成完整路径 \u003crouter-link to=\"/home/news\" active-class=\"active\"\u003eNew\u003c/router-link\u003e ​ ","date":"2024-08-21","objectID":"/vue2/:38:3","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"路由传参 路由的query参数 路由嵌套极限一般都在4-5层为极限，一般都在2-3层 只写一个组件Detail路由组件，通过传参来实现多个路由被点击使用时，对应显示的组件内容不同 路由组件有两个参数，其中query参数，和ajax中的query参数传参类似： //路径后面用问号?的形式，多个参数之间用\u0026间隔，例如： \u003crouter-link to=\"/home/message/detail?id=666\u0026title=hello\"\u003e跳转 \u003c/router-link\u003e 在唯一的Detail组件中，有一个属性this.$route能够得到这个组件相关的所有路由配置信息。在配置信息中，有一个属性query包含所有传递过来的参数及参数值。 在组件中获取参数，并页面显示渲染： \u003cul\u003e \u003cli\u003e消息编号：{{$route.query.id}}\u003c/li\u003e \u003cli\u003e消息内容：{{$route.query.title}}\u003c/li\u003e \u003c/ul\u003e 注意： \u003c!--要使参数值为变量，需要使用模版字符串标识符``，并且使用${}包裹变量--\u003e \u003crouter-link to=\"/home/message/detail?id=666\u0026title=hello\"\u003e \u003c/router-link\u003e \u003c!--例如，下面的写法：(字符串写法)--\u003e \u003crouter-link :to=\"`/home/message/detail?id=${m.id}\u0026title=${m.title}`\"\u003e \u003c/router-link\u003e \u003c!--或者，下面的写法：(对象写法)--\u003e \u003crouter-link :to=\"{ path:'/home/message/detail', query:{ id:m.id, title:m.title } }\"\u003e \u003c/router-link\u003e 路由的params参数 路由组件的第二个参数，params参数，和ajax中的params参数传参也类似： //path配置项，路径后面，使用传参占位符 name:'about', path:'/about/:id/:title', component:About, children:[{...}] \u003c!--跳转时传参紧跟路径--\u003e \u003crouter-link to=\"/home/message/about/666/hello\"\u003e\u003c/router-link\u003e 此时参数及参数值，出现在this.$route的params中 在组件中获取参数，并页面显示渲染： \u003cul\u003e \u003cli\u003e消息编号：{{$route.params.id}}\u003c/li\u003e \u003cli\u003e消息内容：{{$route.params.title}}\u003c/li\u003e \u003c/ul\u003e 同样的，将写死的传递参数位置改为变量取值的方式： \u003c!--传参写死--\u003e \u003crouter-link to=\"/home/message/about/666/hello\"\u003e\u003c/router-link\u003e \u003c!--传参改为变量：(字符串写法)--\u003e \u003crouter-link :to=\"`/home/message/about/${m.id}/${m.title}`\"\u003e\u003c/router-link\u003e \u003c!--或者，下面的写法：(对象写法)--\u003e \u003crouter-link :to=\"{ name:'about', params:{ id:m.id, title:m.title } }\"\u003e \u003c/router-link\u003e \u003c!--注：params的对象传参写法，只能使用name来确定路由跳转位置，不能使用path--\u003e 路由的props配置 路由中的一个全新的配置项props，用于路由更加方便的接受参数 props的第一种写法：值为对象 该对象中的所有key-value都会以props的形式传给Detail组件 name:'...', path:'...', component:..., children:[{...}], //props的第一种写法：值为对象-------------------------------------------------- //该对象中的所有key-value都会以props的形式传给Detail组件 props:{ a:666, b:'hello' } 在组件中接受并使用： \u003cul\u003e \u003cli\u003e消息编号：{{a}}\u003c/li\u003e \u003cli\u003e消息内容：{{b}}\u003c/li\u003e \u003c/ul\u003e \u003cscript\u003e { ..., porps:['a','b'] } \u003c/script\u003e 这种写法比较少用，一般情况下，我们不直接在路由配置中写死数据进行传参。 所以我们了解第二种props的写法 props的第二种写法：值为布尔值 若布尔值为真，就会把该路由组件收到的所有params参数，以props的形式传递给Detail组件 name:'...', path:'/about/:id/:title', component:..., children:[{...}], //props的第二种写法：值为布尔值-------------------------------------------------- props:true 在组件中接受并使用： \u003cul\u003e \u003cli\u003e消息编号：{{id}}\u003c/li\u003e \u003cli\u003e消息内容：{{title}}\u003c/li\u003e \u003c/ul\u003e \u003cscript\u003e { ..., porps:['id','title'] } \u003c/script\u003e props的第三种写法：值为函数 依赖return，返回的一定是一个对象，对象内的数据都会以props的形式传递给Detail组件 name:'...', path:'/about', component:..., children:[{...}], //props的第三种写法：值为函数-------------------------------------------------- props:function(){} //简写为 props(){ return {id:'666',title:'hello'} } //路由的回调函数带有$route参数 props($route){ return {id:$route.query.id,title:$route.query.title} } //通过解构赋值，可以简写为 props(query){ return {id:query.id,title:query.title} } //或者 props(query:{id,title}){ return {id:id,title:title} } //不过一般情况下，解构赋值的语句语义可读性和理解性不是很清楚，所以一般还是写回调函数$route的写法 ","date":"2024-08-21","objectID":"/vue2/:38:4","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"命名路由 给路由器取名字 1、作用：可以简化路由的跳转写法 2、示例： //命名使用name配置项 name:'about', path:'/about', component:About, children:[{...}] \u003c!--简化跳转--\u003e \u003c!--简化前：完整路径的2种写法--\u003e \u003crouter-link to=\"/home/message/about\"\u003e\u003c/router-link\u003e \u003crouter-link :to=\"{path:'/home/message/about'}\"\u003e\u003c/router-link\u003e \u003c!--简化后：直接使用命名--\u003e \u003crouter-link :to=\"{name:'about'}\"\u003e\u003c/router-link\u003e \u003c!--这里注意，to属性，不注明使用name，默认是使用的path--\u003e \u003c!--简化传递参数--\u003e \u003crouter-link :to=\"{ name:'about', query:{ id:m.id, title:m.title } }\"\u003e \u003c/router-link\u003e ","date":"2024-08-21","objectID":"/vue2/:38:5","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"\u003crouter-link\u003e的replace属性 作用：控制路由跳转时操作浏览器历史记录的模式 浏览器的历史记录有两种写入方式：分别为push和 replace，push是追加历史记录，replace 是替换当前记录。路由跳转时候默认为 push 如何开启replace模式：\u003crouter-link replace.......\u003eNews\u003c/router-link\u003e 路由对浏览器历史记录的影响： 浏览器中有两个按钮，← →，一个是前进一个是后退，这两个按钮都是依赖浏览器的历史记录在工作 浏览器的历史记录的操作模式是栈push模式：根据点击，不停的往栈中追加信息。 我们通常将这种追加信息的方式，称为push方式（与数组身上的push类似，不破坏任意一个元素，只往后面追加一个元素。在官方他有一个好听名字，叫压栈） 浏览器的前进与后退，就是操作历史记录列表中的指针进行移动 对历史记录的操作，除了push，还有另外一种方式，replace replace最大的特点就是替换掉当前栈点那一个元素 默认router-link所开起的模式是push模式，如果要开启replace模式，写法如下： \u003c!--追加replace属性--\u003e \u003c!--完整写法--\u003e \u003crouter-link :replace=\"true\" \u003e\u003c/router-link\u003e \u003c!--可简写为--\u003e \u003crouter-link replace \u003e\u003c/router-link\u003e ","date":"2024-08-21","objectID":"/vue2/:38:6","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"编程式路由导航 作用：不借助\u003croute-link\u003e实现路由跳转，让路由跳转更加灵活 如果不使用\u003croute-link\u003e标签进行路由跳转的实现，路由器中的缔造者提供了$router.push \u003cbutton click=\"pushShow(i)\"\u003e按钮1\u003c/button\u003e \u003cscript\u003e ..... methods:{ pushShow(i){ this.$router.push({ //push对象中的写法，同route-link中的to中内容一摸一样 name:'about', //跳转以改命名路由为目标路由的界面 query:{ //正常传参 id:i.id, title:i.title } }) } } \u003c/script\u003e 同理，对应$router.push也有$router.replace，以实现操作历史记录的方式为替换型。写法： \u003cbutton click=\"replaceShow(i)\"\u003e按钮2\u003c/button\u003e \u003cscript\u003e ..... methods:{ replaceShow(i){ this.$router.replace({ //replace和push写法一样 name:'about', //跳转以改命名路由为目标路由的界面 query:{ //正常传参 id:i.id, title:i.title } }) } } \u003c/script\u003e 路由器中也提供了操作历史记录的方法，：后退$router.back()、前进$router.forward()、$router.go(入参) //后退一步 this.$router.back() //前进一步 this.$router.forward() //前进或者后退多少步 //入参必须是数字 this.$router.go(3) //入参是正数，则前进。这里表示前进3步 this.$router.go(-2) //入参是负数，则后退。这里表示后退2步 ","date":"2024-08-21","objectID":"/vue2/:38:7","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"缓存路由组件 作用：让不展示的路由组件保持挂载，不被销毁。 我们每切换一个路由，切换前的路由组件就会被销毁。 当用户在一个路由页面输入信息后，切换致另一个路由浏览信息再切回输入的路由页面进行继续输入时，我们发现，原路由已经被销毁，该路由页面重新渲染，导致了用户输入内容丢失。 在该需求下，我们需要一个缓存原路由组件的办法。由此，我们引入缓存路由组件标签\u003ckeep-alive\u003e \u003c!--该标签包裹住的路由，均不被销毁，均保持缓存--\u003e \u003ckeep-alive\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/keep-alive\u003e \u003c!--include属性,设定只缓存哪一个路由--\u003e \u003c!--特别注意：About为组件名称，要缓存哪个组件，就写哪个组件的组件名称--\u003e \u003ckeep-alive include=\"About\"\u003e \u003c!--如果是缓存多个，则用数组形式--\u003e \u003ckeep-alive :include=\"['About','News']\"\u003e ","date":"2024-08-21","objectID":"/vue2/:38:8","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"两个新的生命周期钩子 作用：用于捕获路由组件的激活状态 定时器开启后，必须在组件即将销毁的生命周期函数beforeDestroy中关闭 当路由组件被缓存时，销毁生命周期函数不会被触发。 上面两个限制，导致了定时器无法被关闭，并会在浏览者中持续一直调用。针对该需求，引出，路由组件独有的两个生命周期钩子：激活activated()、失活deactivated() 当页面切换在当前组件，则当前组件被激活。activated在被激活时候触发 当页面切换至其他组件，则当前组件失活。deactivated再失活时触发 activated(){ console.log('该组件被激活了') //这里可以开启定时器 } deactivated(){ console.log('该组件失活了') //这里关闭定时器 } This is a tip\r**3个不在生命周期图示里面的生命周期构子：**这里的2个路由生命周期构子 + nextTick this.nextTick(function(){ ... })该钩子，当你操作完数据之后，Vue把真实Dom放入页面了以后，Vue再帮你调用该函数里面的内容。 ​ ","date":"2024-08-21","objectID":"/vue2/:38:9","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"路由守卫 作用：对路由进行权限控制。【主要作用：权限校验】 当某个人登陆时，我们将此人对于各个路由所对应的路由组件是否可见，称为对其鉴权。 分类：全局守卫、独享守卫、组件内守卫 代码位置：在router文件夹下的index.js中，在暴露一个创建的路由器对象之前，添加路由守卫。 全局前置 路由守卫 router.beforeEach 全局前置 路由守卫：页面切换前调用 //创建一个路由器 const router = new VueRouter({...}) //--------------全局前置路由守卫-------------- //在每一次路由切换之前，都会调用该函数，进行权限校验; //在初始化到时候，也被调用。 router.beforeEach((to,from,next)=\u003e{ ... //to：【要去哪里】目标路径路由对象 //from：【从哪里去】当前所在路径路由对象 //next()：【放行】没有这条就都不会继续往下走了，需要手动抛出'无权限'异常 next() }) //暴露路由 export default router 判断去哪里是否有权限时我们通常会使用目标路径path属性来进行判定，例如： if(to.path === '/about'){ next() } 当设置需要权限的路由较多时，这样判定就变得不可取了。 此时，我们想要在每个路由申明时，设置某个配置项，以简洁路由权限的判定。 在路由对象中Vue提供了meta这个对象，用于设置一些自定义的配置项。 meta在官方有个好听的名字，叫路由元。我们通常在其中设置一个配置项isAuth(是否被授权)，用来进行路由守卫的判定。 //哪个路由需要鉴权，meta:{isAuth:true}就写在哪里 routes:[ {name:'about',path:'/about',meta:{isAuth:false}}, {name:'home',path:'/home',meta:{isAuth:true}} ] //路由守卫判定:需要鉴权就往下走。没有设置的默认为undefined，该处判定为假，就不进行鉴权 if(to.meta.isAuth){ if('满足鉴权放行的条件：例如登录账号满足超级管理员'){ next()//放行 }else{ console.log('该账号无权限') } }else{ next()//不参与鉴权的路由均放行 } ​ 全局后置 路由守卫 router.afterRach全局后置 路由守卫：页面切换后调用。 //创建一个路由器 const router = new VueRouter({...}) //--------------全局后置路由守卫-------------- //在每一次路由切换之后，都会调用该函数，进行资源操作; router.afterRach((to,from)=\u003e{ //注意该API就没有next入参了，因为是切换后调用，是不用进行放行操作的 //此处通常用来修改：需要页面有权限显示之后，一些页面信息，如： document.title = '对应跳转页面的标题' //修改网页标签名称为跳转页面名称 }) //暴露路由 export default router 独享 路由守卫 独享路由守卫：顾名思义指，某一个路由单独使用的路由守卫。 //某route路由申明中 { name:'', ...., //进入该路由之前，调用该函数中内容 beforeEnter:(to,from,next) =\u003e { .... //写法和前置路由一样 } } 注意：和全局路由守卫不同的是，独享路由守卫只有前置，没有后置。如果想要使用后置，可以独享守卫和全局后置守卫搭配使用。 ​ 组件内 路由守卫 组件内路由守卫：指在具体的某一个组件中去写路由守卫，而不是在这个路由器配置 文件中编写。 //进入守卫：通过路由规则，进入该组件时被调用 beforeRouteEnter(to,from,next){ next() //都得放行才能往下走 }, //离开守卫：通过路由规则，离开该组件时被调用 beforeRouteLeave(to,from,next){ next() //都得放行才能往下走 } 注意\r通过路由规则：通过导航栏点击，改变地址栏路由，引起路由组件展示，则是经过了路由规则。 如果是直接放在其他组件中引用该路由组件，引起路由组件展示，这种方式是不会触发组件内路由守卫的。 ​ ","date":"2024-08-21","objectID":"/vue2/:38:10","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"路由器的两种工作模式 hash模式 在地址栏，我们分析地址：localhost:8080/#/home/message。我们发现，从路由访问开始，地址就一直存在的一个符号：/#/，我们把它称作hash。 这里提到的所有的hash与数据加密无关，只是站在前端的角度，对路径进行分析。 路径中，所有的从#开始，到结束的内容，都称作：路径中的hash值。 hash值的作用：hash最大的特点就是不会随着http的请求发给服务器。 所以路径中属于hash值的内容，不会作为路径发给服务器，进行请求。例如： --请求117服务器5000端口的student资源信息 10.10.10.117:5000/student --添加hash值 10.10.10.117:5000/student/#/xjdsdldfj/sdjfs/2342432/wasdf 以上这两个地址在浏览器地址栏中的请求，返回是一模一样的。因为#/xjdsdldfj/sdjfs/2342432/wasdf不会作为地址发送给服务器。 history模式 在router文件夹下的配置文件index.js中，设置路由器中的mode的配置项。如果不设置，默认使用hash模式。写法： const router = new VueRouter({ mode:'history', //该配置项只有两种值：history、hash。不写该配置项，则默认使用hash模式 routes:[...], }) export default router 这里注意\rVue脚手架的特性是修改代码以后，在当前路径下进行刷新。 所以如果地址栏路径为localhost:8080/#/home/message/detail时，此时修改了mode属性为history，页面刷新依旧默认使用当前路径，导致没有任何效果。 此时，需要将地址栏路径手动改成基本根路径localhost:8080，再进行路由访问。 访问符合路由规则，实现路由组件正常跳转。地址栏路径中#标识符消失，地址格式为localhost:8080/home/message/detail **符合路由规则：**点击路由，经过路由器，根据路由规则rules，匹配路由组件进行展示。 所以符合路由规则是没有进行服务器请求的，此时如果在地址栏点击刷新localhost:8080/home/message/detail该地址会全部作为路径请求服务器，导致404 解决history模式刷新404问题 404问题出现在服务器无法请求访问不存在的地址路径接口。 所以该问题，由后端出面解决。 nodejs服务器有个专门解决这个问题的中间件插件，java也有专门的库（这里只演示nodejs的处理） 在https://www.npmjs.com/官方网站搜索插件connect-history-api-fallback 在服务器控制台，输入下面代码，安装这个中间件： C:Users\\wangty\\Desktop\\demo\u003enpm i connect-history-api-fallback 安装完成后，在server.js中引入中间件： //在“const express = ...”的代码后面 添加这一句 var history = require('connect-history-api-fallback'); 并在server.js中使用中间件： //在“const app = .......”的代码后面 添加这一句 app.use(history()) //在“app.use(express.......”的代码钱面 添加这一句 history模式 VS hash模式 hash模式 history模式 浏览器(路由跳转)兼容性更好 浏览器(路由跳转)兼容性略差 地址不够美观，带# 地址美观，不带# 上线部署不影响后端请求 上线部署需要后端配置配合 地址校验严格时，会被标记不合法 地址校验合法 项目上线的基本流程 所有的.vue文件，通过npm run build命令打包之后形成.html文件放置在服务器中供用户使用。 打包之后形成一个新的dist文件夹，该文件夹只有一个单文件页面index.html。直接访问无效果。 打包的所有文件，需要放置在服务器上，进行部署。 这里使用nodejs的express搭建一个微型的服务器，并将前端打包文件部署上去 只记录简单操作步骤，不解释原理： 桌面新建一个demo文件夹，用vscode打开 vscode中打开控制台，运行npm init package name设置为：wangty_test_server（随便起个服务器名字） 一路回车 控制台路径回到demo时，运行npm i express demo文件夹下新建一个server.js，里面代码如下： const express =require('express') //引入express const app = express() //创建一个app服务实例对象 app·get('/person',(req,res)=\u003e{ //配置一个后端路由，person，返回一个人员信息 res.send({ //req - 请求 ， res - 返回 name:\"tom', age:18 }) }) app.listen(5005,(err)=\u003e{ //app开启一个端口监听，开在5005端口 if(!err)console.log('服务器启动成功了!') //没有错误对象信息，就提示启动成功 }) 控制台运行node server，控制台打印服务器启动成功了表示该微型服务器已经启动成功。 打开浏览器地址栏访问localhost:5005/person，可以成功返回人员信息。 demo文件夹下新建一个static文件夹（有时候也叫public文件夹），在其中放入.html文件 这里为了测试是否成功展示，我们手动新建一个demo.html放入static文件夹下： ```html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003etest\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv\u003e\u003ch1\u003e你好！\u003c/h1\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ``` 回到server.js，添加代码： //在“const app = ...”的代码后面 添加这一句 app.use(express.static(__dirname+'/static')) //使用插件,读取当前static文件下的页面 ctrl+c停掉服务器，重新启动服务器 打开浏览器地址栏访问localhost:5005/demo.html，可以成功展示demo.html的你好页面。 我们知道默认浏览器访问index.html页面，所以我们可以将其改得更简化一点。将demo.html文件名称修改为index.html，并且地址栏访问localhost:5005，即可成功展示你好页面。 此时，即可对前端打包文件进行部署。 拷贝所有的dist文件夹中内容，放入static文件夹中，重复的文件点击替换覆盖即可。 ctrl+c停掉服务器，重新启动服务器 地址栏访问localhost:5005，打包的项目即可以正常运行。 部署上线完成。 ","date":"2024-08-21","objectID":"/vue2/:38:11","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["前端"],"content":"39.Vue UI组件库 移动端常用UI组件库：Vant 、Cube Ul、Mint Ul PC端常用UI组件库：Element Ul、IView Ul、 京东也有一个组件库：NUTUI element-ui举例： element-ui是一个饿了么团队打造的，pc端基于Vue基本使用的一个组件样式库。 引入 Element：完整引入、按需引入 https://element.eleme.cn/#/zh-CN/component/quickstart 【完整引入会导致前端js文件过大，如果引入使用的部分较少，推荐使用按需引入的方式】 ​ 第五章：vue3 使用vue-cli创建工程 使用vite创建工程 分析工程结构 安装开发者工具 初识setup re数 处理基本类型 re函数 处理对象类型 reactive函数 回顾Vue2的响应式原理 Vue3响应式原理proxy Vue3响应式原理reflect reactive对比ref setup的两个注意点 computed计算属性 watch监视re定义的数据 watch监视reactive定义的数据 watch时value的问题 watchEffect函数 Vue3生命周期 自定义hook toRef与toRefs shallowReactive与shallowRef readonly与shallowReadonly toRaw与markRaw customRef provide与inject 响应式数据的判断 CompositionAPl的优势 Fragment组件 Teleport组件 Suspense组件 Vue3中其他的改变 ","date":"2024-08-21","objectID":"/vue2/:39:0","tags":["vue"],"title":"【Vue前端框架】Vue2.0全套教程","uri":"/vue2/"},{"categories":["Hugo系列"],"content":"官网下载Typora 安装 网址：Typora 官方中文站 (typoraio.cn) 点立即下载，下载下来的安装包，双击Typora.exe 完成安装 ","date":"2024-08-11","objectID":"/text08/:1:0","tags":["Typora"],"title":"【Typora】破解/安装激活 Typora 2024 教程","uri":"/text08/"},{"categories":["Hugo系列"],"content":"本地激活Typora 激活方法 安装路径下找到：Typora\\resources\\page-dist\\static\\js 右键用记事本打开这个文件，ctrl+F定位到 e.hasActivated=\"true\"==e.hasActivated 替换为 e.hasActivated=\"true\"==\"true\" 这样就已经后台激活完成，但是每次开软件开始会提醒激活。 关闭软件每次启动时的已激活弹窗 继续在安装路径下resources\\page-dist\\license.html，找到 依旧ctrl+F 定位到： \u003c/body\u003e\u003c/html\u003e 替换为 \u003c/body\u003e\u003cscript\u003ewindow.onload=function(){setTimeout(()=\u003e{window.close();},5);}\u003c/script\u003e\u003c/html\u003e 特别注意！！！\r复制粘贴上面这段代码的时候： 有些系统会将window.onload 中onload的英文字母o和n变成其他希腊字母或其他Unicode字符（例如，ο是希腊字母omicron，而ο和o在视觉上非常相似） 这会导致这段代码没有起作用！！！！ 如果这段代码替换后没反应，请务必手敲onload保存后再试。。。。 去除软件左下角“未激活”提示 按照安装路径，找到 resources\\locales\\zh-Hans.lproj\\Panel.json 文件中查找： \"UNREGISTERED\":\"未激活\"， 替换为： \"UNREGISTERED\":\" \" 最后，重新打开Typora，手动关掉激活窗口，之后就不会再出现。 ","date":"2024-08-11","objectID":"/text08/:2:0","tags":["Typora"],"title":"【Typora】破解/安装激活 Typora 2024 教程","uri":"/text08/"},{"categories":["Hugo系列"],"content":"引用图片 注意：Typora 使用带图片的文件，使用相对路径，创建带图片的笔记时，.md文件命名需为index。自动访问路径中的index文件，剪切图片时自动生成image文件夹，使得图片相对路径访问正常 【注意：我的安装路径位置在 C:\\Program Files\\Typora】 ","date":"2024-08-11","objectID":"/text08/:3:0","tags":["Typora"],"title":"【Typora】破解/安装激活 Typora 2024 教程","uri":"/text08/"},{"categories":["Hugo系列"],"content":"Hugo 是 Go 编写的静态网站生成器，速度快，易用，可配置。 Hugo 依赖于 Markdown 文件，元数据字体 。用户可以从任意的目录中运行 Hugo，支持共享主机和其他系统。只需要几分之一秒就可以渲染一个经典的中型网站，非常适合博客，文档等等网站的生成。 ","date":"2024-08-09","objectID":"/text07/:0:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"HUGO下载安装 ","date":"2024-08-09","objectID":"/text07/:1:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"安装环境 安装好Windows版本的 git： git官网：https://git-scm.com/downloads git安装教程请参考：【 Windows系统Git安装教程（详解Git安装过程） - 学为所用 - 博客园 (cnblogs.com)】 下载并安装Windows版本的 GO： go的中文官网：https://go.p2hp.com/ 下载并安装Windows版本的 hugo： hugo·GitHub 地址 https://github.com/gohugoio/hugo/releases 本教程中下载的项目压缩包名为：hugo_extended_0.128.2_windows-amd64 压缩包下载路径：https://github.com/gohugoio/hugo/releases/download/v0.128.2/hugo_extended_0.128.2_windows-amd64.zip ","date":"2024-08-09","objectID":"/text07/:1:1","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"配置环境变量 创建程序目录 在C盘新建一个名为hugo的文件夹，进入文件夹后再创建一个名为bin的文件夹 将下载好的Windows版本hugo应用程序压缩包解压到这个bin文件夹 配置环境变量 然后在Windows搜索栏中搜索环境变量，点击环境变量 选择系统变量中的Path，点击新建 将 C:\\hugo\\bin 这个路径添加到环境变量 查看程序版本 然后打开powershell终端，输入下方命令查看 hugo version 显示版本号，即为成功安装了hugo程序。 ","date":"2024-08-09","objectID":"/text07/:1:2","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"创建博客网站 现在我们就可以使用hugo搭建一个属于自己的博客网站了。 创建站点 首先，我们进入到C盘下的hugo文件夹，点击鼠标右键选择在终端中打开 执行下方命令创建一个静态站点：（本例创建的站点名为myblog，大家可以自定义） hugo new site myblog 创建后，我们回到hugo目录，可以看到新增了一个名为myblog的文件夹： 进入该文件夹后，就能看到刚刚创建的博客网站程序： 在站点中创建一篇文章 创建好了站点后，现在网站中还什么内容都没有，我们可以创建一篇文章来进行一下测试： 现在我们在终端中执行下方命令，进入站点目录： 进入网站目录后，执行下方命令创建一篇markdown格式的文章： hugo new posts/Articles01.md 执行后可以看到提示已经创建了一篇名为Articles01的文章与其所属路径。 进入这个路径，就能看到文章了。 打开这篇文章后能看到这篇文章的标题，日期等相关信息 在这里我们需要把draft（草稿） = true 修改为 draft = false 来表示这并不是一篇草稿。 然后随便在文档中写一些内容，比如： 然后保存关闭即可。 为网站添加主题 现在我们已经创建好了一个博客网站，并在网站中发布了一篇文章，不过现在我们还不能在浏览器中运行这个本地网站进行查看，因为在这之前，我们需要先给网站添加一个主题。 我们可以登录下方的hugo官网页面来挑选一个你喜欢的网站主题： https://themes.gohugo.io/themes 这里我们随便选择一个主题，点击进入页面后，可以看到安装方式： 可以看到，想要安装这个网站主题，需要先在终端中进入站点目录： cd myblog 也可以想上边一样，在myblog目录中右键在终端中打开。 然后执行下方命令： git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c 然后在打开名为 hugo 的 toml源文件，添加主题配置即可。 网站标题修改为myblog，然后再把theme = “m10c”这行代码加进去保存即可。 现在，我们在myblog目录下的主题文件夹中就能看到刚才添加的主题文件目录了： 本地访问测试 现在，我们在终端中执行下方代码启动本地网站进行测试： hugo server 本地清除缓存运行 hugo server --disableFastRender --gc --noHTTPCache --noBuildLock --logLevel debug 可以看到成功启动，在浏览器中输入 localhost:1313/ 即可访问这个本地站点： 可以看到网站标题为myblog，里边有刚才我们发布的第一篇文章Article01： 点击文章标题Article01，即可进入文章页面。 这样我们就成功使用HUGO在Windows本地快速部署了一个静态博客网站。 ","date":"2024-08-09","objectID":"/text07/:2:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"部署到公网 This is a tip\r下面是三种部署网站到公网的办法\r","date":"2024-08-09","objectID":"/text07/:3:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"安装内网穿透工具 目前我们在本机成功部署了一个博客网站，但如果没有公网IP的话，只能在本地局域网环境使用，有一定局限性。如果出差在外想要远程使用的话，可以结合Cpolar内网穿透生成公网地址，免去了本地重新部署过程，只需要使用公网地址直接就可以访问本地部署的网站，进行演示。 点击进入cpolar官网注册一个账号，并下载最新版本的Cpolar https://www.cpolar.com/ 登录成功后，点击下载Cpolar到本地并安装（一路默认安装即可）本教程选择下载Windows版本。 Cpolar安装成功后，在浏览器上访问 localhost:9200，使用cpolar账号登录,登录后即可看到Cpolar web 配置界面,结下来在web 管理界面配置即可。 http://localhost:9200/#/login?redirect=%2Fdashboard 【hugo-账户：1437059026@qq.com 密码：Wty201408.】 配置公网地址 接下来配置一下本地 博客网站 的公网地址， 登录后，点击左侧仪表盘的隧道管理——创建隧道， 创建一个 博客网站 的公网地址隧道： 隧道名称：可自定义命名，注意不要与已有的隧道名称重复 协议：选择 本地地址：1313 域名类型：选择随机域名 地区：选择China VIP 点击创建 隧道创建成功后，点击左侧的状态——在线隧道列表,查看所生成的公网访问地址，有两种访问方式。 使用任意一个上面生成的公网地址,在电脑或任意设备在浏览器进行登录访问,即可成功看到 本地博客网站 界面,这样一个可以远程访问的公网地址就创建好了,使用了Cpolar的公网域名,无需自己购买云服务器,即可在公网访问本地部署的服务了！ ","date":"2024-08-09","objectID":"/text07/:3:1","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"搭建本地服务器 内网穿透地址会随着ip的更新而变化，为了保证不一直修改baseUrl，配置服务器来搭载网站。 配置本地服务器，将编译后的网站文件运行与服务器后，本地可以不启动hugo server 在控制面板打开命令提示符窗格，键入npm install -g anywhere 9999 npm install -g anywhere 9999 9999这里是设置端口号，端口号自行设置，也可以不输入xxx会默认8000端口号 安装成功anywhere后，可以直接使用anywhere指令启动服务，但是默认是查看全部文件列表 编译网站文件并运行于本地服务器 进入myblog根目录下，输入hugo命令进行编译 hugo 编译后，生成public文件夹，进入该文件夹根目录，并输入anywhere使编译文件运行在上面 cd public anywhere 【特别注意：运行在服务器上的一定是：\"编译后的文件！！！！\"】 ","date":"2024-08-09","objectID":"/text07/:3:2","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"BaseUrl配置 使用hugo server本地运行的程序，每次跳转都将走localhost或者127.0.0.1，此处理解和其他程序启动一样，访问及跳转都将走本地。 若要使baseURL配置每次跳转时，自动请求的域名地址为服务器地址，则需要设置.toml文件中的baseURL。 baseURL = 'http://136c5bcc.r16.vip.cpolar.cn/' //内网穿透地址 baseURL = 'http://192.168.9.125/' //本地服务器地址 内网穿透地址需先将本地服务器内网地址先生成，再配置。配置方法同小结6相同，配置好后如图 逻辑为： 1、配置本地baseURL为内网穿透地址，使每次访问均可访问内网穿透地址 2、编译文件后，跳转路径指向内网穿透地址 3、内网穿透地址配置localhost:8000指向本地服务器 4、启动本地服务器，使内网穿透访问正常 5、使跳转路径正常 当此处修改为内网穿透地址后，需先进行编译，再通过本地服务器启动后的地址后，记得编译之后再运行本地服务器 ","date":"2024-08-09","objectID":"/text07/:3:3","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"创建 GitHub Pages 站点 GitHub提供了Github pages用于挂在类似于hugo，hexo这样的博客静态网页， 官方教程：https://docs.github.com/zh/enterprise-server@3.12/pages/getting-started-with-github-pages/creating-a-github-pages-site GitHub登陆后，新建仓库Wangty654.github.io 注意仓库名需要和账户名一致 修改博客配置文件.toml中的默认跳转地址为仓库名 baseURL = 'https://Wangty654.github.io' //仓库服务器地址 仓库建好后，进入博客根目录，编译网站 cd myblog C:/hugo/myblog \u003e hugo 生成的编译后文件夹public为所有html、css、js组成的静态网站文件 上传GitHub cd public C:/hugo/myblog/public \u003e git init git add . git commit -m '1' git push 请求成功后直接访问https://Wangty654.github.io即可 ","date":"2024-08-09","objectID":"/text07/:3:4","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"腾讯云服务器部署 配置的后台的代理 静态资源服务器 如果是放我的静态网页 只需要将dist配置在root上，并对其刷新页面的位置进行配置就行 dist内存在index页面等同于，hugo的public页面 ftp传文件 、shell 输入命令 ","date":"2024-08-09","objectID":"/text07/:3:5","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"网站样式自定义设置 This is a tip\r一些基础样式调整，具体样式美化可以参考：Hugo的LoveIt主题美化（一、二、三、四）\r","date":"2024-08-09","objectID":"/text07/:4:0","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["Hugo系列"],"content":"关于themes主题 themes主题为git拉取下来用于整个静态网站的样式代码，均可按照需求进行修改 头像设置 1、在layouts包下，有一个baseof.html文件，将其中的首页文件指向调整为你想要的图片 2、并同时更改static文件夹中的图片，使指向和文件名一致。 主题颜色设置 1、拷取themes中配置文件config.toml里默认设置主题颜色的部分代码 默认主题有三种样式 选择其中一种样式，放入我们的配置文件hugo.toml，可以对其中的文字颜色也进行修改，本主题改为粉色 主页文字设置 更改layouts包下，baseof.html文件中书写首页介绍文字的位置 主页分类菜单设置 1、配置文件hugo.html中配置菜单栏 2、并在每条笔记中，使用yaml格式书写抬头 主页关于菜单设置 取主题中content包下的about文件放入myblog的content包根目录下。about内的内容可以自行定义 关于代码块样式设置 配置文件中写入设置样式的命令模块，根据需要更改其中style的值。 hugo中文文档中 ：https://hugo.opendocs.io/getting-started/ 选择“内容管理” - “语法高亮” 在style中选择想要更改的样式，放入配置文件中：https://xyproto.github.io/splash/docs/ ","date":"2024-08-09","objectID":"/text07/:4:1","tags":["hugo","本地服务器","内网穿透","gitHub"],"title":"【HUGO】HUGO博客网站搭建","uri":"/text07/"},{"categories":["腾讯云"],"content":"腾讯云服务相关配置 添加依赖 \u003cdependency\u003e \u003cgroupId\u003ecom.tencentcloudapi\u003c/groupId\u003e \u003cartifactId\u003etencentcloud-sdk-java-trtc\u003c/artifactId\u003e \u003cversion\u003e3.1.637\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.tencentcloudapi\u003c/groupId\u003e \u003cartifactId\u003etencentcloud-sdk-java-live\u003c/artifactId\u003e \u003cversion\u003e3.1.637\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.tencentcloudapi\u003c/groupId\u003e \u003cartifactId\u003etencentcloud-sdk-java-vod\u003c/artifactId\u003e \u003cversion\u003e3.1.637\u003c/version\u003e \u003c/dependency\u003e 在后端项目resource包目录下，选择或者新建文件application-integration.yml 配置内容： # 腾讯云服务相关配置 tencent: #腾讯云账号 secretId: AKIDRo**********hDyV0 secretKey: wxuy2**********Yiv8 #即时视频 SDKAppId: 160****473 rtcSecretKey: f5391*****************75054 #直播 live: secretId: AKIDRo8XoE**********2GZ2KhDyV0 secretKey: wxuy2AeTI8***********IKKRYiv8 #播放 play: domainName: play.gajy.org.cn authenticationKey: pnWY4******a2sMpR #推流 push: domainName: 203204.push.tlivecloud.com authenticationKey: 627a88a**********9a0eab11 对应的直播服务账户和密码，播放的域名，到 腾讯云官网 付费获取。 这里是：账号申请 相关文档 ","date":"2024-08-09","objectID":"/text41/:0:1","tags":["腾讯云"],"title":"【腾讯云】腾讯云直播后端","uri":"/text41/"},{"categories":["腾讯云"],"content":"腾讯直播工具类 公共包common下，选择或新建util，新建文件TencentLiveBroadcastUtil.java package com.hrss.remotework.infrastructure.common.util; /* * @Description //TODO * @Date 2023/1/5 14:40 * @Author xx **/ import com.hrss.remotework.infrastructure.config.TencentConfig; import com.hrss.remotework.infrastructure.gatewayimpl.database.dataobject.TaskInfo; import com.tencentcloudapi.common.exception.TencentCloudSDKException; import com.tencentcloudapi.live.v20180801.LiveClient; import com.tencentcloudapi.live.v20180801.models.*; import com.tencentcloudapi.trtc.v20190722.models.WaterMark; import com.tencentcloudapi.vod.v20180717.VodClient; import com.tencentcloudapi.vod.v20180717.models.*; import com.yinhai.ta404.core.restservice.resultbean.Page; import com.yinhai.ta404.core.utils.DateUtils; import lombok.extern.slf4j.Slf4j; import org.apache.commons.codec.digest.DigestUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.autoconfigure.condition.ConditionalOnClass; import org.springframework.cglib.beans.BeanMap; import org.springframework.stereotype.Component; import org.springframework.util.Assert; import javax.annotation.Resource; import java.io.UnsupportedEncodingException; import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.util.Arrays; import java.util.HashMap; import java.util.List; import java.util.concurrent.atomic.AtomicLong; import java.util.stream.Collectors; /** * 腾讯直播工具类 * * @author xx * @date 2023/01/05 */ @Component @ConditionalOnClass(TencentConfig.class) @Slf4j public class TencentLiveBroadcastUtil { @Resource private TencentLiveBroadcastProperties tencentLiveBroadcastProperties; private final static String MD5String = \"MD5\"; private VodClient vodClient; @Resource private LiveClient liveClient; @Autowired public void setVodClient(VodClient vodClient) { this.vodClient = vodClient; } private static final char[] DIGITS_LOWER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'}; public String getPushUrl(String streamName) { long txTime = DateUtils.getCurrentDate().getTime() / 1000 + tencentLiveBroadcastProperties.expireTime.getSeconds(); return new StringBuilder() .append(tencentLiveBroadcastProperties.getPush().domainName).append(\"/\") .append(tencentLiveBroadcastProperties.getAppName()).append(\"/\") .append(streamName).append(\"?\"). append(getTxSecretAndTxTime(tencentLiveBroadcastProperties.getPush().authenticationKey, streamName, txTime)).toString(); } public String getPlayUrl(String streamName) { long txTime = DateUtils.getCurrentDate().getTime() / 1000 + tencentLiveBroadcastProperties.expireTime.getSeconds(); return new StringBuilder() .append(tencentLiveBroadcastProperties.getPlay().domainName).append(\"/\") .append(tencentLiveBroadcastProperties.getAppName()).append(\"/\") .append(streamName).append(\"?\"). append(getTxSecretAndTxTime(tencentLiveBroadcastProperties.getPlay().authenticationKey, streamName, txTime)).toString(); } /* * KEY+ streamName + txTime */ private String getTxSecretAndTxTime(String key, String streamName, long txTime) { String input = new StringBuilder(). append(key). append(streamName). append(Long.toHexString(txTime).toUpperCase()).toString(); String txSecret = null; try { MessageDigest messageDigest = MessageDigest.getInstance(MD5String); txSecret = byteArrayToHexString( messageDigest.digest(input.getBytes(\"UTF-8\"))); } catch (NoSuchAlgorithmException e) { log.error(e.getLocalizedMessage()); } catch (UnsupportedEncodingException e) { log.error(e.getLocalizedMessage()); } return txSecret == null ? \"\" : new StringBuilder(). append(\"txSecret=\"). append(txSecret). append(\"\u0026\"). append(\"txTime=\"). append(Long.toHexString(txTime).toUpperCase()). toString(); } private String byteArrayToHexString(byte[] data) { char[] out = new char[data.length \u003c\u003c 1]; for (int i = 0, j = 0; i \u003c data.length; i++) { out[j++] = DIGITS_LOWER[(0xF0 \u0026 data[i]) \u003e\u003e\u003e 4]; out[j++] = DIGITS_LOWER[0x0F \u0026 data[i]]; } return new String(out)","date":"2024-08-09","objectID":"/text41/:0:2","tags":["腾讯云"],"title":"【腾讯云】腾讯云直播后端","uri":"/text41/"},{"categories":["腾讯云"],"content":"推流地址生成 调用工具类，并存储推流地址。 //推流地址 cz30Do.setAcz02b(tencentLiveBroadcastUtil.getPushUrl(acz300.toString())); //直播存储实体cz30Do //推流记录地址字段acz02b //直播主键id字段acz300 自动生成满足位数的uuid就可以 获取该推流地址，放入前端直播推流代码相应位置。前端推流写法参照：本网站【腾讯云】腾讯云直播前端 ","date":"2024-08-09","objectID":"/text41/:0:3","tags":["腾讯云"],"title":"【腾讯云】腾讯云直播后端","uri":"/text41/"},{"categories":["腾讯云"],"content":"拉流地址生成 调用工具类，并存储拉流地址。 //直播视频流地址(播放) cz30Do.setAcz01y(tencentLiveBroadcastUtil.getPlayUrl(acz300.toString())); //直播存储实体cz30Do //推流记录地址字段acz01y //直播主键id字段acz300 与推流同一个id，则可以拉取到此id推流的直播间的直播信息 获取该拉流地址，放入前端直播拉流代码相应位置。前端拉流写法参照：本网站【腾讯云】腾讯云直播前端 This is a tip\r注：推拉流生成方法一致，但根据推拉流域名不同，所以生成的地址也不同。如图所示： 则每一个直播间一个推流地址对应一个拉流地址，且不同直播间之间互不影响 ","date":"2024-08-09","objectID":"/text41/:0:4","tags":["腾讯云"],"title":"【腾讯云】腾讯云直播后端","uri":"/text41/"},{"categories":["腾讯云"],"content":"腾讯云直播推流器TXLivePusher ：文档地址 腾讯云Web端超级播放器体验：tcplayer Demo 这里是：直播和点播播放的 Web 播放器（ TCPlayer ）的相关参数以及 API 1.直播推流 直播推流需要第三方库 \u003cscript src=\"https://video.sdk.qcloudecdn.com/web/TXLivePusher-2.0.3.min.js\" charset=\"utf-8\"\u003e\u003c/script\u003e 直播推流代码 var livePusher = new TXLivePusher(); console.log(livePusher); livePusher.setRenderView('id_local_video'); // 设置视频质量 livePusher.setVideoQuality('720p'); // 设置音频质量 livePusher.setAudioQuality('standard'); // 自定义设置帧率 livePusher.setProperty('setVideoFPS', 25); // 采集完摄像头和麦克风之后自动推流 Promise.all([livePusher.startScreenCapture(), livePusher.startMicrophone()]) .then(function () { //传入的是一个推流地址，后端返回的，把后端返回的一个地址前边的rtmp换成webrtc就可以了 livePusher.startPush(推流地址) .then(() =\u003e { console.log('pushing'); if (livePusher.isPushing()) { console.log('pushing'); } }) .catch(err =\u003e { console.log(err); }) }) .catch(err =\u003e { console.log(err); }) 2.直播拉流 这里是：腾讯云官方直播拉流的API文档，其中详细阐述了拉流的调用方式和对应参数。 第三方库：腾讯云音视频SDK下载地址 直播拉流所需第三方库 \u003clink href=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/tcplayer.min.css\" rel=\"stylesheet\" /\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 Webrtc 视频，需要在 tcplayer.vx.x.x.min.js 之前引入 TXLivePlayer-x.x.x.min.js。--\u003e \u003c!--有些浏览器环境不支持 Webrtc，播放器会将 Webrtc 流地址自动转换为 HLS 格式地址，因此快直播场景同样需要引入hls.min.x.xx.xm.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/TXLivePlayer-1.2.3.min.js\"\u003e\u003c/script\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 HLS 协议的视频，需要在 tcplayer.vx.x.x.min.js 之前引入 hls.min.x.xx.xm.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/hls.min.1.1.6.js\"\u003e\u003c/script\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 FLV 格式的视频，需要在 tcplayer.vx.x.x.min.js 之前引入 flv.min.x.x.x.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/flv.min.1.6.3.js\"\u003e\u003c/script\u003e \u003c!--如果需要在 Chrome 和 Firefox 等现代浏览器中通过 H5 播放 DASH 视频，需要在 tcplayer.vx.x.x.min.js 之前引入 dash.min.x.x.x.js。--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/libs/dash.all.min.4.5.2.js\"\u003e\u003c/script\u003e \u003c!--播放器脚本文件--\u003e \u003cscript src=\"https://web.sdk.qcloud.com/player/tcplayer/release/v4.7.2/tcplayer.v4.7.2.min.js\"\u003e\u003c/script\u003e 播放容器 \u003cvideo id=\"player-container-id\" preload=\"auto\" playsinline webkit-playsinline\u003e\u003c/video\u003e 拉流js var player = TCPlayer('player-container-id', {}); // player-container-id 为播放器容器 ID，必须与 html 中一致 player.src(url); // url 播放地址 This is a warning\r直播视频全屏canvas元素无法在最上层 直播弹幕无法在最上层，将z-index设置为最大也没效果，那是因为第三方库用了一个toplayer的东西将播放视频的元素放到最顶层了，用css设置的东西没效果，解决方案就是设置个延时器，等到第三方库把元素放置到页面之后dom操作canvas元素，将其放置到设置toplayer的盒子里边，这样就可以了 ","date":"2024-08-09","objectID":"/text16/:0:0","tags":["腾讯云直播"],"title":"【腾讯云】腾讯云直播前端","uri":"/text16/"},{"categories":["版本控制工具"],"content":" //报错信息 Failed to connect to github.com port 443: Connection refused. //报错翻译 连接github.com 443端口失败:连接拒绝 解决办法： 排查代理问题 尝试重置代理或者取消代理的方式： git config --global --unset http.proxy git config --global --unset https.proxy 如果没效果，接着添加全局代理试试： git config --global http.proxy git config --global https.proxy 如果以上问题还未得到解决 排查DNS解析问题 在DNS解析前先会尝试走hosts，然后在找不到的的情况下再DNS解析,修改hosts文件域名解析就会先走hosts中的ip和域名的映射关系。 我们可以修改hosts文件，修改ip地址和域名的映射关系： Windows：位于C:\\Windows\\System32\\drivers\\etc ping gitHub.com 20.205.243.166 github.com 140.82.112.4 github.com 151.101.1.6 github.global.ssl.fastly.net 185.199.108.153 assets-cdn.github.com 185.199.109.153 assets-cdn.github.com 185.199.110.153 assets-cdn.github.com 185.199.111.153 assets-cdn.github.com 【注意：用“管理员身份运行记事本”进行hosts文件的修改】 刷新DNS ipconfig /flushdns ","date":"2024-08-03","objectID":"/text09/:0:0","tags":["git","gitHub"],"title":"【git】git克隆失败解决办法","uri":"/text09/"},{"categories":["前端"],"content":"1.变量定义 ES6新增了 let 和 const，分别用来声明变量和常量，应该尽可能使用 let 和 const 来定义变量，而不是 var ","date":"2024-07-21","objectID":"/es6/:1:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"1.1 let 关键字 let 用于声明变量，声明的变量只在当前代码块能被访问到 // 外部代码块不能访问到内部代码块定义的变量 if(true) { let a = 1; } console.log(a); // 报错：Uncaught ReferenceError: a is not defined /*-----------------分隔线-----------------*/ // 内部代码块能访问到外部代码块的变量 let arr = [] for(let i = 0; i \u003c 10; i++) { arr.push(i); } console.log(arr.join()); // 打印：0,1,2,3,4,5,6,7,8,9 /*-----------------分隔线-----------------*/ // 注意：在for循环中，循环在一个代码块，循环体在一个代码块 for (let i = 0; i \u003c 3; i++) { let i = 'abc'; console.log(i); } // 打印如下： // abc // abc // abc ","date":"2024-07-21","objectID":"/es6/:1:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"1.2 const 关键字 const 声明一个只读的常量 一旦声明，常量的值就不能改变，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值 const foo; // SyntaxError: Missing initializer in const declaration /*-----------------分隔线-----------------*/ const a = 1; a = 2; // 报错：Uncaught TypeError: Assignment to constant variable. /*-----------------分隔线-----------------*/ // 对于对象 const obj = { str: '123'} console.log(obj.str) // 打印：123 obj.str = '456' console.log(obj.str) // 打印：456 obj = {} // 报错：Uncaught TypeError: Assignment to constant variable. // 或者 let newObj = { str: '123' } obj = newObj // 报错：Uncaught TypeError: Assignment to constant variable. ","date":"2024-07-21","objectID":"/es6/:1:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"2. 模板字符串 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，即换行和缩进将会被保留，或者在字符串中嵌入变量。 let name = 'Ryan'; let age = 23; let str = ` name: ${name} age: 23` console.log(str) ","date":"2024-07-21","objectID":"/es6/:2:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3. 数组常用方法 这里列举数组的常用方法，并不都是ES6新增的方法 ","date":"2024-07-21","objectID":"/es6/:3:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.1 forEach 遍历数组，没有返回值，不改变原数组，处理函数可以接收三个参数，分别是当前位置元素item，当前位置下标index，当前遍历的数组 let arr = [1, 2, 3] arr.forEach(function(item) { console.log(item) }) // 打印： //1 //2 //3 ","date":"2024-07-21","objectID":"/es6/:3:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.2 map 遍历数组，不在源数组上进行操作，返回一个新的数组，处理函数可以接收三个参数，分别是当前位置元素item，当前位置下标index，当前遍历的数组 let arr = [1, 2, 3] let arr1 = arr.map(function(item) { console.log(item) item *= 2 return item }) // 打印： //1 //2 //3 console.log(arr.join()) // 打印：1,2,3 console.log(arr1.join()) //打印：2,4,6 //map一定要返回一个新数组，需要一个新的数组变量来接受 This is a tip\rforEach 和 map 的区别 map方法： map它返回一个新数组，原数组的结构不会被改变。 如果需要对原数组进行操作并返回一个新的数组，map是更合适的选择。 map经常用于转换数组中的每个元素。 forEach方法： forEach直接在原数组上进行操作，不返回任何值（或者说返回undefined）。 它没有能力中断循环，也就是说，即使出现错误，forEach中的函数也会继续执行。 如果需要在数组上直接进行修改，并不需要一个新数组，那么可以使用forEach。 ","date":"2024-07-21","objectID":"/es6/:3:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.3 filter 不在源数组上进行操作，返回一个新的数组，处理函数可以接收三个参数，分别是当前位置元素item，当前位置下标index，当前遍历的数组 let arr = [1, 2, 3, 4] let arr1 = arr.filter(function(item) { return item \u003e 2 }) console.log(arr1.join()) // 打印：3,4 ","date":"2024-07-21","objectID":"/es6/:3:3","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.4 includes 返回一个布尔值，表示某个数组是否包含给定的值，该方法的第二个参数表示搜索的起始位置 let arr = [1, 2, 3, 4] console.log(arr.includes(2)) // 打印：true // 从下标为2的位置开始向数组末尾搜索，没找到，返回false console.log(arr.includes(2, 2)) // 打印：false // 如果第二个参数为负数，则表示倒数的位置，从倒数第二个开始搜索，没找到，返回false console.log(arr.includes(2, -2)) // 打印：false // 如果这时它大于数组长度，则会重置为从0开始，倒数第五个，超过数组长度，则从数组开头向数组末尾搜索 console.log(arr.includes(2, -5)) // 打印：true ","date":"2024-07-21","objectID":"/es6/:3:4","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.5 find() find()方法在JavaScript中用于在数组中查找满足特定条件的第一个元素。它接受一个回调函数作为参数，该函数返回布尔值来确定元素是否匹配。如果找到匹配项，则返回该元素，否则返回undefined。此方法不会改变原始数组，适用于寻找单个匹配项。 array.find((item,index)=\u003e{ console.log(item,index); }) array.find(callback(element[, index[, array]])[, thisArg]) 参数解释： callback：必需。要在数组中每个元素上执行的函数。 element：必需。当前正在处理的数组元素。 index：可选。正在处理的元素的索引。 array：可选。调用该方法的数组本身。 thisArg：可选。当执行回调函数时使用的 this 值。 find() 方法的第一个参数 callback 是一个函数，用于测试每个元素是否符合条件，接收三个 参数： element：表示当前正在被处理的元素。 index：表示正在被处理的元素的索引。 array：表示当前正在被处理的数组对象。 回调函数应该返回一个布尔值，表示当前元素是否符合我们的条件。如果返回 true，则会停止遍历并返回该元素的值；否则，继续遍历直到遇到符合条件的元素或者整个数组都被遍历完毕。 find() 方法实际应用： **实例 1：**查找数组中的第一个负数。 const arr = [1, 2, -3, 4, -5]; const negativeNum = arr.find(num =\u003e num \u003c 0); console.log(negativeNum); // 输出：-3 **实例 2：**从对象数组中查找符合条件的对象。 const users = [ {id: 1, name: 'Alice'}, {id: 2, name: 'Bob'}, {id: 3, name: 'Charlie'} ]; const user = users.find(u =\u003e u.id === 2); console.log(user); // 输出：{id: 2, name: 'Bob'} **实例 3：**使用 thisArg 参数指定回调函数中的 this 值。 function isEven(num) { return num % 2 === 0; } const nums = [1, 3, 4, 7, 8]; const evenNum = nums.find(isEven, this); console.log(evenNum); // 输出：4 ★注意事项 find() 方法会遍历整个数组，直到找到满足条件的元素或者遍历完整个数组。 如果数组为空，那么返回 undefined。 在回调函数中修改数组本身不是一个好习惯。如果要修改数组，请使用 map() 或者 filter() 方法。 当多个元素符合条件时，find() 方法只会返回第一个符合条件的元素。 find() 方法是 ES6 中新增的方法，在较旧的浏览器中可能不被支持。 ","date":"2024-07-21","objectID":"/es6/:3:5","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.6 findIndex() findIndex返回满足条件的第一个元素的索引，而find返回满足条件的元素本身。这两个方法都不会改变原数组，且在找到匹配项后停止遍历剩余元素。 findIndex方法常用来查找数组中满足条件的第一项元素的下标 const arr = [1, 2, 3, 4, 5, 3, 3, 2, 4, 5 ] // 可以这么写 const index = arr.findIndex(item =\u003e { return item \u003e 2 }) console.log(index) // 2 //------------------------------------------ // 也可以这么写 const index = arr.findIndex(item =\u003e item \u003e 2) console.log(index) // 2 返回的index是满足条件的第一项元素的下标，这要注意的是findIndex会给数组中的每一项执行一个函数来判断是否满足表达式，如果满足条件后，剩下的元素则不再执行 ","date":"2024-07-21","objectID":"/es6/:3:6","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"3.7 indexOf() indexOf方法可返回某个指定的字符串值在字符串中首次出现的位置。 如果没有找到匹配的字符串则返回 -1 注意： indexOf() 方法区分大小写。 let str = 'orange'; str.indexOf('o'); //0 str.indexOf('n'); //3 str.indexOf('c'); //-1 //这里 0 和 3 分别是 o 和 n 在字符串中出现的位置。起始下标是 0。而 -1 代表未匹配 **注意：**indexOf 会做简单的类型转换 let numStr = '2016'; numStr.indexOf('2'); //0 numStr.indexOf(2); //0 //把会先把数字转换成字符串 '2' 然后再执行。 **注意：**number 类型有没有 indexOf 方法 let num = 2016; num.indexOf(2); //Uncaught TypeError: num.indexOf is not a function 对 number 类型使用 indexOf 方法，需要先转换成字符串 //二逼青年的写法 num = '2016'; num.indexOf(2); //0 //普通青年的写法 num.toString().indexOf(2); //0 //文艺青年的写法 ('' + num).indexOf(2); //0 //这里注意，第一种写死的写法在num为变量的时候会显得很蠢。第二种比较常用，第三种则比较精明 **注意：**Array 类型 indexOf() 方法在数组中搜索指定项目，并返回其位置。 搜索将从指定位置开始，如果未指定开始位置，则从头开始，并在数组末尾结束搜索。 如果未找到该项目，则 indexOf() 返回 -1。 如果该项目出现多次，则 indexOf() 方法返回第一次出现的位置。 注释：第一项的位置为 0，第二项的位置为 1，依此类推。 提示：如果您想从尾到头搜索，请使用 lastIndexOf() 方法。 array.indexOf(item, start) 参数值 参数 描述 item 必需。要搜索的项目。 start 可选。从哪里开始搜索。负值给定的位置将从结尾计数，然后搜索到最后。 示例 let arr = ['orange', '2016', '2016']; arr.indexOf('orange'); //0 arr.indexOf('o'); //-1 arr.indexOf('2016'); //1 arr.indexOf(2016); //-1 This is a tip\rfind 与 findIndex find返回元素，findIndex返回索引 找不到时find返回undefined，findlIndex返回-1 findIndex 与 indexOf findlndex比indexOf更强大一些，可以查找 对象数组， indexOf只能查找 数组 中指定时值，不过indexOf可以指定开始查找位置的索引 ","date":"2024-07-21","objectID":"/es6/:3:7","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"4. 对象常用方法 ","date":"2024-07-21","objectID":"/es6/:4:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"4.1 Object.assign() 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target），第一层属性是深拷贝，第二层属性是浅拷贝 const target1 = { a: 1 }; const source1 = { b: 2 }; const source2 = { c: 3 }; Object.assign(target1, source1, source2); console.log(target1) // 打印：{a:1, b:2, c:3} /*-----------------分隔线-----------------*/ // 第二层属性浅拷贝 const target2 = { a: 1 }; const source3 = { b: { name: 'test' }, c: 3 }; Object.assign(target2, source3); source3.b.name = 'nick' console.log(target2) // 打印：{a:1, b:{ name: 'nick' }, c:3} ","date":"2024-07-21","objectID":"/es6/:4:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5. 解构赋值 解构赋值 是一种特殊的语法，它使我们可以将数组或对象“拆包”为到一系列变量中，因为有时候使用变量更加方便 解构操作对那些具有很多参数和默认值等的函数也很奏效 “解构”并不意味着“破坏” 这种语法叫做解构赋值，因为它通过将结构中的各元素复制到变量中来达到“解构”的目的，但数组本身是没有被修改的 ","date":"2024-07-21","objectID":"/es6/:5:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5.1 数组解构赋值 基础 // 我们有一个存放了名字和姓氏的数组 let arr = [\"Ilya\", \"Kantor\"] // 解构赋值 // sets firstName = arr[0] // and surname = arr[1] let [firstName, surname] = arr; console.log(firstName); // Ilya console.log(surname); // Kantor /*-----------------分隔线-----------------*/ // 不需要第二个元素 let [firstName, , title] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"]; console.log( title ); // Consul /*-----------------分隔线-----------------*/ // 等号右侧可以是任何可迭代对象 let [a, b, c] = \"abc\"; // [\"a\", \"b\", \"c\"] let [one, two, three] = new Set([1, 2, 3]); /*-----------------分隔线-----------------*/ // 赋值给等号左侧的任何内容 let user = {}; [user.name, user.surname] = \"Ilya Kantor\".split(' '); console.log(user.name); // Ilya 我们可以将 Object.entries() 方法与解构语法一同使用，来遍历一个对象的”键—值“对： let user = { name: \"John\", age: 30 }; // 循环遍历键—值对 for (let [key, value] of Object.entries(user)) { console.log(`${key}: ${value}`); // name:John, then age:30 } ……对于 map 对象也类似： let user = new Map(); user.set(\"name\", \"John\"); user.set(\"age\", \"30\"); for (let [key, value] of user) { console.log(`${key}: ${value}`); // name:John, then age:30 } 默认值 // 默认值 let [name = \"Guest\", surname = \"Anonymous\"] = [\"Julius\"]; console.log(name); // Julius（来自数组的值） console.log(surname); // Anonymous（默认值被使用了） 剩余的 ... let [name1, name2, ...rest] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"]; console.log(name1); // Julius console.log(name2); // Caesar // 请注意，`rest` 的类型是数组 console.log(rest[0]); // Consul console.log(rest[1]); // of the Roman Republic console.log(rest.length); // 2 5.1.1关于（…）运算符 ","date":"2024-07-21","objectID":"/es6/:5:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5.2 对象解构赋值 基础 let options = { title: \"Menu\", width: 100, height: 200 }; let {title, width, height} = options; console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 /*-----------------分隔线-----------------*/ // 仅提取 title 作为变量 let { title } = options; console.log(title); // Menu /*-----------------分隔线-----------------*/ // 在options变量的基础上，改变 let {...} 中元素的顺序 let {height, width, title} = { title: \"Menu\", height: 200, width: 100 } console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 /*-----------------分隔线-----------------*/ // 在options变量的基础上，改变映射关系，冒号表示“什么值：赋值给谁” let {width: w, height: h, title} = options; // width -\u003e w // height -\u003e h // title -\u003e title console.log(title); // Menu console.log(w); // 100 console.log(h); // 200 默认值 let options = { title: \"Menu\" }; let {width = 100, height = 200, title} = options; console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 /*-----------------分隔线-----------------*/ // 改变映射关系并设置默认值 let {width: w = 100, height: h = 200, title} = options; console.log(title); // Menu console.log(w); // 100 console.log(h); // 200 剩余的 ... let options = { title: \"Menu\", height: 200, width: 100 }; // title = 名为 title 的属性 // rest = 存有剩余属性的对象 let {title, ...rest} = options; // 现在 title=\"Menu\", rest={height: 200, width: 100} console.log(rest.height); // 200 console.log(rest.width); // 100 ","date":"2024-07-21","objectID":"/es6/:5:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5.3 嵌套解构 let options = { size: { width: 100, height: 200 }, items: [\"Cake\", \"Donut\"], extra: true }; // 为了清晰起见，解构赋值语句被写成多行的形式 let { size: { // 把 size 赋值到这里 width, height }, items: [item1, item2], // 把 items 赋值到这里 title = \"Menu\" // 在对象中不存在（使用默认值） } = options; console.log(title); // Menu console.log(width); // 100 console.log(height); // 200 console.log(item1); // Cake console.log(item2); // Donut ","date":"2024-07-21","objectID":"/es6/:5:3","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"5.4 函数参数 let options = { title: \"My menu\", items: [\"Item1\", \"Item2\"] }; // 函数把对象展开成变量 function showMenu({ title = \"Untitled\", width = 200, height = 100, items = [] }) { // title, items – 提取于 options， // width, height – 使用默认值 console.log( `${title} ${width} ${height}` ); // My Menu 200 100 console.log( items ); // Item1, Item2 } showMenu(options); ","date":"2024-07-21","objectID":"/es6/:5:4","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"6. ... 运算符 ","date":"2024-07-21","objectID":"/es6/:6:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"6.1 Rest 参数 This is a warning\r注意：Rest 参数必须放到参数列表的末尾\rfunction sumAll(...args) { // 数字名为 args let sum = 0; for (let arg of args) sum += arg; return sum; } console.log( sumAll(1) ); // 1 console.log( sumAll(1, 2) ); // 3 console.log( sumAll(1, 2, 3) ); // 6 function showName(firstName, lastName, ...titles) { console.log( `${firstName} ${lastName}` ); // Julius Caesar // 剩余的参数被放入 titles 数组中 // i.e. titles = [\"Consul\", \"Imperator\"] console.log( titles[0] ); // Consul console.log( titles[1] ); // Imperator console.log( titles.length ); // 2 } showName(\"Julius\", \"Caesar\", \"Consul\", \"Imperator\"); ","date":"2024-07-21","objectID":"/es6/:6:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"6.2 Spread 语法 基础 let arr = [3, 5, 1]; console.log( Math.max(...arr) ); // 5（spread 语法把数组转换为参数列表） /*-----------------分隔线-----------------*/ let arr1 = [1, -2, 3, 4]; let arr2 = [8, 3, -8, 1]; console.log( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25 /*-----------------分隔线-----------------*/ let arr = [3, 5, 1]; let arr2 = [8, 9, 15]; let merged = [0, ...arr, 2, ...arr2]; console.log(merged); // 0,3,5,1,2,8,9,15（0，然后是 arr，然后是 2，然后是arr2） 获取一个对象或数组的副本 let arr = [1, 2, 3]; // 将数组 spread 到参数列表中，然后将结果放到一个新数组 let arrCopy = [...arr]; // 两个数组中的内容相同吗？ console.log(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true // 两个数组相等吗？ console.log(arr === arrCopy); // false（它们的引用是不同的） // 修改我们初始的数组不会修改副本： arr.push(4); console.log(arr); // 1, 2, 3, 4 console.log(arrCopy); // 1, 2, 3 /*-----------------分隔线-----------------*/ // 同样适用于对象 let obj = { a: 1, b: 2, c: 3 }; let objCopy = { ...obj }; // 将对象 spread 到参数列表中，然后将结果返回到一个新对象 // 两个对象中的内容相同吗？ console.log(JSON.stringify(obj) === JSON.stringify(objCopy)); // true // 两个对象相等吗？ console.log(obj === objCopy); // false (not same reference) // 修改我们初始的对象不会修改副本： obj.d = 4; console.log(JSON.stringify(obj)); // {\"a\":1,\"b\":2,\"c\":3,\"d\":4} console.log(JSON.stringify(objCopy)); // {\"a\":1,\"b\":2,\"c\":3} ","date":"2024-07-21","objectID":"/es6/:6:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"6.3 …语法 1.1 合并数组 //es5写法，使用concat let arr1 = [1,2]; let arr2 = [5,6]; let newArr = [20]; newArr = newArr.concat(arr1).concat(arr2); //es6写法 let arr1 = [1,2]; let arr2 = [5,6]; let newArr = [20]; newArr = [20,...arr1,...arr2]; 1.2合并对象 const baseSquirtle = { name: 'Squirtle', type: 'Water' }; const squirtleDetails = { species: 'Tiny Turtle Pokemon', evolution: 'Wartortle' }; const squirtle = { ...baseSquirtle, ...squirtleDetails }; console.log(squirtle); //Result: { name: 'Squirtle', type: 'Water', species: 'Tiny Turtle Pokemon', evolution: 'Wartortle' } 2.1 为数组新增成员 const pokemon = ['小红', '小李']; const charmander = '大大'; const pokedex = [...pokemon, charmander]; console.log(pokedex); //Result: [ '小红', '小李', '大大' ] 2.2 为对象新增属性 const aa= { name: '小红', type: '123' }; const obj= { ...aa, unit: '米', id: '1' }; console.log(obj); //Result: { name: '小红', type: '123', unit: '米', id: '1' } 将一个数组添加到另一个数组的尾部： let arr1 = [0, 1, 2]; let arr2 = [3, 4, 5]; //es5写法 Array.prototype.push.apply(arr1, arr2); //es6写法 let arr1 = [0, 1, 2]; let arr2 = [3, 4, 5]; arr1.push(...arr2); 将字符串转换成数组： //es5写法需要split和join的操作 //... //es6写法 [...'hello'] // [ \"h\", \"e\", \"l\", \"l\", \"o\" ] 解构赋值 例1： let obj = {name:\"小明\",age:18,hobby:\"小红\"}; let newobj = { ...obj } console.log(newobj)//和obj一样 例2： let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; console.log(x); // 1 console.log(y); // 2 console.log(z); // { a: 3, b: 4 } 可以对数组进行浅克 let arr = [1,2,[1,2],3]; let arr2 = [...arr]; arr2.push(1); console.log(arr);//[1,2,[1,2],3] console.log(arr2);//[1,2,[1,2],3,1] 进阶: 复制具有嵌套结构的数据/对象 先看一个例子： const pokemon = { name: 'Squirtle', type: 'Water', abilities: ['Torrent', 'Rain Dish'] }; const squirtleClone = { ...pokemon }; pokemon.name = 'Charmander'; pokemon.abilities.push('Surf'); console.log(squirtleClone); //Result: { name: 'Squirtle', type: 'Water', abilities: [ 'Torrent', 'Rain Dish', 'Surf' ] } 当我们修改原对象的name 属性时，我们的克隆对象的 name 属性没有受影响， 这是符合我们预期的。但是当修改原对象的abilities 属性时，我们的克隆对象也被修改了。 原因: 因为复制过来的abilities 是一个引用类型， 原数据改了， 用到他的地方也会跟着改 解决办法：const squirtleClone = { …pokemon, abilities: […pokemon.abilities] }; const pokemon = { name: 'Squirtle', type: 'Water', abilities: ['Torrent', 'Rain Dish'] }; const squirtleClone = { ...pokemon, abilities: [...pokemon.abilities] }; pokemon.name = 'Charmander'; pokemon.abilities.push('Surf'); console.log(squirtleClone); //Result: { name: 'Squirtle', type: 'Water', abilities: [ 'Torrent', 'Rain Dish' ] } 增加条件属性 方式一： const pokemon = { name: 'Squirtle', type: 'Water' }; const abilities = ['Torrent', 'Rain dish']; const fullPokemon = abilities ? { ...pokemon, abilities } : pokemon; console.log(fullPokemon); 方式二：简化一下 const fullPokemon = abilities \u0026\u0026 { ...pokemon, abilities }; 短路 const pokemon = { name: 'Squirtle', type: 'Water' }; const abilities = ['Torrent', 'Rain dish']; const fullPokemon = { ...pokemon, ...(abilities \u0026\u0026 { abilities }) }; console.log(fullPokemon); 如果 abilities 为 true， 就相当于是 const fullPokemon = { ...pokemon, ...{ abilities } } ","date":"2024-07-21","objectID":"/es6/:6:3","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"7. 箭头函数 创建函数还有另外一种非常简单的语法，并且这种方法通常比函数表达式更好，它看起来像这样： ","date":"2024-07-21","objectID":"/es6/:7:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"7.1 基础 // 这里创建了一个函数 func，它接受参数 arg1..argN，然后使用参数对右侧的 expression 求值并返回其结果 let func = (arg1, arg2, ...argN) =\u003e expression /*-----------------分隔线-----------------*/ // 具体例子 let sum = (a, b) =\u003e a + b; /* 这个箭头函数是下面这个函数的更短的版本： let sum = function(a, b) { return a + b; }; */ console.log( sum(1, 2) ); // 3 ","date":"2024-07-21","objectID":"/es6/:7:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"7.2 多行箭头函数 let sum = (a, b) =\u003e { // 花括号表示开始一个多行函数 let result = a + b; return result; // 如果我们使用了花括号，那么我们需要一个显式的 “return” }; console.log( sum(1, 2) ); // 3 ","date":"2024-07-21","objectID":"/es6/:7:2","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"7.3 箭头函数没有 this 箭头函数没有 this。如果访问 this，则会从外部获取，例如： let group = { title: \"Our Group\", students: [\"John\", \"Pete\", \"Alice\"], showList1() { this.students.forEach( student =\u003e console.log(this.title + ': ' + student) ); } showList2() { this.students.forEach(function(student) { // Error: Cannot read property 'title' of undefined console.log(this.title + ': ' + student) }); } }; group.showList1(); // 打印： // Our Group: John // Our Group: Pete // Our Group: Alice group.showList2(); // 报错：TypeError: Cannot read property 'title' of undefined 报错是因为 forEach 运行它里面的这个函数，但是这个函数的 this 为默认值 this=undefined，因此就出现了尝试访问 undefined.title 的情况。 但箭头函数就没事，因为它们没有 this。 This is a warning\r注意：不能对箭头函数进行 new 操作 不具有 this 自然也就意味着另一个限制：箭头函数不能用作构造器（constructor）， 即不能用 new 调用它们 ","date":"2024-07-21","objectID":"/es6/:7:3","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"8. Promise Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了 Promise 对象。 所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise 对象有以下两个特点： 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 pending 变为 fulfilled 和从 pending 变为 rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 ","date":"2024-07-21","objectID":"/es6/:8:0","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"8.1 用法 ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例 resolve let promise = new Promise((resolve, reject) =\u003e { // 当 promise 被构造完成时，自动执行此函数 // 1 秒后发出工作已经被完成的信号，并带有结果 \"done\" setTimeout(() =\u003e resolve(\"done\"), 1000); }); promise .then(res =\u003e console.log(res)) // 执行条件：promise内的任务处理完成，resolve被执行 .catch(error =\u003e console.log(error)) // 执行条件：reject被执行或者抛出异常 .finally(() =\u003e console.log('this promist done!')) // 执行条件：不管promise内的任务为什么状态都会执行 // 打印： // done // this promist done! reject let promise1 = new Promise(function(resolve, reject) { // 当 promise 被构造完成时，自动执行此函数 // 1 秒后发出工作执行失败的信号，并带有结果 \"failed\" setTimeout(() =\u003e reject(\"failed\"), 1000); }); promise1 .then(res =\u003e console.log(res)) // 执行条件：promise内的任务处理完成，resolve被执行 .catch(error =\u003e console.log(error)) // 执行条件：reject被执行或者抛出异常 .finally(() =\u003e console.log('this promist done!')) // 执行条件：不管promise内的任务为什么状态都会执行 // 打印： // failed // this promist done! ","date":"2024-07-21","objectID":"/es6/:8:1","tags":["ES6"],"title":"【ES6前端框架】ES6基础","uri":"/es6/"},{"categories":["前端"],"content":"子=\u003e父 子组件向父组件传参的方式通常通过事件来实现。具体步骤如下： 在子组件中定义事件：子组件可以通过 $emit 方法触发一个自定义事件，并传递参数 // 子组件 ChildComponent.vue \u003ctemplate\u003e \u003cbutton @click=\"sendDataToParent\"\u003e向父组件传参\u003c/button\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { sendDataToParent() { let data = '这是子组件传递给父组件的数据'; this.$emit('child-event', data); } } } \u003c/script\u003e 在上面的代码中，sendDataToParent 方法通过 $emit 发送了一个名为 child-event 的事件，并将 data 作为参数传递给父组件 2.在父组件中监听事件：父组件需要在使用子组件的地方监听这个事件，并处理子组件传递过来的数据 // 父组件 ParentComponent.vue \u003ctemplate\u003e \u003cdiv\u003e \u003cp\u003e从子组件接收到的数据：{{ receivedData }}\u003c/p\u003e \u003cchild-component @child-event=\"handleChildEvent\"\u003e\u003c/child-component\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import ChildComponent from './ChildComponent.vue'; export default { components: { ChildComponent }, data() { return { receivedData: '' }; }, methods: { handleChildEvent(data) { this.receivedData = data; } } } \u003c/script\u003e 在父组件中，使用 标签引入子组件，并通过 @child-event 监听子组件触发的 child-event 事件。当事件被触发时，handleChildEvent 方法会被调用，并将子组件传递的 data 参数赋值给 receivedData。 通过以上方式，子组件就能够向父组件传递数据了。 ","date":"2024-07-01","objectID":"/text17/:0:1","tags":["vue","javascript"],"title":"【Vue前端框架】vue子组件向父组件相互传参的方式","uri":"/text17/"},{"categories":["前端"],"content":"父=\u003e子 Vue项目中在父组件中直接调用子组件的方法 方案一：通过ref直接调用子组件的方法 //父组件中 \u003ctemplate\u003e \u003cdiv\u003e \u003cButton @click=\"handleClick\"\u003e点击调用子组件方法\u003c/Button\u003e \u003cChild ref=\"child\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import Child from './child'; export default { methods: { handleClick() { this.$refs.child.sing(); }, }, } \u003c/script\u003e //子组件中 \u003ctemplate\u003e \u003cdiv\u003e我是子组件\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { methods: { sing() { console.log('我是子组件的方法'); }, }, }; \u003c/script\u003e 方案二：通过组件的$emit、$on方法 //父组件中 \u003ctemplate\u003e \u003cdiv\u003e \u003cButton @click=\"handleClick\"\u003e点击调用子组件方法\u003c/Button\u003e \u003cChild ref=\"child\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import Child from './child'; export default { methods: { handleClick() { this.$refs.child.$emit(\"childmethod\") //子组件$on中的名字 }, }, } \u003c/script\u003e //子组件中 \u003ctemplate\u003e \u003cdiv\u003e我是子组件\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { mounted() { this.$nextTick(function() { this.$on('childmethods', function() { console.log('我是子组件方法'); }); }); }, }; \u003c/script\u003e ","date":"2024-07-01","objectID":"/text17/:0:2","tags":["vue","javascript"],"title":"【Vue前端框架】vue子组件向父组件相互传参的方式","uri":"/text17/"},{"categories":["idea"],"content":"1、现象如下 2、解决办法 3、或者搜索框输入ESLint，选择禁用 ","date":"2023-04-03","objectID":"/text05/:0:0","tags":["idea"],"title":"【idea】idea导入ta404前端项目代码后js文件中注释报红色波浪线解决办法","uri":"/text05/"},{"categories":["idea"],"content":"IDEA在Database中连接达梦数据库 repository-达梦8maven.zip · Jared.Yan/dameng-maven - Gitee.com This is a tip\r如果是连接项目代码中的达梦数据库，此处选择的jar包为项目代码依赖中的dm.jar\r1、idea右侧点击database 2、照着我的点就行，驱动包记得得先加上才会出现class选项 3、回到主页面，添加一个数据库连接。 4、测试连接，连接成功 ","date":"2023-04-03","objectID":"/text10/:0:0","tags":["达梦数据库"],"title":"【idea】IDEA在Database中连接达梦数据库","uri":"/text10/"},{"categories":["Java"],"content":"StringEscapeUtils类可以对html js xml sql 等代码进行转义来防止SQL注入及XSS注入 添加依赖 \u003cdependency\u003e \u003cgroupId\u003ecommons-lang\u003c/groupId\u003e \u003cartifactId\u003ecommons-lang\u003c/artifactId\u003e \u003cversion\u003e2.6\u003c/version\u003e \u003c/dependency\u003e 1.html脚本 escapeHtml转义html脚本 unescapeHtml反转义html脚本 System.out.println(StringEscapeUtils.escapeHtml(\"\u003ca\u003eabc\u003c/a\u003e\")); System.out.println(StringEscapeUtils.unescapeHtml(\"\u0026lt;a\u0026gt;abc\u0026lt;/a\u0026gt;\")); 输出 \u0026lt;a\u0026gt;abc\u0026lt;/a\u0026gt; \u003ca\u003eabc\u003c/a\u003e 2.js脚本 escapeJavaScript转义js脚本 unescapeJavaScript反转义js脚本 System.out.println(StringEscapeUtils.escapeJavaScript(\"\u003cscript\u003ealert('123')\u003cscript\u003e\")); System.out.println(StringEscapeUtils.unescapeJavaScript(\"\u003cscript\u003ealert(\\'123\\')\u003cscript\u003e\")); 输出 \u003cscript\u003ealert(\\'123\\')\u003cscript\u003e \u003cscript\u003ealert('123')\u003cscript\u003e 3.字符串Unicode　escapeJava转义成Unicode编码 unescapeJava反转义成Unicode编码 System.out.println(StringEscapeUtils.escapeJava(\"你好\")); System.out.println(StringEscapeUtils.unescapeJava(\"\\u4F60\\u597D\")); 输出 \\u4F60\\u597D 你好 4.xml escapeXML转义XML unescapeXML反转义XML System.out.println(StringEscapeUtils.escapeXml(\"\u003cname\u003e贝贝\u003c/name\u003e\")); System.out.println(StringEscapeUtils.unescapeXml(\"\u0026lt;name\u0026gt;\u0026#36125;\u0026#36125;\u0026lt;/name\u0026gt;\")); 输出 \u0026lt;name\u0026gt;\u0026#36125;\u0026#36125;\u0026lt;/name\u0026gt; \u003cname\u003e贝贝\u003c/name\u003e 5.sql escapeSql sql转义，防止sql注入攻击 转义后 StringBuffer sql = new StringBuffer(\"select * from users where 1=1 \"); String keyWord=\"aaa' or '1=1\"; if(!keyWord.isEmpty()){ sql.append(\" and username like '%\" + StringEscapeUtils.escapeSql(keyWord) + \"%'\"); } System.out.println(sql); 输出 select * from users where 1=1 and username like '%aaa'' or ''1=1%' 不进行转义的 select * from users where 1=1 and username like '%aaa' or '1=1%' ","date":"2023-04-03","objectID":"/text15/:0:0","tags":["java"],"title":"【Java】转义StringEscapeUtils的使用","uri":"/text15/"},{"categories":["Java"],"content":"String转为int，使用parseInt，或者valueOf.intValue int i = Integer.parseInt（string）; int i = Integer.valueOf(s).intValue(); int转为String，使用valueOf，或者toString，或者\"“空字符串相加 String s = String.valueOf(i); String s = Integer.toString(i); String s = \"\" + i; ","date":"2023-03-01","objectID":"/text02/:0:0","tags":["java"],"title":"【Java】Java中int与String互相转换方法","uri":"/text02/"},{"categories":["Python"],"content":"本文指导如何处理PyCharm中关于MicrosoftWebDriver.exe路径错误，需下载对应浏览器驱动，如Edge驱动，重命名并将其放置在Python安装目录下，以便PyCharm正常使用Selenium打开浏览器。edge驱动下载地址：驱动程序 将下载好的驱动程序解压。 找到python的目录文件，将Edge驱动程序放置在python根目录下。 This is a tip\r如果不知道自己的python安装在什么位置了，可以打开cmd键入“where python”\r3.完成以上步骤你得pycharm就可以正常打开浏览器了。 driver = webdriver.Edge() url = \"https://www.baidu.com\" driver.get(url) ","date":"2022-07-12","objectID":"/text19/:0:0","tags":["Python"],"title":"【Python】Python的WebDriver问题","uri":"/text19/"},{"categories":["Python"],"content":"python官网地址：https://www.python.org/ 第1步：先勾选，再安装，上面是默认安装路径，下面是自定义安装路径 等待安装 安装完成，设置MAX_PATH，授管理员权限 打开终端窗口，输入python命令，验证是否安装成功 ","date":"2022-07-08","objectID":"/text04/:0:0","tags":["Python"],"title":"【Python】Python下载与安装操作步骤","uri":"/text04/"},{"categories":["读卡器驱动"],"content":"报错信息Exception in thread “AWT-EventQueue-0” java.lang.UnsatisfiedLinkError: Unable to load library ‘c:\\dcrf32.dll’:Native library (win32-x86-64/c:\\dcrf32.dll) not found in resource path 翻译过来就是：线程“AWT-EventQueue-0”出现异常，无法加载库’c:\\dcrf32.dll’:本机库(win32-x86-64/c:\\dcrf32.dll)在资源路径中找不到 解决办法： 1、我先是检查了jdk 版本，jre是不是选择和动态库相同位数的32 or 64？ 检查jdk版本位数的方法: java -version 2、 动态库是否添加到jdk里面？我检查的时候，是加了的，但是还是报找不到 3、是不是动态库要求放到具体某一个文件夹下了？ Unable to load library ‘c:\\dcrf32.dll’:Native library (win32-x86-64/c:\\dcrf32.dll) not found 这个括号里面搜索的动态库的位置在c盘根目录下，很像是代码写死了访问位置。于是我找代码去了，确实代码里面是指定要求限制了。 解决办法：把动态库的位置移动到c盘根目录下，或者代码访问位置去掉前面的磁盘限制。 这个错找了很久，特此记录 ","date":"2022-05-18","objectID":"/text03/:0:0","tags":["idea","jar"],"title":"【读卡器驱动】dcrf32.dll","uri":"/text03/"},{"categories":["前端"],"content":"数字短信验证码 思路： a.两个文本框+一个获取验证码按钮，文本框用来输入手机号和获取到的验证码，按钮负责点击和记录倒计时； b.js书写定时器setTimeout，进行60秒验证码失效时间记录； c.后台提供短信获取验证的接口，我们把手机号作为参数上传，后台获取到后给该手机号下发验证码 下放代码可以直接 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cscript type=\"text/javascript\" src=\"https://libs.baidu.com/jquery/2.1.4/jquery.min.js\" \u003e //验证码 var counts = 60; function settime(val) { if(counts == 0) { val.removeAttribute(\"disabled\"); val.value = \"获取验证码\"; counts = 60; return false; } else { val.setAttribute(\"disabled\", true); val.value = \"重新发送（\" + counts + \"）\"; counts--; } setTimeout(function() { settime(val); }, 1000); } $(function(){ //获取验证码 $(\"#verCodeBtn\").click(function() { var userinfo = { \"UserPhoneNum\": '86//' + $(\"input[name='phone']\").val() } $.ajax({ url: \"https://www.xxxxx.cn/user/sendcode/\", data: userinfo, type: \"get\", success: function(data) { if(JSON.parse(data).state === 404 || JSON.parse(data).state === 202 || userinfo.UserPhoneNum === '86//') { alert(\"验证码发送失败\") } else { alert(\"验证码发送成功，请耐心等待\") } }, error: function() { alert(\"发送失败\"); } }); }); }) \u003c/script\u003e \u003cbody\u003e \u003cinput type=\"text\" name=\"phone\" id=\"phone\" value=\"\" placeholder=\"请输入手机号\" maxlength=\"11\" /\u003e \u003cinput type=\"\" name=\"verCode\" id=\"verCode\" value=\"\" placeholder=\"请输入验证码\" maxlength=\"6\"/\u003e \u003cinput type=\"button\" name=\"\" id=\"verCodeBtn\" value=\"获取验证码\" onclick=\"settime(this);\"/\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-01-09","objectID":"/text14/:0:1","tags":["JavaScript"],"title":"【JS】JS 验证码功能的三种实现方式","uri":"/text14/"},{"categories":["前端"],"content":"图形验证码 概要：一般的图形验证码就像上方的短信验证码一样，就是后台生成的验证码图片返回给前端的，那样的话就比较简单，因为复杂的都让后台解决了，我在这里主要说的是另一种，就是不调用后台接口，通过canvas画布来解决图形验证码。 思路： a.一个文本框用来输入由数字和字母组合的验证码+一个画布标签来显示图形验证码+一个提交按钮； b.提交按钮进行表单验证，输入正确或者错误进行相应的提示； c.用画布生成并渲染出验证码图形，并且得到随机的颜色值； \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e验证码\u003c/title\u003e \u003cstyle\u003e .input-val { width: 150px; height: 30px; border: 1px solid #ddd; box-sizing: border-box;/*box-sizing 属性允许你以某种方式定义某些元素，以适应指定区域。*/ } #canvas { vertical-align: middle;/*vertical-align属性设置一个元素的垂直对齐。*/ box-sizing: border-box; border: 1px solid #ddd; cursor: pointer; } .btn { display: block; margin-top: 10px; height: 30px; width: 80px; font-size: 16px; color: #fff; background-color: #409EFE; border: 1px solid #EBEDEF; border-radius: 50px; } \u003c/style\u003e \u003c/head\u003e \u003cscript type=\"text/javascript\" src=\"https://libs.baidu.com/jquery/2.1.4/jquery.min.js\" \u003e\u003c/script\u003e \u003cscript\u003e $(function(){ var show_num = []; draw(show_num); $(\"#canvas\").on('click',function(){ draw(show_num); }) $(\".btn\").on('click',function(){ var val = $(\".input-val\").val().toLowerCase(); //toLowerCase()函数将字符串中的所有字符转为小写。所以输入框不区分大小写。 var num = show_num.join(\"\"); if(val==''){ alert('请输入验证码！'); }else if(val == num){ alert('提交成功！'); $(\".input-val\").val(''); }else{ alert('验证码错误！请重新输入！'); $(\".input-val\").val(''); } }) }) function draw(show_num) {//生成并渲染出验证码图形 var canvas_width=$('#canvas').width(); var canvas_height=$('#canvas').height(); var canvas = document.getElementById(\"canvas\");//获取canvas var context = canvas.getContext(\"2d\");//获取到canvas画图的环境 canvas.width = canvas_width; canvas.height = canvas_height; var sCode = \"A,B,C,E,F,G,H,J,K,L,M,N,P,Q,R,S,T,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,m,n,p,q,r,s,t,u,v,w,x,y,z,1,2,3,4,5,6,7,8,9,0\"; var aCode = sCode.split(\",\"); var aLength = aCode.length;//获取到数组的长度 for (var i = 0; i \u003c 4; i++) { //这里的for循环可以控制验证码位数 var j = Math.floor(Math.random() * aLength);//获取到随机的索引值 var deg = Math.random() - 0.5; //产生一个随机弧度 var txt = aCode[j];//得到随机的一个内容 show_num[i] = txt.toLowerCase(); var x = 10 + i * 20;//文字在canvas上的x坐标 var y = 20 + Math.random() * 8;//文字在canvas上的y坐标 context.font = \"bold 24px 微软雅黑\"; context.translate(x, y); context.rotate(deg); context.fillStyle = randomColor(); context.fillText(txt, 0, 0); context.rotate(-deg); context.translate(-x, -y); } for (var i = 0; i \u003c= 5; i++) { //验证码上显示线条 context.strokeStyle = randomColor(); context.beginPath(); context.moveTo(Math.random() * canvas_width, Math.random() * canvas_height); context.lineTo(Math.random() * canvas_width, Math.random() * canvas_height); context.stroke(); } for (var i = 0; i \u003c= 20; i++) { //验证码上的小点 context.strokeStyle = randomColor();//随机生成 context.beginPath(); var x = Math.random() * canvas_width; var y = Math.random() * canvas_height; context.moveTo(x, y); context.lineTo(x + 1, y + 1); context.stroke(); } } function randomColor() {//得到随机的颜色值 var r = Math.floor(Math.random() * 256); var g = Math.floor(Math.random() * 256); var b = Math.floor(Math.random() * 256); return \"rgb(\" + r + \",\" + g + \",\" + b + \")\"; } \u003c/script\u003e \u003cbody\u003e \u003cdiv class=\"code\"\u003e \u003cinput type=\"text\" value=\"\" placeholder=\"请输入验证码\" class=\"input-val\"\u003e \u003ccanvas id=\"canvas\" width=\"100\" height=\"30\"\u003e\u003c/canvas\u003e \u003cbutton class=\"btn\"\u003e验证\u003c/button\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-01-09","objectID":"/text14/:0:2","tags":["JavaScript"],"title":"【JS】JS 验证码功能的三种实现方式","uri":"/text14/"},{"categories":["前端"],"content":"滑动验证码 滑块登录，是完成拼图形式的，我下面这个原理是一样的，逻辑是根据鼠标滑动轨迹，坐标位置，计算拖动速度等等来判断是否人为操作，如果小伙伴想做和博客园效果一样的，那么可以用来做参考。 思路： a.由三个div组成，构成了滑块和底部进度条的效果； b.书写js,注册鼠标按下，悬浮，松开事件； c.记录滑块移动的距离和状态进行判断是否成功； html \u003cdiv class=\"drag\"\u003e \u003cdiv class=\"bg\"\u003e\u003c/div\u003e \u003cdiv class=\"text\" onselectstart=\"return false;\"\u003e请拖动滑块解锁\u003c/div\u003e \u003cdiv class=\"btn\"\u003e\u0026gt;\u0026gt;\u003c/div\u003e \u003c/div\u003e css \u003cstyle\u003e .drag{ width: 300px; height: 40px; line-height: 40px; background-color: #e8e8e8; position: relative; margin:0 auto; } .bg{ width:40px; height: 100%; position: absolute; background-color: #75CDF9; } .text{ position: absolute; width: 100%; height: 100%; text-align: center; user-select: none; } .btn{ width:40px; height: 38px; position: absolute; border:1px solid #ccc; cursor: move; font-family: \"宋体\"; text-align: center; background-color: #fff; user-select: none; color:#666; } \u003c/style\u003e js \u003cscript\u003e //一、定义一个获取DOM元素的方法 var $ = function(selector){ return document.querySelector(selector); }, box = $(\".drag\"),//容器 bg = $(\".bg\"),//背景 text = $(\".text\"),//文字 btn = $(\".btn\"),//滑块 success = false,//是否通过验证的标志 distance = box.offsetWidth - btn.offsetWidth;//滑动成功的宽度（距离） //二、给滑块注册鼠标按下事件 btn.onmousedown = function(e){ //1.鼠标按下之前必须清除掉后面设置的过渡属性 btn.style.transition = \"\"; bg.style.transition =\"\"; //说明：clientX 事件属性会返回当事件被触发时，鼠标指针向对于浏览器页面(或客户区)的水平坐标。 //2.当滑块位于初始位置时，得到鼠标按下时的水平位置 var e = e || window.event; var downX = e.clientX; //三、给文档注册鼠标移动事件 document.onmousemove = function(e){ var e = e || window.event; //1.获取鼠标移动后的水平位置 var moveX = e.clientX; //2.得到鼠标水平位置的偏移量（鼠标移动时的位置 - 鼠标按下时的位置） var offsetX = moveX - downX; //3.在这里判断一下：鼠标水平移动的距离 与 滑动成功的距离 之间的关系 if( offsetX \u003e distance){ offsetX = distance;//如果滑过了终点，就将它停留在终点位置 }else if( offsetX \u003c 0){ offsetX = 0;//如果滑到了起点的左侧，就将它重置为起点位置 } //4.根据鼠标移动的距离来动态设置滑块的偏移量和背景颜色的宽度 btn.style.left = offsetX + \"px\"; bg.style.width = offsetX + \"px\"; //如果鼠标的水平移动距离 = 滑动成功的宽度 if( offsetX == distance){ //1.设置滑动成功后的样式 text.innerHTML = \"验证通过\"; text.style.color = \"#fff\"; btn.innerHTML = \"\u0026radic;\"; btn.style.color = \"green\"; bg.style.backgroundColor = \"lightgreen\"; //2.设置滑动成功后的状态 success = true; //成功后，清除掉鼠标按下事件和移动事件（因为移动时并不会涉及到鼠标松开事件） btn.onmousedown = null; document.onmousemove = null; //3.成功解锁后的回调函数 setTimeout(function(){ alert('解锁成功！'); },100); } } //四、给文档注册鼠标松开事件 document.onmouseup = function(e){ //如果鼠标松开时，滑到了终点，则验证通过 if(success){ return; }else{ //反之，则将滑块复位（设置了1s的属性过渡效果） btn.style.left = 0; bg.style.width = 0; btn.style.transition = \"left 1s ease\"; bg.style.transition = \"width 1s ease\"; } //只要鼠标松开了，说明此时不需要拖动滑块了，那么就清除鼠标移动和松开事件。 document.onmousemove = null; document.onmouseup = null; } } \u003c/script\u003e ","date":"2022-01-09","objectID":"/text14/:0:3","tags":["JavaScript"],"title":"【JS】JS 验证码功能的三种实现方式","uri":"/text14/"},{"categories":["前端"],"content":"利用原生JSON对象，将对象转为字符串，使用 JSON.stringify（对象名） var jsObj = {}; jsObj.testArray = [1,2,3,4,5]; jsObj.name = 'CSS3'; jsObj.date = '8 May, 2011'; var str = JSON.stringify(jsObj); alert(str); 从JSON字符串转为对象 ，使用JSON.parse（字符串名） var jsObj = {}; jsObj.testArray = [1,2,3,4,5]; jsObj.name = 'CSS3'; jsObj.date = '8 May, 2011'; var str = JSON.stringify(jsObj); var str1 = JSON.parse(str); alert(str1); ","date":"2022-01-09","objectID":"/text01/:0:0","tags":["JavaScript"],"title":"【Js】JS 中Object和String互转方法","uri":"/text01/"},{"categories":["前端"],"content":"利用来JS控制页面控件显示和隐藏有两种方法，两种方法分别利用HTML的style中的两个属性，两种方法的不同之处在于控件隐藏后是否还在页面上占空位。 ","date":"2022-01-09","objectID":"/text013/:0:0","tags":["javascript"],"title":"【Js】JS控制元素的显示和隐藏","uri":"/text013/"},{"categories":["前端"],"content":"方法一 document.getElementById(\"EleId\").style.visibility=\"hidden\"; document.getElementById(\"EleId\").style.visibility=\"visible\"; 利用上述方法实现隐藏后，页面的位置还被控件占用，显示空白。 ","date":"2022-01-09","objectID":"/text013/:0:1","tags":["javascript"],"title":"【Js】JS控制元素的显示和隐藏","uri":"/text013/"},{"categories":["前端"],"content":"方法二 document.getElementById(\"EleId\").style.display=\"none\"; document.getElementById(\"EleId\").style.display=\"inline\"; 利用上述方法实现隐藏后，页面的位置不被占用。 ","date":"2022-01-09","objectID":"/text013/:0:2","tags":["javascript"],"title":"【Js】JS控制元素的显示和隐藏","uri":"/text013/"},{"categories":["前端"],"content":"方法三 显示元素进行隐藏 document.getElementById(\"ID名\").hidden=ture; 根据页面元素ID名获得页面元素值，进而将其属性设置成隐藏。 将隐藏元素进行显示对于已经隐藏的页面元素如果要将其再次显示，不是将 document.getElementById(\"ID名\").hidden=false; 而是将其隐藏属性删除 document.getElementById(\"ID名\").removeAttribute(\"hidden\"); ","date":"2022-01-09","objectID":"/text013/:0:3","tags":["javascript"],"title":"【Js】JS控制元素的显示和隐藏","uri":"/text013/"},{"categories":["前端"],"content":"一些基本定义 ","date":"2021-07-01","objectID":"/text22/:1:0","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"1、万维网 （world wide web ===\u003e www）作用：实现资源共享 ​ 是Internet上基于客户/服务器体系结构的分布式多平台的超文本超媒体信息服务系统，它是Internet最主要的信息服务，允许用户在一台计算机上通过Internet读取另一台计算机上的信息。 ","date":"2021-07-01","objectID":"/text22/:1:1","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"2、网页 （web page） ​ 是存放在web服务器上供客户端用户浏览的文件，可以在Internet上传输。网页是按照网页文档规范编写的一个或多个文件，这种格式的文件由超文本标记语言创建，能将文字、图片、声音等各种多媒体文件组合在一起，这些文件被保存在特定计算机的特定目录中。 ","date":"2021-07-01","objectID":"/text22/:1:2","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"3、网站 （web site） ​ 也称站点，定义为已注册的域名、主页或web服务器。 ​ “网站 = 域名（网站地址）+ 网站空间” ​ 网站是一系列网页的组合，这些网站拥有相同或者相似的属性，并通过各种链接相关联。 相同或者相似的属性\r相同实现目的、相似设计、共同描述相关主导体\r浏览器 ——\u003e 地址栏 ——\u003e 网站地址 ——\u003e网络服务器 ——\u003e 默认网页（首页/主页） 浏览器作用\r浏览器：简译和显示 网页数据包\r","date":"2021-07-01","objectID":"/text22/:1:3","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"4、web标准 ​ 不是某一种标准，而是一系列标准的集合。 ​ “网页组成 = 结构 + 行为 + 表现” 对应三类标准： ​ 1、结构化标准语言：XHMTL、XML、【HTML: 超文本标记语言HyperText Markup Lauguage】 ​ 2、表现标准语言：CSS【Cascading Style Sheets 层叠样式表】 ​ 3、行为标准语言：对象模型W3C DOM 【Document Object Model 文档对象模型】、ECMAScript【API应用接口：连接“网站文件”与“js”的接口】 ","date":"2021-07-01","objectID":"/text22/:1:4","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"5、Inter网 ​ 由双绞线通过物理连接构成网。（路由器、交换机） ","date":"2021-07-01","objectID":"/text22/:1:5","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"6、http ​ 超文本传输协议资源 ","date":"2021-07-01","objectID":"/text22/:1:6","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"7、URL 统一资源定位符 ","date":"2021-07-01","objectID":"/text22/:1:7","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"8、UML 统一建模语言 ","date":"2021-07-01","objectID":"/text22/:1:8","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"9、DNS 域名解析服务器 ","date":"2021-07-01","objectID":"/text22/:1:9","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"10、网页工作原理 ​ 1、静态网页（工作原理） ​ 2、动态网页（工作原理） ","date":"2021-07-01","objectID":"/text22/:1:10","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"11、Java Script ​ 运行在客户端的一段程序。 ","date":"2021-07-01","objectID":"/text22/:1:11","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"12、架构 ​ BS架构：浏览器/服务器 ​ CS架构：客户端（下载APP）/服务器 ","date":"2021-07-01","objectID":"/text22/:1:12","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"13、网页图形图像处理工具 ​ 网页图形图像处理工具可以设计图像： ​ Fireworks （背景透明 jpg.不支持） ​ PhotoShop （背景透明 gif.动画 支持） ​ CorelDraw （背景透明 png.支持） ps处理图像 -使用位图 文件尾缀.psd 1024×768：表示横纵向像数点（位图放大会失真、会模糊） cd处理图像 - 使用矢量图算法记录图像的轮廓，内部颜色填充。文件尾缀 .cdr（随意放大，不会失真） ","date":"2021-07-01","objectID":"/text22/:1:13","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"14、网页维护 ​ 1、上传网页：ftp文件传输协议 ​ 2、网站管理员：修改文件 ​ 3、服务器管理员：远程桌面 ​ 4、 网站风格布局：位置、疏密、颜色、装饰、线条、排版 ","date":"2021-07-01","objectID":"/text22/:1:14","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"15、网页设计流程 目标 -图片- 加工-优化 色彩：暖色（红橙黄）、冷色（青、蓝）、中色（紫、黑、白） 色彩搭配：单色搭配、类比色（相近色、近似色120°内）搭配、互补色[搭配/对比]、三元配色 用户体验：浏览、相交互、信任 颜色的属性： ​ 色相：一个物体的颜色（H色相环） ​ 明相：亮度B ​ 纯色：相对于白色的亮度S 三元色：发光体（红、绿、蓝）、反射光（红【品红】、黄、蓝【青绿】） RGB色彩值：（#000000 黑、#666666 灰、 #FFFFFF 白）16进制、0~256、最大值为FF之间元素在此过渡 ","date":"2021-07-01","objectID":"/text22/:1:15","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"16、网页布局 “国”字型、“厂”字型、“框架”型、“封面”型（表格+框架+DIV+CSS） ","date":"2021-07-01","objectID":"/text22/:1:16","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"HTML编译规范 ","date":"2021-07-01","objectID":"/text22/:2:0","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"1、标签 标签：告诉浏览器以下是什么内容。（“英文、半角”下输入，不能有空格） \u003c起始标签\u003e 受标签影响的内容 \u003c/结束标签\u003e 单标记：类似于\u003c/p\u003e以下是一个段落、 \u003cbr/\u003e换行、 \u003cimg/\u003e引用图片 双标记：类似于\u003cfont\u003e\u003c/font\u003e文字 、\u003ctr\u003e\u003c/tr\u003e表格的一行、\u003ctd\u003e\u003c/td\u003e表格的一个单元格 【双标记要标识出作用范围】 ","date":"2021-07-01","objectID":"/text22/:2:1","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"2、属性 属性：告诉浏览器、以下内容如何显示 ①不同的标签有不同的属性，标签可以有很多种属性。 ②“属性”与“属性”之间由“空格”间隔。“属性”与“属性值”之间由“=”连接。 \u003c标签 属性1 = \"属性值1\" 属性2 = \"属性值2\" ...\u003e xxx \u003c/标签\u003e This is a warning\r像\u003cb\u003e \u003cstrong\u003e \u003ci\u003e \u003cem\u003e等与表现css标准有关的标签， 在软件改进中，或许可以生效，通常不再直接使用。 标签可以嵌套，但不允许交叉 显示文件后缀的方法：计算机 - 组织 - 查看 - 显示文件后缀。【直接改.txt 为 .html可以直接编译静态网页】 ","date":"2021-07-01","objectID":"/text22/:2:2","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"3、文档的基本结构 \u003c!-- 支持规范，符合html5 编写规范 --\u003e \u003c!DOCTYPE html\u003e \u003c!-- 告诉浏览器，以下是html代码，语言使用en --\u003e \u003chtml lang=\"en\"\u003e \u003c!-- 告诉浏览器房网页文档的相关信息 --\u003e \u003chead\u003e \u003c!-- 元标签，编码方式为“UTF-8” --\u003e \u003c!-- 修改页面编码方式：页面 - 编码 - UTF-8 --\u003e \u003c!-- 1B=8bt 指 1字节=8位 ，一般2个字节存放一个字符 --\u003e \u003c!-- ASCII编码，为2的8次方=256个字符对应不同的文字和字母 --\u003e \u003c!-- GB2312简体中文 --\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003c!-- 网页名称，显示在每个打开在浏览器的页面标签头上 --\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003c!-- 告诉浏览器，放网页要显示的内容 --\u003e \u003cbody\u003e 网页内容 \u003c/body\u003e \u003c!-- 告诉浏览器，模版结束 --\u003e \u003c/html\u003e ","date":"2021-07-01","objectID":"/text22/:2:3","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"4、超链接标签（跳转页面） \u003c!-- a标签 表示“锚点标记”，即超链接标记 --\u003e \u003c!-- href地址属性 #内部的锚点名称标记 记号名：链接的目标+路径URL--\u003e \u003c!-- target打开窗口方式属性 _blank在新窗口打开 _self本窗口打开 --\u003e \u003c!-- 热点：点击时跳转的对象（可以是图片、文字） --\u003e \u003ca href=\"# 记号名\" target=\"_blank\"\u003e热点\u003c/a\u003e 点击的时候是图片（或者跳转链接是图片）： \u003ca href=\"C:\\Users\\Administrator\\Desktop\\123.jpg\" \u003e\u003cimg src=\"123.jpg\" \u003e\u003c/a\u003e 阐述【URL相对/绝对 路径】 网络路径：http://www.baidu.com - 在线网络文档路径（优点：不占空间。缺点：保证网络通畅、别人正常维护可访问） 本地路径：绝对路径 - 有盘符、斜杠方向向右（C:\\Users\\……\\xxxx.jpg） 相对路径 - 以编辑网页文件所在的文件夹位置为原点（../父级文件/父上一级）优点：加载快。缺点：位置不能随意更改） ","date":"2021-07-01","objectID":"/text22/:2:4","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"5、书签标记 \u003ca name=\"# 记号名\" \u003e目标文本附近的内容\u003c/a\u003e 例： \u003ca name=\"#z1\" \u003e第一章\u003c/a\u003e ","date":"2021-07-01","objectID":"/text22/:2:5","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"6、文字标签（排版） ①\u003cbr\u003e强制换行符 ②\u0026nbsp空格符 ③\u0026转义字符 ④lt小于 ⑤qt大于 ⑥;结束 ⑦\u003cnobr\u003e...\u003c/nobr\u003e不换行，当窗口大小化时 ⑧\u003c!-- 注释 --\u003e单行注释标记 ⑨\u003cp align=\"left/center/right\"\u003e……\u003c/p\u003e段落 - 段前，段后均会有一排空行，独占一行显示 ⑩\u003cdiv\u003e……\u003c/div\u003e独占一行显示，没有空行 ⑪\u003cpre\u003e……\u003c/pre\u003e预先排版标记，按照你输入进行排版，没有便会自动识别为所有格式为一个空格 ⑫\u003chr\u003e单标记，插入一条水平线，独占一行显示 （属性：位置、颜色、粗细。width没有宽度） ⑬\u003ch#\u003e标题，h#1~6字体的大小，\u003ch1\u003e……\u003c/h1\u003e一级标题 ⑭\u003cfont\u003e……\u003c/font\u003e字体标题，属性：size字体大小，1~7逐渐变大，color=颜色，face = 字体 ⑮ \u003csub\u003e……\u003c/sub\u003e下标标记 ⑯\u003csup\u003e……\u003c/sup\u003e上标标记 ","date":"2021-07-01","objectID":"/text22/:2:6","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"7、图片标签 图片标签\u003cimg\u003e跟属性 \u003cimg src=\"\" - 图片的路径 width=\"\" - 宽：默认单位为像素 height=\"\" - 长：默认单位为像素 border=\"\" - 边框宽度 hspace=\"\" - 图片与文字之间、留白设置（xx像素） vspace=\"\" - 垂直方向上、留白设置 align=\"\" - 环绕方式（left/right）、对齐方式（top/mindle/bottom） alt=\"\" - 简单说明（无法正常显示的时候给出的提示） title=\"\" - 简单说明（鼠标移动到正常上出现的说明文字） usemap=\"\" - 分隔一张图中的各个板块 /\u003e \u003c!-- name定义地图的名称 --\u003e \u003cmap name=\"\"\u003e\u003c/map\u003e \u003c!-- shape 形状（circle圆形/ rect矩形 / poly多边形）--\u003e \u003c!-- coords 位置：圆（圆心坐标x轴,圆心坐标y轴,半径）、矩形（左顶点左边,右顶点坐标）--\u003e \u003c!-- href 链接--\u003e \u003carea shape=\"\" coords=\"\" href=\"\" alt=\"\"\u003e \u003c!-- 左顶格、上顶格 --\u003e \u003cbody leftmargin=\"0\" topmargin=\"0\"\u003e \u003c/body\u003e ","date":"2021-07-01","objectID":"/text22/:2:7","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"8、表格标签 表格标签\u003ctable\u003e \u003ctable border=\"\" - 表格的边框 width=\"x|x%\" - 是body的百分比，占父级容器的百分比 cellspacing=\"\" - 单元格的间距 cellpadding=\"\" - 内容和边框的间距 colspan=\"\" - 占2个横向单元格 rowspan=\"\" - 占2个纵向单元格 \u003e \u003ctr\u003e \u003ctd\u003e\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003ccaption\u003e显示表格的标题\u003c/caption\u003e可以写在所有的\u003ctr\u003e之前或者之后，但不可以写在之间 background背景图片，\u003ctr\u003e表示单元格表头，默认会加粗、居中显示 属性：（●disc ○circle） ","date":"2021-07-01","objectID":"/text22/:2:8","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"9、表单 表单：收集客户端信息发送给服务器的某个动态网页的目标程序，完成客户端与服务器之间的交互。 \u003cform name=\"\" - 表单名称 action=\"\" - URL路径，当action为空时，传递给自己 method=\"\" - 用什么方式进行传输 get/post ，get：以明文字符串进行传输≤256字符，post以表单整体进行传输 \u003e \u003c/form\u003e 注：①一切内容都要在“表单之内”才能被提交 ②一个网页可以有多个表单 ③表单只是一个区域、内容需要加入表单元素 ④表单内的元素 一定要有名称 才能被提交 input输入框 \u003c!-- 下面都是表单元素 --\u003e \u003cinput type=\"text\" name=\"text\"\u003e \u003c!--单行文本≤255个字符 --\u003e \u003cinput type=\"button\" value=\"按钮\" name=\"button\"\u003e \u003c!-- 按钮类型 --\u003e \u003cinput type=\"submit\" value=\"提交\" name=\"submit\"\u003e \u003c!-- 提交类型--\u003e \u003c!-- 表单输入框元素的详解 --\u003e \u003cinput type=\"表项类型\" - password 密码类型 、reset重置类型(使表单回到初始状态)、radio单选框、checkbox多选框、hidden隐藏域、date时间域、file文件选择框、image图片作为按钮 name=\"表项名\" - 一组单选框的name必须相同，不同组的单选框name必须不相同 value=\"默认值\" - 初始值 size=\"x\" - 控制输入框的大小，单位为“x”个字符 maxlength=\"y\" - 最大输入长度，单位为“y”个字符 \u003e \u003cinput type=\"button\" - 点击触发onclick事件 value=\"\" - 按钮名字 onclick=\"\" - 事件函数 readonly=\"\" - 只读 true/false disabled=\"\" - 不可更改，框为灰色 \u003e 文本域 \u003c!-- name名称 rows行数 cols列数 --\u003e \u003ctextarea name=\"\" id=\"\" rows=\"\" cols=\"\"\u003e多行文本\u003c/textarea\u003e 选择栏 \u003c!-- name传输的名称 size可选择的个数：1单选 2多选 --\u003e \u003cselect name=\"\" id=\"\" size=\"\" multiple=\"\"\u003e \u003c!-- 下拉框 可选择的内容 --\u003e \u003coption value=\"\"\u003exxx\u003c/option\u003e \u003c/select\u003e 列表标签 \u003c!-- 列表格式显示为：项目符号 列表项 --\u003e \u003c!-- 有序列表 ol--\u003e \u003col\u003e \u003cli start=\"开始序号\"\u003e列表项1\u003c/li\u003e \u003cli start=\"1\"\u003e列表项2\u003c/li\u003e \u003cli\u003e列表项3\u003c/li\u003e \u003c/ol\u003e \u003c!-- 无序列表 ul --\u003e \u003cul\u003e \u003cli type=\"符号类型\"\u003e列表项1\u003c/li\u003e \u003cli type=\"disc\"\u003e列表项2\u003c/li\u003e \u003cli type=\"disc\"\u003e列表项3\u003c/li\u003e \u003c/ul\u003e 注意！！！\r注：html中是无法使用图片作为项目符号的！！ \u003c!-- 去掉无序前面的点 --\u003e \u003cstyle\u003e ul li { list-style: none; } \u003c/style\u003e ","date":"2021-07-01","objectID":"/text22/:2:9","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"CSS部分 ","date":"2021-07-01","objectID":"/text22/:3:0","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"一、基本选择符 1、标签选择符（所有的读标签下都使用这个样式）【4】 //html中标签的名字 标签{属性：属性值} 例： td { width : 100px } 2、class类选择符（自由定义）【2】 //class=\"自定义的名称\"（字母开头，下划线数，数字） ·类名称{属性：属性值} 例： \u003cp class=\"abc\"\u003e\u003c/p\u003e .abc{ font-size : 18px} 3、id选择符（能且只能使用一次）【1】 #id名{属性：属性值} 例： \u003cp id=\"abc\"\u003e\u003c/p\u003e #abc{ font-size : 18px} 4、复合选择符【3】 ①“交集”选择符（两个基本选择符、直接连接、且同时满足 ） ②“并集”选择符（两者择其一） ③“后代/包含”选择符（x y{ }，表示在x中的y标签，应用{ }中的样式内容） 5、标签默认样式【5】 This is a tip\r【编号】中的数字表示层叠使用时的优先级。若要提高优先级，则需要使用\u003c!important\u003e\r","date":"2021-07-01","objectID":"/text22/:3:1","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"二、 css层叠样式表 1、后缀.css层叠样式表（格式设定） 层叠：发生样式冲突时，系统以上面编号的优先级进行展示 继承：\u003cdiv\u003e\u003cp\u003e\u003c/p\u003e\u003c/div\u003e继承父级的样式设定 将css文件单独拎出来，放置在html文件的同级根目录下，可以使用style引用该路径下的css使得多个html同时可以使用同一个css css实现的4种形式 ①行内样式表 \u003c!-- style=\"\"双引号中的内容，即为css代码 --\u003e \u003cdiv style=\"font-size: 10px;color: black;\"\u003e\u003c/div\u003e ②内部样式表 \u003c!-- 放在html的head中 --\u003e \u003chead\u003e \u003c!-- 使用style标签，之间为css代码 --\u003e \u003cstyle\u003e div{ font-size: 10px; color: black; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e\u003c/body\u003e ③链入外部样式表 \u003c!-- 引用同级根目录下的css文件 --\u003e \u003clink rel=\"stylesheet\" href=\"根目录.css\" type=\"text/css\"\u003e ④导入外部样式表 \u003c!-- 这种引入外部css的方法必须写在第2种的前面才会生效 --\u003e \u003cstyle @import url=\"根目录.css\"\u003e\u003c/style\u003e 2、通用选择符* ：所有的网页元素都会被改变 3、属性选择符：【优先级高于标签选择符】 格式为：元素[属性] 或者 元素[属性 * = 属性值] ， 例：E[alt]{ css代码 } 如果我们用E代表元素、alt代表属性、val代表属性值。则下面： E [alt] { } - 属性名选择符 E [alt = val] { } - 属性值选择符 E [alt ~ = val ] { } - 属性值选择符（其中一个匹配） E [alt 1 = val ] { } - 属性值选择符（连字符匹配、空白匹配） E [alt = val- ] { } - 属性值选择符（连字符匹配、空白匹配） E [alt^ = val ] { } - 属性值子串选择符（前缀匹配） E [alt$ = val ] { } - 属性值子串选择符（后缀匹配） E [alt* = val ] { } - 属性值子串选择符（子字符串匹配） 4、伪类选择符 UI元素 - 表单元素 ： hover：当鼠标移动到上面的时的状态 fous：当聚焦在上面时的状态 active：按下激活时的状态 link：未访问时的状态 锚点标签： a : link { } 未访问的链接状态 a : visited { } 已访问的链接状态 a : hover { }鼠标悬停在链接上的状态 a : active { }被激活的链接状态 text-indent : 2em ; 文章首行缩进：2个字符 色彩RGB rgba函数（R G B A ）A为透明通道，也叫透明度 == filter : opacity(0.5) 透明滤镜 This is a tip\r①HTML： 超文本标记语言【不是编程语言】，【超文本】比普通文本功能更高的文本文件，【标记语言】使用一组标签对内容进行描述的语言 ②语法规范： A、后缀为 -.html 或 -.htm B、头文件 + 体文件（head + body） C、开头标签 + 结束标签 D、不区分大小写，常用小写 ③JavaScript语法规范 变量（字母、数字、下划线）区分大小写，toSum：以小驼峰来进行命名，尽量避免使用a，b，c这种单字母命名。 ","date":"2021-07-01","objectID":"/text22/:3:2","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"三、CSS盒模型 针对块级元素 {padding：__ } 一个值：上下左右 {padding：__ __ } 两个值：上下/左右 {padding：__ __ __ __ } 四个值：上/下/左/右 我们一般用类似于3px这样的长度单位来设定css盒模型某元素属性的长宽，由此这里对长度单位进行了梳理 长度单位有： em - 首行缩进 - 相对长度单位 px - 像素 - 绝对长度单位 pt - 点 - 绝对长度单位 in - 英寸 - 绝对长度单位 cm - 厘米 - 绝对长度单位 css中的一些属性: 1、brackground-image:url(跟图片的位置) 2、【居中】margin: 0px auto 上下间距为0，左右平均分配 3、【两端对齐】text-align: justify 4、【首字下沉】first-letter 5、【设置行高】line-height：length| normal 6、【设置文本换行】word-warp：normal|break-word 7、【设置图像位置】background-position（百分比/长度） 长度：左上角顶点距离背景两边移动的长度 百分比：中心与中心重叠，占整体的百分比大小 边框属性： 1、所有边框宽度（border-width）：1+7同时使用、才有效果 medium - 默认宽度 thin - 小于默认宽度 thick - 小于默认宽度 length - 数字+单位标识符（长度值），不可为负值 （4个）上下左右 、 （2个）上下/左右 、（1个）四周、（3个）上/左右/下 2、上边框宽度（border-top）：border-width || border-style || border - color 3、右边框宽度（border-right） 4、左边框宽度（border-left） 5、下边框宽度（border-bottom） 6、边框颜色（border-color）： 6和7一起使用 7、边框样式（border - style）：是个复合属性 none 无边框样式 solid实线 hidden 隐藏样式 double 双线 dotted 点虚线 groove 三维凹槽 inset 三维凹边 outset三维凸边 dashed 长矩线 ridge 菱形边框 使用时+height + width 设定position：absolute 内边距 内边距padding，和内容在一层，且不允许为负数 上内边距padding-top 下内边距padding-bottom 左内边距padding-right 右内边距padding-right 外边距 外边距margin length：数字+单位标识符（长度值/百分比） 上外边距margin-top 下外边距margin-bottom 左外边距margin- left 右外边距margin-right 定位方式 定位方式position width宽 height高 min-height最小高度 static【默认】静态定位/无特殊定位 relative 相对定位（左、右）表偏移量 absolute 绝对定位（上、下、左、右）属性 fixed 绝对定位（相对于浏览器窗口）-固定定位 z-index浮动序列 可见性 可见性visibility inherit 继承上一个对父对象的可见性 visible 对象可见 collapse 隐藏表格的行列 hidden 对象隐藏 水平叠加问题 span1\\span2 :两个行级元素紧邻不重叠 垂直叠加问题 div1/div2 ：两个块级元素垂直相遇，会产生叠加，形成一个新的外边距，以大的为准 div1/div2：两个块级元素包含相遇，也会产生叠加，面积以大的为准 浮动清除浮动 浮动float none不浮动 left向左浮动 right向右浮动 清除浮动clear none允许浮动 left清除左浮动 right清除右浮动 both两边均清除 ","date":"2021-07-01","objectID":"/text22/:3:3","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"div+css布局 常见的“三行两列”布局 文本控制 文本控制font font-family 字体名称类别 font-size 字体尺寸||绝对尺寸||相对尺寸 12px正文文字大小 font-weight 字体的粗细（bold粗体，normal默认400、number、lighter默认细、100~900越小字体越细） font-style 字体的倾斜（normal默认、italic斜体、obligue倾斜体） color 颜色值 background-color（color颜色、transparent透明） text-decoration文本的修饰（underline下划线、blink闪烁、overline上划线、line-through贯穿线、none无装饰） 段落控制 段落控制text text-align 设置文本的水平对齐方式 （left左对齐、right右对齐、center居中、justify两端对齐） text-indent 设置段落的首行缩进 first-letter 设置首字母下沉 line-height 设置行高 letter-spacing 设置字符间距（word-spacing：length|normal词间距） text - overflow 设置文字的截断（clip 简单的裁切、不能显示省略标记 | ellipsis 文本溢出时 显示省略标记 ） background-image 背景图像设置（URL+none） background-repeat 图像重复方式（no-不平铺、-x水平平铺、~-y垂直平铺） ","date":"2021-07-01","objectID":"/text22/:3:4","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["前端"],"content":"JavaScript部分 JavaScript网页行为语言（代码区分大小写） 核心部分：ECMAScript核心、BOM、DOM（包含：基本语法、变量、关键字、保留字、数据类型、语句、函数） ——是基于对象和事件驱动、并具有相对安全性的客户端脚本语言 使用的三种方法 直接加入HTML文档 \u003cscript type=\"text/javascript\"\u003e ....js代码 \u003c/script\u003e 链接脚本文件 \u003chead\u003e \u003cscript type=\"text/javascript\" src=\"脚本文件名.js\"\u003e\u003c/script\u003e \u003c/head\u003e 在HTML标签内添加脚本，在HTML表单的输入标签内添加脚本 javascript交互基本方法 document.write() 文档输出函数 alert() 窗口对象方法（对话框） confirm() 选择对话框（提示文字） prompt() 提示文字内容对话框 javascript相关概念 变量 变量：开辟在内存中的一块空间 变量声明 var \u003c变量\u003e[=值] //（任何）变量声明的关键词、弱变量，不区分数据类型 数据类型 整形 浮点型 字符串型 表达式/运算符 取反 - ! “或”用于嵌套 基本编程命令/语句 单行注释 // 多行注释 /*。。。*/ 转义字符 \\ \\\" 双引号 \\' 单引号 \\n 换行 \\r 回车 条件结构if if(i%10 == 0) cout \u003cbr\u003e //每10个换行 循环结构for for(变量=初始值;循环条件;循环变量的改变) {\u003c语句\u003e} ----------------------------------- while(循环条件) break 直接中断，跳出 continue 只中断该次循环 函数function 有返回值的称为函数，没有返回值的称为操作 函数名(形参) {函数体;} haha(a,b){return a+b;} 调用方式： 返回值 = 函数名(参数1,参数2) b = haha(data1，data2) 全局变量：函数在方法外声明的变量 局部变量：函数内部声明的变量（在函数被调用时激活，才开辟一个存储单元，在函数结束时被释放） 递归 递归调用 - 递归体 - 出口 //阶乘 function jc(n){ if(n=1){ return 1; //留出口，否则死循环 }else{ return n*jc(n-1); //调用自身函数，以形成递归体 } } docment.write(jc(5)); 面向对象的程序设计 对象：属性+方法+事件 number对象 number对象为【数值】，可以使用toString()：将数值转化为字符串 String对象 String对象【字符串】属性： length()：返回字符串的长度 chatAt(*) ：返回 * 所在位置的字符，下标从0开始 chatCodeAt(*)：返回 * 所在位置字符的ASCII码 indexOf(**)：返回 xx所在位置的下标，找不到返回“-1” lastIndexOf(xx，x)：同上，下标也同上，只是倒序查找 split()：返回一个数组 join()：将一个数组返回字符串 Substring(始，终)：截取字符串 substr（始，长度）：截取子字符串 toUpperCase()：小写全转化大写 Array对象 Array对象【数组】属性 var \u003c数组名\u003e = new Array(); //javaScript中数组没有二维数组 Math对象 Math对象【数学】属性 E 返回e=2.71828…. PI 返回π = 3.1415926… random() 返回0到1中的一个随机数 parseInt 构造整数、取整 parseInt(Math.random()*(100-60)+60) //生成60-100间的随机整数 round() 四舍五入 Date对象 Date对象【日期】 var d = new Date(); //获取当前客户端的时间 g/set[UTC]year - 设置年份 g/set[UTC]month - 设置月份 g/set[UTC]Date- 设置日 g/set[UTC]Day- 设置星期几 Global全局对象 eval() 字符串当作表达式处理 parseInt() 括号内的转化为数值（整数），若以字母开头，返回“NAN” parseFloat() 转化为浮点数 toString() 转化为字符串 Dom文档对象 Dom是Bom中的一小部分 Bom浏览器对象（navigate 浏览器对象、screen屏幕对象、window窗口对象：“history历史、location地址、document文档”） Dom（open打开一个窗口）（open（\u003cURL字符串\u003e,\u003c窗口名称字符串\u003e,\u003cxx属性\u003e）） menubar = \" no \" 无菜单栏 toolbar 工具栏 scrollbar滚动条 resizable 可拉动 location 地址栏 d.导航栏 navigate 浏览器对象 appCodeName 返回“码名” appName 返回“浏览器名称” appVersion 返回“浏览器版本” javaEnable 返回“一个布尔型，允不允许使用java” window窗口对象 Name 窗口的名称 Status “状态栏” 可读可写，在最下方 opener 返回打开该窗口的上一窗口 close 关闭一个打开的窗口 window.close() //self.close //setInterval(\"funl,time\")定时器（函数体，时间，单位毫秒） blur() 失去焦点 focus() 获得焦点 scrollTo() 滚动到 scrollBy() 滚动多少 reSizeTo() 调整到 setInterval（funl，time）每隔多少时间执行该函数 setFimeout（funl，time）延迟多少时间执行该函数 history历史对象 length - 访问的窗口数 back - 后退 forward - 前进 history.go(x) - 前进到第x个窗口 history.go(0) - history.reload - 刷新 location地址栏对象 protocol - 返回协议 hostname - 返回地址的主机名 port - 地址端口 host - 地址路径 document文档对象 lastModified - 输出到修改网页最后一次的时间 referrer - 返回打开它的网页窗口 tittle - 返回tittle的名称 fgcolor - 文字颜色 bgcolor - 背景颜色 write() - 输出一个文档流（在\u003c/html时结束）（\u003chtml到\u003c/html算一个文档流，文档流结束会新开一个窗口） getElementById() 通过ID来获取网页上的元素 getElementByName() 通过名称ID来获取网页上的元素 body.clientwidth() / clientwidth() 获取客户端网页窗口大小 offsettop()、offsetleft()、offset() 获取匹配元素在当前视的相对偏移 内联元素 内联元素（行内元素） -属性display：inline； 这个属性能够修复著名的IE双倍浮动边界问题（html规范中的概念-外文名：inline element） 内联元素又名行内元素和其对应的是块元素 内联元素的显示，为了帮助理解，可以形象的称为“文本模式”。即一个挨着一个，都在用一行按从左至右的顺序显示，不单独占一行。display：vnone表示隐藏 加入css控制 内联元素+display = block属性，可以从新行开始 ；块元素+display = inline属性，可以在一行上排列 常见的块级元素address地址/特点：总是在新行上开始 内联元素（特点） 和其他元素都在一行上（左右可以改变设置） 高度，行高和顶以及底边距都不可改变 宽度就是它的文字或图片的宽度不可改变 总的来说，内联元素一般都是基于语义级的基本元素，它只能容纳“文本或其他内联元素，通常被包括在块级元素中使用，常见的内联元素： a - 锚点 b - 粗体 br - 换行 font - 字体 abbr - 编写 acronym - 首字母 big - 大字体 cite - 引用 em - 强调 块级元素 块级元素特点： 总是在新行上开始 高度、行高以及外边距和内边距都可以控制 宽度缺省是它的容器的100%，除非设定一个宽度 它可以容纳内联元素和其他块元素 常见的块级元素： address - 地址 blockquote - 块引用 center -居中对齐块 div - 常用块容器 h1 - 一级大标题 HBuilder：编写软件（放html代码，生成js文件） frameset框架集： \u003c!--横向分割--\u003e \u003cframeset row=\"20%,*\"\u003e \u003cframe src=\"上\"\u003e\u003c/frame\u003e \u003c!--纵向分割--\u003e \u003cframeset cols=\"20%,*\"\u003e \u003cframe src=\"左\"\u003e\u003c/frame\u003e \u003cframe src=\"右\"\u003e\u003c/frame\u003e \u003c/frameset\u003e \u003c/frameset\u003e 图解： 如何控制表单提交？ 关于事件onsubmit：一般用于表单提交的位置 那么需要在定义函数的时候，给出一个返回值 onsubmit = return checkForm()； 返回","date":"2021-07-01","objectID":"/text22/:3:5","tags":["html","JavaScript"],"title":"【html】网页设计笔记（html+css+javaScript基础）","uri":"/text22/"},{"categories":["SQL"],"content":"Oracle查询sql 查询系统当前日期 select sysdate from dual; 请查询每个员工的名字、薪水和加薪15.5%之后的薪水（trunc取整） Select 名字,薪水,trunc(薪水*1.155) \"new salary\" from employees; 请显示所有以’J’，‘A’，‘M’打头的员工的名字和名字长度，且按照名字排升序 select 名字,LENGTH(名字) from employees where substr(名字,0,1) in ('J','A','M') order by 名字 asc; 请查询员工名和工作时间（换算成月并取整），并按工作时间排降序 Select 名,trunc(months_between(sysdate,时间),0) from employees order by trunc(months_between(sysdate,时间),0) desc; 请查询员工的名字和薪水，并将薪水列变成15个字符长度，左边填充“$”符号 select 名字,lpad(薪水,15,'$') from employees; 请查询部门id为90的所有员工的名字和他们参加工作的星期数(保留2位小数，不需要四舍五入)使用 select 名字 , trunc((参加工作星期数)/7,2) from employees where 员工id=90 创建报告，显示员工名和奖金系数,如果奖金系数为空,则显示$无奖金 select 名字,decode(奖金系数,'','无奖金',奖金系数) from employees; 请使用case语句，查询员工的job_id和级别.例如: select t.job_id, decode(t.job_id, 'AD_PRES', 'A','ST_MAN', 'B','IT_PROG', 'C','SA_REP', 'D','ST_CLERK', 'E','0') from employees t; 或者 Select job_id, case job_id when 'AD_PRES' then 'A' when 'ST_MAN' then 'B' when 'IT_PROG' then 'C' when 'SA_REP' then 'D' when 'ST_CLERK' then 'E' else '0' end \"Grage\" from employees; ","date":"2021-07-01","objectID":"/text18/:0:0","tags":["sql","Oracle"],"title":"【SQL语句】Oracle查询sql","uri":"/text18/"},{"categories":["SQL"],"content":"一、聚合函数 有一个学生表如下： ","date":"2021-07-01","objectID":"/text11/:1:0","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"count 1、统计记录总个数 SELECT COUNT (*) FROM 学生表 若要命名 SELECT COUNT (* ) as 学生总人数 FROM 学生表 2、统计指定列的值的数目（NULL 值不计入） SELECT COUNT (专业代码) FROM 学生表 3、统计指定列，拥有不同值的数目（NULL 值不计入） SELECT COUNT (distinct 专业代码) FROM 学生表 ","date":"2021-07-01","objectID":"/text11/:1:1","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"sum 4、计算某一列值的总和 SELECT sum(高考分数) as 高考总分数 FROM 学生表 ","date":"2021-07-01","objectID":"/text11/:1:2","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"MAX、MIN、AVG 5、求某一列值的最大值 This is a tip\rMAX 函数返回一列中的最大值。NULL 值不包括在计算中。 注释：MIN 和 MAX 也可用于文本列，以获得按字母顺序排列的最高或最低值。 SELECT MAX(高考分数) as 高考最高分数 FROM 学生表 6、求某一列值的最小值 SELECT MIN(高考分数) as 高考最低分数 FROM 学生表 7、求某一列值的平均值 SELECT AVG(高考分数) as 高考最高分数 FROM 学生表 ","date":"2021-07-01","objectID":"/text11/:1:3","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"FIRST、ROUND 6、取指定字段的第一个记录的值 select first(column_name) from table_name 7、ROUND() 函数（四舍五入规则）、用于把数值字段舍入为指定的小数位数。 SELECT round(列名,小数位数) FROM table_name ","date":"2021-07-01","objectID":"/text11/:1:4","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"MID 8、MID() 函数 ：用于从文本字段中提取字符。 SELECT MID(列名,开始截取位置,结束截取位置) FROM table_name This is a tip\rSELECT MID(列名,1,3) FROM table_name 3不写，默认返回剩余的所有字段 ","date":"2021-07-01","objectID":"/text11/:1:5","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"LEN 9、LEN 函数返回文本字段中值的长度。 SELECT LEN(列名) FROM table_name ","date":"2021-07-01","objectID":"/text11/:1:6","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"二、数据库查询前10条数据 Oracle中查询 select * from table where rownum\u003c=10; DB2中查询 select * from table fetch first 10 rows only; MySql中查询 select * from table limit 10; ","date":"2021-07-01","objectID":"/text11/:2:0","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["SQL"],"content":"三、SQL语言多表关联查询 一、外连接 外连接可分为：左连接、右连接、完全外连接。 select * from A表 left join B表 on A表条件 = B表条件 This is a tip\r左外连接包含left join左表所有行，如果左表中某行在右表没有匹配，则结果中对应行右表的部分全部为空(NULL) select * from A表 right join B表 on A表条件 = B表条件 This is a tip\r右外连接包含right join右表所有行，如果左表中某行在右表没有匹配，则结果中对应左表的部分全部为空(NULL)。 select * from A表 full join B表 on A表条件 = B表条件 This is a tip\r完全外连接包含full join左右两表中所有的行，如果右表中某行在左表中没有匹配，则结果中对应行右表的部分全部为空(NULL)，如果左表中某行在右表中没有匹配，则结果中对应行左表的部分全部为空(NULL)。 二、内连接 join 或 inner join select * from A表 join B表 on A表条件 = B表条件 This is a tip\rinner join 是比较运算符，只返回符合条件的行。\r","date":"2021-07-01","objectID":"/text11/:3:0","tags":["SQL"],"title":"【SQL语句】SQL语句部分写法","uri":"/text11/"},{"categories":["服务器"],"content":"打开命令行，输入mstsc 点击确认 出现以下界面 输入ip地址及端口号，然后点击连接 提示页面均点，连接 提示页面均点，是 输入用户名和密码即可 ","date":"2021-07-01","objectID":"/text06/:0:0","tags":["远程"],"title":"【服务器】远程登陆服务器教程","uri":"/text06/"},{"categories":["计算机网络"],"content":"路由表 路由表操作 ipconfig route print route delete 0.0.0.0 route delete 10.163.0.0 route delete 10.164.0.0 route delete 10.160.0.0 route delete 10.1.0.0 route add -p 0.0.0.0 mask 0.0.0.0 192.168.9.1 metric 20 route add -p 10.163.0.0 mask 255.255.0.0 192.168.8.1 metric 30 route add -p 10.164.0.0 mask 255.255.0.0 192.168.8.1 metric 30 route add -p 10.160.0.0 mask 255.255.0.0 192.168.8.1 metric 30 route add -p 10.1.0.0 mask 255.255.0.0 192.168.8.1 metric 30 ","date":"2021-07-01","objectID":"/text21/:0:0","tags":["路由"],"title":"【计算机网络】路由表","uri":"/text21/"},{"categories":null,"content":"此网站建立于2024年七夕…… ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"关于我们","uri":"/about/"},{"categories":null,"content":"\rHugo\rhugo官方文档中文版\rLovelt\r一个简洁、优雅且高效的 Hugo 主题\r","date":"0001-01-01","objectID":"/friend/:0:0","tags":null,"title":"友情链接","uri":"/friend/"}]